package com.jetbrains.lang.dart.ide.runner.test;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;
import com.intellij.execution.testframework.TestConsoleProperties;
import com.intellij.execution.testframework.sm.ServiceMessageBuilder;
import com.intellij.execution.testframework.sm.runner.OutputToGeneralTestEventsConverter;
import com.intellij.openapi.util.Key;
import jetbrains.buildServer.messages.serviceMessages.ServiceMessageVisitor;
import org.jetbrains.annotations.NotNull;

import java.text.ParseException;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Convert events from JSON format generated by package:test to the string format
 * expected by the event processor.
 * NOTE: The test runner runs tests asynchronously. It is possible to get a 'testDone'
 * event followed some time later by an 'error' event for that same test. That should
 * convert a successful test into a failure. That case is not being handled.
 * NOTE: Due to coordination between mods to package:test and this code a number of
 * tasks still need to be completed. They are identified with to-do's in the code.
 * TODO: Create a test similar to the one for the deleted class DartTestJsonReader.
 */
public class DartTestEventsConverter extends OutputToGeneralTestEventsConverter {

  private static final String TYPE_START = "start";
  private static final String TYPE_TEST_START = "testStart";
  private static final String TYPE_ERROR = "error";
  private static final String TYPE_GROUP = "group";
  private static final String TYPE_PRINT = "print";
  private static final String TYPE_TEST_DONE = "testDone";
  private static final String TYPE_DONE = "done";

  private static final String DEF_GROUP = "group";
  private static final String DEF_TEST = "test";
  private static final String DEF_METADATA = "metadata";

  private static final String JSON_TYPE = "type";
  private static final String JSON_NAME = "name";
  private static final String JSON_SKIP = "skip";
  private static final String JSON_SKIP_REASON = "skipReason";
  private static final String JSON_ID = "id";
  private static final String JSON_TEST_ID = "testID";
  private static final String JSON_RESULT = "result";
  private static final String JSON_HIDDEN = "hidden";
  private static final String JSON_MILLIS = "time";
  private static final String JSON_MESSAGE = "message";
  private static final String JSON_ERROR_MESSAGE = "error";
  private static final String JSON_STACK_TRACE = "stackTrace";
  private static final String JSON_IS_FAILURE = "isFailure";

  private static final String RESULT_SUCCESS = "success";
  private static final String RESULT_FAILURE = "failure";
  private static final String RESULT_ERROR = "error";

  private static final String NEWLINE = "\n";
  private static final String EXPECTED = "Expected: ";
  private static final Pattern EXPECTED_ACTUAL_RESULT = Pattern.compile("\\nExpected: (.*)\\n  Actual: (.*)\\n *\\^\\n Differ.*\\n");

  private int myTestId = 0;
  private int myParentId = 0;
  // In theory, test events could be generated asynchronously and out of order. We might want to keep a map of tests to start times
  // so we get accurate durations when tests end.
  private long myStartMillis;
  private boolean myOutputAppeared = false;
  private Key myCurrentOutputType;
  private ServiceMessageVisitor myCurrentVisitor;
  private Map<Integer, JsonObject> myTestData;

  public DartTestEventsConverter(@NotNull final String testFrameworkName, @NotNull final TestConsoleProperties consoleProperties) {
    super(testFrameworkName, consoleProperties);
    myTestData = new HashMap<Integer, JsonObject>();
  }

  protected boolean processServiceMessages(final String text, final Key outputType, final ServiceMessageVisitor visitor)
    throws ParseException {
    myCurrentOutputType = outputType;
    myCurrentVisitor = visitor;
    // service getMessage parser expects line like "##teamcity[ .... ]" without whitespaces in the end.
    return processEventText(text);
  }

  private boolean processEventText(final String text) throws JsonSyntaxException, ParseException {
    JsonParser jp = new JsonParser();
    JsonElement elem;
    try {
      elem = jp.parse(text);
    }
    catch (JsonSyntaxException ex) {
      return super.processServiceMessages(text, myCurrentOutputType, myCurrentVisitor);
    }
    if (elem == null || !elem.isJsonObject()) return false;
    return process(elem.getAsJsonObject());
  }

  private boolean process(JsonObject obj) throws JsonSyntaxException, ParseException {
    String type = obj.get(JSON_TYPE).getAsString();
    if (TYPE_TEST_START.equals(type)) {
      return processTestStart(obj);
    }
    else if (TYPE_TEST_DONE.equals(type)) {
      return processTestDone(obj);
    }
    else if (TYPE_ERROR.equals(type)) {
      return processError(obj);
    }
    else if (TYPE_PRINT.equals(type)) {
      return processPrint(obj);
    }
    else if (TYPE_GROUP.equals(type)) {
      return processGroup(obj);
    }
    else if (TYPE_START.equals(type)) {
      return processStart(obj);
    }
    else if (TYPE_DONE.equals(type)) {
      return processDone(obj);
    }
    else {
      throw new JsonSyntaxException("Unexpected type: " + type + " (check for SDK update)");
    }
  }

  private boolean processTestStart(JsonObject obj) throws ParseException {
    JsonObject testObj = obj.getAsJsonObject(DEF_TEST);
    myTestId = getInitialTestID(testObj);
    // Not reached if testObj == null.
    myParentId = 0; // TODO Reconstruct group hierarchy.
    if (myTestId == 0) return true; // Do not display "loading" event. TODO Generalize for multiple suites.
    String testName = getTestName(testObj);
    ServiceMessageBuilder testStarted = ServiceMessageBuilder.testStarted(testName);
    testStarted.addAttribute("locationHint", "unknown"); // TODO Save file path from hidden "loading" event.
    myStartMillis = getTestMillis(obj);
    myOutputAppeared = false;
    boolean result = finishMessage(testStarted);
    myParentId = myTestId;
    if (result) {
      JsonObject metadata = testObj.getAsJsonObject(DEF_METADATA);
      if (getBoolean(metadata, JSON_SKIP)) {
        result = processSkip(metadata, testName) && eventFinished(obj);
      }
    }
    return result;
  }

  private boolean processTestDone(JsonObject obj) throws ParseException {
    if (getBoolean(obj, JSON_HIDDEN)) return true;
    String result = getResult(obj);
    if (result.equals(RESULT_SUCCESS)) {
      return processPass(obj);
    }
    else if (result.equals(RESULT_FAILURE)) {
      return true;
    }
    else if (result.equals(RESULT_ERROR)) {
      return true;
    }
    else {
      throw new ParseException("Unknown result: " + obj, 0);
    }
  }

  private boolean processGroup(JsonObject obj) throws ParseException {
    // TODO Reconstruct group hierarchy.
    return true;
  }

  private boolean processPass(JsonObject obj) throws ParseException {
    return eventFinished(obj);
  }

  private boolean processError(JsonObject obj) throws ParseException {
    String message = getErrorMessage(obj);
    String expectedText = null, actualText = null, failureMessage = message;
    ServiceMessageBuilder testError = ServiceMessageBuilder.testFailed(getTestName(obj));
    ServiceMessageBuilder msg = ServiceMessageBuilder.testStdErr(getTestName(obj));
    int firstExpectedIndex = message.indexOf(EXPECTED);
    if (firstExpectedIndex >= 0) {
      Matcher matcher = EXPECTED_ACTUAL_RESULT.matcher(message);
      if (matcher.find(firstExpectedIndex + EXPECTED.length())) {
        expectedText = matcher.group(1);
        actualText = matcher.group(2);
        testError.addAttribute("expected", expectedText);
        testError.addAttribute("actual", actualText);
        if (firstExpectedIndex == 0) {
          failureMessage = "Comparison failed";
        }
        else {
          failureMessage = message.substring(0, firstExpectedIndex);
        }
      }
    }
    // The stack trace could be null, but we disallow that for consistency with all the transmitted values.
    if (!getBoolean(obj, JSON_IS_FAILURE)) testError.addAttribute("error", "true");
    testError.addAttribute("message", failureMessage + NEWLINE);
    msg.addAttribute("out", getStackTrace(obj));
    return finishMessage(testError) && finishMessage(msg) && eventFinished(obj);
  }

  private boolean processSkip(JsonObject obj, String testName) throws ParseException {
    ServiceMessageBuilder message = ServiceMessageBuilder.testIgnored(testName);
    message.addAttribute("out", getSkipReason(obj));
    return finishMessage(message);
  }

  private boolean processPrint(JsonObject obj) throws ParseException {
    ServiceMessageBuilder message = ServiceMessageBuilder.testStdOut(getTestName(obj));
    String out;
    if (myOutputAppeared) {
      out = getMessage(obj) + NEWLINE;
    }
    else {
      out = NEWLINE + getMessage(obj) + NEWLINE;
    }
    message.addAttribute("out", out);
    myOutputAppeared = true;
    return finishMessage(message);
  }

  private boolean processStart(JsonObject obj) {
    myTestData.clear();
    // This apparently is a no-op: myProcessor.signalTestFrameworkAttached();
    return true;
  }

  private boolean processDone(JsonObject obj) {
    // Tests are done.
    myTestData.clear();
    return true;
  }

  private boolean eventFinished(JsonObject obj) throws ParseException {
    long duration = getTestMillis(obj) - myStartMillis;
    ServiceMessageBuilder testFinished = ServiceMessageBuilder.testFinished(getTestName(obj));
    testFinished.addAttribute("duration", Long.toString(duration));
    return finishMessage(testFinished);
  }

  private boolean finishMessage(@NotNull ServiceMessageBuilder msg) throws ParseException {
    msg.addAttribute("nodeId", String.valueOf(myTestId));
    msg.addAttribute("parentNodeId", String.valueOf(myParentId));
    return super.processServiceMessages(msg.toString(), myCurrentOutputType, myCurrentVisitor);
  }

  private static long getTestMillis(JsonObject obj) throws ParseException {
    return getLong(obj, JSON_MILLIS);
  }

  private static int getInitialTestID(JsonObject obj) throws ParseException {
    return getInt(obj, JSON_ID);
  }

  private static int getInt(JsonObject obj, String name) throws ParseException {
    JsonElement val = obj == null ? null : obj.get(name);
    if (val == null || !val.isJsonPrimitive()) throw new ParseException("Value is not type int: " + val, 0);
    return val.getAsInt();
  }

  private static long getLong(JsonObject obj, String name) throws ParseException {
    JsonElement val = obj == null ? null : obj.get(name);
    if (val == null || !val.isJsonPrimitive()) throw new ParseException("Value is not type long: " + val, 0);
    return val.getAsLong();
  }

  private static boolean getBoolean(JsonObject obj, String name) throws ParseException {
    JsonElement val = obj == null ? null : obj.get(name);
    if (val == null || !val.isJsonPrimitive()) throw new ParseException("Value is not type boolean: " + val, 0);
    return val.getAsBoolean();
  }

  @NotNull
  private String getTestName(JsonObject obj) throws ParseException {
    if (obj == null) throw new ParseException("Unexpected null json object", 0);
    JsonElement id = obj.get(JSON_ID);
    if (id != null) {
      // Record myTestData for new test.
      myTestData.put(id.getAsInt(), obj);
    }
    else {
      JsonElement testId = obj.get(JSON_TEST_ID);
      if (testId != null) {
        int baseId = testId.getAsInt();
        obj = myTestData.get(baseId);
      }
      else {
        throw new ParseException("No testId in json object", 0);
      }
    }
    JsonElement val = obj.get(JSON_NAME);
    if (val != null) {
      return val.getAsString();
    }
    return "<no name>";
  }

  @NotNull
  private static String getErrorMessage(JsonObject obj) {
    return nonNullJsonValue(obj, JSON_ERROR_MESSAGE, "<no error message>");
  }

  @NotNull
  private static String getMessage(JsonObject obj) {
    return nonNullJsonValue(obj, JSON_MESSAGE, "<no message>");
  }

  @NotNull
  private static String getStackTrace(JsonObject obj) {
    return nonNullJsonValue(obj, JSON_STACK_TRACE, "<no stack trace>");
  }

  @NotNull
  private static String getSkipReason(JsonObject obj) {
    return nonNullJsonValue(obj, JSON_SKIP_REASON, "<no skip reason>");
  }

  @NotNull
  private static String getResult(JsonObject obj) {
    return nonNullJsonValue(obj, JSON_RESULT, "<no result>");
  }

  @NotNull
  private static String nonNullJsonValue(JsonObject obj, @NotNull String id, @NotNull String def) {
    JsonElement val = obj == null ? null : obj.get(id);
    if (val == null || !val.isJsonPrimitive()) return def;
    return val.getAsString();
  }
}
