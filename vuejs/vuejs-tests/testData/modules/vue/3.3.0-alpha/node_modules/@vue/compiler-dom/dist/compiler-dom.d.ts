import { ParserOptions, NodeTransform, SourceLocation, CompilerError, DirectiveTransform, CompilerOptions, CodegenResult, RootNode } from '@vue/compiler-core';
export * from '@vue/compiler-core';

declare const parserOptions: ParserOptions;

declare const V_MODEL_RADIO: unique symbol;
declare const V_MODEL_CHECKBOX: unique symbol;
declare const V_MODEL_TEXT: unique symbol;
declare const V_MODEL_SELECT: unique symbol;
declare const V_MODEL_DYNAMIC: unique symbol;
declare const V_ON_WITH_MODIFIERS: unique symbol;
declare const V_ON_WITH_KEYS: unique symbol;
declare const V_SHOW: unique symbol;
declare const TRANSITION: unique symbol;
declare const TRANSITION_GROUP: unique symbol;

declare const transformStyle: NodeTransform;

export interface DOMCompilerError extends CompilerError {
    code: DOMErrorCodes;
}
declare function createDOMCompilerError(code: DOMErrorCodes, loc?: SourceLocation): DOMCompilerError;
declare const enum DOMErrorCodes {
    X_V_HTML_NO_EXPRESSION = 51,
    X_V_HTML_WITH_CHILDREN = 52,
    X_V_TEXT_NO_EXPRESSION = 53,
    X_V_TEXT_WITH_CHILDREN = 54,
    X_V_MODEL_ON_INVALID_ELEMENT = 55,
    X_V_MODEL_ARG_ON_ELEMENT = 56,
    X_V_MODEL_ON_FILE_INPUT_ELEMENT = 57,
    X_V_MODEL_UNNECESSARY_VALUE = 58,
    X_V_SHOW_NO_EXPRESSION = 59,
    X_TRANSITION_INVALID_CHILDREN = 60,
    X_IGNORED_SIDE_EFFECT_TAG = 61,
    __EXTEND_POINT__ = 62
}

declare const DOMNodeTransforms: NodeTransform[];
declare const DOMDirectiveTransforms: Record<string, DirectiveTransform>;
declare function compile(template: string, options?: CompilerOptions): CodegenResult;
declare function parse(template: string, options?: ParserOptions): RootNode;

export { DOMDirectiveTransforms, DOMErrorCodes, DOMNodeTransforms, TRANSITION, TRANSITION_GROUP, V_MODEL_CHECKBOX, V_MODEL_DYNAMIC, V_MODEL_RADIO, V_MODEL_SELECT, V_MODEL_TEXT, V_ON_WITH_KEYS, V_ON_WITH_MODIFIERS, V_SHOW, compile, createDOMCompilerError, parse, parserOptions, transformStyle };
