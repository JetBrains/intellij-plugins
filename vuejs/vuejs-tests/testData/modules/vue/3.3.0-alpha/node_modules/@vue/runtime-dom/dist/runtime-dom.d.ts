import { SetupContext, RenderFunction, ComputedOptions, MethodOptions, ComponentOptionsMixin, EmitsOptions, ComponentInjectOptions, ComponentOptionsWithoutProps, ComponentOptionsWithArrayProps, ComponentPropsOptions, ComponentOptionsWithObjectProps, ExtractPropTypes, ComponentPublicInstance, ComponentInternalInstance, RootHydrateFunction, ConcreteComponent, BaseTransitionProps, FunctionalComponent, ObjectDirective, RootRenderFunction, CreateAppFunction } from '@vue/runtime-core';
export * from '@vue/runtime-core';

export type VueElementConstructor<P = {}> = {
    new (initialProps?: Record<string, any>): VueElement & P;
};
declare function defineCustomElement<Props, RawBindings = object>(setup: (props: Readonly<Props>, ctx: SetupContext) => RawBindings | RenderFunction): VueElementConstructor<Props>;
declare function defineCustomElement<Props = {}, RawBindings = {}, D = {}, C extends ComputedOptions = {}, M extends MethodOptions = {}, Mixin extends ComponentOptionsMixin = ComponentOptionsMixin, Extends extends ComponentOptionsMixin = ComponentOptionsMixin, E extends EmitsOptions = EmitsOptions, EE extends string = string, I extends ComponentInjectOptions = {}, II extends string = string>(options: ComponentOptionsWithoutProps<Props, RawBindings, D, C, M, Mixin, Extends, E, EE, I, II> & {
    styles?: string[];
}): VueElementConstructor<Props>;
declare function defineCustomElement<PropNames extends string, RawBindings, D, C extends ComputedOptions = {}, M extends MethodOptions = {}, Mixin extends ComponentOptionsMixin = ComponentOptionsMixin, Extends extends ComponentOptionsMixin = ComponentOptionsMixin, E extends EmitsOptions = Record<string, any>, EE extends string = string, I extends ComponentInjectOptions = {}, II extends string = string>(options: ComponentOptionsWithArrayProps<PropNames, RawBindings, D, C, M, Mixin, Extends, E, EE, I, II> & {
    styles?: string[];
}): VueElementConstructor<{
    [K in PropNames]: any;
}>;
declare function defineCustomElement<PropsOptions extends Readonly<ComponentPropsOptions>, RawBindings, D, C extends ComputedOptions = {}, M extends MethodOptions = {}, Mixin extends ComponentOptionsMixin = ComponentOptionsMixin, Extends extends ComponentOptionsMixin = ComponentOptionsMixin, E extends EmitsOptions = Record<string, any>, EE extends string = string, I extends ComponentInjectOptions = {}, II extends string = string>(options: ComponentOptionsWithObjectProps<PropsOptions, RawBindings, D, C, M, Mixin, Extends, E, EE, I, II> & {
    styles?: string[];
}): VueElementConstructor<ExtractPropTypes<PropsOptions>>;
declare function defineCustomElement(options: {
    new (...args: any[]): ComponentPublicInstance;
}): VueElementConstructor;
declare const defineSSRCustomElement: typeof defineCustomElement;
declare const BaseClass: {
    new (): HTMLElement;
    prototype: HTMLElement;
};
export type InnerComponentDef = ConcreteComponent & {
    styles?: string[];
};
declare class VueElement extends BaseClass {
    private _def;
    private _props;
    /**
     * @internal
     */
    _instance: ComponentInternalInstance | null;
    private _connected;
    private _resolved;
    private _numberProps;
    private _styles?;
    constructor(_def: InnerComponentDef, _props?: Record<string, any>, hydrate?: RootHydrateFunction);
    connectedCallback(): void;
    disconnectedCallback(): void;
    /**
     * resolve inner component definition (handle possible async component)
     */
    private _resolveDef;
    private _resolveProps;
    protected _setAttr(key: string): void;
    /**
     * @internal
     */
    protected _getProp(key: string): any;
    /**
     * @internal
     */
    protected _setProp(key: string, val: any, shouldReflect?: boolean, shouldUpdate?: boolean): void;
    private _update;
    private _createVNode;
    private _applyStyles;
}

declare function useCssModule(name?: string): Record<string, string>;

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
declare function useCssVars(getter: (ctx: any) => Record<string, string>): void;

declare const TRANSITION = "transition";
declare const ANIMATION = "animation";
export type AnimationTypes = typeof TRANSITION | typeof ANIMATION;
export interface TransitionProps extends BaseTransitionProps<Element> {
    name?: string;
    type?: AnimationTypes;
    css?: boolean;
    duration?: number | {
        enter: number;
        leave: number;
    };
    enterFromClass?: string;
    enterActiveClass?: string;
    enterToClass?: string;
    appearFromClass?: string;
    appearActiveClass?: string;
    appearToClass?: string;
    leaveFromClass?: string;
    leaveActiveClass?: string;
    leaveToClass?: string;
}
declare const Transition: FunctionalComponent<TransitionProps>;

export type TransitionGroupProps = Omit<TransitionProps, 'mode'> & {
    tag?: string;
    moveClass?: string;
};
declare const TransitionGroup: new () => {
    $props: TransitionGroupProps;
};

export type AssignerFn = (value: any) => void;
export type ModelDirective<T> = ObjectDirective<T & {
    _assign: AssignerFn;
}>;
declare const vModelText: ModelDirective<HTMLInputElement | HTMLTextAreaElement>;
declare const vModelCheckbox: ModelDirective<HTMLInputElement>;
declare const vModelRadio: ModelDirective<HTMLInputElement>;
declare const vModelSelect: ModelDirective<HTMLSelectElement>;
declare const vModelDynamic: ObjectDirective<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>;

/**
 * @private
 */
declare const withModifiers: (fn: Function, modifiers: string[]) => (event: Event, ...args: unknown[]) => any;
/**
 * @private
 */
declare const withKeys: (fn: Function, modifiers: string[]) => (event: KeyboardEvent) => any;

export interface VShowElement extends HTMLElement {
    _vod: string;
}
declare const vShow: ObjectDirective<VShowElement>;

declare module '@vue/reactivity' {
    interface RefUnwrapBailTypes {
        runtimeDOMBailTypes: Node | Window;
    }
}
declare const render: RootRenderFunction<Element | ShadowRoot>;
declare const hydrate: RootHydrateFunction;
declare const createApp: CreateAppFunction<Element>;
declare const createSSRApp: CreateAppFunction<Element>;



export { Transition, TransitionGroup, VueElement, createApp, createSSRApp, defineCustomElement, defineSSRCustomElement, hydrate, render, useCssModule, useCssVars, vModelCheckbox, vModelDynamic, vModelRadio, vModelSelect, vModelText, vShow, withKeys, withModifiers };
