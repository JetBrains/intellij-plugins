import { VNode, GenericComponentInstance, TransitionHooks, TransitionState, TransitionProps, Plugin, SchedulerJob, EmitsOptions, ComponentObjectPropsOptions, ExtractPropTypes, ReservedProps, AllowedComponentProps, ComponentCustomProps, EmitsToProps, ExtractDefaultPropTypes, EmitFn, ComponentTypeEmits, TypeEmitsToOptions, GenericAppContext, EffectScope as EffectScope$1, ShallowUnwrapRef, SuspenseBoundary, LifecycleHook, NormalizedPropsOptions, ObjectEmitsOptions, ComponentInternalOptions, AsyncComponentInternalOptions, ComponentPropsOptions, NULL_DYNAMIC_COMPONENT, CreateAppFunction, AsyncComponentLoader, AsyncComponentOptions, DirectiveModifiers, CustomElementOptions, VueElementBase } from '@vue/runtime-dom';
import { Ref, EffectScope, ReactiveEffect, ShallowRef } from '@vue/reactivity';
import { Prettify, IsKeyValues, Namespace, NormalizedStyle } from '@vue/shared';

type NodeRef = string | Ref | ((ref: Element | VaporComponentInstance, refs: Record<string, any>) => void);
type RefEl = Element | VaporComponentInstance;
type setRefFn = (el: RefEl, ref: NodeRef, refFor?: boolean, refKey?: string) => NodeRef | undefined;
export declare function createTemplateRefSetter(): setRefFn;

export declare class VaporFragment<T extends Block = Block> implements TransitionOptions {
    $key?: any;
    $transition?: VaporTransitionHooks | undefined;
    nodes: T;
    vnode?: VNode | null;
    anchor?: Node;
    parentComponent?: GenericComponentInstance | null;
    fallback?: BlockFn;
    insert?: (parent: ParentNode, anchor: Node | null, transitionHooks?: TransitionHooks) => void;
    remove?: (parent?: ParentNode, transitionHooks?: TransitionHooks) => void;
    hydrate?: (...args: any[]) => void;
    setRef?: (instance: VaporComponentInstance, ref: NodeRef, refFor: boolean, refKey: string | undefined) => void;
    onUpdated?: ((nodes?: Block) => void)[];
    constructor(nodes: T);
}
declare class ForFragment extends VaporFragment<Block[]> {
    constructor(nodes: Block[]);
}
declare class DynamicFragment extends VaporFragment {
    anchor: Node;
    scope: EffectScope | undefined;
    current?: BlockFn;
    pending?: {
        render?: BlockFn;
        key: any;
    };
    fallback?: BlockFn;
    anchorLabel?: string;
    keyed?: boolean;
    attrs?: Record<string, any>;
    setAsyncRef?: (instance: VaporComponentInstance) => void;
    getScope?: (key: any) => EffectScope | undefined;
    onBeforeTeardown?: ((oldKey: any, nodes: Block, scope: EffectScope) => boolean)[];
    onBeforeMount?: ((newKey: any, nodes: Block, scope: EffectScope) => void)[];
    slotOwner: VaporComponentInstance | null;
    constructor(anchorLabel?: string, keyed?: boolean);
    update(render?: BlockFn, key?: any): void;
    renderBranch(render: BlockFn | undefined, transition: VaporTransitionHooks | undefined, parent: ParentNode | null, instance: GenericComponentInstance | null): void;
    hydrate: (isEmpty?: boolean) => void;
}
export declare function isFragment(val: NonNullable<unknown>): val is VaporFragment;

export interface VaporTransitionHooks extends TransitionHooks {
    state: TransitionState;
    props: TransitionProps;
    instance: VaporComponentInstance;
    disabled?: boolean;
}
interface TransitionOptions {
    $key?: any;
    $transition?: VaporTransitionHooks;
}
export type Block = Node | VaporFragment | DynamicFragment | VaporComponentInstance | Block[];
type BlockFn = (...args: any[]) => Block;
export declare function insert(block: Block, parent: ParentNode & {
    $fc?: Node | null;
}, anchor?: Node | null | 0, // 0 means prepend
parentSuspense?: any): void;
export declare function prepend(parent: ParentNode, ...blocks: Block[]): void;
export declare function remove(block: Block, parent?: ParentNode): void;

declare const interopKey: unique symbol;
export declare const vaporInteropPlugin: Plugin;

type RawProps = Record<string, () => unknown> & {
    $?: DynamicPropsSource[] & {
        [interopKey]?: boolean;
    };
};
type DynamicPropsSource = (() => Record<string, unknown>) | Record<string, () => unknown>;

declare class RenderEffect extends ReactiveEffect {
    render: () => void;
    i: VaporComponentInstance | null;
    job: SchedulerJob;
    updateJob: SchedulerJob;
    constructor(render: () => void);
    fn(): void;
    notify(): void;
}
export declare function renderEffect(fn: () => void, noLifecycle?: boolean): void;

type RawSlots = Record<string, VaporSlot> & {
    $?: DynamicSlotSource[];
};
type StaticSlots = Record<string, VaporSlot>;
export type VaporSlot = BlockFn;
type DynamicSlot = {
    name: string;
    fn: VaporSlot;
};
type DynamicSlotFn = () => DynamicSlot | DynamicSlot[];
type DynamicSlotSource = StaticSlots | DynamicSlotFn;
/**
 * Wrap a slot function to track the slot owner.
 *
 * This ensures:
 * 1. createSlot gets rawSlots from the correct component (slot owner)
 * 2. Elements inherit the slot owner's scopeId
 */
export declare function withVaporCtx(fn: Function): BlockFn;
export declare function createSlot(name: string | (() => string), rawProps?: LooseRawProps | null, fallback?: VaporSlot, noSlotted?: boolean, once?: boolean): Block;

export declare const VaporTeleportImpl: {
    name: string;
    __isTeleport: boolean;
    __vapor: boolean;
    process(props: LooseRawProps, slots: LooseRawSlots): TeleportFragment;
};
declare class TeleportFragment extends VaporFragment {
    anchor?: Node;
    private rawProps?;
    private resolvedProps?;
    private rawSlots?;
    isDisabled?: boolean;
    target?: ParentNode | null;
    targetAnchor?: Node | null;
    targetStart?: Node | null;
    placeholder?: Node;
    mountContainer?: ParentNode | null;
    mountAnchor?: Node | null;
    constructor(props: LooseRawProps, slots: LooseRawSlots);
    get parent(): ParentNode | null;
    private initChildren;
    private registerUpdateCssVars;
    private handleChildrenUpdate;
    private mount;
    private mountToTarget;
    private handlePropsUpdate;
    insert: (container: ParentNode, anchor: Node | null) => void;
    remove: (parent?: ParentNode | undefined) => void;
    private hydrateDisabledTeleport;
    private mountChildren;
    hydrate: () => void;
}

export type VaporPublicProps = ReservedProps & AllowedComponentProps & ComponentCustomProps;
export type VaporRenderResult<T = Block> = VNode | T | VaporRenderResult<T>[];
type VaporComponentInstanceConstructor<T extends VaporComponentInstance> = {
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
    new (...args: any[]): T;
};
export type DefineVaporComponent<RuntimePropsOptions = {}, RuntimePropsKeys extends string = string, Emits extends EmitsOptions = {}, RuntimeEmitsKeys extends string = string, Slots extends StaticSlots = StaticSlots, Exposed extends Record<string, any> = Record<string, any>, TypeBlock extends Block = Block, TypeRefs extends Record<string, unknown> = {}, MakeDefaultsOptional extends boolean = true, InferredProps = string extends RuntimePropsKeys ? ComponentObjectPropsOptions extends RuntimePropsOptions ? {} : ExtractPropTypes<RuntimePropsOptions> : {
    [key in RuntimePropsKeys]?: any;
}, PublicProps = VaporPublicProps, ResolvedProps = InferredProps & EmitsToProps<Emits>, Defaults = ExtractDefaultPropTypes<RuntimePropsOptions>> = VaporComponentInstanceConstructor<VaporComponentInstance<MakeDefaultsOptional extends true ? keyof Defaults extends never ? Prettify<ResolvedProps> & PublicProps : Partial<Defaults> & Omit<Prettify<ResolvedProps> & PublicProps, keyof Defaults> : Prettify<ResolvedProps> & PublicProps, Emits, Slots, Exposed, TypeBlock, TypeRefs>> & ObjectVaporComponent<RuntimePropsOptions | RuntimePropsKeys[], Emits, RuntimeEmitsKeys, Slots, Exposed>;
type DefineVaporSetupFnComponent<Props extends Record<string, any> = {}, Emits extends EmitsOptions = {}, Slots extends StaticSlots = StaticSlots, Exposed extends Record<string, any> = Record<string, any>, TypeBlock extends Block = Block, ResolvedProps extends Record<string, any> = Props & EmitsToProps<Emits> & VaporPublicProps> = new (props?: ResolvedProps) => VaporComponentInstance<ResolvedProps, Emits, Slots, Exposed, TypeBlock>;
export declare function defineVaporComponent<Props extends Record<string, any>, Emits extends EmitsOptions = {}, RuntimeEmitsKeys extends string = string, Slots extends StaticSlots = StaticSlots, Exposed extends Record<string, any> = Record<string, any>, TypeBlock extends Block = Block>(setup: (props: Props, ctx: {
    emit: EmitFn<Emits>;
    slots: Slots;
    attrs: Record<string, any>;
    expose: (exposed: Exposed) => void;
}) => VaporRenderResult<TypeBlock> | void, extraOptions?: ObjectVaporComponent<(keyof Props)[], Emits, RuntimeEmitsKeys, Slots, Exposed> & ThisType<void>): DefineVaporSetupFnComponent<Props, Emits, Slots, Exposed, TypeBlock>;
export declare function defineVaporComponent<Props extends Record<string, any>, Emits extends EmitsOptions = {}, RuntimeEmitsKeys extends string = string, Slots extends StaticSlots = StaticSlots, Exposed extends Record<string, any> = Record<string, any>, TypeBlock extends Block = Block>(setup: (props: Props, ctx: {
    emit: EmitFn<Emits>;
    slots: Slots;
    attrs: Record<string, any>;
    expose: (exposed: Exposed) => void;
}) => VaporRenderResult<TypeBlock> | void, extraOptions?: ObjectVaporComponent<ComponentObjectPropsOptions<Props>, Emits, RuntimeEmitsKeys, Slots, Exposed> & ThisType<void>): DefineVaporSetupFnComponent<Props, Emits, Slots, Exposed, TypeBlock>;
export declare function defineVaporComponent<TypeProps, RuntimePropsOptions extends ComponentObjectPropsOptions = ComponentObjectPropsOptions, RuntimePropsKeys extends string = string, TypeEmits extends ComponentTypeEmits = {}, RuntimeEmitsOptions extends EmitsOptions = {}, RuntimeEmitsKeys extends string = string, Slots extends StaticSlots = StaticSlots, Exposed extends Record<string, any> = Record<string, any>, ResolvedEmits extends EmitsOptions = {} extends RuntimeEmitsOptions ? TypeEmitsToOptions<TypeEmits> : RuntimeEmitsOptions, InferredProps = IsKeyValues<TypeProps> extends true ? TypeProps : string extends RuntimePropsKeys ? ComponentObjectPropsOptions extends RuntimePropsOptions ? {} : ExtractPropTypes<RuntimePropsOptions> : {
    [key in RuntimePropsKeys]?: any;
}, TypeRefs extends Record<string, unknown> = {}, TypeBlock extends Block = Block>(options: ObjectVaporComponent<RuntimePropsOptions | RuntimePropsKeys[], ResolvedEmits, RuntimeEmitsKeys, Slots, Exposed, TypeBlock, InferredProps> & {
    /**
     * @private for language-tools use only
     */
    __typeProps?: TypeProps;
    /**
     * @private for language-tools use only
     */
    __typeEmits?: TypeEmits;
    /**
     * @private for language-tools use only
     */
    __typeRefs?: TypeRefs;
    /**
     * @private for language-tools use only
     */
    __typeEl?: TypeBlock;
} & ThisType<void>): DefineVaporComponent<RuntimePropsOptions, RuntimePropsKeys, ResolvedEmits, RuntimeEmitsKeys, Slots, Exposed extends Block ? Record<string, any> : Exposed, TypeBlock, TypeRefs, unknown extends TypeProps ? true : false, InferredProps>;

export type VaporComponent = FunctionalVaporComponent | ObjectVaporComponent | DefineVaporComponent;
export type FunctionalVaporComponent<Props = {}, Emits extends EmitsOptions = {}, Slots extends StaticSlots = StaticSlots, Exposed extends Record<string, any> = Record<string, any>> = ((props: Readonly<Props & EmitsToProps<Emits>>, ctx: {
    emit: EmitFn<Emits>;
    slots: Slots;
    attrs: Record<string, any>;
    expose: <T extends Record<string, any> = Exposed>(exposed: T) => void;
}) => VaporRenderResult) & Omit<ObjectVaporComponent<ComponentPropsOptions<Props>, Emits, string, Slots>, 'setup'> & {
    displayName?: string;
} & SharedInternalOptions;
interface ObjectVaporComponent<Props = {}, Emits extends EmitsOptions = {}, RuntimeEmitsKeys extends string = string, Slots extends StaticSlots = StaticSlots, Exposed extends Record<string, any> = Record<string, any>, TypeBlock extends Block = Block, InferredProps = ComponentObjectPropsOptions extends Props ? {} : ExtractPropTypes<Props>> extends ComponentInternalOptions, AsyncComponentInternalOptions<ObjectVaporComponent, VaporComponentInstance>, SharedInternalOptions {
    inheritAttrs?: boolean;
    props?: Props;
    emits?: Emits | RuntimeEmitsKeys[];
    slots?: Slots;
    setup?: (props: Readonly<InferredProps>, ctx: {
        emit: EmitFn<Emits>;
        slots: Slots;
        attrs: Record<string, any>;
        expose: <T extends Record<string, any> = Exposed>(exposed: T) => void;
    }) => TypeBlock | Exposed | Promise<Exposed> | void;
    render?(ctx: Exposed extends Block ? undefined : ShallowUnwrapRef<Exposed>, props: Readonly<InferredProps>, emit: EmitFn<Emits>, attrs: any, slots: Slots): VaporRenderResult<TypeBlock> | void;
    name?: string;
    vapor?: boolean;
    components?: Record<string, VaporComponent>;
}
interface SharedInternalOptions {
    /**
     * Cached normalized props options.
     * In vapor mode there are no mixins so normalized options can be cached
     * directly on the component
     */
    __propsOptions?: NormalizedPropsOptions;
    /**
     * Cached normalized props proxy handlers.
     */
    __propsHandlers?: [ProxyHandler<any> | null, ProxyHandler<any>];
    /**
     * Cached normalized emits options.
     */
    __emitsOptions?: ObjectEmitsOptions;
}
type LooseRawProps = Record<string, (() => unknown) | DynamicPropsSource[]> & {
    $?: DynamicPropsSource[];
};
type LooseRawSlots = Record<string, VaporSlot | DynamicSlotSource[]> & {
    $?: DynamicSlotSource[];
};
export declare function createComponent(component: VaporComponent, rawProps?: LooseRawProps | null, rawSlots?: LooseRawSlots | null, isSingleRoot?: boolean, once?: boolean, appContext?: GenericAppContext): VaporComponentInstance;
export declare class VaporComponentInstance<Props extends Record<string, any> = {}, Emits extends EmitsOptions = {}, Slots extends StaticSlots = StaticSlots, Exposed extends Record<string, any> = Record<string, any>, TypeBlock extends Block = Block, TypeRefs extends Record<string, any> = Record<string, any>> implements GenericComponentInstance {
    vapor: true;
    uid: number;
    type: VaporComponent;
    root: GenericComponentInstance | null;
    parent: GenericComponentInstance | null;
    appContext: GenericAppContext;
    block: TypeBlock;
    scope: EffectScope$1;
    rawProps: RawProps;
    rawSlots: RawSlots;
    props: Readonly<Props>;
    attrs: Record<string, any>;
    propsDefaults: Record<string, any> | null;
    slots: Slots;
    scopeId?: string | null;
    rawPropsRef?: ShallowRef<any>;
    rawSlotsRef?: ShallowRef<any>;
    emit: EmitFn<Emits>;
    emitted: Record<string, boolean> | null;
    expose: (<T extends Record<string, any> = Exposed>(exposed: T) => void) & string[];
    exposed: Exposed | null;
    exposeProxy: Prettify<ShallowUnwrapRef<Exposed>> | null;
    refs: TypeRefs;
    provides: Record<string, any>;
    ids: [string, number, number];
    suspense: SuspenseBoundary | null;
    suspenseId: number;
    asyncDep: Promise<any> | null;
    asyncResolved: boolean;
    renderEffects?: RenderEffect[];
    hasFallthrough: boolean;
    shapeFlag?: number;
    oncePropsCache?: Record<string | symbol, any>;
    isMounted: boolean;
    isUnmounted: boolean;
    isDeactivated: boolean;
    isUpdating: boolean;
    bc?: LifecycleHook;
    c?: LifecycleHook;
    bm?: LifecycleHook;
    m?: LifecycleHook;
    bu?: LifecycleHook;
    u?: LifecycleHook;
    um?: LifecycleHook;
    bum?: LifecycleHook;
    da?: LifecycleHook;
    a?: LifecycleHook;
    rtg?: LifecycleHook;
    rtc?: LifecycleHook;
    ec?: LifecycleHook;
    sp?: LifecycleHook<() => Promise<unknown>>;
    setupState?: Exposed extends Block ? undefined : ShallowUnwrapRef<Exposed>;
    devtoolsRawSetupState?: any;
    hmrRerender?: () => void;
    hmrReload?: (newComp: VaporComponent) => void;
    parentTeleport?: TeleportFragment | null;
    propsOptions?: NormalizedPropsOptions;
    emitsOptions?: ObjectEmitsOptions | null;
    isSingleRoot?: boolean;
    /**
     * dev only flag to track whether $attrs was used during render.
     * If $attrs was used during render then the warning for failed attrs
     * fallthrough can be suppressed.
     */
    accessedAttrs: boolean;
    constructor(comp: VaporComponent, rawProps?: RawProps | null, rawSlots?: RawSlots | null, appContext?: GenericAppContext, once?: boolean);
    /**
     * Expose `getKeysFromRawProps` on the instance so it can be used in code
     * paths where it's needed, e.g. `useModel`
     */
    rawKeys(): string[];
}
export declare function isVaporComponent(value: unknown): value is VaporComponentInstance;
/**
 * Used when a component cannot be resolved at compile time
 * and needs rely on runtime resolution - where it might fallback to a plain
 * element if the resolution fails.
 */
export declare function createComponentWithFallback(comp: VaporComponent | typeof NULL_DYNAMIC_COMPONENT | string, rawProps?: LooseRawProps | null, rawSlots?: LooseRawSlots | null, isSingleRoot?: boolean, once?: boolean, appContext?: GenericAppContext): HTMLElement | VaporComponentInstance;
export declare function createPlainElement(comp: string, rawProps?: LooseRawProps | null, rawSlots?: LooseRawSlots | null, isSingleRoot?: boolean, once?: boolean): HTMLElement;

export declare const createVaporApp: CreateAppFunction<ParentNode, VaporComponent>;
export declare const createVaporSSRApp: CreateAppFunction<ParentNode, VaporComponent>;

export declare function defineVaporAsyncComponent<T extends VaporComponent>(source: AsyncComponentLoader<T> | AsyncComponentOptions<T>): T;

export type VaporDirective = (node: Element | VaporComponentInstance, value?: () => any, argument?: string, modifiers?: DirectiveModifiers) => (() => void) | void;
type VaporDirectiveArguments = Array<[VaporDirective | undefined] | [VaporDirective | undefined, () => any] | [VaporDirective | undefined, (() => any) | undefined, argument: string] | [
    VaporDirective | undefined,
    value: (() => any) | undefined,
    argument: string | undefined,
    modifiers: DirectiveModifiers
]>;
export declare function withVaporDirectives(node: Element | VaporComponentInstance, dirs: VaporDirectiveArguments): void;

export declare const VaporKeepAliveImpl: ObjectVaporComponent;

export type VaporElementConstructor<P = {}> = {
    new (initialProps?: Record<string, any>): VaporElement & P;
};
export declare function defineVaporCustomElement<Props, RawBindings = object>(setup: (props: Props, ctx: {
    attrs: Record<string, any>;
    slots: StaticSlots;
    emit: EmitFn;
    expose: (exposed: Record<string, any>) => void;
}) => RawBindings | VaporRenderResult, options?: Pick<ObjectVaporComponent, 'name' | 'inheritAttrs' | 'emits'> & CustomElementOptions & {
    props?: (keyof Props)[];
}): VaporElementConstructor<Props>;
export declare function defineVaporCustomElement<Props, RawBindings = object>(setup: (props: Props, ctx: {
    attrs: Record<string, any>;
    slots: StaticSlots;
    emit: EmitFn;
    expose: (exposed: Record<string, any>) => void;
}) => RawBindings | VaporRenderResult, options?: Pick<ObjectVaporComponent, 'name' | 'inheritAttrs' | 'emits'> & CustomElementOptions & {
    props?: ComponentObjectPropsOptions<Props>;
}): VaporElementConstructor<Props>;
export declare function defineVaporCustomElement<RuntimePropsOptions extends ComponentObjectPropsOptions = ComponentObjectPropsOptions, RuntimePropsKeys extends string = string, RuntimeEmitsOptions extends EmitsOptions = {}, RuntimeEmitsKeys extends string = string, Slots extends StaticSlots = StaticSlots, InferredProps = string extends RuntimePropsKeys ? ComponentObjectPropsOptions extends RuntimePropsOptions ? {} : ExtractPropTypes<RuntimePropsOptions> : {
    [key in RuntimePropsKeys]?: any;
}, ResolvedProps = InferredProps & EmitsToProps<RuntimeEmitsOptions>>(options: CustomElementOptions & {
    props?: (RuntimePropsOptions & ThisType<void>) | RuntimePropsKeys[];
    emits?: RuntimeEmitsOptions | RuntimeEmitsKeys[];
    slots?: Slots;
    setup?: (props: Readonly<InferredProps>, ctx: {
        attrs: Record<string, any>;
        slots: Slots;
        emit: EmitFn<RuntimeEmitsOptions>;
        expose: (exposed: Record<string, any>) => void;
    }) => any;
} & ThisType<void>, extraOptions?: CustomElementOptions): VaporElementConstructor<ResolvedProps>;
export declare function defineVaporCustomElement<T extends DefineVaporComponent<any, any, any, any, any, any, any, any, any, any> | DefineVaporSetupFnComponent<any, any, any, any, any>>(options: T, extraOptions?: CustomElementOptions): VaporElementConstructor<T extends DefineVaporComponent<infer RuntimePropsOptions, any, any, any, any, any, any, any, any, any> ? ComponentObjectPropsOptions extends RuntimePropsOptions ? {} : ExtractPropTypes<RuntimePropsOptions> : T extends DefineVaporSetupFnComponent<infer P extends Record<string, any>, any, any, any, any> ? P : unknown>;
export declare const defineVaporSSRCustomElement: typeof defineVaporCustomElement;
type VaporInnerComponentDef = VaporComponent & CustomElementOptions;
export declare class VaporElement extends VueElementBase<ParentNode, VaporComponent, VaporInnerComponentDef> {
    constructor(def: VaporInnerComponentDef, props?: Record<string, any> | undefined, createAppFn?: CreateAppFunction<ParentNode, VaporComponent>);
    protected _needsHydration(): boolean;
    protected _mount(def: VaporInnerComponentDef): void;
    protected _update(): void;
    protected _unmount(): void;
    /**
     * Only called when shadowRoot is false
     */
    protected _updateSlotNodes(replacements: Map<Node, Node[]>): void;
    private _createComponent;
}

type InsertionParent = ParentNode & {
    $fc?: Node | null;
    $llc?: Node | null;
    $lpn?: Node | null;
    $lan?: Node | null;
    $curIdx?: number;
};
/**
 * This function is called before a block type that requires insertion
 * (component, slot outlet, if, for) is created. The state is used for actual
 * insertion on client-side render, and used for node adoption during hydration.
 */
export declare function setInsertionState(parent: ParentNode & {
    $fc?: Node | null;
}, anchor?: Node | 0 | null | number, last?: boolean): void;

export declare function template(html: string, root?: boolean, ns?: Namespace): () => Node & {
    $root?: true;
};

export declare function createTextNode(value?: string): Text;
declare const _txt: typeof _child;
declare function _child(node: InsertionParent): Node;
declare function _nthChild(node: InsertionParent, i: number): Node;
declare function _next(node: Node): Node;
type DelegatedFunction<T extends (...args: any[]) => any> = T & {
    impl: T;
};
export declare const txt: DelegatedFunction<typeof _txt>;
export declare const child: DelegatedFunction<typeof _child>;
export declare const next: DelegatedFunction<typeof _next>;
export declare const nthChild: DelegatedFunction<typeof _nthChild>;

type TargetElement = Element & {
    $root?: true;
    $html?: string;
    $cls?: string;
    $sty?: NormalizedStyle | string | undefined;
    value?: string;
    _value?: any;
};
export declare function setProp(el: any, key: string, value: any): void;
export declare function setAttr(el: any, key: string, value: any, isSVG?: boolean): void;
export declare function setDOMProp(el: any, key: string, value: any, forceHydrate?: boolean, attrName?: string): void;
export declare function setClass(el: TargetElement, value: any, isSVG?: boolean): void;
export declare function setStyle(el: TargetElement, value: any): void;
export declare function setValue(el: TargetElement, value: any, forceHydrate?: boolean): void;
/**
 * Only called on text nodes!
 * Compiler should also ensure value passed here is already converted by
 * `toDisplayString`
 */
export declare function setText(el: Text & {
    $txt?: string;
}, value: string): void;
/**
 * Used by setDynamicProps only, so need to guard with `toDisplayString`
 */
export declare function setElementText(el: Node & {
    $txt?: string;
}, value: unknown): void;
export declare function setBlockText(block: Block & {
    $txt?: string;
}, value: unknown): void;
export declare function setHtml(el: TargetElement, value: any): void;
export declare function setBlockHtml(block: Block & {
    $html?: string;
}, value: any): void;
export declare function setDynamicProps(el: any, args: any[], isSVG?: boolean): void;

export declare function on(el: Element, event: string, handler: (e: Event) => any | ((e: Event) => any)[], options?: AddEventListenerOptions & {
    effect?: boolean;
}): void;
export declare function delegate(el: any, event: string, handler: (e: Event) => any): void;
export declare const delegateEvents: (...names: string[]) => void;
export declare function setDynamicEvents(el: HTMLElement, events: Record<string, (...args: any[]) => any>): void;
export declare function createInvoker(handler: (...args: any[]) => any): (...args: any[]) => any;

export declare function createIf(condition: () => any, b1: BlockFn, b2?: BlockFn, once?: boolean): Block;

/**
 * Create a dynamic fragment keyed by a reactive value for Vapor transitions.
 * The fragment is re-rendered when the key changes to trigger enter/leave
 * animations.
 *
 * Example:
 * <VaporTransition>
 *   <h1 :key="count">{{ count }}</h1>
 * </VaporTransition>
 */
export declare function createKeyedFragment(key: () => any, render: BlockFn): Block;

type Source = any[] | Record<any, any> | number | Set<any> | Map<any, any>;
export declare const createFor: (src: () => Source, renderItem: (item: ShallowRef<any>, key: ShallowRef<any>, index: ShallowRef<number | undefined>) => Block, getKey?: (item: any, key: any, index?: number) => any, flags?: number, setup?: (_: {
    createSelector: (source: () => any) => (cb: () => void) => void;
}) => void) => ForFragment;
export declare function createForSlots(rawSource: Source, getSlot: (item: any, key: any, index?: number) => DynamicSlot): DynamicSlot[];
export declare function getRestElement(val: any, keys: string[]): any;
export declare function getDefaultValue(val: any, defaultVal: any): any;

export declare function useVaporCssVars(getter: () => Record<string, string>): void;

export declare function createDynamicComponent(getter: () => any, rawProps?: RawProps | null, rawSlots?: RawSlots | null, isSingleRoot?: boolean, once?: boolean): VaporFragment;

export declare function applyVShow(target: Block, source: () => any): void;

type VaporModelDirective<T extends HTMLElement = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement, Modifiers extends string = string> = (el: T, get: () => any, set: (v: any) => void, modifiers?: {
    [key in Modifiers]?: true;
}) => void;
export declare const applyTextModel: VaporModelDirective<HTMLInputElement | HTMLTextAreaElement, 'trim' | 'number' | 'lazy'>;
export declare const applyCheckboxModel: VaporModelDirective<HTMLInputElement>;
export declare const applyRadioModel: VaporModelDirective<HTMLInputElement>;
export declare const applySelectModel: VaporModelDirective<HTMLSelectElement, 'number'>;
export declare const applyDynamicModel: VaporModelDirective;

export declare const VaporTransition: FunctionalVaporComponent<TransitionProps>;

export declare const VaporTransitionGroup: ObjectVaporComponent;

export { VaporKeepAliveImpl as VaporKeepAlive, VaporTeleportImpl as VaporTeleport,  };
