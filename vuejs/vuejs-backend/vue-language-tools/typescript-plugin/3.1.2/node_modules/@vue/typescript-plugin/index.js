"use strict";


//#region rolldown:runtime
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

//#endregion

//#region node_modules/@volar/source-map/lib/binarySearch.js
var require_binarySearch$1 = __commonJS({ "node_modules/@volar/source-map/lib/binarySearch.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.binarySearch = binarySearch$2;
	function binarySearch$2(values, searchValue) {
		let low = 0;
		let high = values.length - 1;
		let match;
		while (low <= high) {
			const mid = Math.floor((low + high) / 2);
			const midValue = values[mid];
			if (midValue < searchValue) low = mid + 1;
			else if (midValue > searchValue) high = mid - 1;
			else {
				low = mid;
				high = mid;
				match = mid;
				break;
			}
		}
		const finalLow = Math.max(Math.min(low, high, values.length - 1), 0);
		const finalHigh = Math.min(Math.max(low, high, 0), values.length - 1);
		return {
			low: finalLow,
			high: finalHigh,
			match
		};
	}
} });

//#endregion
//#region node_modules/@volar/source-map/lib/translateOffset.js
var require_translateOffset = __commonJS({ "node_modules/@volar/source-map/lib/translateOffset.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.translateOffset = translateOffset;
	let warned = false;
	function translateOffset(start, fromOffsets, toOffsets$1, fromLengths, toLengths = fromLengths) {
		const isSorted = fromOffsets.every((value, index) => index === 0 || fromOffsets[index - 1] <= value);
		if (!isSorted) {
			for (let i = 0; i < fromOffsets.length; i++) {
				const fromOffset = fromOffsets[i];
				const fromLength = fromLengths[i];
				if (start >= fromOffset && start <= fromOffset + fromLength) {
					const toLength = toLengths[i];
					const toOffset = toOffsets$1[i];
					let rangeOffset = Math.min(start - fromOffset, toLength);
					return toOffset + rangeOffset;
				}
			}
			if (!warned) {
				warned = true;
				console.warn("fromOffsets should be sorted in ascending order");
			}
		}
		let low = 0;
		let high = fromOffsets.length - 1;
		while (low <= high) {
			const mid = Math.floor((low + high) / 2);
			const fromOffset = fromOffsets[mid];
			const fromLength = fromLengths[mid];
			if (start >= fromOffset && start <= fromOffset + fromLength) {
				const toLength = toLengths[mid];
				const toOffset = toOffsets$1[mid];
				let rangeOffset = Math.min(start - fromOffset, toLength);
				return toOffset + rangeOffset;
			} else if (start < fromOffset) high = mid - 1;
			else low = mid + 1;
		}
	}
} });

//#endregion
//#region node_modules/@volar/source-map/lib/sourceMap.js
var require_sourceMap = __commonJS({ "node_modules/@volar/source-map/lib/sourceMap.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SourceMap = void 0;
	const binarySearch_1$1 = require_binarySearch$1();
	const translateOffset_1 = require_translateOffset();
	var SourceMap = class {
		constructor(mappings) {
			this.mappings = mappings;
		}
		toSourceRange(generatedStart, generatedEnd, fallbackToAnyMatch, filter) {
			return this.findMatchingStartEnd(generatedStart, generatedEnd, fallbackToAnyMatch, "generatedOffsets", filter);
		}
		toGeneratedRange(sourceStart, sourceEnd, fallbackToAnyMatch, filter) {
			return this.findMatchingStartEnd(sourceStart, sourceEnd, fallbackToAnyMatch, "sourceOffsets", filter);
		}
		toSourceLocation(generatedOffset, filter) {
			return this.findMatchingOffsets(generatedOffset, "generatedOffsets", filter);
		}
		toGeneratedLocation(sourceOffset, filter) {
			return this.findMatchingOffsets(sourceOffset, "sourceOffsets", filter);
		}
		*findMatchingOffsets(offset, fromRange, filter) {
			const memo = this.getMemoBasedOnRange(fromRange);
			if (memo.offsets.length === 0) return;
			const { low: start, high: end } = (0, binarySearch_1$1.binarySearch)(memo.offsets, offset);
			const skip = /* @__PURE__ */ new Set();
			const toRange = fromRange == "sourceOffsets" ? "generatedOffsets" : "sourceOffsets";
			for (let i = start; i <= end; i++) for (const mapping of memo.mappings[i]) {
				if (skip.has(mapping)) continue;
				skip.add(mapping);
				if (filter && !filter(mapping.data)) continue;
				const mapped = (0, translateOffset_1.translateOffset)(offset, mapping[fromRange], mapping[toRange], getLengths(mapping, fromRange), getLengths(mapping, toRange));
				if (mapped !== void 0) yield [mapped, mapping];
			}
		}
		*findMatchingStartEnd(start, end, fallbackToAnyMatch, fromRange, filter) {
			const toRange = fromRange == "sourceOffsets" ? "generatedOffsets" : "sourceOffsets";
			const mappedStarts = [];
			let hadMatch = false;
			for (const [mappedStart, mapping] of this.findMatchingOffsets(start, fromRange)) {
				if (filter && !filter(mapping.data)) continue;
				mappedStarts.push([mappedStart, mapping]);
				const mappedEnd = (0, translateOffset_1.translateOffset)(end, mapping[fromRange], mapping[toRange], getLengths(mapping, fromRange), getLengths(mapping, toRange));
				if (mappedEnd !== void 0) {
					hadMatch = true;
					yield [
						mappedStart,
						mappedEnd,
						mapping,
						mapping
					];
				}
			}
			if (!hadMatch && fallbackToAnyMatch) for (const [mappedStart, mappingStart] of mappedStarts) for (const [mappedEnd, mappingEnd] of this.findMatchingOffsets(end, fromRange)) {
				if (filter && !filter(mappingEnd.data) || mappedEnd < mappedStart) continue;
				yield [
					mappedStart,
					mappedEnd,
					mappingStart,
					mappingEnd
				];
				break;
			}
		}
		getMemoBasedOnRange(fromRange) {
			return fromRange === "sourceOffsets" ? this.sourceCodeOffsetsMemo ??= this.createMemo("sourceOffsets") : this.generatedCodeOffsetsMemo ??= this.createMemo("generatedOffsets");
		}
		createMemo(key) {
			const offsetsSet = /* @__PURE__ */ new Set();
			for (const mapping of this.mappings) for (let i = 0; i < mapping[key].length; i++) {
				offsetsSet.add(mapping[key][i]);
				offsetsSet.add(mapping[key][i] + getLengths(mapping, key)[i]);
			}
			const offsets = [...offsetsSet].sort((a, b) => a - b);
			const mappings = offsets.map(() => /* @__PURE__ */ new Set());
			for (const mapping of this.mappings) for (let i = 0; i < mapping[key].length; i++) {
				const startIndex = (0, binarySearch_1$1.binarySearch)(offsets, mapping[key][i]).match;
				const endIndex = (0, binarySearch_1$1.binarySearch)(offsets, mapping[key][i] + getLengths(mapping, key)[i]).match;
				for (let i$1 = startIndex; i$1 <= endIndex; i$1++) mappings[i$1].add(mapping);
			}
			return {
				offsets,
				mappings
			};
		}
	};
	exports.SourceMap = SourceMap;
	function getLengths(mapping, key) {
		return key == "sourceOffsets" ? mapping.lengths : mapping.generatedLengths ?? mapping.lengths;
	}
} });

//#endregion
//#region node_modules/@volar/source-map/index.js
var require_source_map$1 = __commonJS({ "node_modules/@volar/source-map/index.js"(exports) {
	var __createBinding$5 = void 0 && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	});
	var __exportStar$4 = void 0 && (void 0).__exportStar || function(m, exports$1) {
		for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$5(exports$1, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar$4(require_sourceMap(), exports);
	__exportStar$4(require_translateOffset(), exports);
} });

//#endregion
//#region node_modules/@volar/language-core/lib/editor.js
var require_editor = __commonJS({ "node_modules/@volar/language-core/lib/editor.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isHoverEnabled = isHoverEnabled;
	exports.isInlayHintsEnabled = isInlayHintsEnabled;
	exports.isCodeLensEnabled = isCodeLensEnabled;
	exports.isMonikerEnabled = isMonikerEnabled;
	exports.isInlineValueEnabled = isInlineValueEnabled;
	exports.isSemanticTokensEnabled = isSemanticTokensEnabled;
	exports.isCallHierarchyEnabled = isCallHierarchyEnabled;
	exports.isTypeHierarchyEnabled = isTypeHierarchyEnabled;
	exports.isRenameEnabled = isRenameEnabled;
	exports.isDefinitionEnabled = isDefinitionEnabled;
	exports.isTypeDefinitionEnabled = isTypeDefinitionEnabled;
	exports.isReferencesEnabled = isReferencesEnabled;
	exports.isImplementationEnabled = isImplementationEnabled;
	exports.isHighlightEnabled = isHighlightEnabled;
	exports.isSymbolsEnabled = isSymbolsEnabled;
	exports.isFoldingRangesEnabled = isFoldingRangesEnabled;
	exports.isSelectionRangesEnabled = isSelectionRangesEnabled;
	exports.isLinkedEditingEnabled = isLinkedEditingEnabled;
	exports.isColorEnabled = isColorEnabled;
	exports.isDocumentLinkEnabled = isDocumentLinkEnabled;
	exports.isDiagnosticsEnabled = isDiagnosticsEnabled;
	exports.isCodeActionsEnabled = isCodeActionsEnabled;
	exports.isFormattingEnabled = isFormattingEnabled;
	exports.isCompletionEnabled = isCompletionEnabled;
	exports.isAutoInsertEnabled = isAutoInsertEnabled;
	exports.isSignatureHelpEnabled = isSignatureHelpEnabled;
	exports.shouldReportDiagnostics = shouldReportDiagnostics;
	exports.resolveRenameNewName = resolveRenameNewName;
	exports.resolveRenameEditText = resolveRenameEditText;
	exports.findOverlapCodeRange = findOverlapCodeRange;
	function isHoverEnabled(info) {
		return !!info.semantic;
	}
	function isInlayHintsEnabled(info) {
		return !!info.semantic;
	}
	function isCodeLensEnabled(info) {
		return !!info.semantic;
	}
	function isMonikerEnabled(info) {
		return !!info.semantic;
	}
	function isInlineValueEnabled(info) {
		return !!info.semantic;
	}
	function isSemanticTokensEnabled(info) {
		return typeof info.semantic === "object" ? info.semantic.shouldHighlight?.() ?? true : !!info.semantic;
	}
	function isCallHierarchyEnabled(info) {
		return !!info.navigation;
	}
	function isTypeHierarchyEnabled(info) {
		return !!info.navigation;
	}
	function isRenameEnabled(info) {
		return typeof info.navigation === "object" ? info.navigation.shouldRename?.() ?? true : !!info.navigation;
	}
	function isDefinitionEnabled(info) {
		return !!info.navigation;
	}
	function isTypeDefinitionEnabled(info) {
		return !!info.navigation;
	}
	function isReferencesEnabled(info) {
		return !!info.navigation;
	}
	function isImplementationEnabled(info) {
		return !!info.navigation;
	}
	function isHighlightEnabled(info) {
		return typeof info.navigation === "object" ? info.navigation.shouldHighlight?.() ?? true : !!info.navigation;
	}
	function isSymbolsEnabled(info) {
		return !!info.structure;
	}
	function isFoldingRangesEnabled(info) {
		return !!info.structure;
	}
	function isSelectionRangesEnabled(info) {
		return !!info.structure;
	}
	function isLinkedEditingEnabled(info) {
		return !!info.structure;
	}
	function isColorEnabled(info) {
		return !!info.structure;
	}
	function isDocumentLinkEnabled(info) {
		return !!info.structure;
	}
	function isDiagnosticsEnabled(info) {
		return !!info.verification;
	}
	function isCodeActionsEnabled(info) {
		return !!info.verification;
	}
	function isFormattingEnabled(info) {
		return !!info.format;
	}
	function isCompletionEnabled(info) {
		return !!info.completion;
	}
	function isAutoInsertEnabled(info) {
		return !!info.completion;
	}
	function isSignatureHelpEnabled(info) {
		return !!info.completion;
	}
	function shouldReportDiagnostics(info, source, code$1) {
		return typeof info.verification === "object" ? info.verification.shouldReport?.(source, code$1) ?? true : !!info.verification;
	}
	function resolveRenameNewName(newName, info) {
		return typeof info.navigation === "object" ? info.navigation.resolveRenameNewName?.(newName) ?? newName : newName;
	}
	function resolveRenameEditText(text, info) {
		return typeof info.navigation === "object" ? info.navigation.resolveRenameEditText?.(text) ?? text : text;
	}
	function findOverlapCodeRange(start, end, map, filter) {
		let mappedStart;
		let mappedEnd;
		for (const [mapped, mapping] of map.toGeneratedLocation(start)) if (filter(mapping.data)) {
			mappedStart = mapped;
			break;
		}
		for (const [mapped, mapping] of map.toGeneratedLocation(end)) if (filter(mapping.data)) {
			mappedEnd = mapped;
			break;
		}
		if (mappedStart === void 0 || mappedEnd === void 0) {
			for (const mapping of map.mappings) if (filter(mapping.data)) {
				const mappingStart = mapping.sourceOffsets[0];
				const mappingEnd = mapping.sourceOffsets[mapping.sourceOffsets.length - 1] + mapping.lengths[mapping.lengths.length - 1];
				const overlap = getOverlapRange(start, end, mappingStart, mappingEnd);
				if (overlap) {
					const curMappedStart = overlap.start - mappingStart + mapping.generatedOffsets[0];
					const lastGeneratedLength = (mapping.generatedLengths ?? mapping.lengths)[mapping.generatedOffsets.length - 1];
					const curMappedEndOffset = Math.min(overlap.end - mapping.sourceOffsets[mapping.sourceOffsets.length - 1], lastGeneratedLength);
					const curMappedEnd = mapping.generatedOffsets[mapping.generatedOffsets.length - 1] + curMappedEndOffset;
					mappedStart = mappedStart === void 0 ? curMappedStart : Math.min(mappedStart, curMappedStart);
					mappedEnd = mappedEnd === void 0 ? curMappedEnd : Math.max(mappedEnd, curMappedEnd);
				}
			}
		}
		if (mappedStart !== void 0 && mappedEnd !== void 0) return {
			start: mappedStart,
			end: mappedEnd
		};
	}
	function getOverlapRange(range1Start, range1End, range2Start, range2End) {
		const start = Math.max(range1Start, range2Start);
		const end = Math.min(range1End, range2End);
		if (start > end) return void 0;
		return {
			start,
			end
		};
	}
} });

//#endregion
//#region node_modules/@volar/language-core/lib/linkedCodeMap.js
var require_linkedCodeMap = __commonJS({ "node_modules/@volar/language-core/lib/linkedCodeMap.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.LinkedCodeMap = void 0;
	const source_map_1$1 = require_source_map$1();
	var LinkedCodeMap = class extends source_map_1$1.SourceMap {
		*getLinkedOffsets(start) {
			for (const mapped of this.toGeneratedLocation(start)) yield mapped[0];
			for (const mapped of this.toSourceLocation(start)) yield mapped[0];
		}
	};
	exports.LinkedCodeMap = LinkedCodeMap;
} });

//#endregion
//#region node_modules/@volar/language-core/lib/types.js
var require_types$2 = __commonJS({ "node_modules/@volar/language-core/lib/types.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
} });

//#endregion
//#region node_modules/@volar/language-core/lib/utils.js
var require_utils$5 = __commonJS({ "node_modules/@volar/language-core/lib/utils.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FileMap = void 0;
	var FileMap = class extends Map {
		constructor(caseSensitive) {
			super();
			this.caseSensitive = caseSensitive;
			this.originalFileNames = /* @__PURE__ */ new Map();
		}
		keys() {
			return this.originalFileNames.values();
		}
		get(key) {
			return super.get(this.normalizeId(key));
		}
		has(key) {
			return super.has(this.normalizeId(key));
		}
		set(key, value) {
			this.originalFileNames.set(this.normalizeId(key), key);
			return super.set(this.normalizeId(key), value);
		}
		delete(key) {
			this.originalFileNames.delete(this.normalizeId(key));
			return super.delete(this.normalizeId(key));
		}
		clear() {
			this.originalFileNames.clear();
			return super.clear();
		}
		normalizeId(id) {
			return this.caseSensitive ? id : id.toLowerCase();
		}
	};
	exports.FileMap = FileMap;
} });

//#endregion
//#region node_modules/@volar/language-core/index.js
var require_language_core$1 = __commonJS({ "node_modules/@volar/language-core/index.js"(exports) {
	var __createBinding$4 = void 0 && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	});
	var __exportStar$3 = void 0 && (void 0).__exportStar || function(m, exports$1) {
		for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$4(exports$1, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.defaultMapperFactory = exports.SourceMap = void 0;
	exports.createLanguage = createLanguage;
	exports.forEachEmbeddedCode = forEachEmbeddedCode;
	var source_map_1 = require_source_map$1();
	Object.defineProperty(exports, "SourceMap", {
		enumerable: true,
		get: function() {
			return source_map_1.SourceMap;
		}
	});
	__exportStar$3(require_editor(), exports);
	__exportStar$3(require_linkedCodeMap(), exports);
	__exportStar$3(require_types$2(), exports);
	__exportStar$3(require_utils$5(), exports);
	const source_map_2 = require_source_map$1();
	const linkedCodeMap_1 = require_linkedCodeMap();
	const defaultMapperFactory = (mappings) => new source_map_2.SourceMap(mappings);
	exports.defaultMapperFactory = defaultMapperFactory;
	function createLanguage(plugins, scriptRegistry, sync, onAssociationDirty) {
		const virtualCodeToSourceScriptMap = /* @__PURE__ */ new WeakMap();
		const virtualCodeToSourceMap = /* @__PURE__ */ new WeakMap();
		const virtualCodeToLinkedCodeMap = /* @__PURE__ */ new WeakMap();
		const language = {
			mapperFactory: exports.defaultMapperFactory,
			plugins,
			scripts: {
				fromVirtualCode(virtualCode) {
					return virtualCodeToSourceScriptMap.get(virtualCode);
				},
				get(id, includeFsFiles = true, shouldRegister = false) {
					sync(id, includeFsFiles, shouldRegister);
					const result = scriptRegistry.get(id);
					if (result?.isAssociationDirty) this.set(id, result.snapshot, result.languageId);
					return scriptRegistry.get(id);
				},
				set(id, snapshot, languageId, _plugins = plugins) {
					if (!languageId) for (const plugin$14 of plugins) {
						languageId = plugin$14.getLanguageId?.(id);
						if (languageId) break;
					}
					if (!languageId) {
						console.warn(`languageId not found for ${id}`);
						return;
					}
					let associatedOnly = false;
					for (const plugin$14 of plugins) if (plugin$14.isAssociatedFileOnly?.(id, languageId)) {
						associatedOnly = true;
						break;
					}
					if (scriptRegistry.has(id)) {
						const sourceScript = scriptRegistry.get(id);
						if (sourceScript.languageId !== languageId || sourceScript.associatedOnly !== associatedOnly) {
							this.delete(id);
							triggerTargetsDirty(sourceScript);
							return this.set(id, snapshot, languageId);
						} else if (associatedOnly) {
							if (sourceScript.snapshot !== snapshot) {
								sourceScript.snapshot = snapshot;
								triggerTargetsDirty(sourceScript);
							}
						} else if (sourceScript.isAssociationDirty || sourceScript.snapshot !== snapshot) {
							if (sourceScript.snapshot !== snapshot) {
								sourceScript.snapshot = snapshot;
								triggerTargetsDirty(sourceScript);
							}
							const codegenCtx = prepareCreateVirtualCode(sourceScript);
							if (sourceScript.generated) {
								const { updateVirtualCode, createVirtualCode } = sourceScript.generated.languagePlugin;
								const newVirtualCode = updateVirtualCode ? updateVirtualCode(id, sourceScript.generated.root, snapshot, codegenCtx) : createVirtualCode?.(id, languageId, snapshot, codegenCtx);
								if (newVirtualCode) {
									sourceScript.generated.root = newVirtualCode;
									sourceScript.generated.embeddedCodes.clear();
									for (const code$1 of forEachEmbeddedCode(sourceScript.generated.root)) {
										virtualCodeToSourceScriptMap.set(code$1, sourceScript);
										sourceScript.generated.embeddedCodes.set(code$1.id, code$1);
									}
									return sourceScript;
								} else {
									this.delete(id);
									return;
								}
							}
						} else return sourceScript;
					} else {
						const sourceScript = {
							id,
							languageId,
							snapshot,
							associatedIds: /* @__PURE__ */ new Set(),
							targetIds: /* @__PURE__ */ new Set(),
							associatedOnly
						};
						scriptRegistry.set(id, sourceScript);
						if (associatedOnly) return sourceScript;
						for (const languagePlugin of _plugins) {
							const virtualCode = languagePlugin.createVirtualCode?.(id, languageId, snapshot, prepareCreateVirtualCode(sourceScript));
							if (virtualCode) {
								sourceScript.generated = {
									root: virtualCode,
									languagePlugin,
									embeddedCodes: /* @__PURE__ */ new Map()
								};
								for (const code$1 of forEachEmbeddedCode(virtualCode)) {
									virtualCodeToSourceScriptMap.set(code$1, sourceScript);
									sourceScript.generated.embeddedCodes.set(code$1.id, code$1);
								}
								break;
							}
						}
						return sourceScript;
					}
				},
				delete(id) {
					const sourceScript = scriptRegistry.get(id);
					if (sourceScript) {
						sourceScript.generated?.languagePlugin.disposeVirtualCode?.(id, sourceScript.generated.root);
						scriptRegistry.delete(id);
						triggerTargetsDirty(sourceScript);
					}
				}
			},
			maps: {
				get(virtualCode, sourceScript) {
					let mapCache = virtualCodeToSourceMap.get(virtualCode.snapshot);
					if (!mapCache) virtualCodeToSourceMap.set(virtualCode.snapshot, mapCache = /* @__PURE__ */ new WeakMap());
					if (!mapCache.has(sourceScript.snapshot)) {
						const mappings = virtualCode.associatedScriptMappings?.get(sourceScript.id) ?? virtualCode.mappings;
						mapCache.set(sourceScript.snapshot, language.mapperFactory(mappings));
					}
					return mapCache.get(sourceScript.snapshot);
				},
				*forEach(virtualCode) {
					const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);
					yield [sourceScript, this.get(virtualCode, sourceScript)];
					if (virtualCode.associatedScriptMappings) for (const [relatedScriptId] of virtualCode.associatedScriptMappings) {
						const relatedSourceScript = scriptRegistry.get(relatedScriptId);
						if (relatedSourceScript) yield [relatedSourceScript, this.get(virtualCode, relatedSourceScript)];
					}
				}
			},
			linkedCodeMaps: { get(virtualCode) {
				const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);
				let mapCache = virtualCodeToLinkedCodeMap.get(virtualCode.snapshot);
				if (mapCache?.[0] !== sourceScript.snapshot) virtualCodeToLinkedCodeMap.set(virtualCode.snapshot, mapCache = [sourceScript.snapshot, virtualCode.linkedCodeMappings ? new linkedCodeMap_1.LinkedCodeMap(virtualCode.linkedCodeMappings) : void 0]);
				return mapCache[1];
			} }
		};
		return language;
		function triggerTargetsDirty(sourceScript) {
			sourceScript.targetIds.forEach((id) => {
				const sourceScript$1 = scriptRegistry.get(id);
				if (sourceScript$1) {
					sourceScript$1.isAssociationDirty = true;
					onAssociationDirty?.(sourceScript$1.id);
				}
			});
		}
		function prepareCreateVirtualCode(sourceScript) {
			for (const id of sourceScript.associatedIds) scriptRegistry.get(id)?.targetIds.delete(sourceScript.id);
			sourceScript.associatedIds.clear();
			sourceScript.isAssociationDirty = false;
			return { getAssociatedScript(id) {
				sync(id, true, true);
				const relatedSourceScript = scriptRegistry.get(id);
				if (relatedSourceScript) {
					relatedSourceScript.targetIds.add(sourceScript.id);
					sourceScript.associatedIds.add(relatedSourceScript.id);
				}
				return relatedSourceScript;
			} };
		}
	}
	function* forEachEmbeddedCode(virtualCode) {
		yield virtualCode;
		if (virtualCode.embeddedCodes) for (const embeddedCode of virtualCode.embeddedCodes) yield* forEachEmbeddedCode(embeddedCode);
	}
} });

//#endregion
//#region node_modules/@volar/typescript/lib/node/dedupe.js
var require_dedupe = __commonJS({ "node_modules/@volar/typescript/lib/node/dedupe.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.dedupeDocumentSpans = dedupeDocumentSpans;
	function dedupeDocumentSpans(items) {
		return dedupe(items, (item) => [
			item.fileName,
			item.textSpan.start,
			item.textSpan.length
		].join(":"));
	}
	function dedupe(items, getKey) {
		const map = /* @__PURE__ */ new Map();
		for (const item of items.reverse()) map.set(getKey(item), item);
		return [...map.values()];
	}
} });

//#endregion
//#region node_modules/@volar/typescript/lib/node/utils.js
var require_utils$4 = __commonJS({ "node_modules/@volar/typescript/lib/node/utils.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getServiceScript = getServiceScript;
	function getServiceScript(language, fileName) {
		const sourceScript = language.scripts.get(fileName);
		if (sourceScript?.targetIds.size) for (const targetId of sourceScript.targetIds) {
			const targetScript = language.scripts.get(targetId);
			if (targetScript?.generated) {
				const serviceScript = targetScript.generated.languagePlugin.typescript?.getServiceScript(targetScript.generated.root);
				if (serviceScript) return [
					serviceScript,
					targetScript,
					sourceScript
				];
			}
		}
		if (sourceScript?.associatedOnly) return [
			void 0,
			sourceScript,
			sourceScript
		];
		if (sourceScript?.generated) {
			const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
			if (serviceScript) return [
				serviceScript,
				sourceScript,
				sourceScript
			];
		}
		return [
			void 0,
			void 0,
			void 0
		];
	}
} });

//#endregion
//#region node_modules/@volar/typescript/lib/node/transform.js
var require_transform = __commonJS({ "node_modules/@volar/typescript/lib/node/transform.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.transformCallHierarchyItem = transformCallHierarchyItem;
	exports.transformDiagnostic = transformDiagnostic;
	exports.fillSourceFileText = fillSourceFileText;
	exports.transformFileTextChanges = transformFileTextChanges;
	exports.transformDocumentSpan = transformDocumentSpan;
	exports.transformSpan = transformSpan;
	exports.transformTextChange = transformTextChange;
	exports.transformTextSpan = transformTextSpan;
	exports.toSourceOffset = toSourceOffset;
	exports.toSourceRanges = toSourceRanges;
	exports.toSourceOffsets = toSourceOffsets;
	exports.toGeneratedRange = toGeneratedRange;
	exports.toGeneratedRanges = toGeneratedRanges;
	exports.toGeneratedOffset = toGeneratedOffset;
	exports.toGeneratedOffsets = toGeneratedOffsets;
	exports.getMappingOffset = getMappingOffset;
	const language_core_1$8 = require_language_core$1();
	const utils_1$36 = require_utils$4();
	const transformedDiagnostics = /* @__PURE__ */ new WeakMap();
	const transformedSourceFile = /* @__PURE__ */ new WeakSet();
	/**
	* This file contains a number of facilities for transforming `ts.Diagnostic`s returned
	* from the  base TypeScript LanguageService, which reference locations in generated
	* TS code (e.g. the TypeScript codegen'd from the script portion of a .vue file) into locations
	* in the script portion of the .vue file.
	*/
	function transformCallHierarchyItem(language, item, fallbackToAnyMatch, filter) {
		const span = transformSpan(language, item.file, item.span, fallbackToAnyMatch, filter);
		const selectionSpan = transformSpan(language, item.file, item.selectionSpan, fallbackToAnyMatch, filter);
		return {
			...item,
			file: span?.fileName ?? item.file,
			span: span?.textSpan ?? {
				start: 0,
				length: 0
			},
			selectionSpan: selectionSpan?.textSpan ?? {
				start: 0,
				length: 0
			}
		};
	}
	function transformDiagnostic(language, diagnostic, program, isTsc) {
		if (!transformedDiagnostics.has(diagnostic)) {
			transformedDiagnostics.set(diagnostic, void 0);
			const { relatedInformation } = diagnostic;
			if (relatedInformation) diagnostic.relatedInformation = relatedInformation.map((d) => transformDiagnostic(language, d, program, isTsc)).filter((d) => !!d);
			if (diagnostic.file !== void 0 && diagnostic.start !== void 0 && diagnostic.length !== void 0) {
				const [serviceScript] = (0, utils_1$36.getServiceScript)(language, diagnostic.file.fileName);
				if (serviceScript) {
					const [sourceSpanFileName, sourceSpan] = transformTextSpan(void 0, language, serviceScript, {
						start: diagnostic.start,
						length: diagnostic.length
					}, true, (data) => (0, language_core_1$8.shouldReportDiagnostics)(data, String(diagnostic.source), String(diagnostic.code))) ?? [];
					const actualDiagnosticFile = sourceSpanFileName ? diagnostic.file.fileName === sourceSpanFileName ? diagnostic.file : program?.getSourceFile(sourceSpanFileName) : void 0;
					if (sourceSpan && actualDiagnosticFile) {
						if (isTsc) fillSourceFileText(language, diagnostic.file);
						transformedDiagnostics.set(diagnostic, {
							...diagnostic,
							file: actualDiagnosticFile,
							start: sourceSpan.start,
							length: sourceSpan.length
						});
					}
				} else transformedDiagnostics.set(diagnostic, diagnostic);
			} else transformedDiagnostics.set(diagnostic, diagnostic);
		}
		return transformedDiagnostics.get(diagnostic);
	}
	function fillSourceFileText(language, sourceFile) {
		if (transformedSourceFile.has(sourceFile)) return;
		transformedSourceFile.add(sourceFile);
		const [serviceScript] = (0, utils_1$36.getServiceScript)(language, sourceFile.fileName);
		if (serviceScript && !serviceScript.preventLeadingOffset) {
			const sourceScript = language.scripts.fromVirtualCode(serviceScript.code);
			sourceFile.text = sourceScript.snapshot.getText(0, sourceScript.snapshot.getLength()) + sourceFile.text.substring(sourceScript.snapshot.getLength());
		}
	}
	function transformFileTextChanges(language, changes, fallbackToAnyMatch, filter) {
		const changesPerFile = {};
		const newFiles = /* @__PURE__ */ new Set();
		for (const fileChanges of changes) {
			const [_, source] = (0, utils_1$36.getServiceScript)(language, fileChanges.fileName);
			if (source) fileChanges.textChanges.forEach((c) => {
				const { fileName, textSpan } = transformSpan(language, fileChanges.fileName, c.span, fallbackToAnyMatch, filter) ?? {};
				if (fileName && textSpan) (changesPerFile[fileName] ?? (changesPerFile[fileName] = [])).push({
					...c,
					span: textSpan
				});
			});
			else {
				const list = changesPerFile[fileChanges.fileName] ?? (changesPerFile[fileChanges.fileName] = []);
				fileChanges.textChanges.forEach((c) => {
					list.push(c);
				});
				if (fileChanges.isNewFile) newFiles.add(fileChanges.fileName);
			}
		}
		const result = [];
		for (const fileName in changesPerFile) result.push({
			fileName,
			isNewFile: newFiles.has(fileName),
			textChanges: changesPerFile[fileName]
		});
		return result;
	}
	function transformDocumentSpan(language, documentSpan, fallbackToAnyMatch, filter, shouldFallback) {
		let textSpan = transformSpan(language, documentSpan.fileName, documentSpan.textSpan, fallbackToAnyMatch, filter);
		if (!textSpan && shouldFallback) textSpan = {
			fileName: documentSpan.fileName,
			textSpan: {
				start: 0,
				length: 0
			}
		};
		if (!textSpan) return;
		const contextSpan = transformSpan(language, documentSpan.fileName, documentSpan.contextSpan, fallbackToAnyMatch, filter);
		const originalTextSpan = transformSpan(language, documentSpan.originalFileName, documentSpan.originalTextSpan, fallbackToAnyMatch, filter);
		const originalContextSpan = transformSpan(language, documentSpan.originalFileName, documentSpan.originalContextSpan, fallbackToAnyMatch, filter);
		return {
			...documentSpan,
			fileName: textSpan.fileName,
			textSpan: textSpan.textSpan,
			contextSpan: contextSpan?.textSpan,
			originalFileName: originalTextSpan?.fileName,
			originalTextSpan: originalTextSpan?.textSpan,
			originalContextSpan: originalContextSpan?.textSpan
		};
	}
	function transformSpan(language, fileName, textSpan, fallbackToAnyMatch, filter) {
		if (!fileName || !textSpan) return;
		const [serviceScript] = (0, utils_1$36.getServiceScript)(language, fileName);
		if (serviceScript) {
			const [sourceSpanFileName, sourceSpan] = transformTextSpan(void 0, language, serviceScript, textSpan, fallbackToAnyMatch, filter) ?? [];
			if (sourceSpan && sourceSpanFileName) return {
				fileName: sourceSpanFileName,
				textSpan: sourceSpan
			};
		} else return {
			fileName,
			textSpan
		};
	}
	function transformTextChange(sourceScript, language, serviceScript, textChange, fallbackToAnyMatch, filter) {
		const [sourceSpanFileName, sourceSpan] = transformTextSpan(sourceScript, language, serviceScript, textChange.span, fallbackToAnyMatch, filter) ?? [];
		if (sourceSpan && sourceSpanFileName) return [sourceSpanFileName, {
			newText: textChange.newText,
			span: sourceSpan
		}];
		return void 0;
	}
	function transformTextSpan(sourceScript, language, serviceScript, textSpan, fallbackToAnyMatch, filter) {
		const start = textSpan.start;
		const end = textSpan.start + textSpan.length;
		for (const [fileName, sourceStart, sourceEnd] of toSourceRanges(sourceScript, language, serviceScript, start, end, fallbackToAnyMatch, filter)) return [fileName, {
			start: sourceStart,
			length: sourceEnd - sourceStart
		}];
	}
	function toSourceOffset(sourceScript, language, serviceScript, position, filter) {
		for (const source of toSourceOffsets(sourceScript, language, serviceScript, position, filter)) return source;
	}
	function* toSourceRanges(sourceScript, language, serviceScript, start, end, fallbackToAnyMatch, filter) {
		if (sourceScript) {
			const map = language.maps.get(serviceScript.code, sourceScript);
			for (const [sourceStart, sourceEnd] of map.toSourceRange(start - getMappingOffset(language, serviceScript), end - getMappingOffset(language, serviceScript), fallbackToAnyMatch, filter)) yield [
				sourceScript.id,
				sourceStart,
				sourceEnd
			];
		} else for (const [sourceScript$1, map] of language.maps.forEach(serviceScript.code)) for (const [sourceStart, sourceEnd] of map.toSourceRange(start - getMappingOffset(language, serviceScript), end - getMappingOffset(language, serviceScript), fallbackToAnyMatch, filter)) yield [
			sourceScript$1.id,
			sourceStart,
			sourceEnd
		];
	}
	function* toSourceOffsets(sourceScript, language, serviceScript, position, filter) {
		if (sourceScript) {
			const map = language.maps.get(serviceScript.code, sourceScript);
			for (const [sourceOffset, mapping] of map.toSourceLocation(position - getMappingOffset(language, serviceScript))) if (filter(mapping.data)) yield [sourceScript.id, sourceOffset];
		} else for (const [sourceScript$1, map] of language.maps.forEach(serviceScript.code)) for (const [sourceOffset, mapping] of map.toSourceLocation(position - getMappingOffset(language, serviceScript))) if (filter(mapping.data)) yield [sourceScript$1.id, sourceOffset];
	}
	function toGeneratedRange(language, serviceScript, sourceScript, start, end, filter) {
		for (const result of toGeneratedRanges(language, serviceScript, sourceScript, start, end, filter)) return result;
	}
	function* toGeneratedRanges(language, serviceScript, sourceScript, start, end, filter) {
		const map = language.maps.get(serviceScript.code, sourceScript);
		for (const [generateStart, generateEnd] of map.toGeneratedRange(start, end, true, filter)) yield [generateStart + getMappingOffset(language, serviceScript), generateEnd + getMappingOffset(language, serviceScript)];
	}
	function toGeneratedOffset(language, serviceScript, sourceScript, position, filter) {
		for (const [generateOffset] of toGeneratedOffsets(language, serviceScript, sourceScript, position, filter)) return generateOffset;
	}
	function* toGeneratedOffsets(language, serviceScript, sourceScript, position, filter) {
		const map = language.maps.get(serviceScript.code, sourceScript);
		for (const [generateOffset, mapping] of map.toGeneratedLocation(position)) if (filter(mapping.data)) yield [generateOffset + getMappingOffset(language, serviceScript), mapping];
	}
	function getMappingOffset(language, serviceScript) {
		if (serviceScript.preventLeadingOffset) return 0;
		const sourceScript = language.scripts.fromVirtualCode(serviceScript.code);
		return sourceScript.snapshot.getLength();
	}
} });

//#endregion
//#region node_modules/@volar/typescript/lib/node/proxyLanguageService.js
var require_proxyLanguageService = __commonJS({ "node_modules/@volar/typescript/lib/node/proxyLanguageService.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createProxyLanguageService = createProxyLanguageService;
	const language_core_1$7 = require_language_core$1();
	const dedupe_1 = require_dedupe();
	const transform_1 = require_transform();
	const utils_1$35 = require_utils$4();
	const windowsPathReg$1 = /\\/g;
	/**
	* Creates and returns a Proxy around the base TypeScript LanguageService.
	*
	* This is used by the Volar TypeScript Plugin (which can be created by `createLanguageServicePlugin`
	* and `createAsyncLanguageServicePlugin`) as an adapter layer between the TypeScript Language Service
	* plugin API (see https://github.com/microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin)
	* and a Volar `Language`.
	*
	* Once the `initialize` method is called, the proxy will begin intercepting requests and
	* enhancing the default behavior of the LanguageService with enhancements based on
	* the Volar `Language` that has been passed to `initialize`.
	*/
	function createProxyLanguageService(languageService) {
		const proxyCache = /* @__PURE__ */ new Map();
		let getProxyMethod;
		return {
			initialize(language) {
				getProxyMethod = (target, p) => {
					switch (p) {
						case "getNavigationTree": return getNavigationTree(language, target[p]);
						case "getOutliningSpans": return getOutliningSpans(language, target[p]);
						case "getFormattingEditsForDocument": return getFormattingEditsForDocument(language, target[p]);
						case "getFormattingEditsForRange": return getFormattingEditsForRange(language, target[p]);
						case "getFormattingEditsAfterKeystroke": return getFormattingEditsAfterKeystroke(language, target[p]);
						case "getEditsForFileRename": return getEditsForFileRename(language, target[p]);
						case "getLinkedEditingRangeAtPosition": return getLinkedEditingRangeAtPosition(language, target[p]);
						case "prepareCallHierarchy": return prepareCallHierarchy(language, target[p]);
						case "provideCallHierarchyIncomingCalls": return provideCallHierarchyIncomingCalls(language, target[p]);
						case "provideCallHierarchyOutgoingCalls": return provideCallHierarchyOutgoingCalls(language, target[p]);
						case "organizeImports": return organizeImports(language, target[p]);
						case "getQuickInfoAtPosition": return getQuickInfoAtPosition(language, target[p]);
						case "getSignatureHelpItems": return getSignatureHelpItems(language, target[p]);
						case "getDocumentHighlights": return getDocumentHighlights(language, target[p]);
						case "getApplicableRefactors": return getApplicableRefactors(language, target[p]);
						case "getEditsForRefactor": return getEditsForRefactor(language, target[p]);
						case "getCombinedCodeFix": return getCombinedCodeFix(language, target[p]);
						case "getRenameInfo": return getRenameInfo(language, target[p]);
						case "getCodeFixesAtPosition": return getCodeFixesAtPosition$1(language, target[p]);
						case "getEncodedSemanticClassifications": return getEncodedSemanticClassifications(language, target[p]);
						case "getSyntacticDiagnostics": return getSyntacticDiagnostics(language, languageService, target[p]);
						case "getSemanticDiagnostics": return getSemanticDiagnostics(language, languageService, target[p]);
						case "getSuggestionDiagnostics": return getSuggestionDiagnostics(language, languageService, target[p]);
						case "getDefinitionAndBoundSpan": return getDefinitionAndBoundSpan$1(language, target[p]);
						case "findReferences": return findReferences(language, target[p]);
						case "getDefinitionAtPosition": return getDefinitionAtPosition(language, target[p]);
						case "getTypeDefinitionAtPosition": return getTypeDefinitionAtPosition(language, target[p]);
						case "getImplementationAtPosition": return getImplementationAtPosition(language, target[p]);
						case "findRenameLocations": return findRenameLocations(language, target[p]);
						case "getReferencesAtPosition": return getReferencesAtPosition(language, target[p]);
						case "getCompletionsAtPosition": return getCompletionsAtPosition$1(language, target[p]);
						case "getCompletionEntryDetails": return getCompletionEntryDetails$1(language, target[p]);
						case "provideInlayHints": return provideInlayHints(language, target[p]);
						case "getFileReferences": return getFileReferences(language, target[p]);
						case "getNavigateToItems": return getNavigateToItems(language, target[p]);
					}
				};
			},
			proxy: new Proxy(languageService, {
				get(target, p, receiver) {
					if (getProxyMethod) {
						if (!proxyCache.has(p)) proxyCache.set(p, getProxyMethod(target, p));
						const proxyMethod = proxyCache.get(p);
						if (proxyMethod) return proxyMethod;
					}
					return Reflect.get(target, p, receiver);
				},
				set(target, p, value, receiver) {
					return Reflect.set(target, p, value, receiver);
				}
			})
		};
	}
	function getNavigationTree(language, getNavigationTree$1) {
		return (filePath) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (serviceScript || targetScript?.associatedOnly) {
				const tree = getNavigationTree$1(targetScript.id);
				tree.childItems = void 0;
				return tree;
			} else return getNavigationTree$1(fileName);
		};
	}
	function getOutliningSpans(language, getOutliningSpans$1) {
		return (filePath) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (serviceScript || targetScript?.associatedOnly) return [];
			else return getOutliningSpans$1(fileName);
		};
	}
	function getFormattingEditsForDocument(language, getFormattingEditsForDocument$1) {
		return (filePath, options) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return [];
			if (serviceScript) {
				const map = language.maps.get(serviceScript.code, targetScript);
				if (!map.mappings.some((mapping) => (0, language_core_1$7.isFormattingEnabled)(mapping.data))) return [];
				const edits = getFormattingEditsForDocument$1(targetScript.id, options);
				return edits.map((edit) => (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, false, language_core_1$7.isFormattingEnabled)?.[1]).filter((edit) => !!edit);
			} else return getFormattingEditsForDocument$1(fileName, options);
		};
	}
	function getFormattingEditsForRange(language, getFormattingEditsForRange$1) {
		return (filePath, start, end, options) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return [];
			if (serviceScript) {
				const generatedRange = (0, transform_1.toGeneratedRange)(language, serviceScript, sourceScript, start, end, language_core_1$7.isFormattingEnabled);
				if (generatedRange !== void 0) {
					const edits = getFormattingEditsForRange$1(targetScript.id, generatedRange[0], generatedRange[1], options);
					return edits.map((edit) => (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, false, language_core_1$7.isFormattingEnabled)?.[1]).filter((edit) => !!edit);
				}
				return [];
			} else return getFormattingEditsForRange$1(fileName, start, end, options);
		};
	}
	function getFormattingEditsAfterKeystroke(language, getFormattingEditsAfterKeystroke$1) {
		return (filePath, position, key, options) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return [];
			if (serviceScript) {
				const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1$7.isFormattingEnabled);
				if (generatePosition !== void 0) {
					const edits = getFormattingEditsAfterKeystroke$1(targetScript.id, generatePosition, key, options);
					return edits.map((edit) => (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, false, language_core_1$7.isFormattingEnabled)?.[1]).filter((edit) => !!edit);
				}
				return [];
			} else return getFormattingEditsAfterKeystroke$1(fileName, position, key, options);
		};
	}
	function getEditsForFileRename(language, getEditsForFileRename$1) {
		return (oldFilePath, newFilePath, formatOptions, preferences) => {
			const edits = getEditsForFileRename$1(oldFilePath, newFilePath, formatOptions, preferences);
			return (0, transform_1.transformFileTextChanges)(language, edits, false, language_core_1$7.isRenameEnabled);
		};
	}
	function getLinkedEditingRangeAtPosition(language, getLinkedEditingRangeAtPosition$1) {
		return (filePath, position) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return void 0;
			if (serviceScript) {
				const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1$7.isLinkedEditingEnabled);
				if (generatePosition !== void 0) {
					const info = getLinkedEditingRangeAtPosition$1(targetScript.id, generatePosition);
					if (info) return {
						ranges: info.ranges.map((span) => (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, span, false, language_core_1$7.isLinkedEditingEnabled)?.[1]).filter((span) => !!span),
						wordPattern: info.wordPattern
					};
				}
			} else return getLinkedEditingRangeAtPosition$1(fileName, position);
		};
	}
	function prepareCallHierarchy(language, prepareCallHierarchy$1) {
		return (filePath, position) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return void 0;
			if (serviceScript) {
				const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1$7.isCallHierarchyEnabled);
				if (generatePosition !== void 0) {
					const item = prepareCallHierarchy$1(targetScript.id, generatePosition);
					if (Array.isArray(item)) return item.map((item$1) => (0, transform_1.transformCallHierarchyItem)(language, item$1, true, language_core_1$7.isCallHierarchyEnabled));
					else if (item) return (0, transform_1.transformCallHierarchyItem)(language, item, true, language_core_1$7.isCallHierarchyEnabled);
				}
			} else return prepareCallHierarchy$1(fileName, position);
		};
	}
	function provideCallHierarchyIncomingCalls(language, provideCallHierarchyIncomingCalls$1) {
		return (filePath, position) => {
			let calls = [];
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return [];
			if (serviceScript) {
				const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1$7.isCallHierarchyEnabled);
				if (generatePosition !== void 0) calls = provideCallHierarchyIncomingCalls$1(targetScript.id, generatePosition);
			} else calls = provideCallHierarchyIncomingCalls$1(fileName, position);
			return calls.map((call) => {
				const from = (0, transform_1.transformCallHierarchyItem)(language, call.from, true, language_core_1$7.isCallHierarchyEnabled);
				const fromSpans = call.fromSpans.map((span) => (0, transform_1.transformSpan)(language, call.from.file, span, true, language_core_1$7.isCallHierarchyEnabled)?.textSpan).filter((span) => !!span);
				return {
					from,
					fromSpans
				};
			});
		};
	}
	function provideCallHierarchyOutgoingCalls(language, provideCallHierarchyOutgoingCalls$1) {
		return (filePath, position) => {
			let calls = [];
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return [];
			if (serviceScript) {
				const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1$7.isCallHierarchyEnabled);
				if (generatePosition !== void 0) calls = provideCallHierarchyOutgoingCalls$1(targetScript.id, generatePosition);
			} else calls = provideCallHierarchyOutgoingCalls$1(fileName, position);
			return calls.map((call) => {
				const to = (0, transform_1.transformCallHierarchyItem)(language, call.to, true, language_core_1$7.isCallHierarchyEnabled);
				const fromSpans = call.fromSpans.map((span) => serviceScript ? (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, span, true, language_core_1$7.isCallHierarchyEnabled)?.[1] : span).filter((span) => !!span);
				return {
					to,
					fromSpans
				};
			});
		};
	}
	function organizeImports(language, organizeImports$1) {
		return (args, formatOptions, preferences) => {
			const unresolved = organizeImports$1(args, formatOptions, preferences);
			return (0, transform_1.transformFileTextChanges)(language, unresolved, false, language_core_1$7.isCodeActionsEnabled);
		};
	}
	function getQuickInfoAtPosition(language, getQuickInfoAtPosition$1) {
		/**
		* Using `...args` for pass through rest params (including internal `verbosityLevel` param).
		* https://github.com/microsoft/TypeScript/blob/dd830711041b7b0cfd3da7937755996b1e1b1c7e/src/services/types.ts#L588
		*/
		return (filePath, position, ...args) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return void 0;
			if (serviceScript) {
				const infos = [];
				for (const [generatePosition] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, language_core_1$7.isHoverEnabled)) {
					const info = getQuickInfoAtPosition$1(targetScript.id, generatePosition, ...args);
					if (info) {
						const textSpan = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, info.textSpan, true, language_core_1$7.isHoverEnabled)?.[1];
						if (textSpan) infos.push({
							...info,
							textSpan
						});
					}
				}
				if (infos.length === 1) return infos[0];
				else if (infos.length >= 2) {
					const combine = { ...infos[0] };
					combine.displayParts = combine.displayParts?.slice();
					combine.documentation = combine.documentation?.slice();
					combine.tags = combine.tags?.slice();
					const displayPartsStrs = new Set([displayPartsToString(infos[0].displayParts)]);
					const documentationStrs = new Set([displayPartsToString(infos[0].documentation)]);
					const tagsStrs = /* @__PURE__ */ new Set();
					for (const tag of infos[0].tags ?? []) tagsStrs.add(tag.name + "__volar__" + displayPartsToString(tag.text));
					for (let i = 1; i < infos.length; i++) {
						const { displayParts, documentation, tags } = infos[i];
						if (displayParts?.length && !displayPartsStrs.has(displayPartsToString(displayParts))) {
							displayPartsStrs.add(displayPartsToString(displayParts));
							combine.displayParts ??= [];
							combine.displayParts.push({
								...displayParts[0],
								text: "\n\n" + displayParts[0].text
							});
							combine.displayParts.push(...displayParts.slice(1));
						}
						if (documentation?.length && !documentationStrs.has(displayPartsToString(documentation))) {
							documentationStrs.add(displayPartsToString(documentation));
							combine.documentation ??= [];
							combine.documentation.push({
								...documentation[0],
								text: "\n\n" + documentation[0].text
							});
							combine.documentation.push(...documentation.slice(1));
						}
						for (const tag of tags ?? []) if (!tagsStrs.has(tag.name + "__volar__" + displayPartsToString(tag.text))) {
							tagsStrs.add(tag.name + "__volar__" + displayPartsToString(tag.text));
							combine.tags ??= [];
							combine.tags.push(tag);
						}
					}
					return combine;
				}
			} else return getQuickInfoAtPosition$1(fileName, position, ...args);
		};
	}
	function getSignatureHelpItems(language, getSignatureHelpItems$1) {
		return (filePath, position, options) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return void 0;
			if (serviceScript) {
				const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1$7.isSignatureHelpEnabled);
				if (generatePosition !== void 0) {
					const result = getSignatureHelpItems$1(targetScript.id, generatePosition, options);
					if (result) {
						const applicableSpan = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, result.applicableSpan, true, language_core_1$7.isSignatureHelpEnabled)?.[1];
						if (applicableSpan) return {
							...result,
							applicableSpan
						};
					}
				}
			} else return getSignatureHelpItems$1(fileName, position, options);
		};
	}
	function getDocumentHighlights(language, getDocumentHighlights$1) {
		return (filePath, position, filesToSearch) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1$7.isHighlightEnabled, (fileName$1, position$1) => getDocumentHighlights$1(fileName$1, position$1, filesToSearch), function* (result) {
				for (const ref of result) for (const reference of ref.highlightSpans) yield [reference.fileName ?? ref.fileName, reference.textSpan.start];
			});
			const resolved = unresolved.flat().map((highlights) => {
				return {
					...highlights,
					highlightSpans: highlights.highlightSpans.map((span) => {
						const { textSpan } = (0, transform_1.transformSpan)(language, span.fileName ?? highlights.fileName, span.textSpan, false, language_core_1$7.isHighlightEnabled) ?? {};
						if (textSpan) return {
							...span,
							contextSpan: (0, transform_1.transformSpan)(language, span.fileName ?? highlights.fileName, span.contextSpan, false, language_core_1$7.isHighlightEnabled)?.textSpan,
							textSpan
						};
					}).filter((span) => !!span)
				};
			});
			return resolved;
		};
	}
	function getApplicableRefactors(language, getApplicableRefactors$1) {
		return (filePath, positionOrRange, preferences, triggerReason, kind, includeInteractiveActions) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return [];
			if (serviceScript) {
				if (typeof positionOrRange === "number") {
					const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, positionOrRange, language_core_1$7.isCodeActionsEnabled);
					if (generatePosition !== void 0) return getApplicableRefactors$1(targetScript.id, generatePosition, preferences, triggerReason, kind, includeInteractiveActions);
				} else for (const [generatedStart, generatedEnd] of (0, transform_1.toGeneratedRanges)(language, serviceScript, sourceScript, positionOrRange.pos, positionOrRange.end, language_core_1$7.isCodeActionsEnabled)) return getApplicableRefactors$1(targetScript.id, {
					pos: generatedStart,
					end: generatedEnd
				}, preferences, triggerReason, kind, includeInteractiveActions);
				return [];
			} else return getApplicableRefactors$1(fileName, positionOrRange, preferences, triggerReason, kind, includeInteractiveActions);
		};
	}
	function getEditsForRefactor(language, getEditsForRefactor$1) {
		return (filePath, formatOptions, positionOrRange, refactorName, actionName, preferences, interactiveRefactorArguments) => {
			let edits;
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return void 0;
			if (serviceScript) if (typeof positionOrRange === "number") {
				const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, positionOrRange, language_core_1$7.isCodeActionsEnabled);
				if (generatePosition !== void 0) edits = getEditsForRefactor$1(targetScript.id, formatOptions, generatePosition, refactorName, actionName, preferences, interactiveRefactorArguments);
			} else for (const [generatedStart, generatedEnd] of (0, transform_1.toGeneratedRanges)(language, serviceScript, sourceScript, positionOrRange.pos, positionOrRange.end, language_core_1$7.isCodeActionsEnabled)) edits = getEditsForRefactor$1(targetScript.id, formatOptions, {
				pos: generatedStart,
				end: generatedEnd
			}, refactorName, actionName, preferences, interactiveRefactorArguments);
			else edits = getEditsForRefactor$1(fileName, formatOptions, positionOrRange, refactorName, actionName, preferences, interactiveRefactorArguments);
			if (edits) {
				edits.edits = (0, transform_1.transformFileTextChanges)(language, edits.edits, false, language_core_1$7.isCodeActionsEnabled);
				return edits;
			}
		};
	}
	function getCombinedCodeFix(language, getCombinedCodeFix$1) {
		return (...args) => {
			const codeActions = getCombinedCodeFix$1(...args);
			codeActions.changes = (0, transform_1.transformFileTextChanges)(language, codeActions.changes, false, language_core_1$7.isCodeActionsEnabled);
			return codeActions;
		};
	}
	function getRenameInfo(language, getRenameInfo$1) {
		return (filePath, position, options) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return {
				canRename: false,
				localizedErrorMessage: "Cannot rename"
			};
			if (serviceScript) {
				let failed;
				for (const [generateOffset] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, language_core_1$7.isRenameEnabled)) {
					const info = getRenameInfo$1(targetScript.id, generateOffset, options);
					if (info.canRename) {
						const span = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, info.triggerSpan, false, language_core_1$7.isRenameEnabled)?.[1];
						if (span) {
							info.triggerSpan = span;
							return info;
						}
					} else failed = info;
				}
				if (failed) return failed;
				return {
					canRename: false,
					localizedErrorMessage: "Failed to get rename locations"
				};
			} else return getRenameInfo$1(fileName, position, options);
		};
	}
	function getCodeFixesAtPosition$1(language, getCodeFixesAtPosition$2) {
		return (filePath, start, end, errorCodes, formatOptions, preferences) => {
			let fixes = [];
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return [];
			if (serviceScript) {
				const generateRange = (0, transform_1.toGeneratedRange)(language, serviceScript, sourceScript, start, end, language_core_1$7.isCodeActionsEnabled);
				if (generateRange !== void 0) fixes = getCodeFixesAtPosition$2(targetScript.id, generateRange[0], generateRange[1], errorCodes, formatOptions, preferences);
			} else fixes = getCodeFixesAtPosition$2(fileName, start, end, errorCodes, formatOptions, preferences);
			fixes = fixes.map((fix) => {
				fix.changes = (0, transform_1.transformFileTextChanges)(language, fix.changes, false, language_core_1$7.isCodeActionsEnabled);
				return fix;
			});
			return fixes;
		};
	}
	function getEncodedSemanticClassifications(language, getEncodedSemanticClassifications$1) {
		return (filePath, span, format) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return {
				spans: [],
				endOfLineState: 0
			};
			if (serviceScript) {
				const map = language.maps.get(serviceScript.code, targetScript);
				const mapped = (0, language_core_1$7.findOverlapCodeRange)(span.start, span.start + span.length, map, language_core_1$7.isSemanticTokensEnabled);
				if (!mapped) return {
					spans: [],
					endOfLineState: 0
				};
				const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript);
				const start = mapped.start + mappingOffset;
				const end = mapped.end + mappingOffset;
				const result = getEncodedSemanticClassifications$1(targetScript.id, {
					start,
					length: end - start
				}, format);
				const spans = [];
				for (let i = 0; i < result.spans.length; i += 3) for (const [_, sourceStart, sourceEnd] of (0, transform_1.toSourceRanges)(sourceScript, language, serviceScript, result.spans[i], result.spans[i] + result.spans[i + 1], false, language_core_1$7.isSemanticTokensEnabled)) {
					spans.push(sourceStart, sourceEnd - sourceStart, result.spans[i + 2]);
					break;
				}
				result.spans = spans;
				return result;
			} else return getEncodedSemanticClassifications$1(fileName, span, format);
		};
	}
	function getSyntacticDiagnostics(language, languageService, getSyntacticDiagnostics$1) {
		return (filePath) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return [];
			return getSyntacticDiagnostics$1(targetScript?.id ?? fileName).map((d) => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false)).filter((d) => !!d).filter((d) => !serviceScript || language.scripts.get(d.file.fileName) === sourceScript);
		};
	}
	function getSemanticDiagnostics(language, languageService, getSemanticDiagnostics$1) {
		return (filePath) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return [];
			return getSemanticDiagnostics$1(targetScript?.id ?? fileName).map((d) => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false)).filter((d) => !!d).filter((d) => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
		};
	}
	function getSuggestionDiagnostics(language, languageService, getSuggestionDiagnostics$1) {
		return (filePath) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return [];
			return getSuggestionDiagnostics$1(targetScript?.id ?? fileName).map((d) => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false)).filter((d) => !!d).filter((d) => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
		};
	}
	function getDefinitionAndBoundSpan$1(language, getDefinitionAndBoundSpan$2) {
		return (filePath, position) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1$7.isDefinitionEnabled, (fileName$1, position$1) => getDefinitionAndBoundSpan$2(fileName$1, position$1), function* (result) {
				for (const ref of result.definitions ?? []) yield [ref.fileName, ref.textSpan.start];
			});
			const textSpan = unresolved.map((s) => (0, transform_1.transformSpan)(language, fileName, s.textSpan, true, language_core_1$7.isDefinitionEnabled)?.textSpan).filter((s) => !!s)[0];
			if (!textSpan) return;
			const definitions = unresolved.map((s) => s.definitions?.map((s$1) => (0, transform_1.transformDocumentSpan)(language, s$1, true, language_core_1$7.isDefinitionEnabled, s$1.fileName !== fileName)).filter((s$1) => !!s$1) ?? []).flat();
			return {
				textSpan,
				definitions: (0, dedupe_1.dedupeDocumentSpans)(definitions)
			};
		};
	}
	function findReferences(language, findReferences$1) {
		return (filePath, position) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1$7.isReferencesEnabled, (fileName$1, position$1) => findReferences$1(fileName$1, position$1), function* (result) {
				for (const ref of result) for (const reference of ref.references) yield [reference.fileName, reference.textSpan.start];
			});
			const resolved = unresolved.flat().map((symbol) => {
				const definition = (0, transform_1.transformDocumentSpan)(language, symbol.definition, true, language_core_1$7.isDefinitionEnabled, true);
				return {
					definition,
					references: symbol.references.map((r) => (0, transform_1.transformDocumentSpan)(language, r, true, language_core_1$7.isReferencesEnabled)).filter((r) => !!r)
				};
			});
			return resolved;
		};
	}
	function getDefinitionAtPosition(language, getDefinitionAtPosition$1) {
		return (filePath, position) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1$7.isDefinitionEnabled, (fileName$1, position$1) => getDefinitionAtPosition$1(fileName$1, position$1), function* (result) {
				for (const ref of result) yield [ref.fileName, ref.textSpan.start];
			});
			const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1$7.isDefinitionEnabled, s.fileName !== fileName)).filter((s) => !!s);
			return (0, dedupe_1.dedupeDocumentSpans)(resolved);
		};
	}
	function getTypeDefinitionAtPosition(language, getTypeDefinitionAtPosition$1) {
		return (filePath, position) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1$7.isTypeDefinitionEnabled, (fileName$1, position$1) => getTypeDefinitionAtPosition$1(fileName$1, position$1), function* (result) {
				for (const ref of result) yield [ref.fileName, ref.textSpan.start];
			});
			const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1$7.isTypeDefinitionEnabled)).filter((s) => !!s);
			return (0, dedupe_1.dedupeDocumentSpans)(resolved);
		};
	}
	function getImplementationAtPosition(language, getImplementationAtPosition$1) {
		return (filePath, position) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1$7.isImplementationEnabled, (fileName$1, position$1) => getImplementationAtPosition$1(fileName$1, position$1), function* (result) {
				for (const ref of result) yield [ref.fileName, ref.textSpan.start];
			});
			const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1$7.isImplementationEnabled)).filter((s) => !!s);
			return (0, dedupe_1.dedupeDocumentSpans)(resolved);
		};
	}
	function findRenameLocations(language, findRenameLocations$1) {
		return (filePath, position, findInStrings, findInComments, preferences) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1$7.isRenameEnabled, (fileName$1, position$1) => findRenameLocations$1(fileName$1, position$1, findInStrings, findInComments, preferences), function* (result) {
				for (const ref of result) yield [ref.fileName, ref.textSpan.start];
			});
			const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, false, language_core_1$7.isRenameEnabled)).filter((s) => !!s);
			return (0, dedupe_1.dedupeDocumentSpans)(resolved);
		};
	}
	function getReferencesAtPosition(language, getReferencesAtPosition$1) {
		return (filePath, position) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1$7.isReferencesEnabled, (fileName$1, position$1) => getReferencesAtPosition$1(fileName$1, position$1), function* (result) {
				for (const ref of result) yield [ref.fileName, ref.textSpan.start];
			});
			const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1$7.isReferencesEnabled)).filter((s) => !!s);
			return (0, dedupe_1.dedupeDocumentSpans)(resolved);
		};
	}
	function getCompletionsAtPosition$1(language, getCompletionsAtPosition$2) {
		return (filePath, position, options, formattingSettings) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return void 0;
			if (serviceScript) {
				let mainResult;
				const additionalResults = [];
				for (const [generatedOffset, mapping] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, language_core_1$7.isCompletionEnabled)) {
					const isAdditional = typeof mapping.data.completion === "object" && mapping.data.completion.isAdditional;
					if (!isAdditional && mainResult?.entries.length) continue;
					const result = getCompletionsAtPosition$2(targetScript.id, generatedOffset, options, formattingSettings);
					if (!result) continue;
					if (typeof mapping.data.completion === "object" && mapping.data.completion.onlyImport) result.entries = result.entries.filter((entry) => !!entry.sourceDisplay);
					for (const entry of result.entries) entry.replacementSpan = entry.replacementSpan && (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, entry.replacementSpan, false, language_core_1$7.isCompletionEnabled)?.[1];
					result.optionalReplacementSpan = result.optionalReplacementSpan && (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, result.optionalReplacementSpan, false, language_core_1$7.isCompletionEnabled)?.[1];
					if (isAdditional) additionalResults.push(result);
					else mainResult = result;
				}
				const results = additionalResults;
				if (mainResult) results.unshift(mainResult);
				if (results.length) return {
					...results[0],
					entries: results.map((additionalResult) => additionalResult.entries).flat()
				};
			} else return getCompletionsAtPosition$2(fileName, position, options, formattingSettings);
		};
	}
	function getCompletionEntryDetails$1(language, getCompletionEntryDetails$2) {
		return (filePath, position, entryName, formatOptions, source, preferences, data) => {
			let details;
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return void 0;
			if (serviceScript) {
				const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1$7.isCompletionEnabled);
				if (generatePosition !== void 0) details = getCompletionEntryDetails$2(targetScript.id, generatePosition, entryName, formatOptions, source, preferences, data);
			} else return getCompletionEntryDetails$2(fileName, position, entryName, formatOptions, source, preferences, data);
			if (details?.codeActions) for (const codeAction of details.codeActions) codeAction.changes = (0, transform_1.transformFileTextChanges)(language, codeAction.changes, false, language_core_1$7.isCompletionEnabled);
			return details;
		};
	}
	function provideInlayHints(language, provideInlayHints$1) {
		return (filePath, span, preferences) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
			if (targetScript?.associatedOnly) return [];
			if (serviceScript) {
				const map = language.maps.get(serviceScript.code, sourceScript);
				const mapped = (0, language_core_1$7.findOverlapCodeRange)(span.start, span.start + span.length, map, language_core_1$7.isSemanticTokensEnabled);
				if (!mapped) return [];
				const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript);
				const start = mapped.start + mappingOffset;
				const end = mapped.end + mappingOffset;
				const result = provideInlayHints$1(targetScript.id, {
					start,
					length: end - start
				}, preferences);
				const hints = [];
				for (const hint of result) {
					const sourcePosition = (0, transform_1.toSourceOffset)(sourceScript, language, serviceScript, hint.position, language_core_1$7.isInlayHintsEnabled);
					if (sourcePosition !== void 0) hints.push({
						...hint,
						position: sourcePosition[1]
					});
				}
				return hints;
			} else return provideInlayHints$1(fileName, span, preferences);
		};
	}
	function getFileReferences(language, getFileReferences$1) {
		return (filePath) => {
			const fileName = filePath.replace(windowsPathReg$1, "/");
			const unresolved = getFileReferences$1(fileName);
			const resolved = unresolved.map((s) => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1$7.isReferencesEnabled)).filter((s) => !!s);
			return (0, dedupe_1.dedupeDocumentSpans)(resolved);
		};
	}
	function getNavigateToItems(language, getNavigateToItems$1) {
		return (...args) => {
			const unresolved = getNavigateToItems$1(...args);
			const resolved = unresolved.map((s) => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1$7.isReferencesEnabled)).filter((s) => !!s);
			return (0, dedupe_1.dedupeDocumentSpans)(resolved);
		};
	}
	function linkedCodeFeatureWorker(language, fileName, position, filter, worker, getLinkedCodes) {
		const results = [];
		const processedFilePositions = /* @__PURE__ */ new Set();
		const [serviceScript, targetScript, sourceScript] = (0, utils_1$35.getServiceScript)(language, fileName);
		if (serviceScript) for (const [generatedOffset] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, filter)) process$1(targetScript.id, generatedOffset);
		else process$1(fileName, position);
		return results;
		function process$1(fileName$1, position$1) {
			if (processedFilePositions.has(fileName$1 + ":" + position$1)) return;
			processedFilePositions.add(fileName$1 + ":" + position$1);
			const result = worker(fileName$1, position$1);
			if (!result) return;
			results.push(result);
			for (const ref of getLinkedCodes(result)) {
				processedFilePositions.add(ref[0] + ":" + ref[1]);
				const [serviceScript$1] = (0, utils_1$35.getServiceScript)(language, ref[0]);
				if (!serviceScript$1) continue;
				const linkedCodeMap = language.linkedCodeMaps.get(serviceScript$1.code);
				if (!linkedCodeMap) continue;
				const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript$1);
				for (const linkedCodeOffset of linkedCodeMap.getLinkedOffsets(ref[1] - mappingOffset)) process$1(ref[0], linkedCodeOffset + mappingOffset);
			}
		}
	}
	function displayPartsToString(displayParts) {
		if (displayParts) return displayParts.map((displayPart) => displayPart.text).join("");
		return "";
	}
} });

//#endregion
//#region node_modules/@volar/typescript/lib/common.js
var require_common$1 = __commonJS({ "node_modules/@volar/typescript/lib/common.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.resolveFileLanguageId = resolveFileLanguageId;
	function resolveFileLanguageId(path$4) {
		const ext = path$4.split(".").pop();
		switch (ext) {
			case "js": return "javascript";
			case "cjs": return "javascript";
			case "mjs": return "javascript";
			case "ts": return "typescript";
			case "cts": return "typescript";
			case "mts": return "typescript";
			case "jsx": return "javascriptreact";
			case "tsx": return "typescriptreact";
			case "json": return "json";
		}
	}
} });

//#endregion
//#region node_modules/@volar/typescript/lib/resolveModuleName.js
var require_resolveModuleName = __commonJS({ "node_modules/@volar/typescript/lib/resolveModuleName.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createResolveModuleName = createResolveModuleName;
	function createResolveModuleName(ts, getFileSize, host, languagePlugins, getSourceScript) {
		const toSourceFileInfo = /* @__PURE__ */ new Map();
		const moduleResolutionHost = {
			readFile: host.readFile.bind(host),
			directoryExists: host.directoryExists?.bind(host),
			realpath: host.realpath?.bind(host),
			getCurrentDirectory: host.getCurrentDirectory?.bind(host),
			getDirectories: host.getDirectories?.bind(host),
			useCaseSensitiveFileNames: typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames.bind(host) : host.useCaseSensitiveFileNames,
			fileExists(fileName) {
				const result = host.fileExists(fileName);
				for (const { typescript: typescript$1 } of languagePlugins) {
					if (!typescript$1) continue;
					if (!result) for (const { extension } of typescript$1.extraFileExtensions) {
						if (!fileName.endsWith(`.d.${extension}.ts`)) continue;
						const sourceFileName = fileName.slice(0, -`.d.${extension}.ts`.length) + `.${extension}`;
						if (fileExists(sourceFileName)) {
							const sourceScript = getSourceScript(sourceFileName);
							if (sourceScript?.generated) {
								const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
								if (serviceScript) {
									const dtsPath = sourceFileName + ".d.ts";
									if ((serviceScript.extension === ".js" || serviceScript.extension === ".jsx") && fileExists(dtsPath)) toSourceFileInfo.set(fileName, {
										sourceFileName: dtsPath,
										extension: ".ts"
									});
									else toSourceFileInfo.set(fileName, {
										sourceFileName,
										extension: serviceScript.extension
									});
									return true;
								}
							}
						}
					}
					if (typescript$1.resolveHiddenExtensions && fileName.endsWith(`.d.ts`)) for (const { extension } of typescript$1.extraFileExtensions) {
						const sourceFileName = fileName.slice(0, -`.d.ts`.length) + `.${extension}`;
						if (fileExists(sourceFileName)) {
							const sourceScript = getSourceScript(sourceFileName);
							if (sourceScript?.generated) {
								const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
								if (serviceScript) {
									toSourceFileInfo.set(fileName, {
										sourceFileName,
										extension: serviceScript.extension
									});
									return true;
								}
							}
						}
					}
				}
				return result;
			}
		};
		return (moduleName, containingFile, compilerOptions, cache, redirectedReference, resolutionMode) => {
			const result = ts.resolveModuleName(moduleName, containingFile, compilerOptions, moduleResolutionHost, cache, redirectedReference, resolutionMode);
			if (result.resolvedModule) {
				const sourceFileInfo = toSourceFileInfo.get(result.resolvedModule.resolvedFileName);
				if (sourceFileInfo) {
					result.resolvedModule.resolvedFileName = sourceFileInfo.sourceFileName;
					result.resolvedModule.extension = sourceFileInfo.extension;
				}
			}
			toSourceFileInfo.clear();
			return result;
		};
		function fileExists(fileName) {
			if (host.fileExists(fileName)) {
				const fileSize = getFileSize?.(fileName) ?? host.readFile(fileName)?.length ?? 0;
				return fileSize < 4 * 1024 * 1024;
			}
			return false;
		}
	}
} });

//#endregion
//#region node_modules/@volar/typescript/lib/node/decorateLanguageServiceHost.js
var require_decorateLanguageServiceHost = __commonJS({ "node_modules/@volar/typescript/lib/node/decorateLanguageServiceHost.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.decorateLanguageServiceHost = decorateLanguageServiceHost;
	exports.searchExternalFiles = searchExternalFiles;
	const resolveModuleName_1 = require_resolveModuleName();
	function decorateLanguageServiceHost(ts, language, languageServiceHost) {
		const pluginExtensions = language.plugins.map((plugin$14) => plugin$14.typescript?.extraFileExtensions.map((ext) => "." + ext.extension) ?? []).flat();
		const scripts = /* @__PURE__ */ new Map();
		const crashFileNames = /* @__PURE__ */ new Set();
		const readDirectory = languageServiceHost.readDirectory?.bind(languageServiceHost);
		const resolveModuleNameLiterals = languageServiceHost.resolveModuleNameLiterals?.bind(languageServiceHost);
		const resolveModuleNames = languageServiceHost.resolveModuleNames?.bind(languageServiceHost);
		const getScriptSnapshot = languageServiceHost.getScriptSnapshot.bind(languageServiceHost);
		const getScriptKind = languageServiceHost.getScriptKind?.bind(languageServiceHost);
		if (readDirectory) languageServiceHost.readDirectory = (path$4, extensions, exclude, include, depth$1) => {
			if (extensions) {
				for (const ext of pluginExtensions) if (!extensions.includes(ext)) extensions = [...extensions, ext];
			}
			return readDirectory(path$4, extensions, exclude, include, depth$1);
		};
		if (pluginExtensions.length) {
			const resolveModuleName = (0, resolveModuleName_1.createResolveModuleName)(ts, ts.sys.getFileSize, languageServiceHost, language.plugins, (fileName) => language.scripts.get(fileName));
			const getCanonicalFileName = languageServiceHost.useCaseSensitiveFileNames?.() ? (fileName) => fileName : (fileName) => fileName.toLowerCase();
			const moduleResolutionCache = ts.createModuleResolutionCache(languageServiceHost.getCurrentDirectory(), getCanonicalFileName, languageServiceHost.getCompilationSettings());
			if (resolveModuleNameLiterals) languageServiceHost.resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, options, containingSourceFile, ...rest) => {
				if (moduleLiterals.every((name) => !pluginExtensions.some((ext) => name.text.endsWith(ext)))) return resolveModuleNameLiterals(moduleLiterals, containingFile, redirectedReference, options, containingSourceFile, ...rest);
				return moduleLiterals.map((moduleLiteral) => {
					const mode = ts.getModeForUsageLocation(containingSourceFile, moduleLiteral, options);
					return resolveModuleName(moduleLiteral.text, containingFile, options, moduleResolutionCache, redirectedReference, mode);
				});
			};
			if (resolveModuleNames) languageServiceHost.resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, options, containingSourceFile) => {
				if (moduleNames.every((name) => !pluginExtensions.some((ext) => name.endsWith(ext)))) return resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, options, containingSourceFile);
				return moduleNames.map((moduleName) => {
					return resolveModuleName(moduleName, containingFile, options, moduleResolutionCache, redirectedReference).resolvedModule;
				});
			};
		}
		languageServiceHost.getScriptSnapshot = (fileName) => {
			const virtualScript = updateVirtualScript(fileName, true);
			if (virtualScript) return virtualScript.snapshot;
			return getScriptSnapshot(fileName);
		};
		if (getScriptKind) languageServiceHost.getScriptKind = (fileName) => {
			const virtualScript = updateVirtualScript(fileName, false);
			if (virtualScript) return virtualScript.scriptKind;
			return getScriptKind(fileName);
		};
		function updateVirtualScript(fileName, shouldRegister) {
			if (crashFileNames.has(fileName)) return;
			let version;
			try {
				version = languageServiceHost.getScriptVersion(fileName);
			} catch {
				crashFileNames.add(fileName);
			}
			if (version === void 0) return;
			let script = scripts.get(fileName);
			if (!script || script[0] !== version) {
				script = [version];
				const sourceScript = language.scripts.get(fileName, void 0, shouldRegister);
				if (sourceScript?.generated) {
					const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
					if (serviceScript) if (serviceScript.preventLeadingOffset) script[1] = {
						extension: serviceScript.extension,
						scriptKind: serviceScript.scriptKind,
						snapshot: serviceScript.code.snapshot
					};
					else {
						const sourceContents = sourceScript.snapshot.getText(0, sourceScript.snapshot.getLength());
						const virtualContents = sourceContents.split("\n").map((line) => " ".repeat(line.length)).join("\n") + serviceScript.code.snapshot.getText(0, serviceScript.code.snapshot.getLength());
						script[1] = {
							extension: serviceScript.extension,
							scriptKind: serviceScript.scriptKind,
							snapshot: ts.ScriptSnapshot.fromString(virtualContents)
						};
					}
					if (sourceScript.generated.languagePlugin.typescript?.getExtraServiceScripts) console.warn("getExtraServiceScripts() is not available in TS plugin.");
				}
				scripts.set(fileName, script);
			}
			return script[1];
		}
	}
	function searchExternalFiles(ts, project, exts) {
		if (project.projectKind !== ts.server.ProjectKind.Configured) return [];
		const configFile = project.getProjectName();
		const config = ts.readJsonConfigFile(configFile, project.readFile.bind(project));
		const parseHost = {
			useCaseSensitiveFileNames: project.useCaseSensitiveFileNames(),
			fileExists: project.fileExists.bind(project),
			readFile: project.readFile.bind(project),
			readDirectory: (...args) => {
				args[1] = exts;
				return project.readDirectory(...args);
			}
		};
		const parsed = ts.parseJsonSourceFileConfigFileContent(config, parseHost, project.getCurrentDirectory());
		return parsed.fileNames;
	}
} });

//#endregion
//#region node_modules/@volar/typescript/lib/quickstart/languageServicePluginCommon.js
var require_languageServicePluginCommon = __commonJS({ "node_modules/@volar/typescript/lib/quickstart/languageServicePluginCommon.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.makeGetExternalFiles = exports.decoratedLanguageServiceHosts = exports.decoratedLanguageServices = exports.projectExternalFileExtensions = exports.externalFiles = void 0;
	exports.makeGetScriptInfoWithLargeFileFailsafe = makeGetScriptInfoWithLargeFileFailsafe;
	exports.createLanguageCommon = createLanguageCommon;
	exports.isHasAlreadyDecoratedLanguageService = isHasAlreadyDecoratedLanguageService;
	const language_core_1$6 = require_language_core$1();
	const common_1$1 = require_common$1();
	const decorateLanguageServiceHost_1 = require_decorateLanguageServiceHost();
	exports.externalFiles = /* @__PURE__ */ new WeakMap();
	exports.projectExternalFileExtensions = /* @__PURE__ */ new WeakMap();
	exports.decoratedLanguageServices = /* @__PURE__ */ new WeakSet();
	exports.decoratedLanguageServiceHosts = /* @__PURE__ */ new WeakSet();
	/**
	* Wrap `getScriptInfo` to handle large files that may crash the language service.
	*
	* Introduced to fix issues with converting `relatedInformation` (in Diagnostics)
	* when working with large files.
	*
	* https://github.com/volarjs/volar.js/commit/e242709a91e9d2919dc4fa59278dd266fd11e7a3
	*/
	function makeGetScriptInfoWithLargeFileFailsafe(info) {
		return (fileName) => {
			try {
				return info.project.getScriptInfo(fileName);
			} catch {}
		};
	}
	function createLanguageCommon(createPluginResult, ts, info, initializeProxiedLanguageService) {
		const getScriptSnapshot = info.languageServiceHost.getScriptSnapshot.bind(info.languageServiceHost);
		const getScriptInfo = makeGetScriptInfoWithLargeFileFailsafe(info);
		const language = (0, language_core_1$6.createLanguage)([...createPluginResult.languagePlugins, { getLanguageId: common_1$1.resolveFileLanguageId }], new language_core_1$6.FileMap(ts.sys.useCaseSensitiveFileNames), (fileName, _, shouldRegister) => {
			let snapshot;
			if (shouldRegister) snapshot = getScriptSnapshot(fileName);
			else {
				snapshot = getScriptInfo(fileName)?.getSnapshot();
				if (!snapshot) {
					info.project.getScriptVersion(fileName);
					snapshot = getScriptInfo(fileName)?.getSnapshot();
				}
			}
			if (snapshot) language.scripts.set(fileName, snapshot);
			else language.scripts.delete(fileName);
		}, (targetFileName) => {
			info.session.change({
				file: targetFileName,
				line: 1,
				offset: 1,
				endLine: 1,
				endOffset: 1,
				insertString: ""
			});
		});
		initializeProxiedLanguageService(language);
		(0, decorateLanguageServiceHost_1.decorateLanguageServiceHost)(ts, language, info.languageServiceHost);
		createPluginResult.setup?.(language);
	}
	const makeGetExternalFiles = (ts) => (project, updateLevel = 0) => {
		if (updateLevel >= 1 || !exports.externalFiles.has(project)) {
			const oldFiles = exports.externalFiles.get(project);
			const extensions = exports.projectExternalFileExtensions.get(project);
			const newFiles = extensions?.length ? (0, decorateLanguageServiceHost_1.searchExternalFiles)(ts, project, extensions) : [];
			exports.externalFiles.set(project, newFiles);
			if (oldFiles && !arrayItemsEqual(oldFiles, newFiles)) project.refreshDiagnostics();
		}
		return exports.externalFiles.get(project);
	};
	exports.makeGetExternalFiles = makeGetExternalFiles;
	function arrayItemsEqual(a, b) {
		if (a.length !== b.length) return false;
		const set = new Set(a);
		for (const file of b) if (!set.has(file)) return false;
		return true;
	}
	function isHasAlreadyDecoratedLanguageService(info) {
		if (exports.decoratedLanguageServices.has(info.languageService) || exports.decoratedLanguageServiceHosts.has(info.languageServiceHost)) return true;
		else {
			exports.decoratedLanguageServices.add(info.languageService);
			exports.decoratedLanguageServiceHosts.add(info.languageServiceHost);
			return false;
		}
	}
} });

//#endregion
//#region node_modules/@volar/typescript/lib/quickstart/createLanguageServicePlugin.js
var require_createLanguageServicePlugin = __commonJS({ "node_modules/@volar/typescript/lib/quickstart/createLanguageServicePlugin.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createLanguageServicePlugin = createLanguageServicePlugin;
	const proxyLanguageService_1 = require_proxyLanguageService();
	const languageServicePluginCommon_1 = require_languageServicePluginCommon();
	/**
	* Creates and returns a TS Service Plugin using Volar primitives.
	*
	* See https://github.com/microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin for
	* more information.
	*/
	function createLanguageServicePlugin(createPluginCallback) {
		return (modules) => {
			const { typescript: ts } = modules;
			const pluginModule = {
				create(info) {
					if (!(0, languageServicePluginCommon_1.isHasAlreadyDecoratedLanguageService)(info)) {
						const createPluginResult = createPluginCallback(ts, info);
						const extensions = createPluginResult.languagePlugins.map((plugin$14) => plugin$14.typescript?.extraFileExtensions.map((ext) => "." + ext.extension) ?? []).flat();
						languageServicePluginCommon_1.projectExternalFileExtensions.set(info.project, extensions);
						const { proxy, initialize } = (0, proxyLanguageService_1.createProxyLanguageService)(info.languageService);
						info.languageService = proxy;
						(0, languageServicePluginCommon_1.createLanguageCommon)(createPluginResult, ts, info, initialize);
					}
					return info.languageService;
				},
				getExternalFiles: (0, languageServicePluginCommon_1.makeGetExternalFiles)(ts)
			};
			return pluginModule;
		};
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/globalTypes.js
var require_globalTypes = __commonJS({ "node_modules/@vue/language-core/lib/codegen/globalTypes.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getGlobalTypesFileName = getGlobalTypesFileName;
	exports.generateGlobalTypes = generateGlobalTypes;
	function getGlobalTypesFileName(options) {
		return [
			options.lib,
			options.target,
			options.checkUnknownProps
		].map((v) => typeof v === "boolean" ? Number(v) : v).join("_") + ".d.ts";
	}
	function generateGlobalTypes(options) {
		const { lib, target, checkUnknownProps } = options;
		const fnPropsType = `(T extends { $props: infer Props } ? Props : {})${checkUnknownProps ? "" : " & Record<string, unknown>"}`;
		let text = `// @ts-nocheck\nexport {};\n`;
		if (target < 3.5) text += `
; declare module '${lib}' {
	export interface GlobalComponents { }
	export interface GlobalDirectives { }
}`;
		text += `
; declare global {
	const __VLS_directiveBindingRestFields: { instance: null, oldValue: null, modifiers: any, dir: any };
	const __VLS_unref: typeof import('${lib}').unref;
	const __VLS_placeholder: any;

	type __VLS_NativeElements = __VLS_SpreadMerge<SVGElementTagNameMap, HTMLElementTagNameMap>;
	type __VLS_IntrinsicElements = ${target >= 3.3 ? `import('${lib}/jsx-runtime').JSX.IntrinsicElements;` : `globalThis.JSX.IntrinsicElements;`}
	type __VLS_Element = ${target >= 3.3 ? `import('${lib}/jsx-runtime').JSX.Element;` : `globalThis.JSX.Element;`}
	type __VLS_GlobalComponents = ${target >= 3.5 ? `import('${lib}').GlobalComponents;` : `import('${lib}').GlobalComponents & Pick<typeof import('${lib}'), 'Transition' | 'TransitionGroup' | 'KeepAlive' | 'Suspense' | 'Teleport'>;`}
	type __VLS_GlobalDirectives = import('${lib}').GlobalDirectives;
	type __VLS_IsAny<T> = 0 extends 1 & T ? true : false;
	type __VLS_PickNotAny<A, B> = __VLS_IsAny<A> extends true ? B : A;
	type __VLS_SpreadMerge<A, B> = Omit<A, keyof B> & B;
	type __VLS_WithComponent<N0 extends string, LocalComponents, Self, N1 extends string, N2 extends string, N3 extends string> =
		N1 extends keyof LocalComponents ? { [K in N0]: LocalComponents[N1] } :
		N2 extends keyof LocalComponents ? { [K in N0]: LocalComponents[N2] } :
		N3 extends keyof LocalComponents ? { [K in N0]: LocalComponents[N3] } :
		Self extends object ? { [K in N0]: Self } :
		N1 extends keyof __VLS_GlobalComponents ? { [K in N0]: __VLS_GlobalComponents[N1] } :
		N2 extends keyof __VLS_GlobalComponents ? { [K in N0]: __VLS_GlobalComponents[N2] } :
		N3 extends keyof __VLS_GlobalComponents ? { [K in N0]: __VLS_GlobalComponents[N3] } :
		{};
	type __VLS_FunctionalComponentCtx<T, K> = __VLS_PickNotAny<'__ctx' extends keyof __VLS_PickNotAny<K, {}>
		? K extends { __ctx?: infer Ctx } ? NonNullable<Ctx> : never : any
		, T extends (props: any, ctx: infer Ctx) => any ? Ctx : any
	>;
	type __VLS_FunctionalComponentProps<T, K> = '__ctx' extends keyof __VLS_PickNotAny<K, {}>
		? K extends { __ctx?: { props?: infer P } } ? NonNullable<P> : never
		: T extends (props: infer P, ...args: any) => any ? P
		: {};
	type __VLS_FunctionalComponent<T> = (props: ${fnPropsType}, ctx?: any) => __VLS_Element & {
		__ctx?: {
			attrs?: any;
			slots?: T extends { $slots: infer Slots } ? Slots : Record<string, any>;
			emit?: T extends { $emit: infer Emit } ? Emit : {};
			props?: ${fnPropsType};
			expose?: (exposed: T) => void;
		};
	};
	type __VLS_IsFunction<T, K> = K extends keyof T
		? __VLS_IsAny<T[K]> extends false
		? unknown extends T[K]
		? false
		: true
		: false
		: false;
	type __VLS_NormalizeComponentEvent<
		Props,
		Emits,
		onEvent extends keyof Props,
		Event extends keyof Emits,
		CamelizedEvent extends keyof Emits,
	> = __VLS_IsFunction<Props, onEvent> extends true
		? Props
		: __VLS_IsFunction<Emits, Event> extends true
			? { [K in onEvent]?: Emits[Event] }
			: __VLS_IsFunction<Emits, CamelizedEvent> extends true
				? { [K in onEvent]?: Emits[CamelizedEvent] }
				: Props;
	// fix https://github.com/vuejs/language-tools/issues/926
	type __VLS_UnionToIntersection<U> = (U extends unknown ? (arg: U) => unknown : never) extends ((arg: infer P) => unknown) ? P : never;
	type __VLS_OverloadUnionInner<T, U = unknown> = U & T extends (...args: infer A) => infer R
		? U extends T
		? never
		: __VLS_OverloadUnionInner<T, Pick<T, keyof T> & U & ((...args: A) => R)> | ((...args: A) => R)
		: never;
	type __VLS_OverloadUnion<T> = Exclude<
		__VLS_OverloadUnionInner<(() => never) & T>,
		T extends () => never ? never : () => never
	>;
	type __VLS_ConstructorOverloads<T> = __VLS_OverloadUnion<T> extends infer F
		? F extends (event: infer E, ...args: infer A) => any
		? { [K in E & string]: (...args: A) => void; }
		: never
		: never;
	type __VLS_NormalizeEmits<T> = __VLS_PrettifyGlobal<
		__VLS_UnionToIntersection<
			__VLS_ConstructorOverloads<T> & {
				[K in keyof T]: T[K] extends any[] ? { (...args: T[K]): void } : never
			}
		>
	>;
	type __VLS_EmitsToProps<T> = __VLS_PrettifyGlobal<{
		[K in string & keyof T as \`on\${Capitalize<K>}\`]?:
			(...args: T[K] extends (...args: infer P) => any ? P : T[K] extends null ? any[] : never) => any;
	}>;
	type __VLS_ResolveEmits<
		Comp,
		Emits,
		TypeEmits = ${target >= 3.6 ? `Comp extends { __typeEmits?: infer T } ? unknown extends T ? {} : import('${lib}').ShortEmitsToObject<T> : {}` : `{}`},
		NormalizedEmits = __VLS_NormalizeEmits<Emits> extends infer E ? string extends keyof E ? {} : E : never,
	> = __VLS_SpreadMerge<NormalizedEmits, TypeEmits>;
	type __VLS_ResolveDirectives<T> = {
		[K in keyof T & string as \`v\${Capitalize<K>}\`]: T[K];
	};
	type __VLS_PrettifyGlobal<T> = { [K in keyof T as K]: T[K]; } & {};
	type __VLS_WithDefaultsGlobal<P, D> = {
		[K in keyof P as K extends keyof D ? K : never]-?: P[K];
	} & {
		[K in keyof P as K extends keyof D ? never : K]: P[K];
	};
	type __VLS_UseTemplateRef<T> = Readonly<import('${lib}').ShallowRef<T | null>>;
	type __VLS_ProxyRefs<T> = import('${lib}').ShallowUnwrapRef<T>;

	function __VLS_getVForSourceType<T extends number | string | any[] | Iterable<any>>(source: T): [
		item: T extends number ? number
			: T extends string ? string
			: T extends any[] ? T[number]
			: T extends Iterable<infer T1> ? T1
			: any,
		index: number,
	][];
	function __VLS_getVForSourceType<T>(source: T): [
		item: T[keyof T],
		key: keyof T,
		index: number,
	][];
	function __VLS_getSlotParameters<S, D extends S>(slot: S, decl?: D):
		D extends (...args: infer P) => any ? P : any[];
	function __VLS_asFunctionalDirective<T>(dir: T): T extends import('${lib}').ObjectDirective
		? NonNullable<T['created' | 'beforeMount' | 'mounted' | 'beforeUpdate' | 'updated' | 'beforeUnmount' | 'unmounted']>
		: T extends (...args: any) => any
			? T
			: (arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown) => void;
	function __VLS_asFunctionalComponent<T, K = T extends new (...args: any) => any ? InstanceType<T> : unknown>(t: T, instance?: K):
		T extends new (...args: any) => any ? __VLS_FunctionalComponent<K>
		: T extends () => any ? (props: {}, ctx?: any) => ReturnType<T>
		: T extends (...args: any) => any ? T
		: __VLS_FunctionalComponent<{}>;
	function __VLS_functionalComponentArgsRest<T extends (...args: any) => any>(t: T): 2 extends Parameters<T>['length'] ? [any] : [];
	function __VLS_asFunctionalElement<T>(tag: T, endTag?: T): (attrs: T${checkUnknownProps ? "" : " & Record<string, unknown>"}) => void;
	function __VLS_asFunctionalSlot<S>(slot: S): S extends () => infer R ? (props: {}) => R : NonNullable<S>;
	function __VLS_tryAsConstant<const T>(t: T): T;
}
`;
		return text;
	}
} });

//#endregion
//#region node_modules/@vue/shared/dist/shared.cjs.prod.js
var require_shared_cjs_prod = __commonJS({ "node_modules/@vue/shared/dist/shared.cjs.prod.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	/* @__NO_SIDE_EFFECTS__ */
	function makeMap(str) {
		const map = /* @__PURE__ */ Object.create(null);
		for (const key of str.split(",")) map[key] = 1;
		return (val) => val in map;
	}
	const EMPTY_OBJ = {};
	const EMPTY_ARR = [];
	const NOOP = () => {};
	const NO = () => false;
	const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
	const isModelListener = (key) => key.startsWith("onUpdate:");
	const extend = Object.assign;
	const remove = (arr, el) => {
		const i = arr.indexOf(el);
		if (i > -1) arr.splice(i, 1);
	};
	const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
	const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
	const isArray = Array.isArray;
	const isMap = (val) => toTypeString(val) === "[object Map]";
	const isSet = (val) => toTypeString(val) === "[object Set]";
	const isDate = (val) => toTypeString(val) === "[object Date]";
	const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
	const isFunction = (val) => typeof val === "function";
	const isString = (val) => typeof val === "string";
	const isSymbol = (val) => typeof val === "symbol";
	const isObject$1 = (val) => val !== null && typeof val === "object";
	const isPromise = (val) => {
		return (isObject$1(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
	};
	const objectToString = Object.prototype.toString;
	const toTypeString = (value) => objectToString.call(value);
	const toRawType = (value) => {
		return toTypeString(value).slice(8, -1);
	};
	const isPlainObject = (val) => toTypeString(val) === "[object Object]";
	const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
	const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
	const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
	const cacheStringFunction = (fn) => {
		const cache = /* @__PURE__ */ Object.create(null);
		return (str) => {
			const hit = cache[str];
			return hit || (cache[str] = fn(str));
		};
	};
	const camelizeRE = /-\w/g;
	const camelize = cacheStringFunction((str) => {
		return str.replace(camelizeRE, (c) => c.slice(1).toUpperCase());
	});
	const hyphenateRE = /\B([A-Z])/g;
	const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
	const capitalize = cacheStringFunction((str) => {
		return str.charAt(0).toUpperCase() + str.slice(1);
	});
	const toHandlerKey = cacheStringFunction((str) => {
		const s = str ? `on${capitalize(str)}` : ``;
		return s;
	});
	const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
	const invokeArrayFns = (fns, ...arg) => {
		for (let i = 0; i < fns.length; i++) fns[i](...arg);
	};
	const def = (obj, key, value, writable = false) => {
		Object.defineProperty(obj, key, {
			configurable: true,
			enumerable: false,
			writable,
			value
		});
	};
	const looseToNumber = (val) => {
		const n = parseFloat(val);
		return isNaN(n) ? val : n;
	};
	const toNumber = (val) => {
		const n = isString(val) ? Number(val) : NaN;
		return isNaN(n) ? val : n;
	};
	let _globalThis;
	const getGlobalThis = () => {
		return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
	};
	const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
	function genPropsAccessExp(name) {
		return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
	}
	function genCacheKey(source, options) {
		return source + JSON.stringify(options, (_, val) => typeof val === "function" ? val.toString() : val);
	}
	const PatchFlags = {
		"TEXT": 1,
		"1": "TEXT",
		"CLASS": 2,
		"2": "CLASS",
		"STYLE": 4,
		"4": "STYLE",
		"PROPS": 8,
		"8": "PROPS",
		"FULL_PROPS": 16,
		"16": "FULL_PROPS",
		"NEED_HYDRATION": 32,
		"32": "NEED_HYDRATION",
		"STABLE_FRAGMENT": 64,
		"64": "STABLE_FRAGMENT",
		"KEYED_FRAGMENT": 128,
		"128": "KEYED_FRAGMENT",
		"UNKEYED_FRAGMENT": 256,
		"256": "UNKEYED_FRAGMENT",
		"NEED_PATCH": 512,
		"512": "NEED_PATCH",
		"DYNAMIC_SLOTS": 1024,
		"1024": "DYNAMIC_SLOTS",
		"DEV_ROOT_FRAGMENT": 2048,
		"2048": "DEV_ROOT_FRAGMENT",
		"CACHED": -1,
		"-1": "CACHED",
		"BAIL": -2,
		"-2": "BAIL"
	};
	const PatchFlagNames = {
		[1]: `TEXT`,
		[2]: `CLASS`,
		[4]: `STYLE`,
		[8]: `PROPS`,
		[16]: `FULL_PROPS`,
		[32]: `NEED_HYDRATION`,
		[64]: `STABLE_FRAGMENT`,
		[128]: `KEYED_FRAGMENT`,
		[256]: `UNKEYED_FRAGMENT`,
		[512]: `NEED_PATCH`,
		[1024]: `DYNAMIC_SLOTS`,
		[2048]: `DEV_ROOT_FRAGMENT`,
		[-1]: `CACHED`,
		[-2]: `BAIL`
	};
	const ShapeFlags = {
		"ELEMENT": 1,
		"1": "ELEMENT",
		"FUNCTIONAL_COMPONENT": 2,
		"2": "FUNCTIONAL_COMPONENT",
		"STATEFUL_COMPONENT": 4,
		"4": "STATEFUL_COMPONENT",
		"TEXT_CHILDREN": 8,
		"8": "TEXT_CHILDREN",
		"ARRAY_CHILDREN": 16,
		"16": "ARRAY_CHILDREN",
		"SLOTS_CHILDREN": 32,
		"32": "SLOTS_CHILDREN",
		"TELEPORT": 64,
		"64": "TELEPORT",
		"SUSPENSE": 128,
		"128": "SUSPENSE",
		"COMPONENT_SHOULD_KEEP_ALIVE": 256,
		"256": "COMPONENT_SHOULD_KEEP_ALIVE",
		"COMPONENT_KEPT_ALIVE": 512,
		"512": "COMPONENT_KEPT_ALIVE",
		"COMPONENT": 6,
		"6": "COMPONENT"
	};
	const SlotFlags = {
		"STABLE": 1,
		"1": "STABLE",
		"DYNAMIC": 2,
		"2": "DYNAMIC",
		"FORWARDED": 3,
		"3": "FORWARDED"
	};
	const slotFlagsText = {
		[1]: "STABLE",
		[2]: "DYNAMIC",
		[3]: "FORWARDED"
	};
	const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
	const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
	const isGloballyWhitelisted = isGloballyAllowed;
	const range = 2;
	function generateCodeFrame(source, start = 0, end = source.length) {
		start = Math.max(0, Math.min(start, source.length));
		end = Math.max(0, Math.min(end, source.length));
		if (start > end) return "";
		let lines = source.split(/(\r?\n)/);
		const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
		lines = lines.filter((_, idx) => idx % 2 === 0);
		let count = 0;
		const res = [];
		for (let i = 0; i < lines.length; i++) {
			count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
			if (count >= start) {
				for (let j = i - range; j <= i + range || end > count; j++) {
					if (j < 0 || j >= lines.length) continue;
					const line = j + 1;
					res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
					const lineLength = lines[j].length;
					const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
					if (j === i) {
						const pad = start - (count - (lineLength + newLineSeqLength));
						const length = Math.max(1, end > count ? lineLength - pad : end - start);
						res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
					} else if (j > i) {
						if (end > count) {
							const length = Math.max(Math.min(end - count, lineLength), 1);
							res.push(`   |  ` + "^".repeat(length));
						}
						count += lineLength + newLineSeqLength;
					}
				}
				break;
			}
		}
		return res.join("\n");
	}
	function normalizeStyle(value) {
		if (isArray(value)) {
			const res = {};
			for (let i = 0; i < value.length; i++) {
				const item = value[i];
				const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
				if (normalized) for (const key in normalized) res[key] = normalized[key];
			}
			return res;
		} else if (isString(value) || isObject$1(value)) return value;
	}
	const listDelimiterRE = /;(?![^(]*\))/g;
	const propertyDelimiterRE = /:([^]+)/;
	const styleCommentRE = /\/\*[^]*?\*\//g;
	function parseStringStyle(cssText) {
		const ret = {};
		cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
			if (item) {
				const tmp = item.split(propertyDelimiterRE);
				tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
			}
		});
		return ret;
	}
	function stringifyStyle(styles) {
		if (!styles) return "";
		if (isString(styles)) return styles;
		let ret = "";
		for (const key in styles) {
			const value = styles[key];
			if (isString(value) || typeof value === "number") {
				const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
				ret += `${normalizedKey}:${value};`;
			}
		}
		return ret;
	}
	function normalizeClass(value) {
		let res = "";
		if (isString(value)) res = value;
		else if (isArray(value)) for (let i = 0; i < value.length; i++) {
			const normalized = normalizeClass(value[i]);
			if (normalized) res += normalized + " ";
		}
		else if (isObject$1(value)) {
			for (const name in value) if (value[name]) res += name + " ";
		}
		return res.trim();
	}
	function normalizeProps(props) {
		if (!props) return null;
		let { class: klass, style } = props;
		if (klass && !isString(klass)) props.class = normalizeClass(klass);
		if (style) props.style = normalizeStyle(style);
		return props;
	}
	const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
	const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
	const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
	const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
	const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
	const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
	const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
	const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
	const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
	const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
	const isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
	function includeBooleanAttr(value) {
		return !!value || value === "";
	}
	const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
	const attrValidationCache = {};
	function isSSRSafeAttrName(name) {
		if (attrValidationCache.hasOwnProperty(name)) return attrValidationCache[name];
		const isUnsafe = unsafeAttrCharRE.test(name);
		if (isUnsafe) console.error(`unsafe attribute name: ${name}`);
		return attrValidationCache[name] = !isUnsafe;
	}
	const propsToAttrMap = {
		acceptCharset: "accept-charset",
		className: "class",
		htmlFor: "for",
		httpEquiv: "http-equiv"
	};
	const isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
	const isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
	const isKnownMathMLAttr = /* @__PURE__ */ makeMap(`accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`);
	function isRenderableAttrValue(value) {
		if (value == null) return false;
		const type = typeof value;
		return type === "string" || type === "number" || type === "boolean";
	}
	const escapeRE = /["'&<>]/;
	function escapeHtml(string) {
		const str = "" + string;
		const match = escapeRE.exec(str);
		if (!match) return str;
		let html = "";
		let escaped;
		let index;
		let lastIndex = 0;
		for (index = match.index; index < str.length; index++) {
			switch (str.charCodeAt(index)) {
				case 34:
					escaped = "&quot;";
					break;
				case 38:
					escaped = "&amp;";
					break;
				case 39:
					escaped = "&#39;";
					break;
				case 60:
					escaped = "&lt;";
					break;
				case 62:
					escaped = "&gt;";
					break;
				default: continue;
			}
			if (lastIndex !== index) html += str.slice(lastIndex, index);
			lastIndex = index + 1;
			html += escaped;
		}
		return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
	}
	const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
	function escapeHtmlComment(src) {
		return src.replace(commentStripRE, "");
	}
	const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
	function getEscapedCssVarName(key, doubleEscape) {
		return key.replace(cssVarNameEscapeSymbolsRE, (s) => doubleEscape ? s === "\"" ? "\\\\\\\"" : `\\\\${s}` : `\\${s}`);
	}
	function looseCompareArrays(a, b) {
		if (a.length !== b.length) return false;
		let equal = true;
		for (let i = 0; equal && i < a.length; i++) equal = looseEqual(a[i], b[i]);
		return equal;
	}
	function looseEqual(a, b) {
		if (a === b) return true;
		let aValidType = isDate(a);
		let bValidType = isDate(b);
		if (aValidType || bValidType) return aValidType && bValidType ? a.getTime() === b.getTime() : false;
		aValidType = isSymbol(a);
		bValidType = isSymbol(b);
		if (aValidType || bValidType) return a === b;
		aValidType = isArray(a);
		bValidType = isArray(b);
		if (aValidType || bValidType) return aValidType && bValidType ? looseCompareArrays(a, b) : false;
		aValidType = isObject$1(a);
		bValidType = isObject$1(b);
		if (aValidType || bValidType) {
			if (!aValidType || !bValidType) return false;
			const aKeysCount = Object.keys(a).length;
			const bKeysCount = Object.keys(b).length;
			if (aKeysCount !== bKeysCount) return false;
			for (const key in a) {
				const aHasKey = a.hasOwnProperty(key);
				const bHasKey = b.hasOwnProperty(key);
				if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) return false;
			}
		}
		return String(a) === String(b);
	}
	function looseIndexOf(arr, val) {
		return arr.findIndex((item) => looseEqual(item, val));
	}
	const isRef = (val) => {
		return !!(val && val["__v_isRef"] === true);
	};
	const toDisplayString = (val) => {
		return isString(val) ? val : val == null ? "" : isArray(val) || isObject$1(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
	};
	const replacer = (_key, val) => {
		if (isRef(val)) return replacer(_key, val.value);
		else if (isMap(val)) return { [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2], i) => {
			entries[stringifySymbol(key, i) + " =>"] = val2;
			return entries;
		}, {}) };
		else if (isSet(val)) return { [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v)) };
		else if (isSymbol(val)) return stringifySymbol(val);
		else if (isObject$1(val) && !isArray(val) && !isPlainObject(val)) return String(val);
		return val;
	};
	const stringifySymbol = (v, i = "") => {
		var _a$1;
		return isSymbol(v) ? `Symbol(${(_a$1 = v.description) != null ? _a$1 : i})` : v;
	};
	function normalizeCssVarValue(value) {
		if (value == null) return "initial";
		if (typeof value === "string") return value === "" ? " " : value;
		return String(value);
	}
	exports.EMPTY_ARR = EMPTY_ARR;
	exports.EMPTY_OBJ = EMPTY_OBJ;
	exports.NO = NO;
	exports.NOOP = NOOP;
	exports.PatchFlagNames = PatchFlagNames;
	exports.PatchFlags = PatchFlags;
	exports.ShapeFlags = ShapeFlags;
	exports.SlotFlags = SlotFlags;
	exports.camelize = camelize;
	exports.capitalize = capitalize;
	exports.cssVarNameEscapeSymbolsRE = cssVarNameEscapeSymbolsRE;
	exports.def = def;
	exports.escapeHtml = escapeHtml;
	exports.escapeHtmlComment = escapeHtmlComment;
	exports.extend = extend;
	exports.genCacheKey = genCacheKey;
	exports.genPropsAccessExp = genPropsAccessExp;
	exports.generateCodeFrame = generateCodeFrame;
	exports.getEscapedCssVarName = getEscapedCssVarName;
	exports.getGlobalThis = getGlobalThis;
	exports.hasChanged = hasChanged;
	exports.hasOwn = hasOwn;
	exports.hyphenate = hyphenate;
	exports.includeBooleanAttr = includeBooleanAttr;
	exports.invokeArrayFns = invokeArrayFns;
	exports.isArray = isArray;
	exports.isBooleanAttr = isBooleanAttr;
	exports.isBuiltInDirective = isBuiltInDirective;
	exports.isDate = isDate;
	exports.isFunction = isFunction;
	exports.isGloballyAllowed = isGloballyAllowed;
	exports.isGloballyWhitelisted = isGloballyWhitelisted;
	exports.isHTMLTag = isHTMLTag;
	exports.isIntegerKey = isIntegerKey;
	exports.isKnownHtmlAttr = isKnownHtmlAttr;
	exports.isKnownMathMLAttr = isKnownMathMLAttr;
	exports.isKnownSvgAttr = isKnownSvgAttr;
	exports.isMap = isMap;
	exports.isMathMLTag = isMathMLTag;
	exports.isModelListener = isModelListener;
	exports.isObject = isObject$1;
	exports.isOn = isOn;
	exports.isPlainObject = isPlainObject;
	exports.isPromise = isPromise;
	exports.isRegExp = isRegExp;
	exports.isRenderableAttrValue = isRenderableAttrValue;
	exports.isReservedProp = isReservedProp;
	exports.isSSRSafeAttrName = isSSRSafeAttrName;
	exports.isSVGTag = isSVGTag;
	exports.isSet = isSet;
	exports.isSpecialBooleanAttr = isSpecialBooleanAttr;
	exports.isString = isString;
	exports.isSymbol = isSymbol;
	exports.isVoidTag = isVoidTag;
	exports.looseEqual = looseEqual;
	exports.looseIndexOf = looseIndexOf;
	exports.looseToNumber = looseToNumber;
	exports.makeMap = makeMap;
	exports.normalizeClass = normalizeClass;
	exports.normalizeCssVarValue = normalizeCssVarValue;
	exports.normalizeProps = normalizeProps;
	exports.normalizeStyle = normalizeStyle;
	exports.objectToString = objectToString;
	exports.parseStringStyle = parseStringStyle;
	exports.propsToAttrMap = propsToAttrMap;
	exports.remove = remove;
	exports.slotFlagsText = slotFlagsText;
	exports.stringifyStyle = stringifyStyle;
	exports.toDisplayString = toDisplayString;
	exports.toHandlerKey = toHandlerKey;
	exports.toNumber = toNumber;
	exports.toRawType = toRawType;
	exports.toTypeString = toTypeString;
} });

//#endregion
//#region node_modules/@vue/shared/index.js
var require_shared$2 = __commonJS({ "node_modules/@vue/shared/index.js"(exports, module) {
	module.exports = require_shared_cjs_prod();
} });

//#endregion
//#region node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({ "node_modules/entities/lib/generated/decode-data-html.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = new Uint16Array("<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT\"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0p\xA0mp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;".split("").map(function(c) {
		return c.charCodeAt(0);
	}));
} });

//#endregion
//#region node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({ "node_modules/entities/lib/generated/decode-data-xml.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = new Uint16Array("aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(c) {
		return c.charCodeAt(0);
	}));
} });

//#endregion
//#region node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({ "node_modules/entities/lib/decode_codepoint.js"(exports) {
	var _a;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.replaceCodePoint = exports.fromCodePoint = void 0;
	var decodeMap = new Map([
		[0, 65533],
		[128, 8364],
		[130, 8218],
		[131, 402],
		[132, 8222],
		[133, 8230],
		[134, 8224],
		[135, 8225],
		[136, 710],
		[137, 8240],
		[138, 352],
		[139, 8249],
		[140, 338],
		[142, 381],
		[145, 8216],
		[146, 8217],
		[147, 8220],
		[148, 8221],
		[149, 8226],
		[150, 8211],
		[151, 8212],
		[152, 732],
		[153, 8482],
		[154, 353],
		[155, 8250],
		[156, 339],
		[158, 382],
		[159, 376]
	]);
	/**
	* Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
	*/
	exports.fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
		var output = "";
		if (codePoint > 65535) {
			codePoint -= 65536;
			output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
			codePoint = 56320 | codePoint & 1023;
		}
		output += String.fromCharCode(codePoint);
		return output;
	};
	/**
	* Replace the given code point with a replacement character if it is a
	* surrogate or is outside the valid range. Otherwise return the code
	* point unchanged.
	*/
	function replaceCodePoint(codePoint) {
		var _a$1;
		if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) return 65533;
		return (_a$1 = decodeMap.get(codePoint)) !== null && _a$1 !== void 0 ? _a$1 : codePoint;
	}
	exports.replaceCodePoint = replaceCodePoint;
	/**
	* Replace the code point if relevant, then convert it to a string.
	*
	* @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.
	* @param codePoint The code point to decode.
	* @returns The decoded code point.
	*/
	function decodeCodePoint(codePoint) {
		return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
	}
	exports.default = decodeCodePoint;
} });

//#endregion
//#region node_modules/entities/lib/decode.js
var require_decode = __commonJS({ "node_modules/entities/lib/decode.js"(exports) {
	var __createBinding$3 = void 0 && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	});
	var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar = void 0 && (void 0).__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$3(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __importDefault = void 0 && (void 0).__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
	var decode_data_html_js_1 = __importDefault(require_decode_data_html());
	exports.htmlDecodeTree = decode_data_html_js_1.default;
	var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
	exports.xmlDecodeTree = decode_data_xml_js_1.default;
	var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
	exports.decodeCodePoint = decode_codepoint_js_1.default;
	var decode_codepoint_js_2 = require_decode_codepoint();
	Object.defineProperty(exports, "replaceCodePoint", {
		enumerable: true,
		get: function() {
			return decode_codepoint_js_2.replaceCodePoint;
		}
	});
	Object.defineProperty(exports, "fromCodePoint", {
		enumerable: true,
		get: function() {
			return decode_codepoint_js_2.fromCodePoint;
		}
	});
	var CharCodes;
	(function(CharCodes$1) {
		CharCodes$1[CharCodes$1["NUM"] = 35] = "NUM";
		CharCodes$1[CharCodes$1["SEMI"] = 59] = "SEMI";
		CharCodes$1[CharCodes$1["EQUALS"] = 61] = "EQUALS";
		CharCodes$1[CharCodes$1["ZERO"] = 48] = "ZERO";
		CharCodes$1[CharCodes$1["NINE"] = 57] = "NINE";
		CharCodes$1[CharCodes$1["LOWER_A"] = 97] = "LOWER_A";
		CharCodes$1[CharCodes$1["LOWER_F"] = 102] = "LOWER_F";
		CharCodes$1[CharCodes$1["LOWER_X"] = 120] = "LOWER_X";
		CharCodes$1[CharCodes$1["LOWER_Z"] = 122] = "LOWER_Z";
		CharCodes$1[CharCodes$1["UPPER_A"] = 65] = "UPPER_A";
		CharCodes$1[CharCodes$1["UPPER_F"] = 70] = "UPPER_F";
		CharCodes$1[CharCodes$1["UPPER_Z"] = 90] = "UPPER_Z";
	})(CharCodes || (CharCodes = {}));
	/** Bit that needs to be set to convert an upper case ASCII character to lower case */
	var TO_LOWER_BIT = 32;
	var BinTrieFlags;
	(function(BinTrieFlags$1) {
		BinTrieFlags$1[BinTrieFlags$1["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
		BinTrieFlags$1[BinTrieFlags$1["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
		BinTrieFlags$1[BinTrieFlags$1["JUMP_TABLE"] = 127] = "JUMP_TABLE";
	})(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
	function isNumber$1(code$1) {
		return code$1 >= CharCodes.ZERO && code$1 <= CharCodes.NINE;
	}
	function isHexadecimalCharacter(code$1) {
		return code$1 >= CharCodes.UPPER_A && code$1 <= CharCodes.UPPER_F || code$1 >= CharCodes.LOWER_A && code$1 <= CharCodes.LOWER_F;
	}
	function isAsciiAlphaNumeric(code$1) {
		return code$1 >= CharCodes.UPPER_A && code$1 <= CharCodes.UPPER_Z || code$1 >= CharCodes.LOWER_A && code$1 <= CharCodes.LOWER_Z || isNumber$1(code$1);
	}
	/**
	* Checks if the given character is a valid end character for an entity in an attribute.
	*
	* Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
	* See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
	*/
	function isEntityInAttributeInvalidEnd(code$1) {
		return code$1 === CharCodes.EQUALS || isAsciiAlphaNumeric(code$1);
	}
	var EntityDecoderState;
	(function(EntityDecoderState$1) {
		EntityDecoderState$1[EntityDecoderState$1["EntityStart"] = 0] = "EntityStart";
		EntityDecoderState$1[EntityDecoderState$1["NumericStart"] = 1] = "NumericStart";
		EntityDecoderState$1[EntityDecoderState$1["NumericDecimal"] = 2] = "NumericDecimal";
		EntityDecoderState$1[EntityDecoderState$1["NumericHex"] = 3] = "NumericHex";
		EntityDecoderState$1[EntityDecoderState$1["NamedEntity"] = 4] = "NamedEntity";
	})(EntityDecoderState || (EntityDecoderState = {}));
	var DecodingMode;
	(function(DecodingMode$1) {
		/** Entities in text nodes that can end with any character. */
		DecodingMode$1[DecodingMode$1["Legacy"] = 0] = "Legacy";
		/** Only allow entities terminated with a semicolon. */
		DecodingMode$1[DecodingMode$1["Strict"] = 1] = "Strict";
		/** Entities in attributes have limitations on ending characters. */
		DecodingMode$1[DecodingMode$1["Attribute"] = 2] = "Attribute";
	})(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
	/**
	* Token decoder with support of writing partial entities.
	*/
	var EntityDecoder = function() {
		function EntityDecoder$1(decodeTree, emitCodePoint, errors) {
			this.decodeTree = decodeTree;
			this.emitCodePoint = emitCodePoint;
			this.errors = errors;
			/** The current state of the decoder. */
			this.state = EntityDecoderState.EntityStart;
			/** Characters that were consumed while parsing an entity. */
			this.consumed = 1;
			/**
			* The result of the entity.
			*
			* Either the result index of a numeric entity, or the codepoint of a
			* numeric entity.
			*/
			this.result = 0;
			/** The current index in the decode tree. */
			this.treeIndex = 0;
			/** The number of characters that were consumed in excess. */
			this.excess = 1;
			/** The mode in which the decoder is operating. */
			this.decodeMode = DecodingMode.Strict;
		}
		/** Resets the instance to make it reusable. */
		EntityDecoder$1.prototype.startEntity = function(decodeMode) {
			this.decodeMode = decodeMode;
			this.state = EntityDecoderState.EntityStart;
			this.result = 0;
			this.treeIndex = 0;
			this.excess = 1;
			this.consumed = 1;
		};
		/**
		* Write an entity to the decoder. This can be called multiple times with partial entities.
		* If the entity is incomplete, the decoder will return -1.
		*
		* Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
		* entity is incomplete, and resume when the next string is written.
		*
		* @param string The string containing the entity (or a continuation of the entity).
		* @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
		* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		*/
		EntityDecoder$1.prototype.write = function(str, offset) {
			switch (this.state) {
				case EntityDecoderState.EntityStart: {
					if (str.charCodeAt(offset) === CharCodes.NUM) {
						this.state = EntityDecoderState.NumericStart;
						this.consumed += 1;
						return this.stateNumericStart(str, offset + 1);
					}
					this.state = EntityDecoderState.NamedEntity;
					return this.stateNamedEntity(str, offset);
				}
				case EntityDecoderState.NumericStart: return this.stateNumericStart(str, offset);
				case EntityDecoderState.NumericDecimal: return this.stateNumericDecimal(str, offset);
				case EntityDecoderState.NumericHex: return this.stateNumericHex(str, offset);
				case EntityDecoderState.NamedEntity: return this.stateNamedEntity(str, offset);
			}
		};
		/**
		* Switches between the numeric decimal and hexadecimal states.
		*
		* Equivalent to the `Numeric character reference state` in the HTML spec.
		*
		* @param str The string containing the entity (or a continuation of the entity).
		* @param offset The current offset.
		* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		*/
		EntityDecoder$1.prototype.stateNumericStart = function(str, offset) {
			if (offset >= str.length) return -1;
			if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
				this.state = EntityDecoderState.NumericHex;
				this.consumed += 1;
				return this.stateNumericHex(str, offset + 1);
			}
			this.state = EntityDecoderState.NumericDecimal;
			return this.stateNumericDecimal(str, offset);
		};
		EntityDecoder$1.prototype.addToNumericResult = function(str, start, end, base) {
			if (start !== end) {
				var digitCount = end - start;
				this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
				this.consumed += digitCount;
			}
		};
		/**
		* Parses a hexadecimal numeric entity.
		*
		* Equivalent to the `Hexademical character reference state` in the HTML spec.
		*
		* @param str The string containing the entity (or a continuation of the entity).
		* @param offset The current offset.
		* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		*/
		EntityDecoder$1.prototype.stateNumericHex = function(str, offset) {
			var startIdx = offset;
			while (offset < str.length) {
				var char = str.charCodeAt(offset);
				if (isNumber$1(char) || isHexadecimalCharacter(char)) offset += 1;
				else {
					this.addToNumericResult(str, startIdx, offset, 16);
					return this.emitNumericEntity(char, 3);
				}
			}
			this.addToNumericResult(str, startIdx, offset, 16);
			return -1;
		};
		/**
		* Parses a decimal numeric entity.
		*
		* Equivalent to the `Decimal character reference state` in the HTML spec.
		*
		* @param str The string containing the entity (or a continuation of the entity).
		* @param offset The current offset.
		* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		*/
		EntityDecoder$1.prototype.stateNumericDecimal = function(str, offset) {
			var startIdx = offset;
			while (offset < str.length) {
				var char = str.charCodeAt(offset);
				if (isNumber$1(char)) offset += 1;
				else {
					this.addToNumericResult(str, startIdx, offset, 10);
					return this.emitNumericEntity(char, 2);
				}
			}
			this.addToNumericResult(str, startIdx, offset, 10);
			return -1;
		};
		/**
		* Validate and emit a numeric entity.
		*
		* Implements the logic from the `Hexademical character reference start
		* state` and `Numeric character reference end state` in the HTML spec.
		*
		* @param lastCp The last code point of the entity. Used to see if the
		*               entity was terminated with a semicolon.
		* @param expectedLength The minimum number of characters that should be
		*                       consumed. Used to validate that at least one digit
		*                       was consumed.
		* @returns The number of characters that were consumed.
		*/
		EntityDecoder$1.prototype.emitNumericEntity = function(lastCp, expectedLength) {
			var _a$1;
			if (this.consumed <= expectedLength) {
				(_a$1 = this.errors) === null || _a$1 === void 0 || _a$1.absenceOfDigitsInNumericCharacterReference(this.consumed);
				return 0;
			}
			if (lastCp === CharCodes.SEMI) this.consumed += 1;
			else if (this.decodeMode === DecodingMode.Strict) return 0;
			this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
			if (this.errors) {
				if (lastCp !== CharCodes.SEMI) this.errors.missingSemicolonAfterCharacterReference();
				this.errors.validateNumericCharacterReference(this.result);
			}
			return this.consumed;
		};
		/**
		* Parses a named entity.
		*
		* Equivalent to the `Named character reference state` in the HTML spec.
		*
		* @param str The string containing the entity (or a continuation of the entity).
		* @param offset The current offset.
		* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		*/
		EntityDecoder$1.prototype.stateNamedEntity = function(str, offset) {
			var decodeTree = this.decodeTree;
			var current = decodeTree[this.treeIndex];
			var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
			for (; offset < str.length; offset++, this.excess++) {
				var char = str.charCodeAt(offset);
				this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
				if (this.treeIndex < 0) return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
				current = decodeTree[this.treeIndex];
				valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
				if (valueLength !== 0) {
					if (char === CharCodes.SEMI) return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
					if (this.decodeMode !== DecodingMode.Strict) {
						this.result = this.treeIndex;
						this.consumed += this.excess;
						this.excess = 0;
					}
				}
			}
			return -1;
		};
		/**
		* Emit a named entity that was not terminated with a semicolon.
		*
		* @returns The number of characters consumed.
		*/
		EntityDecoder$1.prototype.emitNotTerminatedNamedEntity = function() {
			var _a$1;
			var _b = this, result = _b.result, decodeTree = _b.decodeTree;
			var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
			this.emitNamedEntityData(result, valueLength, this.consumed);
			(_a$1 = this.errors) === null || _a$1 === void 0 || _a$1.missingSemicolonAfterCharacterReference();
			return this.consumed;
		};
		/**
		* Emit a named entity.
		*
		* @param result The index of the entity in the decode tree.
		* @param valueLength The number of bytes in the entity.
		* @param consumed The number of characters consumed.
		*
		* @returns The number of characters consumed.
		*/
		EntityDecoder$1.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
			var decodeTree = this.decodeTree;
			this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
			if (valueLength === 3) this.emitCodePoint(decodeTree[result + 2], consumed);
			return consumed;
		};
		/**
		* Signal to the parser that the end of the input was reached.
		*
		* Remaining data will be emitted and relevant errors will be produced.
		*
		* @returns The number of characters consumed.
		*/
		EntityDecoder$1.prototype.end = function() {
			var _a$1;
			switch (this.state) {
				case EntityDecoderState.NamedEntity: return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
				case EntityDecoderState.NumericDecimal: return this.emitNumericEntity(0, 2);
				case EntityDecoderState.NumericHex: return this.emitNumericEntity(0, 3);
				case EntityDecoderState.NumericStart: {
					(_a$1 = this.errors) === null || _a$1 === void 0 || _a$1.absenceOfDigitsInNumericCharacterReference(this.consumed);
					return 0;
				}
				case EntityDecoderState.EntityStart: return 0;
			}
		};
		return EntityDecoder$1;
	}();
	exports.EntityDecoder = EntityDecoder;
	/**
	* Creates a function that decodes entities in a string.
	*
	* @param decodeTree The decode tree.
	* @returns A function that decodes entities in a string.
	*/
	function getDecoder(decodeTree) {
		var ret = "";
		var decoder = new EntityDecoder(decodeTree, function(str) {
			return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
		});
		return function decodeWithTrie(str, decodeMode) {
			var lastIndex = 0;
			var offset = 0;
			while ((offset = str.indexOf("&", offset)) >= 0) {
				ret += str.slice(lastIndex, offset);
				decoder.startEntity(decodeMode);
				var len = decoder.write(str, offset + 1);
				if (len < 0) {
					lastIndex = offset + decoder.end();
					break;
				}
				lastIndex = offset + len;
				offset = len === 0 ? lastIndex + 1 : lastIndex;
			}
			var result = ret + str.slice(lastIndex);
			ret = "";
			return result;
		};
	}
	/**
	* Determines the branch of the current node that is taken given the current
	* character. This function is used to traverse the trie.
	*
	* @param decodeTree The trie.
	* @param current The current node.
	* @param nodeIdx The index right after the current node and its value.
	* @param char The current character.
	* @returns The index of the next node, or -1 if no branch is taken.
	*/
	function determineBranch(decodeTree, current, nodeIdx, char) {
		var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
		var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
		if (branchCount === 0) return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
		if (jumpOffset) {
			var value = char - jumpOffset;
			return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
		}
		var lo = nodeIdx;
		var hi = lo + branchCount - 1;
		while (lo <= hi) {
			var mid = lo + hi >>> 1;
			var midVal = decodeTree[mid];
			if (midVal < char) lo = mid + 1;
			else if (midVal > char) hi = mid - 1;
			else return decodeTree[mid + branchCount];
		}
		return -1;
	}
	exports.determineBranch = determineBranch;
	var htmlDecoder = getDecoder(decode_data_html_js_1.default);
	var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
	/**
	* Decodes an HTML string.
	*
	* @param str The string to decode.
	* @param mode The decoding mode.
	* @returns The decoded string.
	*/
	function decodeHTML(str, mode) {
		if (mode === void 0) mode = DecodingMode.Legacy;
		return htmlDecoder(str, mode);
	}
	exports.decodeHTML = decodeHTML;
	/**
	* Decodes an HTML string in an attribute.
	*
	* @param str The string to decode.
	* @returns The decoded string.
	*/
	function decodeHTMLAttribute(str) {
		return htmlDecoder(str, DecodingMode.Attribute);
	}
	exports.decodeHTMLAttribute = decodeHTMLAttribute;
	/**
	* Decodes an HTML string, requiring all entities to be terminated by a semicolon.
	*
	* @param str The string to decode.
	* @returns The decoded string.
	*/
	function decodeHTMLStrict(str) {
		return htmlDecoder(str, DecodingMode.Strict);
	}
	exports.decodeHTMLStrict = decodeHTMLStrict;
	/**
	* Decodes an XML string, requiring all entities to be terminated by a semicolon.
	*
	* @param str The string to decode.
	* @returns The decoded string.
	*/
	function decodeXML(str) {
		return xmlDecoder(str, DecodingMode.Strict);
	}
	exports.decodeXML = decodeXML;
} });

//#endregion
//#region node_modules/@babel/parser/lib/index.js
var require_lib = __commonJS({ "node_modules/@babel/parser/lib/index.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	function _objectWithoutPropertiesLoose(r, e) {
		if (null == r) return {};
		var t = {};
		for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
			if (-1 !== e.indexOf(n)) continue;
			t[n] = r[n];
		}
		return t;
	}
	var Position = class {
		constructor(line, col, index) {
			this.line = void 0;
			this.column = void 0;
			this.index = void 0;
			this.line = line;
			this.column = col;
			this.index = index;
		}
	};
	var SourceLocation = class {
		constructor(start, end) {
			this.start = void 0;
			this.end = void 0;
			this.filename = void 0;
			this.identifierName = void 0;
			this.start = start;
			this.end = end;
		}
	};
	function createPositionWithColumnOffset(position, columnOffset) {
		const { line, column, index } = position;
		return new Position(line, column + columnOffset, index + columnOffset);
	}
	const code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
	var ModuleErrors = {
		ImportMetaOutsideModule: {
			message: `import.meta may appear only with 'sourceType: "module"'`,
			code
		},
		ImportOutsideModule: {
			message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
			code
		}
	};
	const NodeDescriptions = {
		ArrayPattern: "array destructuring pattern",
		AssignmentExpression: "assignment expression",
		AssignmentPattern: "assignment expression",
		ArrowFunctionExpression: "arrow function expression",
		ConditionalExpression: "conditional expression",
		CatchClause: "catch clause",
		ForOfStatement: "for-of statement",
		ForInStatement: "for-in statement",
		ForStatement: "for-loop",
		FormalParameters: "function parameter list",
		Identifier: "identifier",
		ImportSpecifier: "import specifier",
		ImportDefaultSpecifier: "import default specifier",
		ImportNamespaceSpecifier: "import namespace specifier",
		ObjectPattern: "object destructuring pattern",
		ParenthesizedExpression: "parenthesized expression",
		RestElement: "rest element",
		UpdateExpression: {
			true: "prefix operation",
			false: "postfix operation"
		},
		VariableDeclarator: "variable declaration",
		YieldExpression: "yield expression"
	};
	const toNodeDescription = (node) => node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];
	var StandardErrors = {
		AccessorIsGenerator: ({ kind }) => `A ${kind}ter cannot be a generator.`,
		ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
		AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
		AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
		AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
		AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
		AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
		AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
		BadGetterArity: "A 'get' accessor must not have any formal parameters.",
		BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
		BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
		ConstructorClassField: "Classes may not have a field named 'constructor'.",
		ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
		ConstructorIsAccessor: "Class constructor may not be an accessor.",
		ConstructorIsAsync: "Constructor can't be an async function.",
		ConstructorIsGenerator: "Constructor can't be a generator.",
		DeclarationMissingInitializer: ({ kind }) => `Missing initializer in ${kind} declaration.`,
		DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
		DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
		DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
		DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
		DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
		DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
		DecoratorStaticBlock: "Decorators can't be used with a static block.",
		DeferImportRequiresNamespace: "Only `import defer * as x from \"./module\"` is valid.",
		DeletePrivateField: "Deleting a private field is not allowed.",
		DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
		DuplicateConstructor: "Duplicate constructor in the same class.",
		DuplicateDefaultExport: "Only one default export allowed per module.",
		DuplicateExport: ({ exportName }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
		DuplicateProto: "Redefinition of __proto__ property.",
		DuplicateRegExpFlags: "Duplicate regular expression flag.",
		ElementAfterRest: "Rest element must be last element.",
		EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
		ExportBindingIsString: ({ localName, exportName }) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
		ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
		ForInOfLoopInitializer: ({ type }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
		ForInUsing: "For-in loop may not start with 'using' declaration.",
		ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
		ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
		GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
		IllegalBreakContinue: ({ type }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
		IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
		IllegalReturn: "'return' outside of function.",
		ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
		ImportBindingIsString: ({ importName }) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${importName}" as foo }\`?`,
		ImportCallArity: `\`import()\` requires exactly one or two arguments.`,
		ImportCallNotNewExpression: "Cannot use new with import(...).",
		ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
		ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
		ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
		ImportReflectionNotBinding: "Only `import module x from \"./module\"` is valid.",
		IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
		InvalidBigIntLiteral: "Invalid BigIntLiteral.",
		InvalidCodePoint: "Code point out of bounds.",
		InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.",
		InvalidCoverInitializedName: "Invalid shorthand property initializer.",
		InvalidDecimal: "Invalid decimal.",
		InvalidDigit: ({ radix }) => `Expected number in radix ${radix}.`,
		InvalidEscapeSequence: "Bad character escape sequence.",
		InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
		InvalidEscapedReservedWord: ({ reservedWord }) => `Escape sequence in keyword ${reservedWord}.`,
		InvalidIdentifier: ({ identifierName }) => `Invalid identifier ${identifierName}.`,
		InvalidLhs: ({ ancestor }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
		InvalidLhsBinding: ({ ancestor }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
		InvalidLhsOptionalChaining: ({ ancestor }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
		InvalidNumber: "Invalid number.",
		InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
		InvalidOrUnexpectedToken: ({ unexpected }) => `Unexpected character '${unexpected}'.`,
		InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
		InvalidPrivateFieldResolution: ({ identifierName }) => `Private name #${identifierName} is not defined.`,
		InvalidPropertyBindingPattern: "Binding member expression.",
		InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
		InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
		LabelRedeclaration: ({ labelName }) => `Label '${labelName}' is already declared.`,
		LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
		LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
		MalformedRegExpFlags: "Invalid regular expression flag.",
		MissingClassName: "A class name is required.",
		MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
		MissingSemicolon: "Missing semicolon.",
		MissingPlugin: ({ missingPlugin }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
		MissingOneOfPlugins: ({ missingPlugin }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
		MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
		MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
		ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
		ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
		ModuleAttributesWithDuplicateKeys: ({ key }) => `Duplicate key "${key}" is not allowed in module attributes.`,
		ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
		ModuleExportUndefined: ({ localName }) => `Export '${localName}' is not defined.`,
		MultipleDefaultsInSwitch: "Multiple default clauses.",
		NewlineAfterThrow: "Illegal newline after throw.",
		NoCatchOrFinally: "Missing catch or finally clause.",
		NumberIdentifier: "Identifier directly after number.",
		NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
		ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
		OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
		OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
		OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
		ParamDupe: "Argument name clash.",
		PatternHasAccessor: "Object pattern can't contain getter or setter.",
		PatternHasMethod: "Object pattern can't contain methods.",
		PrivateInExpectedIn: ({ identifierName }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
		PrivateNameRedeclaration: ({ identifierName }) => `Duplicate private name #${identifierName}.`,
		RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
		RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
		RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
		RecordNoProto: "'__proto__' is not allowed in Record expressions.",
		RestTrailingComma: "Unexpected trailing comma after rest element.",
		SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
		SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
		SourcePhaseImportRequiresDefault: "Only `import source x from \"./module\"` is valid.",
		StaticPrototype: "Classes may not have static property named prototype.",
		SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
		SuperPrivateField: "Private fields can't be accessed on super.",
		TrailingDecorator: "Decorators must be attached to a class element.",
		TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
		TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
		TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
		UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
		UnexpectedAwaitAfterPipelineBody: "Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.",
		UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
		UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
		UnexpectedKeyword: ({ keyword }) => `Unexpected keyword '${keyword}'.`,
		UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
		UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
		UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
		UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
		UnexpectedPrivateField: "Unexpected private name.",
		UnexpectedReservedWord: ({ reservedWord }) => `Unexpected reserved word '${reservedWord}'.`,
		UnexpectedSuper: "'super' is only allowed in object methods and classes.",
		UnexpectedToken: ({ expected, unexpected }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
		UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
		UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.",
		UnexpectedVoidPattern: "Unexpected void binding.",
		UnsupportedBind: "Binding should be performed on object property.",
		UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
		UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
		UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
		UnsupportedMetaProperty: ({ target, onlyValidPropertyName }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
		UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
		UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
		UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
		UnterminatedComment: "Unterminated comment.",
		UnterminatedRegExp: "Unterminated regular expression.",
		UnterminatedString: "Unterminated string constant.",
		UnterminatedTemplate: "Unterminated template.",
		UsingDeclarationExport: "Using declaration cannot be exported.",
		UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
		VarRedeclaration: ({ identifierName }) => `Identifier '${identifierName}' has already been declared.`,
		VoidPatternCatchClauseParam: "A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.",
		VoidPatternInitializer: "A void binding may not have an initializer.",
		YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
		YieldInParameter: "Yield expression is not allowed in formal parameters.",
		YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
		ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
	};
	var StrictModeErrors = {
		StrictDelete: "Deleting local variable in strict mode.",
		StrictEvalArguments: ({ referenceName }) => `Assigning to '${referenceName}' in strict mode.`,
		StrictEvalArgumentsBinding: ({ bindingName }) => `Binding '${bindingName}' in strict mode.`,
		StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
		StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
		StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
		StrictWith: "'with' in strict mode."
	};
	var ParseExpressionErrors = {
		ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.",
		ParseExpressionExpectsEOF: ({ unexpected }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(unexpected)}\`.`
	};
	const UnparenthesizedPipeBodyDescriptions = new Set([
		"ArrowFunctionExpression",
		"AssignmentExpression",
		"ConditionalExpression",
		"YieldExpression"
	]);
	var PipelineOperatorErrors = Object.assign({
		PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
		PipeTopicRequiresHackPipes: "Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.",
		PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
		PipeTopicUnconfiguredToken: ({ token }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
		PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
		PipeUnparenthesizedBody: ({ type }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({ type })}; please wrap it in parentheses.`
	}, {
		PipelineBodyNoArrow: "Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.",
		PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
		PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
		PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
		PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
		PrimaryTopicRequiresSmartPipeline: "Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option."
	});
	const _excluded = ["message"];
	function defineHidden(obj, key, value) {
		Object.defineProperty(obj, key, {
			enumerable: false,
			configurable: true,
			value
		});
	}
	function toParseErrorConstructor({ toMessage, code: code$1, reasonCode, syntaxPlugin }) {
		const hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
		{
			const oldReasonCodes = {
				AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
				AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
				ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
				SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
				SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
				SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
			};
			if (oldReasonCodes[reasonCode]) reasonCode = oldReasonCodes[reasonCode];
		}
		return function constructor(loc, details) {
			const error = new SyntaxError();
			error.code = code$1;
			error.reasonCode = reasonCode;
			error.loc = loc;
			error.pos = loc.index;
			error.syntaxPlugin = syntaxPlugin;
			if (hasMissingPlugin) error.missingPlugin = details.missingPlugin;
			defineHidden(error, "clone", function clone(overrides = {}) {
				var _overrides$loc;
				const { line, column, index } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
				return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
			});
			defineHidden(error, "details", details);
			Object.defineProperty(error, "message", {
				configurable: true,
				get() {
					const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
					this.message = message;
					return message;
				},
				set(value) {
					Object.defineProperty(this, "message", {
						value,
						writable: true
					});
				}
			});
			return error;
		};
	}
	function ParseErrorEnum(argument, syntaxPlugin) {
		if (Array.isArray(argument)) return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
		const ParseErrorConstructors = {};
		for (const reasonCode of Object.keys(argument)) {
			const template = argument[reasonCode];
			const _ref = typeof template === "string" ? { message: () => template } : typeof template === "function" ? { message: template } : template, { message } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
			const toMessage = typeof message === "string" ? () => message : message;
			ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
				code: "BABEL_PARSER_SYNTAX_ERROR",
				reasonCode,
				toMessage
			}, syntaxPlugin ? { syntaxPlugin } : {}, rest));
		}
		return ParseErrorConstructors;
	}
	const Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(ParseExpressionErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
	function createDefaultOptions() {
		return {
			sourceType: "script",
			sourceFilename: void 0,
			startIndex: 0,
			startColumn: 0,
			startLine: 1,
			allowAwaitOutsideFunction: false,
			allowReturnOutsideFunction: false,
			allowNewTargetOutsideFunction: false,
			allowImportExportEverywhere: false,
			allowSuperOutsideMethod: false,
			allowUndeclaredExports: false,
			allowYieldOutsideFunction: false,
			plugins: [],
			strictMode: void 0,
			ranges: false,
			tokens: false,
			createImportExpressions: false,
			createParenthesizedExpressions: false,
			errorRecovery: false,
			attachComment: true,
			annexB: true
		};
	}
	function getOptions(opts) {
		const options = createDefaultOptions();
		if (opts == null) return options;
		if (opts.annexB != null && opts.annexB !== false) throw new Error("The `annexB` option can only be set to `false`.");
		for (const key of Object.keys(options)) if (opts[key] != null) options[key] = opts[key];
		if (options.startLine === 1) {
			if (opts.startIndex == null && options.startColumn > 0) options.startIndex = options.startColumn;
			else if (opts.startColumn == null && options.startIndex > 0) options.startColumn = options.startIndex;
		} else if (opts.startColumn == null || opts.startIndex == null) {
			if (opts.startIndex != null) throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
		}
		if (options.sourceType === "commonjs") {
			if (opts.allowAwaitOutsideFunction != null) throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
			if (opts.allowReturnOutsideFunction != null) throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.");
			if (opts.allowNewTargetOutsideFunction != null) throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.");
		}
		return options;
	}
	const { defineProperty } = Object;
	const toUnenumerable = (object, key) => {
		if (object) defineProperty(object, key, {
			enumerable: false,
			value: object[key]
		});
	};
	function toESTreeLocation(node) {
		toUnenumerable(node.loc.start, "index");
		toUnenumerable(node.loc.end, "index");
		return node;
	}
	var estree = (superClass) => class ESTreeParserMixin extends superClass {
		parse() {
			const file = toESTreeLocation(super.parse());
			if (this.optionFlags & 256) file.tokens = file.tokens.map(toESTreeLocation);
			return file;
		}
		parseRegExpLiteral({ pattern, flags }) {
			let regex = null;
			try {
				regex = new RegExp(pattern, flags);
			} catch (_) {}
			const node = this.estreeParseLiteral(regex);
			node.regex = {
				pattern,
				flags
			};
			return node;
		}
		parseBigIntLiteral(value) {
			let bigInt;
			try {
				bigInt = BigInt(value);
			} catch (_unused) {
				bigInt = null;
			}
			const node = this.estreeParseLiteral(bigInt);
			node.bigint = String(node.value || value);
			return node;
		}
		parseDecimalLiteral(value) {
			const decimal = null;
			const node = this.estreeParseLiteral(decimal);
			node.decimal = String(node.value || value);
			return node;
		}
		estreeParseLiteral(value) {
			return this.parseLiteral(value, "Literal");
		}
		parseStringLiteral(value) {
			return this.estreeParseLiteral(value);
		}
		parseNumericLiteral(value) {
			return this.estreeParseLiteral(value);
		}
		parseNullLiteral() {
			return this.estreeParseLiteral(null);
		}
		parseBooleanLiteral(value) {
			return this.estreeParseLiteral(value);
		}
		estreeParseChainExpression(node, endLoc) {
			const chain = this.startNodeAtNode(node);
			chain.expression = node;
			return this.finishNodeAt(chain, "ChainExpression", endLoc);
		}
		directiveToStmt(directive) {
			const expression = directive.value;
			delete directive.value;
			this.castNodeTo(expression, "Literal");
			expression.raw = expression.extra.raw;
			expression.value = expression.extra.expressionValue;
			const stmt = this.castNodeTo(directive, "ExpressionStatement");
			stmt.expression = expression;
			stmt.directive = expression.extra.rawValue;
			delete expression.extra;
			return stmt;
		}
		fillOptionalPropertiesForTSESLint(node) {}
		cloneEstreeStringLiteral(node) {
			const { start, end, loc, range: range$1, raw: raw$1, value } = node;
			const cloned = Object.create(node.constructor.prototype);
			cloned.type = "Literal";
			cloned.start = start;
			cloned.end = end;
			cloned.loc = loc;
			cloned.range = range$1;
			cloned.raw = raw$1;
			cloned.value = value;
			return cloned;
		}
		initFunction(node, isAsync) {
			super.initFunction(node, isAsync);
			node.expression = false;
		}
		checkDeclaration(node) {
			if (node != null && this.isObjectProperty(node)) this.checkDeclaration(node.value);
			else super.checkDeclaration(node);
		}
		getObjectOrClassMethodParams(method) {
			return method.value.params;
		}
		isValidDirective(stmt) {
			var _stmt$expression$extr;
			return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
		}
		parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
			super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
			const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
			node.body = directiveStatements.concat(node.body);
			delete node.directives;
		}
		parsePrivateName() {
			const node = super.parsePrivateName();
			if (!this.getPluginOption("estree", "classFeatures")) return node;
			return this.convertPrivateNameToPrivateIdentifier(node);
		}
		convertPrivateNameToPrivateIdentifier(node) {
			const name = super.getPrivateNameSV(node);
			delete node.id;
			node.name = name;
			return this.castNodeTo(node, "PrivateIdentifier");
		}
		isPrivateName(node) {
			if (!this.getPluginOption("estree", "classFeatures")) return super.isPrivateName(node);
			return node.type === "PrivateIdentifier";
		}
		getPrivateNameSV(node) {
			if (!this.getPluginOption("estree", "classFeatures")) return super.getPrivateNameSV(node);
			return node.name;
		}
		parseLiteral(value, type) {
			const node = super.parseLiteral(value, type);
			node.raw = node.extra.raw;
			delete node.extra;
			return node;
		}
		parseFunctionBody(node, allowExpression, isMethod = false) {
			super.parseFunctionBody(node, allowExpression, isMethod);
			node.expression = node.body.type !== "BlockStatement";
		}
		parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
			let funcNode = this.startNode();
			funcNode.kind = node.kind;
			funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
			delete funcNode.kind;
			const { typeParameters } = node;
			if (typeParameters) {
				delete node.typeParameters;
				funcNode.typeParameters = typeParameters;
				this.resetStartLocationFromNode(funcNode, typeParameters);
			}
			const valueNode = this.castNodeTo(funcNode, "FunctionExpression");
			node.value = valueNode;
			if (type === "ClassPrivateMethod") node.computed = false;
			if (type === "ObjectMethod") {
				if (node.kind === "method") node.kind = "init";
				node.shorthand = false;
				return this.finishNode(node, "Property");
			} else return this.finishNode(node, "MethodDefinition");
		}
		nameIsConstructor(key) {
			if (key.type === "Literal") return key.value === "constructor";
			return super.nameIsConstructor(key);
		}
		parseClassProperty(...args) {
			const propertyNode = super.parseClassProperty(...args);
			if (!this.getPluginOption("estree", "classFeatures")) return propertyNode;
			this.castNodeTo(propertyNode, "PropertyDefinition");
			return propertyNode;
		}
		parseClassPrivateProperty(...args) {
			const propertyNode = super.parseClassPrivateProperty(...args);
			if (!this.getPluginOption("estree", "classFeatures")) return propertyNode;
			this.castNodeTo(propertyNode, "PropertyDefinition");
			propertyNode.computed = false;
			return propertyNode;
		}
		parseClassAccessorProperty(node) {
			const accessorPropertyNode = super.parseClassAccessorProperty(node);
			if (!this.getPluginOption("estree", "classFeatures")) return accessorPropertyNode;
			if (accessorPropertyNode.abstract && this.hasPlugin("typescript")) {
				delete accessorPropertyNode.abstract;
				this.castNodeTo(accessorPropertyNode, "TSAbstractAccessorProperty");
			} else this.castNodeTo(accessorPropertyNode, "AccessorProperty");
			return accessorPropertyNode;
		}
		parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
			const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
			if (node) {
				node.kind = "init";
				this.castNodeTo(node, "Property");
			}
			return node;
		}
		finishObjectProperty(node) {
			node.kind = "init";
			return this.finishNode(node, "Property");
		}
		isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {
			return type === "Property" ? "value" : super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding);
		}
		isAssignable(node, isBinding) {
			if (node != null && this.isObjectProperty(node)) return this.isAssignable(node.value, isBinding);
			return super.isAssignable(node, isBinding);
		}
		toAssignable(node, isLHS = false) {
			if (node != null && this.isObjectProperty(node)) {
				const { key, value } = node;
				if (this.isPrivateName(key)) this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
				this.toAssignable(value, isLHS);
			} else super.toAssignable(node, isLHS);
		}
		toAssignableObjectExpressionProp(prop, isLast, isLHS) {
			if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) this.raise(Errors.PatternHasAccessor, prop.key);
			else if (prop.type === "Property" && prop.method) this.raise(Errors.PatternHasMethod, prop.key);
			else super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
		}
		finishCallExpression(unfinished, optional) {
			const node = super.finishCallExpression(unfinished, optional);
			if (node.callee.type === "Import") {
				var _ref;
				this.castNodeTo(node, "ImportExpression");
				node.source = node.arguments[0];
				node.options = (_ref = node.arguments[1]) != null ? _ref : null;
				{
					var _ref2;
					node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
				}
				delete node.arguments;
				delete node.callee;
			} else if (node.type === "OptionalCallExpression") this.castNodeTo(node, "CallExpression");
			else node.optional = false;
			return node;
		}
		toReferencedArguments(node) {
			if (node.type === "ImportExpression") return;
			super.toReferencedArguments(node);
		}
		parseExport(unfinished, decorators) {
			const exportStartLoc = this.state.lastTokStartLoc;
			const node = super.parseExport(unfinished, decorators);
			switch (node.type) {
				case "ExportAllDeclaration":
					node.exported = null;
					break;
				case "ExportNamedDeclaration": if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
					this.castNodeTo(node, "ExportAllDeclaration");
					node.exported = node.specifiers[0].exported;
					delete node.specifiers;
				}
				case "ExportDefaultDeclaration":
					{
						var _declaration$decorato;
						const { declaration } = node;
						if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) this.resetStartLocation(node, exportStartLoc);
					}
					break;
			}
			return node;
		}
		stopParseSubscript(base, state) {
			const node = super.stopParseSubscript(base, state);
			if (state.optionalChainMember) return this.estreeParseChainExpression(node, base.loc.end);
			return node;
		}
		parseMember(base, startLoc, state, computed$1, optional) {
			const node = super.parseMember(base, startLoc, state, computed$1, optional);
			if (node.type === "OptionalMemberExpression") this.castNodeTo(node, "MemberExpression");
			else node.optional = false;
			return node;
		}
		isOptionalMemberExpression(node) {
			if (node.type === "ChainExpression") return node.expression.type === "MemberExpression";
			return super.isOptionalMemberExpression(node);
		}
		hasPropertyAsPrivateName(node) {
			if (node.type === "ChainExpression") node = node.expression;
			return super.hasPropertyAsPrivateName(node);
		}
		isObjectProperty(node) {
			return node.type === "Property" && node.kind === "init" && !node.method;
		}
		isObjectMethod(node) {
			return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
		}
		castNodeTo(node, type) {
			const result = super.castNodeTo(node, type);
			this.fillOptionalPropertiesForTSESLint(result);
			return result;
		}
		cloneIdentifier(node) {
			const cloned = super.cloneIdentifier(node);
			this.fillOptionalPropertiesForTSESLint(cloned);
			return cloned;
		}
		cloneStringLiteral(node) {
			if (node.type === "Literal") return this.cloneEstreeStringLiteral(node);
			return super.cloneStringLiteral(node);
		}
		finishNodeAt(node, type, endLoc) {
			return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
		}
		finishNode(node, type) {
			const result = super.finishNode(node, type);
			this.fillOptionalPropertiesForTSESLint(result);
			return result;
		}
		resetStartLocation(node, startLoc) {
			super.resetStartLocation(node, startLoc);
			toESTreeLocation(node);
		}
		resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
			super.resetEndLocation(node, endLoc);
			toESTreeLocation(node);
		}
	};
	var TokContext = class {
		constructor(token, preserveSpace) {
			this.token = void 0;
			this.preserveSpace = void 0;
			this.token = token;
			this.preserveSpace = !!preserveSpace;
		}
	};
	const types = {
		brace: new TokContext("{"),
		j_oTag: new TokContext("<tag"),
		j_cTag: new TokContext("</tag"),
		j_expr: new TokContext("<tag>...</tag>", true)
	};
	types.template = new TokContext("`", true);
	const beforeExpr = true;
	const startsExpr = true;
	const isLoop = true;
	const isAssign = true;
	const prefix = true;
	const postfix = true;
	var ExportedTokenType = class {
		constructor(label, conf = {}) {
			this.label = void 0;
			this.keyword = void 0;
			this.beforeExpr = void 0;
			this.startsExpr = void 0;
			this.rightAssociative = void 0;
			this.isLoop = void 0;
			this.isAssign = void 0;
			this.prefix = void 0;
			this.postfix = void 0;
			this.binop = void 0;
			this.label = label;
			this.keyword = conf.keyword;
			this.beforeExpr = !!conf.beforeExpr;
			this.startsExpr = !!conf.startsExpr;
			this.rightAssociative = !!conf.rightAssociative;
			this.isLoop = !!conf.isLoop;
			this.isAssign = !!conf.isAssign;
			this.prefix = !!conf.prefix;
			this.postfix = !!conf.postfix;
			this.binop = conf.binop != null ? conf.binop : null;
			this.updateContext = null;
		}
	};
	const keywords$1 = /* @__PURE__ */ new Map();
	function createKeyword(name, options = {}) {
		options.keyword = name;
		const token = createToken(name, options);
		keywords$1.set(name, token);
		return token;
	}
	function createBinop(name, binop) {
		return createToken(name, {
			beforeExpr,
			binop
		});
	}
	let tokenTypeCounter = -1;
	const tokenTypes = [];
	const tokenLabels = [];
	const tokenBinops = [];
	const tokenBeforeExprs = [];
	const tokenStartsExprs = [];
	const tokenPrefixes = [];
	function createToken(name, options = {}) {
		var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
		++tokenTypeCounter;
		tokenLabels.push(name);
		tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
		tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
		tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
		tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
		tokenTypes.push(new ExportedTokenType(name, options));
		return tokenTypeCounter;
	}
	function createKeywordLike(name, options = {}) {
		var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
		++tokenTypeCounter;
		keywords$1.set(name, tokenTypeCounter);
		tokenLabels.push(name);
		tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
		tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
		tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
		tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
		tokenTypes.push(new ExportedTokenType("name", options));
		return tokenTypeCounter;
	}
	const tt = {
		bracketL: createToken("[", {
			beforeExpr,
			startsExpr
		}),
		bracketHashL: createToken("#[", {
			beforeExpr,
			startsExpr
		}),
		bracketBarL: createToken("[|", {
			beforeExpr,
			startsExpr
		}),
		bracketR: createToken("]"),
		bracketBarR: createToken("|]"),
		braceL: createToken("{", {
			beforeExpr,
			startsExpr
		}),
		braceBarL: createToken("{|", {
			beforeExpr,
			startsExpr
		}),
		braceHashL: createToken("#{", {
			beforeExpr,
			startsExpr
		}),
		braceR: createToken("}"),
		braceBarR: createToken("|}"),
		parenL: createToken("(", {
			beforeExpr,
			startsExpr
		}),
		parenR: createToken(")"),
		comma: createToken(",", { beforeExpr }),
		semi: createToken(";", { beforeExpr }),
		colon: createToken(":", { beforeExpr }),
		doubleColon: createToken("::", { beforeExpr }),
		dot: createToken("."),
		question: createToken("?", { beforeExpr }),
		questionDot: createToken("?."),
		arrow: createToken("=>", { beforeExpr }),
		template: createToken("template"),
		ellipsis: createToken("...", { beforeExpr }),
		backQuote: createToken("`", { startsExpr }),
		dollarBraceL: createToken("${", {
			beforeExpr,
			startsExpr
		}),
		templateTail: createToken("...`", { startsExpr }),
		templateNonTail: createToken("...${", {
			beforeExpr,
			startsExpr
		}),
		at: createToken("@"),
		hash: createToken("#", { startsExpr }),
		interpreterDirective: createToken("#!..."),
		eq: createToken("=", {
			beforeExpr,
			isAssign
		}),
		assign: createToken("_=", {
			beforeExpr,
			isAssign
		}),
		slashAssign: createToken("_=", {
			beforeExpr,
			isAssign
		}),
		xorAssign: createToken("_=", {
			beforeExpr,
			isAssign
		}),
		moduloAssign: createToken("_=", {
			beforeExpr,
			isAssign
		}),
		incDec: createToken("++/--", {
			prefix,
			postfix,
			startsExpr
		}),
		bang: createToken("!", {
			beforeExpr,
			prefix,
			startsExpr
		}),
		tilde: createToken("~", {
			beforeExpr,
			prefix,
			startsExpr
		}),
		doubleCaret: createToken("^^", { startsExpr }),
		doubleAt: createToken("@@", { startsExpr }),
		pipeline: createBinop("|>", 0),
		nullishCoalescing: createBinop("??", 1),
		logicalOR: createBinop("||", 1),
		logicalAND: createBinop("&&", 2),
		bitwiseOR: createBinop("|", 3),
		bitwiseXOR: createBinop("^", 4),
		bitwiseAND: createBinop("&", 5),
		equality: createBinop("==/!=/===/!==", 6),
		lt: createBinop("</>/<=/>=", 7),
		gt: createBinop("</>/<=/>=", 7),
		relational: createBinop("</>/<=/>=", 7),
		bitShift: createBinop("<</>>/>>>", 8),
		bitShiftL: createBinop("<</>>/>>>", 8),
		bitShiftR: createBinop("<</>>/>>>", 8),
		plusMin: createToken("+/-", {
			beforeExpr,
			binop: 9,
			prefix,
			startsExpr
		}),
		modulo: createToken("%", {
			binop: 10,
			startsExpr
		}),
		star: createToken("*", { binop: 10 }),
		slash: createBinop("/", 10),
		exponent: createToken("**", {
			beforeExpr,
			binop: 11,
			rightAssociative: true
		}),
		_in: createKeyword("in", {
			beforeExpr,
			binop: 7
		}),
		_instanceof: createKeyword("instanceof", {
			beforeExpr,
			binop: 7
		}),
		_break: createKeyword("break"),
		_case: createKeyword("case", { beforeExpr }),
		_catch: createKeyword("catch"),
		_continue: createKeyword("continue"),
		_debugger: createKeyword("debugger"),
		_default: createKeyword("default", { beforeExpr }),
		_else: createKeyword("else", { beforeExpr }),
		_finally: createKeyword("finally"),
		_function: createKeyword("function", { startsExpr }),
		_if: createKeyword("if"),
		_return: createKeyword("return", { beforeExpr }),
		_switch: createKeyword("switch"),
		_throw: createKeyword("throw", {
			beforeExpr,
			prefix,
			startsExpr
		}),
		_try: createKeyword("try"),
		_var: createKeyword("var"),
		_const: createKeyword("const"),
		_with: createKeyword("with"),
		_new: createKeyword("new", {
			beforeExpr,
			startsExpr
		}),
		_this: createKeyword("this", { startsExpr }),
		_super: createKeyword("super", { startsExpr }),
		_class: createKeyword("class", { startsExpr }),
		_extends: createKeyword("extends", { beforeExpr }),
		_export: createKeyword("export"),
		_import: createKeyword("import", { startsExpr }),
		_null: createKeyword("null", { startsExpr }),
		_true: createKeyword("true", { startsExpr }),
		_false: createKeyword("false", { startsExpr }),
		_typeof: createKeyword("typeof", {
			beforeExpr,
			prefix,
			startsExpr
		}),
		_void: createKeyword("void", {
			beforeExpr,
			prefix,
			startsExpr
		}),
		_delete: createKeyword("delete", {
			beforeExpr,
			prefix,
			startsExpr
		}),
		_do: createKeyword("do", {
			isLoop,
			beforeExpr
		}),
		_for: createKeyword("for", { isLoop }),
		_while: createKeyword("while", { isLoop }),
		_as: createKeywordLike("as", { startsExpr }),
		_assert: createKeywordLike("assert", { startsExpr }),
		_async: createKeywordLike("async", { startsExpr }),
		_await: createKeywordLike("await", { startsExpr }),
		_defer: createKeywordLike("defer", { startsExpr }),
		_from: createKeywordLike("from", { startsExpr }),
		_get: createKeywordLike("get", { startsExpr }),
		_let: createKeywordLike("let", { startsExpr }),
		_meta: createKeywordLike("meta", { startsExpr }),
		_of: createKeywordLike("of", { startsExpr }),
		_sent: createKeywordLike("sent", { startsExpr }),
		_set: createKeywordLike("set", { startsExpr }),
		_source: createKeywordLike("source", { startsExpr }),
		_static: createKeywordLike("static", { startsExpr }),
		_using: createKeywordLike("using", { startsExpr }),
		_yield: createKeywordLike("yield", { startsExpr }),
		_asserts: createKeywordLike("asserts", { startsExpr }),
		_checks: createKeywordLike("checks", { startsExpr }),
		_exports: createKeywordLike("exports", { startsExpr }),
		_global: createKeywordLike("global", { startsExpr }),
		_implements: createKeywordLike("implements", { startsExpr }),
		_intrinsic: createKeywordLike("intrinsic", { startsExpr }),
		_infer: createKeywordLike("infer", { startsExpr }),
		_is: createKeywordLike("is", { startsExpr }),
		_mixins: createKeywordLike("mixins", { startsExpr }),
		_proto: createKeywordLike("proto", { startsExpr }),
		_require: createKeywordLike("require", { startsExpr }),
		_satisfies: createKeywordLike("satisfies", { startsExpr }),
		_keyof: createKeywordLike("keyof", { startsExpr }),
		_readonly: createKeywordLike("readonly", { startsExpr }),
		_unique: createKeywordLike("unique", { startsExpr }),
		_abstract: createKeywordLike("abstract", { startsExpr }),
		_declare: createKeywordLike("declare", { startsExpr }),
		_enum: createKeywordLike("enum", { startsExpr }),
		_module: createKeywordLike("module", { startsExpr }),
		_namespace: createKeywordLike("namespace", { startsExpr }),
		_interface: createKeywordLike("interface", { startsExpr }),
		_type: createKeywordLike("type", { startsExpr }),
		_opaque: createKeywordLike("opaque", { startsExpr }),
		name: createToken("name", { startsExpr }),
		placeholder: createToken("%%", { startsExpr }),
		string: createToken("string", { startsExpr }),
		num: createToken("num", { startsExpr }),
		bigint: createToken("bigint", { startsExpr }),
		decimal: createToken("decimal", { startsExpr }),
		regexp: createToken("regexp", { startsExpr }),
		privateName: createToken("#name", { startsExpr }),
		eof: createToken("eof"),
		jsxName: createToken("jsxName"),
		jsxText: createToken("jsxText", { beforeExpr }),
		jsxTagStart: createToken("jsxTagStart", { startsExpr }),
		jsxTagEnd: createToken("jsxTagEnd")
	};
	function tokenIsIdentifier(token) {
		return token >= 93 && token <= 133;
	}
	function tokenKeywordOrIdentifierIsKeyword(token) {
		return token <= 92;
	}
	function tokenIsKeywordOrIdentifier(token) {
		return token >= 58 && token <= 133;
	}
	function tokenIsLiteralPropertyName(token) {
		return token >= 58 && token <= 137;
	}
	function tokenComesBeforeExpression(token) {
		return tokenBeforeExprs[token];
	}
	function tokenCanStartExpression(token) {
		return tokenStartsExprs[token];
	}
	function tokenIsAssignment(token) {
		return token >= 29 && token <= 33;
	}
	function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
		return token >= 129 && token <= 131;
	}
	function tokenIsLoop(token) {
		return token >= 90 && token <= 92;
	}
	function tokenIsKeyword(token) {
		return token >= 58 && token <= 92;
	}
	function tokenIsOperator(token) {
		return token >= 39 && token <= 59;
	}
	function tokenIsPostfix(token) {
		return token === 34;
	}
	function tokenIsPrefix(token) {
		return tokenPrefixes[token];
	}
	function tokenIsTSTypeOperator(token) {
		return token >= 121 && token <= 123;
	}
	function tokenIsTSDeclarationStart(token) {
		return token >= 124 && token <= 130;
	}
	function tokenLabelName(token) {
		return tokenLabels[token];
	}
	function tokenOperatorPrecedence(token) {
		return tokenBinops[token];
	}
	function tokenIsRightAssociative(token) {
		return token === 57;
	}
	function tokenIsTemplate(token) {
		return token >= 24 && token <= 25;
	}
	function getExportedToken(token) {
		return tokenTypes[token];
	}
	{
		tokenTypes[8].updateContext = (context) => {
			context.pop();
		};
		tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
			context.push(types.brace);
		};
		tokenTypes[22].updateContext = (context) => {
			if (context[context.length - 1] === types.template) context.pop();
			else context.push(types.template);
		};
		tokenTypes[143].updateContext = (context) => {
			context.push(types.j_expr, types.j_oTag);
		};
	}
	let nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
	let nonASCIIidentifierChars = "------------------------------------------------------------------------------------------------------------------------------------------------------";
	const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
	const astralIdentifierStartCodes = [
		0,
		11,
		2,
		25,
		2,
		18,
		2,
		1,
		2,
		14,
		3,
		13,
		35,
		122,
		70,
		52,
		268,
		28,
		4,
		48,
		48,
		31,
		14,
		29,
		6,
		37,
		11,
		29,
		3,
		35,
		5,
		7,
		2,
		4,
		43,
		157,
		19,
		35,
		5,
		35,
		5,
		39,
		9,
		51,
		13,
		10,
		2,
		14,
		2,
		6,
		2,
		1,
		2,
		10,
		2,
		14,
		2,
		6,
		2,
		1,
		4,
		51,
		13,
		310,
		10,
		21,
		11,
		7,
		25,
		5,
		2,
		41,
		2,
		8,
		70,
		5,
		3,
		0,
		2,
		43,
		2,
		1,
		4,
		0,
		3,
		22,
		11,
		22,
		10,
		30,
		66,
		18,
		2,
		1,
		11,
		21,
		11,
		25,
		7,
		25,
		39,
		55,
		7,
		1,
		65,
		0,
		16,
		3,
		2,
		2,
		2,
		28,
		43,
		28,
		4,
		28,
		36,
		7,
		2,
		27,
		28,
		53,
		11,
		21,
		11,
		18,
		14,
		17,
		111,
		72,
		56,
		50,
		14,
		50,
		14,
		35,
		39,
		27,
		10,
		22,
		251,
		41,
		7,
		1,
		17,
		5,
		57,
		28,
		11,
		0,
		9,
		21,
		43,
		17,
		47,
		20,
		28,
		22,
		13,
		52,
		58,
		1,
		3,
		0,
		14,
		44,
		33,
		24,
		27,
		35,
		30,
		0,
		3,
		0,
		9,
		34,
		4,
		0,
		13,
		47,
		15,
		3,
		22,
		0,
		2,
		0,
		36,
		17,
		2,
		24,
		20,
		1,
		64,
		6,
		2,
		0,
		2,
		3,
		2,
		14,
		2,
		9,
		8,
		46,
		39,
		7,
		3,
		1,
		3,
		21,
		2,
		6,
		2,
		1,
		2,
		4,
		4,
		0,
		19,
		0,
		13,
		4,
		31,
		9,
		2,
		0,
		3,
		0,
		2,
		37,
		2,
		0,
		26,
		0,
		2,
		0,
		45,
		52,
		19,
		3,
		21,
		2,
		31,
		47,
		21,
		1,
		2,
		0,
		185,
		46,
		42,
		3,
		37,
		47,
		21,
		0,
		60,
		42,
		14,
		0,
		72,
		26,
		38,
		6,
		186,
		43,
		117,
		63,
		32,
		7,
		3,
		0,
		3,
		7,
		2,
		1,
		2,
		23,
		16,
		0,
		2,
		0,
		95,
		7,
		3,
		38,
		17,
		0,
		2,
		0,
		29,
		0,
		11,
		39,
		8,
		0,
		22,
		0,
		12,
		45,
		20,
		0,
		19,
		72,
		200,
		32,
		32,
		8,
		2,
		36,
		18,
		0,
		50,
		29,
		113,
		6,
		2,
		1,
		2,
		37,
		22,
		0,
		26,
		5,
		2,
		1,
		2,
		31,
		15,
		0,
		24,
		43,
		261,
		18,
		16,
		0,
		2,
		12,
		2,
		33,
		125,
		0,
		80,
		921,
		103,
		110,
		18,
		195,
		2637,
		96,
		16,
		1071,
		18,
		5,
		26,
		3994,
		6,
		582,
		6842,
		29,
		1763,
		568,
		8,
		30,
		18,
		78,
		18,
		29,
		19,
		47,
		17,
		3,
		32,
		20,
		6,
		18,
		433,
		44,
		212,
		63,
		33,
		24,
		3,
		24,
		45,
		74,
		6,
		0,
		67,
		12,
		65,
		1,
		2,
		0,
		15,
		4,
		10,
		7381,
		42,
		31,
		98,
		114,
		8702,
		3,
		2,
		6,
		2,
		1,
		2,
		290,
		16,
		0,
		30,
		2,
		3,
		0,
		15,
		3,
		9,
		395,
		2309,
		106,
		6,
		12,
		4,
		8,
		8,
		9,
		5991,
		84,
		2,
		70,
		2,
		1,
		3,
		0,
		3,
		1,
		3,
		3,
		2,
		11,
		2,
		0,
		2,
		6,
		2,
		64,
		2,
		3,
		3,
		7,
		2,
		6,
		2,
		27,
		2,
		3,
		2,
		4,
		2,
		0,
		4,
		6,
		2,
		339,
		3,
		24,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		7,
		1845,
		30,
		7,
		5,
		262,
		61,
		147,
		44,
		11,
		6,
		17,
		0,
		322,
		29,
		19,
		43,
		485,
		27,
		229,
		29,
		3,
		0,
		208,
		30,
		2,
		2,
		2,
		1,
		2,
		6,
		3,
		4,
		10,
		1,
		225,
		6,
		2,
		3,
		2,
		1,
		2,
		14,
		2,
		196,
		60,
		67,
		8,
		0,
		1205,
		3,
		2,
		26,
		2,
		1,
		2,
		0,
		3,
		0,
		2,
		9,
		2,
		3,
		2,
		0,
		2,
		0,
		7,
		0,
		5,
		0,
		2,
		0,
		2,
		0,
		2,
		2,
		2,
		1,
		2,
		0,
		3,
		0,
		2,
		0,
		2,
		0,
		2,
		0,
		2,
		0,
		2,
		1,
		2,
		0,
		3,
		3,
		2,
		6,
		2,
		3,
		2,
		3,
		2,
		0,
		2,
		9,
		2,
		16,
		6,
		2,
		2,
		4,
		2,
		16,
		4421,
		42719,
		33,
		4381,
		3,
		5773,
		3,
		7472,
		16,
		621,
		2467,
		541,
		1507,
		4938,
		6,
		8489
	];
	const astralIdentifierCodes = [
		509,
		0,
		227,
		0,
		150,
		4,
		294,
		9,
		1368,
		2,
		2,
		1,
		6,
		3,
		41,
		2,
		5,
		0,
		166,
		1,
		574,
		3,
		9,
		9,
		7,
		9,
		32,
		4,
		318,
		1,
		78,
		5,
		71,
		10,
		50,
		3,
		123,
		2,
		54,
		14,
		32,
		10,
		3,
		1,
		11,
		3,
		46,
		10,
		8,
		0,
		46,
		9,
		7,
		2,
		37,
		13,
		2,
		9,
		6,
		1,
		45,
		0,
		13,
		2,
		49,
		13,
		9,
		3,
		2,
		11,
		83,
		11,
		7,
		0,
		3,
		0,
		158,
		11,
		6,
		9,
		7,
		3,
		56,
		1,
		2,
		6,
		3,
		1,
		3,
		2,
		10,
		0,
		11,
		1,
		3,
		6,
		4,
		4,
		68,
		8,
		2,
		0,
		3,
		0,
		2,
		3,
		2,
		4,
		2,
		0,
		15,
		1,
		83,
		17,
		10,
		9,
		5,
		0,
		82,
		19,
		13,
		9,
		214,
		6,
		3,
		8,
		28,
		1,
		83,
		16,
		16,
		9,
		82,
		12,
		9,
		9,
		7,
		19,
		58,
		14,
		5,
		9,
		243,
		14,
		166,
		9,
		71,
		5,
		2,
		1,
		3,
		3,
		2,
		0,
		2,
		1,
		13,
		9,
		120,
		6,
		3,
		6,
		4,
		0,
		29,
		9,
		41,
		6,
		2,
		3,
		9,
		0,
		10,
		10,
		47,
		15,
		199,
		7,
		137,
		9,
		54,
		7,
		2,
		7,
		17,
		9,
		57,
		21,
		2,
		13,
		123,
		5,
		4,
		0,
		2,
		1,
		2,
		6,
		2,
		0,
		9,
		9,
		49,
		4,
		2,
		1,
		2,
		4,
		9,
		9,
		55,
		9,
		266,
		3,
		10,
		1,
		2,
		0,
		49,
		6,
		4,
		4,
		14,
		10,
		5350,
		0,
		7,
		14,
		11465,
		27,
		2343,
		9,
		87,
		9,
		39,
		4,
		60,
		6,
		26,
		9,
		535,
		9,
		470,
		0,
		2,
		54,
		8,
		3,
		82,
		0,
		12,
		1,
		19628,
		1,
		4178,
		9,
		519,
		45,
		3,
		22,
		543,
		4,
		4,
		5,
		9,
		7,
		3,
		6,
		31,
		3,
		149,
		2,
		1418,
		49,
		513,
		54,
		5,
		49,
		9,
		0,
		15,
		0,
		23,
		4,
		2,
		14,
		1361,
		6,
		2,
		16,
		3,
		6,
		2,
		1,
		2,
		4,
		101,
		0,
		161,
		6,
		10,
		9,
		357,
		0,
		62,
		13,
		499,
		13,
		245,
		1,
		2,
		9,
		233,
		0,
		3,
		0,
		8,
		1,
		6,
		0,
		475,
		6,
		110,
		6,
		6,
		9,
		4759,
		9,
		787719,
		239
	];
	function isInAstralSet(code$1, set) {
		let pos = 65536;
		for (let i = 0, length = set.length; i < length; i += 2) {
			pos += set[i];
			if (pos > code$1) return false;
			pos += set[i + 1];
			if (pos >= code$1) return true;
		}
		return false;
	}
	function isIdentifierStart(code$1) {
		if (code$1 < 65) return code$1 === 36;
		if (code$1 <= 90) return true;
		if (code$1 < 97) return code$1 === 95;
		if (code$1 <= 122) return true;
		if (code$1 <= 65535) return code$1 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code$1));
		return isInAstralSet(code$1, astralIdentifierStartCodes);
	}
	function isIdentifierChar(code$1) {
		if (code$1 < 48) return code$1 === 36;
		if (code$1 < 58) return true;
		if (code$1 < 65) return false;
		if (code$1 <= 90) return true;
		if (code$1 < 97) return code$1 === 95;
		if (code$1 <= 122) return true;
		if (code$1 <= 65535) return code$1 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code$1));
		return isInAstralSet(code$1, astralIdentifierStartCodes) || isInAstralSet(code$1, astralIdentifierCodes);
	}
	const reservedWords = {
		keyword: [
			"break",
			"case",
			"catch",
			"continue",
			"debugger",
			"default",
			"do",
			"else",
			"finally",
			"for",
			"function",
			"if",
			"return",
			"switch",
			"throw",
			"try",
			"var",
			"const",
			"while",
			"with",
			"new",
			"this",
			"super",
			"class",
			"extends",
			"export",
			"import",
			"null",
			"true",
			"false",
			"in",
			"instanceof",
			"typeof",
			"void",
			"delete"
		],
		strict: [
			"implements",
			"interface",
			"let",
			"package",
			"private",
			"protected",
			"public",
			"static",
			"yield"
		],
		strictBind: ["eval", "arguments"]
	};
	const keywords = new Set(reservedWords.keyword);
	const reservedWordsStrictSet = new Set(reservedWords.strict);
	const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
	function isReservedWord(word, inModule) {
		return inModule && word === "await" || word === "enum";
	}
	function isStrictReservedWord(word, inModule) {
		return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
	}
	function isStrictBindOnlyReservedWord(word) {
		return reservedWordsStrictBindSet.has(word);
	}
	function isStrictBindReservedWord(word, inModule) {
		return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
	}
	function isKeyword(word) {
		return keywords.has(word);
	}
	function isIteratorStart(current, next, next2) {
		return current === 64 && next === 64 && isIdentifierStart(next2);
	}
	const reservedWordLikeSet = new Set([
		"break",
		"case",
		"catch",
		"continue",
		"debugger",
		"default",
		"do",
		"else",
		"finally",
		"for",
		"function",
		"if",
		"return",
		"switch",
		"throw",
		"try",
		"var",
		"const",
		"while",
		"with",
		"new",
		"this",
		"super",
		"class",
		"extends",
		"export",
		"import",
		"null",
		"true",
		"false",
		"in",
		"instanceof",
		"typeof",
		"void",
		"delete",
		"implements",
		"interface",
		"let",
		"package",
		"private",
		"protected",
		"public",
		"static",
		"yield",
		"eval",
		"arguments",
		"enum",
		"await"
	]);
	function canBeReservedWord(word) {
		return reservedWordLikeSet.has(word);
	}
	var Scope = class {
		constructor(flags) {
			this.flags = 0;
			this.names = /* @__PURE__ */ new Map();
			this.firstLexicalName = "";
			this.flags = flags;
		}
	};
	var ScopeHandler = class {
		constructor(parser$1, inModule) {
			this.parser = void 0;
			this.scopeStack = [];
			this.inModule = void 0;
			this.undefinedExports = /* @__PURE__ */ new Map();
			this.parser = parser$1;
			this.inModule = inModule;
		}
		get inTopLevel() {
			return (this.currentScope().flags & 1) > 0;
		}
		get inFunction() {
			return (this.currentVarScopeFlags() & 2) > 0;
		}
		get allowSuper() {
			return (this.currentThisScopeFlags() & 16) > 0;
		}
		get allowDirectSuper() {
			return (this.currentThisScopeFlags() & 32) > 0;
		}
		get allowNewTarget() {
			return (this.currentThisScopeFlags() & 512) > 0;
		}
		get inClass() {
			return (this.currentThisScopeFlags() & 64) > 0;
		}
		get inClassAndNotInNonArrowFunction() {
			const flags = this.currentThisScopeFlags();
			return (flags & 64) > 0 && (flags & 2) === 0;
		}
		get inStaticBlock() {
			for (let i = this.scopeStack.length - 1;; i--) {
				const { flags } = this.scopeStack[i];
				if (flags & 128) return true;
				if (flags & 1731) return false;
			}
		}
		get inNonArrowFunction() {
			return (this.currentThisScopeFlags() & 2) > 0;
		}
		get inBareCaseStatement() {
			return (this.currentScope().flags & 256) > 0;
		}
		get treatFunctionsAsVar() {
			return this.treatFunctionsAsVarInScope(this.currentScope());
		}
		createScope(flags) {
			return new Scope(flags);
		}
		enter(flags) {
			this.scopeStack.push(this.createScope(flags));
		}
		exit() {
			const scope = this.scopeStack.pop();
			return scope.flags;
		}
		treatFunctionsAsVarInScope(scope) {
			return !!(scope.flags & 130 || !this.parser.inModule && scope.flags & 1);
		}
		declareName(name, bindingType, loc) {
			let scope = this.currentScope();
			if (bindingType & 8 || bindingType & 16) {
				this.checkRedeclarationInScope(scope, name, bindingType, loc);
				let type = scope.names.get(name) || 0;
				if (bindingType & 16) type = type | 4;
				else {
					if (!scope.firstLexicalName) scope.firstLexicalName = name;
					type = type | 2;
				}
				scope.names.set(name, type);
				if (bindingType & 8) this.maybeExportDefined(scope, name);
			} else if (bindingType & 4) for (let i = this.scopeStack.length - 1; i >= 0; --i) {
				scope = this.scopeStack[i];
				this.checkRedeclarationInScope(scope, name, bindingType, loc);
				scope.names.set(name, (scope.names.get(name) || 0) | 1);
				this.maybeExportDefined(scope, name);
				if (scope.flags & 1667) break;
			}
			if (this.parser.inModule && scope.flags & 1) this.undefinedExports.delete(name);
		}
		maybeExportDefined(scope, name) {
			if (this.parser.inModule && scope.flags & 1) this.undefinedExports.delete(name);
		}
		checkRedeclarationInScope(scope, name, bindingType, loc) {
			if (this.isRedeclaredInScope(scope, name, bindingType)) this.parser.raise(Errors.VarRedeclaration, loc, { identifierName: name });
		}
		isRedeclaredInScope(scope, name, bindingType) {
			if (!(bindingType & 1)) return false;
			if (bindingType & 8) return scope.names.has(name);
			const type = scope.names.get(name) || 0;
			if (bindingType & 16) return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
			return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
		}
		checkLocalExport(id) {
			const { name } = id;
			const topLevelScope = this.scopeStack[0];
			if (!topLevelScope.names.has(name)) this.undefinedExports.set(name, id.loc.start);
		}
		currentScope() {
			return this.scopeStack[this.scopeStack.length - 1];
		}
		currentVarScopeFlags() {
			for (let i = this.scopeStack.length - 1;; i--) {
				const { flags } = this.scopeStack[i];
				if (flags & 1667) return flags;
			}
		}
		currentThisScopeFlags() {
			for (let i = this.scopeStack.length - 1;; i--) {
				const { flags } = this.scopeStack[i];
				if (flags & 1731 && !(flags & 4)) return flags;
			}
		}
	};
	var FlowScope = class extends Scope {
		constructor(...args) {
			super(...args);
			this.declareFunctions = /* @__PURE__ */ new Set();
		}
	};
	var FlowScopeHandler = class extends ScopeHandler {
		createScope(flags) {
			return new FlowScope(flags);
		}
		declareName(name, bindingType, loc) {
			const scope = this.currentScope();
			if (bindingType & 2048) {
				this.checkRedeclarationInScope(scope, name, bindingType, loc);
				this.maybeExportDefined(scope, name);
				scope.declareFunctions.add(name);
				return;
			}
			super.declareName(name, bindingType, loc);
		}
		isRedeclaredInScope(scope, name, bindingType) {
			if (super.isRedeclaredInScope(scope, name, bindingType)) return true;
			if (bindingType & 2048 && !scope.declareFunctions.has(name)) {
				const type = scope.names.get(name);
				return (type & 4) > 0 || (type & 2) > 0;
			}
			return false;
		}
		checkLocalExport(id) {
			if (!this.scopeStack[0].declareFunctions.has(id.name)) super.checkLocalExport(id);
		}
	};
	const reservedTypes = new Set([
		"_",
		"any",
		"bool",
		"boolean",
		"empty",
		"extends",
		"false",
		"interface",
		"mixed",
		"null",
		"number",
		"static",
		"string",
		"true",
		"typeof",
		"void"
	]);
	const FlowErrors = ParseErrorEnum`flow`({
		AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
		AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
		AssignReservedType: ({ reservedType }) => `Cannot overwrite reserved type ${reservedType}.`,
		DeclareClassElement: "The `declare` modifier can only appear on class fields.",
		DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
		DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
		EnumBooleanMemberNotInitialized: ({ memberName, enumName }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
		EnumDuplicateMemberName: ({ memberName, enumName }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
		EnumInconsistentMemberValues: ({ enumName }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
		EnumInvalidExplicitType: ({ invalidEnumType, enumName }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
		EnumInvalidExplicitTypeUnknownSupplied: ({ enumName }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
		EnumInvalidMemberInitializerPrimaryType: ({ enumName, memberName, explicitType }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
		EnumInvalidMemberInitializerSymbolType: ({ enumName, memberName }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
		EnumInvalidMemberInitializerUnknownType: ({ enumName, memberName }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
		EnumInvalidMemberName: ({ enumName, memberName, suggestion }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
		EnumNumberMemberNotInitialized: ({ enumName, memberName }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
		EnumStringMemberInconsistentlyInitialized: ({ enumName }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
		GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
		ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
		ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
		InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
		InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
		InexactVariance: "Explicit inexact syntax cannot have variance.",
		InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
		MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
		NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
		NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
		PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }),
		SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
		SpreadVariance: "Spread properties cannot have variance.",
		ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
		ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
		ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
		ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
		ThisParamNoDefault: "The `this` parameter may not have a default value.",
		TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
		TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
		UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
		UnexpectedReservedType: ({ reservedType }) => `Unexpected reserved type ${reservedType}.`,
		UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
		UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
		UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
		UnexpectedSubtractionOperand: "Unexpected token, expected \"number\" or \"bigint\".",
		UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
		UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
		UnsupportedDeclareExportKind: ({ unsupportedExportKind, suggestion }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
		UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
		UnterminatedFlowComment: "Unterminated flow-comment."
	});
	function isEsModuleType(bodyElement) {
		return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
	}
	function hasTypeImportKind(node) {
		return node.importKind === "type" || node.importKind === "typeof";
	}
	const exportSuggestions = {
		const: "declare export var",
		let: "declare export var",
		type: "export type",
		interface: "export interface"
	};
	function partition(list, test) {
		const list1 = [];
		const list2 = [];
		for (let i = 0; i < list.length; i++) (test(list[i], i, list) ? list1 : list2).push(list[i]);
		return [list1, list2];
	}
	const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
	var flow = (superClass) => class FlowParserMixin extends superClass {
		constructor(...args) {
			super(...args);
			this.flowPragma = void 0;
		}
		getScopeHandler() {
			return FlowScopeHandler;
		}
		shouldParseTypes() {
			return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
		}
		finishToken(type, val) {
			if (type !== 134 && type !== 13 && type !== 28) {
				if (this.flowPragma === void 0) this.flowPragma = null;
			}
			super.finishToken(type, val);
		}
		addComment(comment) {
			if (this.flowPragma === void 0) {
				const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
				if (!matches);
				else if (matches[1] === "flow") this.flowPragma = "flow";
				else if (matches[1] === "noflow") this.flowPragma = "noflow";
				else throw new Error("Unexpected flow pragma");
			}
			super.addComment(comment);
		}
		flowParseTypeInitialiser(tok) {
			const oldInType = this.state.inType;
			this.state.inType = true;
			this.expect(tok || 14);
			const type = this.flowParseType();
			this.state.inType = oldInType;
			return type;
		}
		flowParsePredicate() {
			const node = this.startNode();
			const moduloLoc = this.state.startLoc;
			this.next();
			this.expectContextual(110);
			if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
			if (this.eat(10)) {
				node.value = super.parseExpression();
				this.expect(11);
				return this.finishNode(node, "DeclaredPredicate");
			} else return this.finishNode(node, "InferredPredicate");
		}
		flowParseTypeAndPredicateInitialiser() {
			const oldInType = this.state.inType;
			this.state.inType = true;
			this.expect(14);
			let type = null;
			let predicate = null;
			if (this.match(54)) {
				this.state.inType = oldInType;
				predicate = this.flowParsePredicate();
			} else {
				type = this.flowParseType();
				this.state.inType = oldInType;
				if (this.match(54)) predicate = this.flowParsePredicate();
			}
			return [type, predicate];
		}
		flowParseDeclareClass(node) {
			this.next();
			this.flowParseInterfaceish(node, true);
			return this.finishNode(node, "DeclareClass");
		}
		flowParseDeclareFunction(node) {
			this.next();
			const id = node.id = this.parseIdentifier();
			const typeNode = this.startNode();
			const typeContainer = this.startNode();
			if (this.match(47)) typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
			else typeNode.typeParameters = null;
			this.expect(10);
			const tmp = this.flowParseFunctionTypeParams();
			typeNode.params = tmp.params;
			typeNode.rest = tmp.rest;
			typeNode.this = tmp._this;
			this.expect(11);
			[typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
			typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
			id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
			this.resetEndLocation(id);
			this.semicolon();
			this.scope.declareName(node.id.name, 2048, node.id.loc.start);
			return this.finishNode(node, "DeclareFunction");
		}
		flowParseDeclare(node, insideModule) {
			if (this.match(80)) return this.flowParseDeclareClass(node);
			else if (this.match(68)) return this.flowParseDeclareFunction(node);
			else if (this.match(74)) return this.flowParseDeclareVariable(node);
			else if (this.eatContextual(127)) if (this.match(16)) return this.flowParseDeclareModuleExports(node);
			else {
				if (insideModule) this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
				return this.flowParseDeclareModule(node);
			}
			else if (this.isContextual(130)) return this.flowParseDeclareTypeAlias(node);
			else if (this.isContextual(131)) return this.flowParseDeclareOpaqueType(node);
			else if (this.isContextual(129)) return this.flowParseDeclareInterface(node);
			else if (this.match(82)) return this.flowParseDeclareExportDeclaration(node, insideModule);
			throw this.unexpected();
		}
		flowParseDeclareVariable(node) {
			this.next();
			node.id = this.flowParseTypeAnnotatableIdentifier(true);
			this.scope.declareName(node.id.name, 5, node.id.loc.start);
			this.semicolon();
			return this.finishNode(node, "DeclareVariable");
		}
		flowParseDeclareModule(node) {
			this.scope.enter(0);
			if (this.match(134)) node.id = super.parseExprAtom();
			else node.id = this.parseIdentifier();
			const bodyNode = node.body = this.startNode();
			const body = bodyNode.body = [];
			this.expect(5);
			while (!this.match(8)) {
				const bodyNode$1 = this.startNode();
				if (this.match(83)) {
					this.next();
					if (!this.isContextual(130) && !this.match(87)) this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
					body.push(super.parseImport(bodyNode$1));
				} else {
					this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
					body.push(this.flowParseDeclare(bodyNode$1, true));
				}
			}
			this.scope.exit();
			this.expect(8);
			this.finishNode(bodyNode, "BlockStatement");
			let kind = null;
			let hasModuleExport = false;
			body.forEach((bodyElement) => {
				if (isEsModuleType(bodyElement)) {
					if (kind === "CommonJS") this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
					kind = "ES";
				} else if (bodyElement.type === "DeclareModuleExports") {
					if (hasModuleExport) this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
					if (kind === "ES") this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
					kind = "CommonJS";
					hasModuleExport = true;
				}
			});
			node.kind = kind || "CommonJS";
			return this.finishNode(node, "DeclareModule");
		}
		flowParseDeclareExportDeclaration(node, insideModule) {
			this.expect(82);
			if (this.eat(65)) {
				if (this.match(68) || this.match(80)) node.declaration = this.flowParseDeclare(this.startNode());
				else {
					node.declaration = this.flowParseType();
					this.semicolon();
				}
				node.default = true;
				return this.finishNode(node, "DeclareExportDeclaration");
			} else {
				if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
					const label = this.state.value;
					throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
						unsupportedExportKind: label,
						suggestion: exportSuggestions[label]
					});
				}
				if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
					node.declaration = this.flowParseDeclare(this.startNode());
					node.default = false;
					return this.finishNode(node, "DeclareExportDeclaration");
				} else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
					node = this.parseExport(node, null);
					if (node.type === "ExportNamedDeclaration") {
						node.default = false;
						delete node.exportKind;
						return this.castNodeTo(node, "DeclareExportDeclaration");
					} else return this.castNodeTo(node, "DeclareExportAllDeclaration");
				}
			}
			throw this.unexpected();
		}
		flowParseDeclareModuleExports(node) {
			this.next();
			this.expectContextual(111);
			node.typeAnnotation = this.flowParseTypeAnnotation();
			this.semicolon();
			return this.finishNode(node, "DeclareModuleExports");
		}
		flowParseDeclareTypeAlias(node) {
			this.next();
			const finished = this.flowParseTypeAlias(node);
			this.castNodeTo(finished, "DeclareTypeAlias");
			return finished;
		}
		flowParseDeclareOpaqueType(node) {
			this.next();
			const finished = this.flowParseOpaqueType(node, true);
			this.castNodeTo(finished, "DeclareOpaqueType");
			return finished;
		}
		flowParseDeclareInterface(node) {
			this.next();
			this.flowParseInterfaceish(node, false);
			return this.finishNode(node, "DeclareInterface");
		}
		flowParseInterfaceish(node, isClass) {
			node.id = this.flowParseRestrictedIdentifier(!isClass, true);
			this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
			if (this.match(47)) node.typeParameters = this.flowParseTypeParameterDeclaration();
			else node.typeParameters = null;
			node.extends = [];
			if (this.eat(81)) do
				node.extends.push(this.flowParseInterfaceExtends());
			while (!isClass && this.eat(12));
			if (isClass) {
				node.implements = [];
				node.mixins = [];
				if (this.eatContextual(117)) do
					node.mixins.push(this.flowParseInterfaceExtends());
				while (this.eat(12));
				if (this.eatContextual(113)) do
					node.implements.push(this.flowParseInterfaceExtends());
				while (this.eat(12));
			}
			node.body = this.flowParseObjectType({
				allowStatic: isClass,
				allowExact: false,
				allowSpread: false,
				allowProto: isClass,
				allowInexact: false
			});
		}
		flowParseInterfaceExtends() {
			const node = this.startNode();
			node.id = this.flowParseQualifiedTypeIdentifier();
			if (this.match(47)) node.typeParameters = this.flowParseTypeParameterInstantiation();
			else node.typeParameters = null;
			return this.finishNode(node, "InterfaceExtends");
		}
		flowParseInterface(node) {
			this.flowParseInterfaceish(node, false);
			return this.finishNode(node, "InterfaceDeclaration");
		}
		checkNotUnderscore(word) {
			if (word === "_") this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
		}
		checkReservedType(word, startLoc, declaration) {
			if (!reservedTypes.has(word)) return;
			this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, { reservedType: word });
		}
		flowParseRestrictedIdentifier(liberal, declaration) {
			this.checkReservedType(this.state.value, this.state.startLoc, declaration);
			return this.parseIdentifier(liberal);
		}
		flowParseTypeAlias(node) {
			node.id = this.flowParseRestrictedIdentifier(false, true);
			this.scope.declareName(node.id.name, 8201, node.id.loc.start);
			if (this.match(47)) node.typeParameters = this.flowParseTypeParameterDeclaration();
			else node.typeParameters = null;
			node.right = this.flowParseTypeInitialiser(29);
			this.semicolon();
			return this.finishNode(node, "TypeAlias");
		}
		flowParseOpaqueType(node, declare) {
			this.expectContextual(130);
			node.id = this.flowParseRestrictedIdentifier(true, true);
			this.scope.declareName(node.id.name, 8201, node.id.loc.start);
			if (this.match(47)) node.typeParameters = this.flowParseTypeParameterDeclaration();
			else node.typeParameters = null;
			node.supertype = null;
			if (this.match(14)) node.supertype = this.flowParseTypeInitialiser(14);
			node.impltype = null;
			if (!declare) node.impltype = this.flowParseTypeInitialiser(29);
			this.semicolon();
			return this.finishNode(node, "OpaqueType");
		}
		flowParseTypeParameter(requireDefault = false) {
			const nodeStartLoc = this.state.startLoc;
			const node = this.startNode();
			const variance = this.flowParseVariance();
			const ident = this.flowParseTypeAnnotatableIdentifier();
			node.name = ident.name;
			node.variance = variance;
			node.bound = ident.typeAnnotation;
			if (this.match(29)) {
				this.eat(29);
				node.default = this.flowParseType();
			} else if (requireDefault) this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
			return this.finishNode(node, "TypeParameter");
		}
		flowParseTypeParameterDeclaration() {
			const oldInType = this.state.inType;
			const node = this.startNode();
			node.params = [];
			this.state.inType = true;
			if (this.match(47) || this.match(143)) this.next();
			else this.unexpected();
			let defaultRequired = false;
			do {
				const typeParameter = this.flowParseTypeParameter(defaultRequired);
				node.params.push(typeParameter);
				if (typeParameter.default) defaultRequired = true;
				if (!this.match(48)) this.expect(12);
			} while (!this.match(48));
			this.expect(48);
			this.state.inType = oldInType;
			return this.finishNode(node, "TypeParameterDeclaration");
		}
		flowInTopLevelContext(cb) {
			if (this.curContext() !== types.brace) {
				const oldContext = this.state.context;
				this.state.context = [oldContext[0]];
				try {
					return cb();
				} finally {
					this.state.context = oldContext;
				}
			} else return cb();
		}
		flowParseTypeParameterInstantiationInExpression() {
			if (this.reScan_lt() !== 47) return;
			return this.flowParseTypeParameterInstantiation();
		}
		flowParseTypeParameterInstantiation() {
			const node = this.startNode();
			const oldInType = this.state.inType;
			this.state.inType = true;
			node.params = [];
			this.flowInTopLevelContext(() => {
				this.expect(47);
				const oldNoAnonFunctionType = this.state.noAnonFunctionType;
				this.state.noAnonFunctionType = false;
				while (!this.match(48)) {
					node.params.push(this.flowParseType());
					if (!this.match(48)) this.expect(12);
				}
				this.state.noAnonFunctionType = oldNoAnonFunctionType;
			});
			this.state.inType = oldInType;
			if (!this.state.inType && this.curContext() === types.brace) this.reScan_lt_gt();
			this.expect(48);
			return this.finishNode(node, "TypeParameterInstantiation");
		}
		flowParseTypeParameterInstantiationCallOrNew() {
			if (this.reScan_lt() !== 47) return null;
			const node = this.startNode();
			const oldInType = this.state.inType;
			node.params = [];
			this.state.inType = true;
			this.expect(47);
			while (!this.match(48)) {
				node.params.push(this.flowParseTypeOrImplicitInstantiation());
				if (!this.match(48)) this.expect(12);
			}
			this.expect(48);
			this.state.inType = oldInType;
			return this.finishNode(node, "TypeParameterInstantiation");
		}
		flowParseInterfaceType() {
			const node = this.startNode();
			this.expectContextual(129);
			node.extends = [];
			if (this.eat(81)) do
				node.extends.push(this.flowParseInterfaceExtends());
			while (this.eat(12));
			node.body = this.flowParseObjectType({
				allowStatic: false,
				allowExact: false,
				allowSpread: false,
				allowProto: false,
				allowInexact: false
			});
			return this.finishNode(node, "InterfaceTypeAnnotation");
		}
		flowParseObjectPropertyKey() {
			return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
		}
		flowParseObjectTypeIndexer(node, isStatic, variance) {
			node.static = isStatic;
			if (this.lookahead().type === 14) {
				node.id = this.flowParseObjectPropertyKey();
				node.key = this.flowParseTypeInitialiser();
			} else {
				node.id = null;
				node.key = this.flowParseType();
			}
			this.expect(3);
			node.value = this.flowParseTypeInitialiser();
			node.variance = variance;
			return this.finishNode(node, "ObjectTypeIndexer");
		}
		flowParseObjectTypeInternalSlot(node, isStatic) {
			node.static = isStatic;
			node.id = this.flowParseObjectPropertyKey();
			this.expect(3);
			this.expect(3);
			if (this.match(47) || this.match(10)) {
				node.method = true;
				node.optional = false;
				node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
			} else {
				node.method = false;
				if (this.eat(17)) node.optional = true;
				node.value = this.flowParseTypeInitialiser();
			}
			return this.finishNode(node, "ObjectTypeInternalSlot");
		}
		flowParseObjectTypeMethodish(node) {
			node.params = [];
			node.rest = null;
			node.typeParameters = null;
			node.this = null;
			if (this.match(47)) node.typeParameters = this.flowParseTypeParameterDeclaration();
			this.expect(10);
			if (this.match(78)) {
				node.this = this.flowParseFunctionTypeParam(true);
				node.this.name = null;
				if (!this.match(11)) this.expect(12);
			}
			while (!this.match(11) && !this.match(21)) {
				node.params.push(this.flowParseFunctionTypeParam(false));
				if (!this.match(11)) this.expect(12);
			}
			if (this.eat(21)) node.rest = this.flowParseFunctionTypeParam(false);
			this.expect(11);
			node.returnType = this.flowParseTypeInitialiser();
			return this.finishNode(node, "FunctionTypeAnnotation");
		}
		flowParseObjectTypeCallProperty(node, isStatic) {
			const valueNode = this.startNode();
			node.static = isStatic;
			node.value = this.flowParseObjectTypeMethodish(valueNode);
			return this.finishNode(node, "ObjectTypeCallProperty");
		}
		flowParseObjectType({ allowStatic, allowExact, allowSpread, allowProto, allowInexact }) {
			const oldInType = this.state.inType;
			this.state.inType = true;
			const nodeStart = this.startNode();
			nodeStart.callProperties = [];
			nodeStart.properties = [];
			nodeStart.indexers = [];
			nodeStart.internalSlots = [];
			let endDelim;
			let exact;
			let inexact = false;
			if (allowExact && this.match(6)) {
				this.expect(6);
				endDelim = 9;
				exact = true;
			} else {
				this.expect(5);
				endDelim = 8;
				exact = false;
			}
			nodeStart.exact = exact;
			while (!this.match(endDelim)) {
				let isStatic = false;
				let protoStartLoc = null;
				let inexactStartLoc = null;
				const node = this.startNode();
				if (allowProto && this.isContextual(118)) {
					const lookahead = this.lookahead();
					if (lookahead.type !== 14 && lookahead.type !== 17) {
						this.next();
						protoStartLoc = this.state.startLoc;
						allowStatic = false;
					}
				}
				if (allowStatic && this.isContextual(106)) {
					const lookahead = this.lookahead();
					if (lookahead.type !== 14 && lookahead.type !== 17) {
						this.next();
						isStatic = true;
					}
				}
				const variance = this.flowParseVariance();
				if (this.eat(0)) {
					if (protoStartLoc != null) this.unexpected(protoStartLoc);
					if (this.eat(0)) {
						if (variance) this.unexpected(variance.loc.start);
						nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
					} else nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
				} else if (this.match(10) || this.match(47)) {
					if (protoStartLoc != null) this.unexpected(protoStartLoc);
					if (variance) this.unexpected(variance.loc.start);
					nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
				} else {
					let kind = "init";
					if (this.isContextual(99) || this.isContextual(104)) {
						const lookahead = this.lookahead();
						if (tokenIsLiteralPropertyName(lookahead.type)) {
							kind = this.state.value;
							this.next();
						}
					}
					const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
					if (propOrInexact === null) {
						inexact = true;
						inexactStartLoc = this.state.lastTokStartLoc;
					} else nodeStart.properties.push(propOrInexact);
				}
				this.flowObjectTypeSemicolon();
				if (inexactStartLoc && !this.match(8) && !this.match(9)) this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
			}
			this.expect(endDelim);
			if (allowSpread) nodeStart.inexact = inexact;
			const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
			this.state.inType = oldInType;
			return out;
		}
		flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
			if (this.eat(21)) {
				const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
				if (isInexactToken) {
					if (!allowSpread) this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
					else if (!allowInexact) this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
					if (variance) this.raise(FlowErrors.InexactVariance, variance);
					return null;
				}
				if (!allowSpread) this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
				if (protoStartLoc != null) this.unexpected(protoStartLoc);
				if (variance) this.raise(FlowErrors.SpreadVariance, variance);
				node.argument = this.flowParseType();
				return this.finishNode(node, "ObjectTypeSpreadProperty");
			} else {
				node.key = this.flowParseObjectPropertyKey();
				node.static = isStatic;
				node.proto = protoStartLoc != null;
				node.kind = kind;
				let optional = false;
				if (this.match(47) || this.match(10)) {
					node.method = true;
					if (protoStartLoc != null) this.unexpected(protoStartLoc);
					if (variance) this.unexpected(variance.loc.start);
					node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
					if (kind === "get" || kind === "set") this.flowCheckGetterSetterParams(node);
					if (!allowSpread && node.key.name === "constructor" && node.value.this) this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);
				} else {
					if (kind !== "init") this.unexpected();
					node.method = false;
					if (this.eat(17)) optional = true;
					node.value = this.flowParseTypeInitialiser();
					node.variance = variance;
				}
				node.optional = optional;
				return this.finishNode(node, "ObjectTypeProperty");
			}
		}
		flowCheckGetterSetterParams(property) {
			const paramCount = property.kind === "get" ? 0 : 1;
			const length = property.value.params.length + (property.value.rest ? 1 : 0);
			if (property.value.this) this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);
			if (length !== paramCount) this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
			if (property.kind === "set" && property.value.rest) this.raise(Errors.BadSetterRestParameter, property);
		}
		flowObjectTypeSemicolon() {
			if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) this.unexpected();
		}
		flowParseQualifiedTypeIdentifier(startLoc, id) {
			startLoc != null || (startLoc = this.state.startLoc);
			let node = id || this.flowParseRestrictedIdentifier(true);
			while (this.eat(16)) {
				const node2 = this.startNodeAt(startLoc);
				node2.qualification = node;
				node2.id = this.flowParseRestrictedIdentifier(true);
				node = this.finishNode(node2, "QualifiedTypeIdentifier");
			}
			return node;
		}
		flowParseGenericType(startLoc, id) {
			const node = this.startNodeAt(startLoc);
			node.typeParameters = null;
			node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
			if (this.match(47)) node.typeParameters = this.flowParseTypeParameterInstantiation();
			return this.finishNode(node, "GenericTypeAnnotation");
		}
		flowParseTypeofType() {
			const node = this.startNode();
			this.expect(87);
			node.argument = this.flowParsePrimaryType();
			return this.finishNode(node, "TypeofTypeAnnotation");
		}
		flowParseTupleType() {
			const node = this.startNode();
			node.types = [];
			this.expect(0);
			while (this.state.pos < this.length && !this.match(3)) {
				node.types.push(this.flowParseType());
				if (this.match(3)) break;
				this.expect(12);
			}
			this.expect(3);
			return this.finishNode(node, "TupleTypeAnnotation");
		}
		flowParseFunctionTypeParam(first) {
			let name = null;
			let optional = false;
			let typeAnnotation = null;
			const node = this.startNode();
			const lh = this.lookahead();
			const isThis = this.state.type === 78;
			if (lh.type === 14 || lh.type === 17) {
				if (isThis && !first) this.raise(FlowErrors.ThisParamMustBeFirst, node);
				name = this.parseIdentifier(isThis);
				if (this.eat(17)) {
					optional = true;
					if (isThis) this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
				}
				typeAnnotation = this.flowParseTypeInitialiser();
			} else typeAnnotation = this.flowParseType();
			node.name = name;
			node.optional = optional;
			node.typeAnnotation = typeAnnotation;
			return this.finishNode(node, "FunctionTypeParam");
		}
		reinterpretTypeAsFunctionTypeParam(type) {
			const node = this.startNodeAt(type.loc.start);
			node.name = null;
			node.optional = false;
			node.typeAnnotation = type;
			return this.finishNode(node, "FunctionTypeParam");
		}
		flowParseFunctionTypeParams(params = []) {
			let rest = null;
			let _this = null;
			if (this.match(78)) {
				_this = this.flowParseFunctionTypeParam(true);
				_this.name = null;
				if (!this.match(11)) this.expect(12);
			}
			while (!this.match(11) && !this.match(21)) {
				params.push(this.flowParseFunctionTypeParam(false));
				if (!this.match(11)) this.expect(12);
			}
			if (this.eat(21)) rest = this.flowParseFunctionTypeParam(false);
			return {
				params,
				rest,
				_this
			};
		}
		flowIdentToTypeAnnotation(startLoc, node, id) {
			switch (id.name) {
				case "any": return this.finishNode(node, "AnyTypeAnnotation");
				case "bool":
				case "boolean": return this.finishNode(node, "BooleanTypeAnnotation");
				case "mixed": return this.finishNode(node, "MixedTypeAnnotation");
				case "empty": return this.finishNode(node, "EmptyTypeAnnotation");
				case "number": return this.finishNode(node, "NumberTypeAnnotation");
				case "string": return this.finishNode(node, "StringTypeAnnotation");
				case "symbol": return this.finishNode(node, "SymbolTypeAnnotation");
				default:
					this.checkNotUnderscore(id.name);
					return this.flowParseGenericType(startLoc, id);
			}
		}
		flowParsePrimaryType() {
			const startLoc = this.state.startLoc;
			const node = this.startNode();
			let tmp;
			let type;
			let isGroupedType = false;
			const oldNoAnonFunctionType = this.state.noAnonFunctionType;
			switch (this.state.type) {
				case 5: return this.flowParseObjectType({
					allowStatic: false,
					allowExact: false,
					allowSpread: true,
					allowProto: false,
					allowInexact: true
				});
				case 6: return this.flowParseObjectType({
					allowStatic: false,
					allowExact: true,
					allowSpread: true,
					allowProto: false,
					allowInexact: false
				});
				case 0:
					this.state.noAnonFunctionType = false;
					type = this.flowParseTupleType();
					this.state.noAnonFunctionType = oldNoAnonFunctionType;
					return type;
				case 47: {
					const node$1 = this.startNode();
					node$1.typeParameters = this.flowParseTypeParameterDeclaration();
					this.expect(10);
					tmp = this.flowParseFunctionTypeParams();
					node$1.params = tmp.params;
					node$1.rest = tmp.rest;
					node$1.this = tmp._this;
					this.expect(11);
					this.expect(19);
					node$1.returnType = this.flowParseType();
					return this.finishNode(node$1, "FunctionTypeAnnotation");
				}
				case 10: {
					const node$1 = this.startNode();
					this.next();
					if (!this.match(11) && !this.match(21)) if (tokenIsIdentifier(this.state.type) || this.match(78)) {
						const token = this.lookahead().type;
						isGroupedType = token !== 17 && token !== 14;
					} else isGroupedType = true;
					if (isGroupedType) {
						this.state.noAnonFunctionType = false;
						type = this.flowParseType();
						this.state.noAnonFunctionType = oldNoAnonFunctionType;
						if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
							this.expect(11);
							return type;
						} else this.eat(12);
					}
					if (type) tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
					else tmp = this.flowParseFunctionTypeParams();
					node$1.params = tmp.params;
					node$1.rest = tmp.rest;
					node$1.this = tmp._this;
					this.expect(11);
					this.expect(19);
					node$1.returnType = this.flowParseType();
					node$1.typeParameters = null;
					return this.finishNode(node$1, "FunctionTypeAnnotation");
				}
				case 134: return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
				case 85:
				case 86:
					node.value = this.match(85);
					this.next();
					return this.finishNode(node, "BooleanLiteralTypeAnnotation");
				case 53:
					if (this.state.value === "-") {
						this.next();
						if (this.match(135)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
						if (this.match(136)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
						throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
					}
					throw this.unexpected();
				case 135: return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
				case 136: return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
				case 88:
					this.next();
					return this.finishNode(node, "VoidTypeAnnotation");
				case 84:
					this.next();
					return this.finishNode(node, "NullLiteralTypeAnnotation");
				case 78:
					this.next();
					return this.finishNode(node, "ThisTypeAnnotation");
				case 55:
					this.next();
					return this.finishNode(node, "ExistsTypeAnnotation");
				case 87: return this.flowParseTypeofType();
				default: if (tokenIsKeyword(this.state.type)) {
					const label = tokenLabelName(this.state.type);
					this.next();
					return super.createIdentifier(node, label);
				} else if (tokenIsIdentifier(this.state.type)) {
					if (this.isContextual(129)) return this.flowParseInterfaceType();
					return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
				}
			}
			throw this.unexpected();
		}
		flowParsePostfixType() {
			const startLoc = this.state.startLoc;
			let type = this.flowParsePrimaryType();
			let seenOptionalIndexedAccess = false;
			while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
				const node = this.startNodeAt(startLoc);
				const optional = this.eat(18);
				seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
				this.expect(0);
				if (!optional && this.match(3)) {
					node.elementType = type;
					this.next();
					type = this.finishNode(node, "ArrayTypeAnnotation");
				} else {
					node.objectType = type;
					node.indexType = this.flowParseType();
					this.expect(3);
					if (seenOptionalIndexedAccess) {
						node.optional = optional;
						type = this.finishNode(node, "OptionalIndexedAccessType");
					} else type = this.finishNode(node, "IndexedAccessType");
				}
			}
			return type;
		}
		flowParsePrefixType() {
			const node = this.startNode();
			if (this.eat(17)) {
				node.typeAnnotation = this.flowParsePrefixType();
				return this.finishNode(node, "NullableTypeAnnotation");
			} else return this.flowParsePostfixType();
		}
		flowParseAnonFunctionWithoutParens() {
			const param = this.flowParsePrefixType();
			if (!this.state.noAnonFunctionType && this.eat(19)) {
				const node = this.startNodeAt(param.loc.start);
				node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
				node.rest = null;
				node.this = null;
				node.returnType = this.flowParseType();
				node.typeParameters = null;
				return this.finishNode(node, "FunctionTypeAnnotation");
			}
			return param;
		}
		flowParseIntersectionType() {
			const node = this.startNode();
			this.eat(45);
			const type = this.flowParseAnonFunctionWithoutParens();
			node.types = [type];
			while (this.eat(45)) node.types.push(this.flowParseAnonFunctionWithoutParens());
			return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
		}
		flowParseUnionType() {
			const node = this.startNode();
			this.eat(43);
			const type = this.flowParseIntersectionType();
			node.types = [type];
			while (this.eat(43)) node.types.push(this.flowParseIntersectionType());
			return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
		}
		flowParseType() {
			const oldInType = this.state.inType;
			this.state.inType = true;
			const type = this.flowParseUnionType();
			this.state.inType = oldInType;
			return type;
		}
		flowParseTypeOrImplicitInstantiation() {
			if (this.state.type === 132 && this.state.value === "_") {
				const startLoc = this.state.startLoc;
				const node = this.parseIdentifier();
				return this.flowParseGenericType(startLoc, node);
			} else return this.flowParseType();
		}
		flowParseTypeAnnotation() {
			const node = this.startNode();
			node.typeAnnotation = this.flowParseTypeInitialiser();
			return this.finishNode(node, "TypeAnnotation");
		}
		flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
			const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
			if (this.match(14)) {
				ident.typeAnnotation = this.flowParseTypeAnnotation();
				this.resetEndLocation(ident);
			}
			return ident;
		}
		typeCastToParameter(node) {
			node.expression.typeAnnotation = node.typeAnnotation;
			this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
			return node.expression;
		}
		flowParseVariance() {
			let variance = null;
			if (this.match(53)) {
				variance = this.startNode();
				if (this.state.value === "+") variance.kind = "plus";
				else variance.kind = "minus";
				this.next();
				return this.finishNode(variance, "Variance");
			}
			return variance;
		}
		parseFunctionBody(node, allowExpressionBody, isMethod = false) {
			if (allowExpressionBody) {
				this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
				return;
			}
			super.parseFunctionBody(node, false, isMethod);
		}
		parseFunctionBodyAndFinish(node, type, isMethod = false) {
			if (this.match(14)) {
				const typeNode = this.startNode();
				[typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
				node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
			}
			return super.parseFunctionBodyAndFinish(node, type, isMethod);
		}
		parseStatementLike(flags) {
			if (this.state.strict && this.isContextual(129)) {
				const lookahead = this.lookahead();
				if (tokenIsKeywordOrIdentifier(lookahead.type)) {
					const node = this.startNode();
					this.next();
					return this.flowParseInterface(node);
				}
			} else if (this.isContextual(126)) {
				const node = this.startNode();
				this.next();
				return this.flowParseEnumDeclaration(node);
			}
			const stmt = super.parseStatementLike(flags);
			if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) this.flowPragma = null;
			return stmt;
		}
		parseExpressionStatement(node, expr, decorators) {
			if (expr.type === "Identifier") {
				if (expr.name === "declare") {
					if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(node);
				} else if (tokenIsIdentifier(this.state.type)) {
					if (expr.name === "interface") return this.flowParseInterface(node);
					else if (expr.name === "type") return this.flowParseTypeAlias(node);
					else if (expr.name === "opaque") return this.flowParseOpaqueType(node, false);
				}
			}
			return super.parseExpressionStatement(node, expr, decorators);
		}
		shouldParseExportDeclaration() {
			const { type } = this.state;
			if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) return !this.state.containsEsc;
			return super.shouldParseExportDeclaration();
		}
		isExportDefaultSpecifier() {
			const { type } = this.state;
			if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) return this.state.containsEsc;
			return super.isExportDefaultSpecifier();
		}
		parseExportDefaultExpression() {
			if (this.isContextual(126)) {
				const node = this.startNode();
				this.next();
				return this.flowParseEnumDeclaration(node);
			}
			return super.parseExportDefaultExpression();
		}
		parseConditional(expr, startLoc, refExpressionErrors) {
			if (!this.match(17)) return expr;
			if (this.state.maybeInArrowParameters) {
				const nextCh = this.lookaheadCharCode();
				if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
					this.setOptionalParametersError(refExpressionErrors);
					return expr;
				}
			}
			this.expect(17);
			const state = this.state.clone();
			const originalNoArrowAt = this.state.noArrowAt;
			const node = this.startNodeAt(startLoc);
			let { consequent, failed } = this.tryParseConditionalConsequent();
			let [valid, invalid] = this.getArrowLikeExpressions(consequent);
			if (failed || invalid.length > 0) {
				const noArrowAt = [...originalNoArrowAt];
				if (invalid.length > 0) {
					this.state = state;
					this.state.noArrowAt = noArrowAt;
					for (let i = 0; i < invalid.length; i++) noArrowAt.push(invalid[i].start);
					({consequent, failed} = this.tryParseConditionalConsequent());
					[valid, invalid] = this.getArrowLikeExpressions(consequent);
				}
				if (failed && valid.length > 1) this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
				if (failed && valid.length === 1) {
					this.state = state;
					noArrowAt.push(valid[0].start);
					this.state.noArrowAt = noArrowAt;
					({consequent, failed} = this.tryParseConditionalConsequent());
				}
			}
			this.getArrowLikeExpressions(consequent, true);
			this.state.noArrowAt = originalNoArrowAt;
			this.expect(14);
			node.test = expr;
			node.consequent = consequent;
			node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
			return this.finishNode(node, "ConditionalExpression");
		}
		tryParseConditionalConsequent() {
			this.state.noArrowParamsConversionAt.push(this.state.start);
			const consequent = this.parseMaybeAssignAllowIn();
			const failed = !this.match(14);
			this.state.noArrowParamsConversionAt.pop();
			return {
				consequent,
				failed
			};
		}
		getArrowLikeExpressions(node, disallowInvalid) {
			const stack$1 = [node];
			const arrows = [];
			while (stack$1.length !== 0) {
				const node$1 = stack$1.pop();
				if (node$1.type === "ArrowFunctionExpression" && node$1.body.type !== "BlockStatement") {
					if (node$1.typeParameters || !node$1.returnType) this.finishArrowValidation(node$1);
					else arrows.push(node$1);
					stack$1.push(node$1.body);
				} else if (node$1.type === "ConditionalExpression") {
					stack$1.push(node$1.consequent);
					stack$1.push(node$1.alternate);
				}
			}
			if (disallowInvalid) {
				arrows.forEach((node$1) => this.finishArrowValidation(node$1));
				return [arrows, []];
			}
			return partition(arrows, (node$1) => node$1.params.every((param) => this.isAssignable(param, true)));
		}
		finishArrowValidation(node) {
			var _node$extra;
			this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
			this.scope.enter(518);
			super.checkParams(node, false, true);
			this.scope.exit();
		}
		forwardNoArrowParamsConversionAt(node, parse$5) {
			let result;
			if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
				this.state.noArrowParamsConversionAt.push(this.state.start);
				result = parse$5();
				this.state.noArrowParamsConversionAt.pop();
			} else result = parse$5();
			return result;
		}
		parseParenItem(node, startLoc) {
			const newNode = super.parseParenItem(node, startLoc);
			if (this.eat(17)) {
				newNode.optional = true;
				this.resetEndLocation(node);
			}
			if (this.match(14)) {
				const typeCastNode = this.startNodeAt(startLoc);
				typeCastNode.expression = newNode;
				typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
				return this.finishNode(typeCastNode, "TypeCastExpression");
			}
			return newNode;
		}
		assertModuleNodeAllowed(node) {
			if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") return;
			super.assertModuleNodeAllowed(node);
		}
		parseExportDeclaration(node) {
			if (this.isContextual(130)) {
				node.exportKind = "type";
				const declarationNode = this.startNode();
				this.next();
				if (this.match(5)) {
					node.specifiers = this.parseExportSpecifiers(true);
					super.parseExportFrom(node);
					return null;
				} else return this.flowParseTypeAlias(declarationNode);
			} else if (this.isContextual(131)) {
				node.exportKind = "type";
				const declarationNode = this.startNode();
				this.next();
				return this.flowParseOpaqueType(declarationNode, false);
			} else if (this.isContextual(129)) {
				node.exportKind = "type";
				const declarationNode = this.startNode();
				this.next();
				return this.flowParseInterface(declarationNode);
			} else if (this.isContextual(126)) {
				node.exportKind = "value";
				const declarationNode = this.startNode();
				this.next();
				return this.flowParseEnumDeclaration(declarationNode);
			} else return super.parseExportDeclaration(node);
		}
		eatExportStar(node) {
			if (super.eatExportStar(node)) return true;
			if (this.isContextual(130) && this.lookahead().type === 55) {
				node.exportKind = "type";
				this.next();
				this.next();
				return true;
			}
			return false;
		}
		maybeParseExportNamespaceSpecifier(node) {
			const { startLoc } = this.state;
			const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
			if (hasNamespace && node.exportKind === "type") this.unexpected(startLoc);
			return hasNamespace;
		}
		parseClassId(node, isStatement, optionalId) {
			super.parseClassId(node, isStatement, optionalId);
			if (this.match(47)) node.typeParameters = this.flowParseTypeParameterDeclaration();
		}
		parseClassMember(classBody, member, state) {
			const { startLoc } = this.state;
			if (this.isContextual(125)) {
				if (super.parseClassMemberFromModifier(classBody, member)) return;
				member.declare = true;
			}
			super.parseClassMember(classBody, member, state);
			if (member.declare) {
				if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") this.raise(FlowErrors.DeclareClassElement, startLoc);
				else if (member.value) this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
			}
		}
		isIterator(word) {
			return word === "iterator" || word === "asyncIterator";
		}
		readIterator() {
			const word = super.readWord1();
			const fullWord = "@@" + word;
			if (!this.isIterator(word) || !this.state.inType) this.raise(Errors.InvalidIdentifier, this.state.curPosition(), { identifierName: fullWord });
			this.finishToken(132, fullWord);
		}
		getTokenFromCode(code$1) {
			const next = this.input.charCodeAt(this.state.pos + 1);
			if (code$1 === 123 && next === 124) this.finishOp(6, 2);
			else if (this.state.inType && (code$1 === 62 || code$1 === 60)) this.finishOp(code$1 === 62 ? 48 : 47, 1);
			else if (this.state.inType && code$1 === 63) if (next === 46) this.finishOp(18, 2);
			else this.finishOp(17, 1);
			else if (isIteratorStart(code$1, next, this.input.charCodeAt(this.state.pos + 2))) {
				this.state.pos += 2;
				this.readIterator();
			} else super.getTokenFromCode(code$1);
		}
		isAssignable(node, isBinding) {
			if (node.type === "TypeCastExpression") return this.isAssignable(node.expression, isBinding);
			else return super.isAssignable(node, isBinding);
		}
		toAssignable(node, isLHS = false) {
			if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") node.left = this.typeCastToParameter(node.left);
			super.toAssignable(node, isLHS);
		}
		toAssignableList(exprList, trailingCommaLoc, isLHS) {
			for (let i = 0; i < exprList.length; i++) {
				const expr = exprList[i];
				if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") exprList[i] = this.typeCastToParameter(expr);
			}
			super.toAssignableList(exprList, trailingCommaLoc, isLHS);
		}
		toReferencedList(exprList, isParenthesizedExpr) {
			for (let i = 0; i < exprList.length; i++) {
				var _expr$extra;
				const expr = exprList[i];
				if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
			}
			return exprList;
		}
		parseArrayLike(close, isTuple, refExpressionErrors) {
			const node = super.parseArrayLike(close, isTuple, refExpressionErrors);
			if (refExpressionErrors != null && !this.state.maybeInArrowParameters) this.toReferencedList(node.elements);
			return node;
		}
		isValidLVal(type, disallowCallExpression, isParenthesized, binding) {
			return type === "TypeCastExpression" || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding);
		}
		parseClassProperty(node) {
			if (this.match(14)) node.typeAnnotation = this.flowParseTypeAnnotation();
			return super.parseClassProperty(node);
		}
		parseClassPrivateProperty(node) {
			if (this.match(14)) node.typeAnnotation = this.flowParseTypeAnnotation();
			return super.parseClassPrivateProperty(node);
		}
		isClassMethod() {
			return this.match(47) || super.isClassMethod();
		}
		isClassProperty() {
			return this.match(14) || super.isClassProperty();
		}
		isNonstaticConstructor(method) {
			return !this.match(14) && super.isNonstaticConstructor(method);
		}
		pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
			if (method.variance) this.unexpected(method.variance.loc.start);
			delete method.variance;
			if (this.match(47)) method.typeParameters = this.flowParseTypeParameterDeclaration();
			super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
			if (method.params && isConstructor) {
				const params = method.params;
				if (params.length > 0 && this.isThisParam(params[0])) this.raise(FlowErrors.ThisParamBannedInConstructor, method);
			} else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
				const params = method.value.params;
				if (params.length > 0 && this.isThisParam(params[0])) this.raise(FlowErrors.ThisParamBannedInConstructor, method);
			}
		}
		pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
			if (method.variance) this.unexpected(method.variance.loc.start);
			delete method.variance;
			if (this.match(47)) method.typeParameters = this.flowParseTypeParameterDeclaration();
			super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
		}
		parseClassSuper(node) {
			super.parseClassSuper(node);
			if (node.superClass && (this.match(47) || this.match(51))) node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();
			if (this.isContextual(113)) {
				this.next();
				const implemented = node.implements = [];
				do {
					const node$1 = this.startNode();
					node$1.id = this.flowParseRestrictedIdentifier(true);
					if (this.match(47)) node$1.typeParameters = this.flowParseTypeParameterInstantiation();
					else node$1.typeParameters = null;
					implemented.push(this.finishNode(node$1, "ClassImplements"));
				} while (this.eat(12));
			}
		}
		checkGetterSetterParams(method) {
			super.checkGetterSetterParams(method);
			const params = this.getObjectOrClassMethodParams(method);
			if (params.length > 0) {
				const param = params[0];
				if (this.isThisParam(param) && method.kind === "get") this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
				else if (this.isThisParam(param)) this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
			}
		}
		parsePropertyNamePrefixOperator(node) {
			node.variance = this.flowParseVariance();
		}
		parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
			if (prop.variance) this.unexpected(prop.variance.loc.start);
			delete prop.variance;
			let typeParameters;
			if (this.match(47) && !isAccessor) {
				typeParameters = this.flowParseTypeParameterDeclaration();
				if (!this.match(10)) this.unexpected();
			}
			const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
			if (typeParameters) (result.value || result).typeParameters = typeParameters;
			return result;
		}
		parseFunctionParamType(param) {
			if (this.eat(17)) {
				if (param.type !== "Identifier") this.raise(FlowErrors.PatternIsOptional, param);
				if (this.isThisParam(param)) this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
				param.optional = true;
			}
			if (this.match(14)) param.typeAnnotation = this.flowParseTypeAnnotation();
			else if (this.isThisParam(param)) this.raise(FlowErrors.ThisParamAnnotationRequired, param);
			if (this.match(29) && this.isThisParam(param)) this.raise(FlowErrors.ThisParamNoDefault, param);
			this.resetEndLocation(param);
			return param;
		}
		parseMaybeDefault(startLoc, left) {
			const node = super.parseMaybeDefault(startLoc, left);
			if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
			return node;
		}
		checkImportReflection(node) {
			super.checkImportReflection(node);
			if (node.module && node.importKind !== "value") this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
		}
		parseImportSpecifierLocal(node, specifier, type) {
			specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
			node.specifiers.push(this.finishImportSpecifier(specifier, type));
		}
		isPotentialImportPhase(isExport) {
			if (super.isPotentialImportPhase(isExport)) return true;
			if (this.isContextual(130)) {
				if (!isExport) return true;
				const ch = this.lookaheadCharCode();
				return ch === 123 || ch === 42;
			}
			return !isExport && this.isContextual(87);
		}
		applyImportPhase(node, isExport, phase, loc) {
			super.applyImportPhase(node, isExport, phase, loc);
			if (isExport) {
				if (!phase && this.match(65)) return;
				node.exportKind = phase === "type" ? phase : "value";
			} else {
				if (phase === "type" && this.match(55)) this.unexpected();
				node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
			}
		}
		parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
			const firstIdent = specifier.imported;
			let specifierTypeKind = null;
			if (firstIdent.type === "Identifier") {
				if (firstIdent.name === "type") specifierTypeKind = "type";
				else if (firstIdent.name === "typeof") specifierTypeKind = "typeof";
			}
			let isBinding = false;
			if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
				const as_ident = this.parseIdentifier(true);
				if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
					specifier.imported = as_ident;
					specifier.importKind = specifierTypeKind;
					specifier.local = this.cloneIdentifier(as_ident);
				} else {
					specifier.imported = firstIdent;
					specifier.importKind = null;
					specifier.local = this.parseIdentifier();
				}
			} else {
				if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
					specifier.imported = this.parseIdentifier(true);
					specifier.importKind = specifierTypeKind;
				} else {
					if (importedIsString) throw this.raise(Errors.ImportBindingIsString, specifier, { importName: firstIdent.value });
					specifier.imported = firstIdent;
					specifier.importKind = null;
				}
				if (this.eatContextual(93)) specifier.local = this.parseIdentifier();
				else {
					isBinding = true;
					specifier.local = this.cloneIdentifier(specifier.imported);
				}
			}
			const specifierIsTypeImport = hasTypeImportKind(specifier);
			if (isInTypeOnlyImport && specifierIsTypeImport) this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
			if (isInTypeOnlyImport || specifierIsTypeImport) this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
			if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
			return this.finishImportSpecifier(specifier, "ImportSpecifier");
		}
		parseBindingAtom() {
			switch (this.state.type) {
				case 78: return this.parseIdentifier(true);
				default: return super.parseBindingAtom();
			}
		}
		parseFunctionParams(node, isConstructor) {
			const kind = node.kind;
			if (kind !== "get" && kind !== "set" && this.match(47)) node.typeParameters = this.flowParseTypeParameterDeclaration();
			super.parseFunctionParams(node, isConstructor);
		}
		parseVarId(decl, kind) {
			super.parseVarId(decl, kind);
			if (this.match(14)) {
				decl.id.typeAnnotation = this.flowParseTypeAnnotation();
				this.resetEndLocation(decl.id);
			}
		}
		parseAsyncArrowFromCallExpression(node, call) {
			if (this.match(14)) {
				const oldNoAnonFunctionType = this.state.noAnonFunctionType;
				this.state.noAnonFunctionType = true;
				node.returnType = this.flowParseTypeAnnotation();
				this.state.noAnonFunctionType = oldNoAnonFunctionType;
			}
			return super.parseAsyncArrowFromCallExpression(node, call);
		}
		shouldParseAsyncArrow() {
			return this.match(14) || super.shouldParseAsyncArrow();
		}
		parseMaybeAssign(refExpressionErrors, afterLeftParse) {
			var _jsx;
			let state = null;
			let jsx$1;
			if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
				state = this.state.clone();
				jsx$1 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
				if (!jsx$1.error) return jsx$1.node;
				const { context } = this.state;
				const currentContext = context[context.length - 1];
				if (currentContext === types.j_oTag || currentContext === types.j_expr) context.pop();
			}
			if ((_jsx = jsx$1) != null && _jsx.error || this.match(47)) {
				var _jsx2, _jsx3;
				state = state || this.state.clone();
				let typeParameters;
				const arrow = this.tryParse((abort) => {
					var _arrowExpression$extr;
					typeParameters = this.flowParseTypeParameterDeclaration();
					const arrowExpression$1 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
						const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
						this.resetStartLocationFromNode(result, typeParameters);
						return result;
					});
					if ((_arrowExpression$extr = arrowExpression$1.extra) != null && _arrowExpression$extr.parenthesized) abort();
					const expr = this.maybeUnwrapTypeCastExpression(arrowExpression$1);
					if (expr.type !== "ArrowFunctionExpression") abort();
					expr.typeParameters = typeParameters;
					this.resetStartLocationFromNode(expr, typeParameters);
					return arrowExpression$1;
				}, state);
				let arrowExpression = null;
				if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
					if (!arrow.error && !arrow.aborted) {
						if (arrow.node.async) this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
						return arrow.node;
					}
					arrowExpression = arrow.node;
				}
				if ((_jsx2 = jsx$1) != null && _jsx2.node) {
					this.state = jsx$1.failState;
					return jsx$1.node;
				}
				if (arrowExpression) {
					this.state = arrow.failState;
					return arrowExpression;
				}
				if ((_jsx3 = jsx$1) != null && _jsx3.thrown) throw jsx$1.error;
				if (arrow.thrown) throw arrow.error;
				throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
			}
			return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
		}
		parseArrow(node) {
			if (this.match(14)) {
				const result = this.tryParse(() => {
					const oldNoAnonFunctionType = this.state.noAnonFunctionType;
					this.state.noAnonFunctionType = true;
					const typeNode = this.startNode();
					[typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
					this.state.noAnonFunctionType = oldNoAnonFunctionType;
					if (this.canInsertSemicolon()) this.unexpected();
					if (!this.match(19)) this.unexpected();
					return typeNode;
				});
				if (result.thrown) return null;
				if (result.error) this.state = result.failState;
				node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
			}
			return super.parseArrow(node);
		}
		shouldParseArrow(params) {
			return this.match(14) || super.shouldParseArrow(params);
		}
		setArrowFunctionParameters(node, params) {
			if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) node.params = params;
			else super.setArrowFunctionParameters(node, params);
		}
		checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
			if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) return;
			for (let i = 0; i < node.params.length; i++) if (this.isThisParam(node.params[i]) && i > 0) this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
			super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
		}
		parseParenAndDistinguishExpression(canBeArrow) {
			return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
		}
		parseSubscripts(base, startLoc, noCalls) {
			if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
				this.next();
				const node = this.startNodeAt(startLoc);
				node.callee = base;
				node.arguments = super.parseCallExpressionArguments();
				base = this.finishNode(node, "CallExpression");
			} else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
				const state = this.state.clone();
				const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
				if (!arrow.error && !arrow.aborted) return arrow.node;
				const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
				if (result.node && !result.error) return result.node;
				if (arrow.node) {
					this.state = arrow.failState;
					return arrow.node;
				}
				if (result.node) {
					this.state = result.failState;
					return result.node;
				}
				throw arrow.error || result.error;
			}
			return super.parseSubscripts(base, startLoc, noCalls);
		}
		parseSubscript(base, startLoc, noCalls, subscriptState) {
			if (this.match(18) && this.isLookaheadToken_lt()) {
				subscriptState.optionalChainMember = true;
				if (noCalls) {
					subscriptState.stop = true;
					return base;
				}
				this.next();
				const node = this.startNodeAt(startLoc);
				node.callee = base;
				node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
				this.expect(10);
				node.arguments = this.parseCallExpressionArguments();
				node.optional = true;
				return this.finishCallExpression(node, true);
			} else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
				const node = this.startNodeAt(startLoc);
				node.callee = base;
				const result = this.tryParse(() => {
					node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
					this.expect(10);
					node.arguments = super.parseCallExpressionArguments();
					if (subscriptState.optionalChainMember) node.optional = false;
					return this.finishCallExpression(node, subscriptState.optionalChainMember);
				});
				if (result.node) {
					if (result.error) this.state = result.failState;
					return result.node;
				}
			}
			return super.parseSubscript(base, startLoc, noCalls, subscriptState);
		}
		parseNewCallee(node) {
			super.parseNewCallee(node);
			let targs = null;
			if (this.shouldParseTypes() && this.match(47)) targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
			node.typeArguments = targs;
		}
		parseAsyncArrowWithTypeParameters(startLoc) {
			const node = this.startNodeAt(startLoc);
			this.parseFunctionParams(node, false);
			if (!this.parseArrow(node)) return;
			return super.parseArrowExpression(node, void 0, true);
		}
		readToken_mult_modulo(code$1) {
			const next = this.input.charCodeAt(this.state.pos + 1);
			if (code$1 === 42 && next === 47 && this.state.hasFlowComment) {
				this.state.hasFlowComment = false;
				this.state.pos += 2;
				this.nextToken();
				return;
			}
			super.readToken_mult_modulo(code$1);
		}
		readToken_pipe_amp(code$1) {
			const next = this.input.charCodeAt(this.state.pos + 1);
			if (code$1 === 124 && next === 125) {
				this.finishOp(9, 2);
				return;
			}
			super.readToken_pipe_amp(code$1);
		}
		parseTopLevel(file, program) {
			const fileNode = super.parseTopLevel(file, program);
			if (this.state.hasFlowComment) this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
			return fileNode;
		}
		skipBlockComment() {
			if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
				if (this.state.hasFlowComment) throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
				this.hasFlowCommentCompletion();
				const commentSkip = this.skipFlowComment();
				if (commentSkip) {
					this.state.pos += commentSkip;
					this.state.hasFlowComment = true;
				}
				return;
			}
			return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
		}
		skipFlowComment() {
			const { pos } = this.state;
			let shiftToFirstNonWhiteSpace = 2;
			while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) shiftToFirstNonWhiteSpace++;
			const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
			const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
			if (ch2 === 58 && ch3 === 58) return shiftToFirstNonWhiteSpace + 2;
			if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") return shiftToFirstNonWhiteSpace + 12;
			if (ch2 === 58 && ch3 !== 58) return shiftToFirstNonWhiteSpace;
			return false;
		}
		hasFlowCommentCompletion() {
			const end = this.input.indexOf("*/", this.state.pos);
			if (end === -1) throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
		}
		flowEnumErrorBooleanMemberNotInitialized(loc, { enumName, memberName }) {
			this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
				memberName,
				enumName
			});
		}
		flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
			return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
		}
		flowEnumErrorNumberMemberNotInitialized(loc, details) {
			this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
		}
		flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
			this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
		}
		flowEnumMemberInit() {
			const startLoc = this.state.startLoc;
			const endOfInit = () => this.match(12) || this.match(8);
			switch (this.state.type) {
				case 135: {
					const literal = this.parseNumericLiteral(this.state.value);
					if (endOfInit()) return {
						type: "number",
						loc: literal.loc.start,
						value: literal
					};
					return {
						type: "invalid",
						loc: startLoc
					};
				}
				case 134: {
					const literal = this.parseStringLiteral(this.state.value);
					if (endOfInit()) return {
						type: "string",
						loc: literal.loc.start,
						value: literal
					};
					return {
						type: "invalid",
						loc: startLoc
					};
				}
				case 85:
				case 86: {
					const literal = this.parseBooleanLiteral(this.match(85));
					if (endOfInit()) return {
						type: "boolean",
						loc: literal.loc.start,
						value: literal
					};
					return {
						type: "invalid",
						loc: startLoc
					};
				}
				default: return {
					type: "invalid",
					loc: startLoc
				};
			}
		}
		flowEnumMemberRaw() {
			const loc = this.state.startLoc;
			const id = this.parseIdentifier(true);
			const init = this.eat(29) ? this.flowEnumMemberInit() : {
				type: "none",
				loc
			};
			return {
				id,
				init
			};
		}
		flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
			const { explicitType } = context;
			if (explicitType === null) return;
			if (explicitType !== expectedType) this.flowEnumErrorInvalidMemberInitializer(loc, context);
		}
		flowEnumMembers({ enumName, explicitType }) {
			const seenNames = /* @__PURE__ */ new Set();
			const members = {
				booleanMembers: [],
				numberMembers: [],
				stringMembers: [],
				defaultedMembers: []
			};
			let hasUnknownMembers = false;
			while (!this.match(8)) {
				if (this.eat(21)) {
					hasUnknownMembers = true;
					break;
				}
				const memberNode = this.startNode();
				const { id, init } = this.flowEnumMemberRaw();
				const memberName = id.name;
				if (memberName === "") continue;
				if (/^[a-z]/.test(memberName)) this.raise(FlowErrors.EnumInvalidMemberName, id, {
					memberName,
					suggestion: memberName[0].toUpperCase() + memberName.slice(1),
					enumName
				});
				if (seenNames.has(memberName)) this.raise(FlowErrors.EnumDuplicateMemberName, id, {
					memberName,
					enumName
				});
				seenNames.add(memberName);
				const context = {
					enumName,
					explicitType,
					memberName
				};
				memberNode.id = id;
				switch (init.type) {
					case "boolean": {
						this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
						memberNode.init = init.value;
						members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
						break;
					}
					case "number": {
						this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
						memberNode.init = init.value;
						members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
						break;
					}
					case "string": {
						this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
						memberNode.init = init.value;
						members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
						break;
					}
					case "invalid": throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
					case "none": switch (explicitType) {
						case "boolean":
							this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
							break;
						case "number":
							this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
							break;
						default: members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
					}
				}
				if (!this.match(8)) this.expect(12);
			}
			return {
				members,
				hasUnknownMembers
			};
		}
		flowEnumStringMembers(initializedMembers, defaultedMembers, { enumName }) {
			if (initializedMembers.length === 0) return defaultedMembers;
			else if (defaultedMembers.length === 0) return initializedMembers;
			else if (defaultedMembers.length > initializedMembers.length) {
				for (const member of initializedMembers) this.flowEnumErrorStringMemberInconsistentlyInitialized(member, { enumName });
				return defaultedMembers;
			} else {
				for (const member of defaultedMembers) this.flowEnumErrorStringMemberInconsistentlyInitialized(member, { enumName });
				return initializedMembers;
			}
		}
		flowEnumParseExplicitType({ enumName }) {
			if (!this.eatContextual(102)) return null;
			if (!tokenIsIdentifier(this.state.type)) throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName });
			const { value } = this.state;
			this.next();
			if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
				enumName,
				invalidEnumType: value
			});
			return value;
		}
		flowEnumBody(node, id) {
			const enumName = id.name;
			const nameLoc = id.loc.start;
			const explicitType = this.flowEnumParseExplicitType({ enumName });
			this.expect(5);
			const { members, hasUnknownMembers } = this.flowEnumMembers({
				enumName,
				explicitType
			});
			node.hasUnknownMembers = hasUnknownMembers;
			switch (explicitType) {
				case "boolean":
					node.explicitType = true;
					node.members = members.booleanMembers;
					this.expect(8);
					return this.finishNode(node, "EnumBooleanBody");
				case "number":
					node.explicitType = true;
					node.members = members.numberMembers;
					this.expect(8);
					return this.finishNode(node, "EnumNumberBody");
				case "string":
					node.explicitType = true;
					node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, { enumName });
					this.expect(8);
					return this.finishNode(node, "EnumStringBody");
				case "symbol":
					node.members = members.defaultedMembers;
					this.expect(8);
					return this.finishNode(node, "EnumSymbolBody");
				default: {
					const empty = () => {
						node.members = [];
						this.expect(8);
						return this.finishNode(node, "EnumStringBody");
					};
					node.explicitType = false;
					const boolsLen = members.booleanMembers.length;
					const numsLen = members.numberMembers.length;
					const strsLen = members.stringMembers.length;
					const defaultedLen = members.defaultedMembers.length;
					if (!boolsLen && !numsLen && !strsLen && !defaultedLen) return empty();
					else if (!boolsLen && !numsLen) {
						node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, { enumName });
						this.expect(8);
						return this.finishNode(node, "EnumStringBody");
					} else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
						for (const member of members.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
							enumName,
							memberName: member.id.name
						});
						node.members = members.booleanMembers;
						this.expect(8);
						return this.finishNode(node, "EnumBooleanBody");
					} else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
						for (const member of members.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
							enumName,
							memberName: member.id.name
						});
						node.members = members.numberMembers;
						this.expect(8);
						return this.finishNode(node, "EnumNumberBody");
					} else {
						this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, { enumName });
						return empty();
					}
				}
			}
		}
		flowParseEnumDeclaration(node) {
			const id = this.parseIdentifier();
			node.id = id;
			node.body = this.flowEnumBody(this.startNode(), id);
			return this.finishNode(node, "EnumDeclaration");
		}
		jsxParseOpeningElementAfterName(node) {
			if (this.shouldParseTypes()) {
				if (this.match(47) || this.match(51)) node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
			}
			return super.jsxParseOpeningElementAfterName(node);
		}
		isLookaheadToken_lt() {
			const next = this.nextTokenStart();
			if (this.input.charCodeAt(next) === 60) {
				const afterNext = this.input.charCodeAt(next + 1);
				return afterNext !== 60 && afterNext !== 61;
			}
			return false;
		}
		reScan_lt_gt() {
			const { type } = this.state;
			if (type === 47) {
				this.state.pos -= 1;
				this.readToken_lt();
			} else if (type === 48) {
				this.state.pos -= 1;
				this.readToken_gt();
			}
		}
		reScan_lt() {
			const { type } = this.state;
			if (type === 51) {
				this.state.pos -= 2;
				this.finishOp(47, 1);
				return 47;
			}
			return type;
		}
		maybeUnwrapTypeCastExpression(node) {
			return node.type === "TypeCastExpression" ? node.expression : node;
		}
	};
	const entities = {
		__proto__: null,
		quot: "\"",
		amp: "&",
		apos: "'",
		lt: "<",
		gt: ">",
		nbsp: "\xA0",
		iexcl: "",
		cent: "",
		pound: "",
		curren: "",
		yen: "",
		brvbar: "",
		sect: "",
		uml: "",
		copy: "",
		ordf: "",
		laquo: "",
		not: "",
		shy: "",
		reg: "",
		macr: "",
		deg: "",
		plusmn: "",
		sup2: "",
		sup3: "",
		acute: "",
		micro: "",
		para: "",
		middot: "",
		cedil: "",
		sup1: "",
		ordm: "",
		raquo: "",
		frac14: "",
		frac12: "",
		frac34: "",
		iquest: "",
		Agrave: "",
		Aacute: "",
		Acirc: "",
		Atilde: "",
		Auml: "",
		Aring: "",
		AElig: "",
		Ccedil: "",
		Egrave: "",
		Eacute: "",
		Ecirc: "",
		Euml: "",
		Igrave: "",
		Iacute: "",
		Icirc: "",
		Iuml: "",
		ETH: "",
		Ntilde: "",
		Ograve: "",
		Oacute: "",
		Ocirc: "",
		Otilde: "",
		Ouml: "",
		times: "",
		Oslash: "",
		Ugrave: "",
		Uacute: "",
		Ucirc: "",
		Uuml: "",
		Yacute: "",
		THORN: "",
		szlig: "",
		agrave: "",
		aacute: "",
		acirc: "",
		atilde: "",
		auml: "",
		aring: "",
		aelig: "",
		ccedil: "",
		egrave: "",
		eacute: "",
		ecirc: "",
		euml: "",
		igrave: "",
		iacute: "",
		icirc: "",
		iuml: "",
		eth: "",
		ntilde: "",
		ograve: "",
		oacute: "",
		ocirc: "",
		otilde: "",
		ouml: "",
		divide: "",
		oslash: "",
		ugrave: "",
		uacute: "",
		ucirc: "",
		uuml: "",
		yacute: "",
		thorn: "",
		yuml: "",
		OElig: "",
		oelig: "",
		Scaron: "",
		scaron: "",
		Yuml: "",
		fnof: "",
		circ: "",
		tilde: "",
		Alpha: "",
		Beta: "",
		Gamma: "",
		Delta: "",
		Epsilon: "",
		Zeta: "",
		Eta: "",
		Theta: "",
		Iota: "",
		Kappa: "",
		Lambda: "",
		Mu: "",
		Nu: "",
		Xi: "",
		Omicron: "",
		Pi: "",
		Rho: "",
		Sigma: "",
		Tau: "",
		Upsilon: "",
		Phi: "",
		Chi: "",
		Psi: "",
		Omega: "",
		alpha: "",
		beta: "",
		gamma: "",
		delta: "",
		epsilon: "",
		zeta: "",
		eta: "",
		theta: "",
		iota: "",
		kappa: "",
		lambda: "",
		mu: "",
		nu: "",
		xi: "",
		omicron: "",
		pi: "",
		rho: "",
		sigmaf: "",
		sigma: "",
		tau: "",
		upsilon: "",
		phi: "",
		chi: "",
		psi: "",
		omega: "",
		thetasym: "",
		upsih: "",
		piv: "",
		ensp: "",
		emsp: "",
		thinsp: "",
		zwnj: "",
		zwj: "",
		lrm: "",
		rlm: "",
		ndash: "",
		mdash: "",
		lsquo: "",
		rsquo: "",
		sbquo: "",
		ldquo: "",
		rdquo: "",
		bdquo: "",
		dagger: "",
		Dagger: "",
		bull: "",
		hellip: "",
		permil: "",
		prime: "",
		Prime: "",
		lsaquo: "",
		rsaquo: "",
		oline: "",
		frasl: "",
		euro: "",
		image: "",
		weierp: "",
		real: "",
		trade: "",
		alefsym: "",
		larr: "",
		uarr: "",
		rarr: "",
		darr: "",
		harr: "",
		crarr: "",
		lArr: "",
		uArr: "",
		rArr: "",
		dArr: "",
		hArr: "",
		forall: "",
		part: "",
		exist: "",
		empty: "",
		nabla: "",
		isin: "",
		notin: "",
		ni: "",
		prod: "",
		sum: "",
		minus: "",
		lowast: "",
		radic: "",
		prop: "",
		infin: "",
		ang: "",
		and: "",
		or: "",
		cap: "",
		cup: "",
		int: "",
		there4: "",
		sim: "",
		cong: "",
		asymp: "",
		ne: "",
		equiv: "",
		le: "",
		ge: "",
		sub: "",
		sup: "",
		nsub: "",
		sube: "",
		supe: "",
		oplus: "",
		otimes: "",
		perp: "",
		sdot: "",
		lceil: "",
		rceil: "",
		lfloor: "",
		rfloor: "",
		lang: "",
		rang: "",
		loz: "",
		spades: "",
		clubs: "",
		hearts: "",
		diams: ""
	};
	const lineBreak = /\r\n|[\r\n\u2028\u2029]/;
	const lineBreakG = new RegExp(lineBreak.source, "g");
	function isNewLine(code$1) {
		switch (code$1) {
			case 10:
			case 13:
			case 8232:
			case 8233: return true;
			default: return false;
		}
	}
	function hasNewLine(input, start, end) {
		for (let i = start; i < end; i++) if (isNewLine(input.charCodeAt(i))) return true;
		return false;
	}
	const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
	const skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
	function isWhitespace$1(code$1) {
		switch (code$1) {
			case 9:
			case 11:
			case 12:
			case 32:
			case 160:
			case 5760:
			case 8192:
			case 8193:
			case 8194:
			case 8195:
			case 8196:
			case 8197:
			case 8198:
			case 8199:
			case 8200:
			case 8201:
			case 8202:
			case 8239:
			case 8287:
			case 12288:
			case 65279: return true;
			default: return false;
		}
	}
	const JsxErrors = ParseErrorEnum`jsx`({
		AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
		MissingClosingTagElement: ({ openingTagName }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
		MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
		UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
		UnexpectedToken: ({ unexpected, HTMLEntity }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
		UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
		UnterminatedJsxContent: "Unterminated JSX contents.",
		UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
	});
	function isFragment$1(object) {
		return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
	}
	function getQualifiedJSXName(object) {
		if (object.type === "JSXIdentifier") return object.name;
		if (object.type === "JSXNamespacedName") return object.namespace.name + ":" + object.name.name;
		if (object.type === "JSXMemberExpression") return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
		throw new Error("Node had unexpected type: " + object.type);
	}
	var jsx = (superClass) => class JSXParserMixin extends superClass {
		jsxReadToken() {
			let out = "";
			let chunkStart = this.state.pos;
			for (;;) {
				if (this.state.pos >= this.length) throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
				const ch = this.input.charCodeAt(this.state.pos);
				switch (ch) {
					case 60:
					case 123:
						if (this.state.pos === this.state.start) {
							if (ch === 60 && this.state.canStartJSXElement) {
								++this.state.pos;
								this.finishToken(143);
							} else super.getTokenFromCode(ch);
							return;
						}
						out += this.input.slice(chunkStart, this.state.pos);
						this.finishToken(142, out);
						return;
					case 38:
						out += this.input.slice(chunkStart, this.state.pos);
						out += this.jsxReadEntity();
						chunkStart = this.state.pos;
						break;
					case 62:
					case 125:
					default: if (isNewLine(ch)) {
						out += this.input.slice(chunkStart, this.state.pos);
						out += this.jsxReadNewLine(true);
						chunkStart = this.state.pos;
					} else ++this.state.pos;
				}
			}
		}
		jsxReadNewLine(normalizeCRLF) {
			const ch = this.input.charCodeAt(this.state.pos);
			let out;
			++this.state.pos;
			if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
				++this.state.pos;
				out = normalizeCRLF ? "\n" : "\r\n";
			} else out = String.fromCharCode(ch);
			++this.state.curLine;
			this.state.lineStart = this.state.pos;
			return out;
		}
		jsxReadString(quote) {
			let out = "";
			let chunkStart = ++this.state.pos;
			for (;;) {
				if (this.state.pos >= this.length) throw this.raise(Errors.UnterminatedString, this.state.startLoc);
				const ch = this.input.charCodeAt(this.state.pos);
				if (ch === quote) break;
				if (ch === 38) {
					out += this.input.slice(chunkStart, this.state.pos);
					out += this.jsxReadEntity();
					chunkStart = this.state.pos;
				} else if (isNewLine(ch)) {
					out += this.input.slice(chunkStart, this.state.pos);
					out += this.jsxReadNewLine(false);
					chunkStart = this.state.pos;
				} else ++this.state.pos;
			}
			out += this.input.slice(chunkStart, this.state.pos++);
			this.finishToken(134, out);
		}
		jsxReadEntity() {
			const startPos = ++this.state.pos;
			if (this.codePointAtPos(this.state.pos) === 35) {
				++this.state.pos;
				let radix = 10;
				if (this.codePointAtPos(this.state.pos) === 120) {
					radix = 16;
					++this.state.pos;
				}
				const codePoint = this.readInt(radix, void 0, false, "bail");
				if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
					++this.state.pos;
					return String.fromCodePoint(codePoint);
				}
			} else {
				let count = 0;
				let semi = false;
				while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) ++this.state.pos;
				if (semi) {
					const desc = this.input.slice(startPos, this.state.pos);
					const entity = entities[desc];
					++this.state.pos;
					if (entity) return entity;
				}
			}
			this.state.pos = startPos;
			return "&";
		}
		jsxReadWord() {
			let ch;
			const start = this.state.pos;
			do
				ch = this.input.charCodeAt(++this.state.pos);
			while (isIdentifierChar(ch) || ch === 45);
			this.finishToken(141, this.input.slice(start, this.state.pos));
		}
		jsxParseIdentifier() {
			const node = this.startNode();
			if (this.match(141)) node.name = this.state.value;
			else if (tokenIsKeyword(this.state.type)) node.name = tokenLabelName(this.state.type);
			else this.unexpected();
			this.next();
			return this.finishNode(node, "JSXIdentifier");
		}
		jsxParseNamespacedName() {
			const startLoc = this.state.startLoc;
			const name = this.jsxParseIdentifier();
			if (!this.eat(14)) return name;
			const node = this.startNodeAt(startLoc);
			node.namespace = name;
			node.name = this.jsxParseIdentifier();
			return this.finishNode(node, "JSXNamespacedName");
		}
		jsxParseElementName() {
			const startLoc = this.state.startLoc;
			let node = this.jsxParseNamespacedName();
			if (node.type === "JSXNamespacedName") return node;
			while (this.eat(16)) {
				const newNode = this.startNodeAt(startLoc);
				newNode.object = node;
				newNode.property = this.jsxParseIdentifier();
				node = this.finishNode(newNode, "JSXMemberExpression");
			}
			return node;
		}
		jsxParseAttributeValue() {
			let node;
			switch (this.state.type) {
				case 5:
					node = this.startNode();
					this.setContext(types.brace);
					this.next();
					node = this.jsxParseExpressionContainer(node, types.j_oTag);
					if (node.expression.type === "JSXEmptyExpression") this.raise(JsxErrors.AttributeIsEmpty, node);
					return node;
				case 143:
				case 134: return this.parseExprAtom();
				default: throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
			}
		}
		jsxParseEmptyExpression() {
			const node = this.startNodeAt(this.state.lastTokEndLoc);
			return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
		}
		jsxParseSpreadChild(node) {
			this.next();
			node.expression = this.parseExpression();
			this.setContext(types.j_expr);
			this.state.canStartJSXElement = true;
			this.expect(8);
			return this.finishNode(node, "JSXSpreadChild");
		}
		jsxParseExpressionContainer(node, previousContext) {
			if (this.match(8)) node.expression = this.jsxParseEmptyExpression();
			else {
				const expression = this.parseExpression();
				node.expression = expression;
			}
			this.setContext(previousContext);
			this.state.canStartJSXElement = true;
			this.expect(8);
			return this.finishNode(node, "JSXExpressionContainer");
		}
		jsxParseAttribute() {
			const node = this.startNode();
			if (this.match(5)) {
				this.setContext(types.brace);
				this.next();
				this.expect(21);
				node.argument = this.parseMaybeAssignAllowIn();
				this.setContext(types.j_oTag);
				this.state.canStartJSXElement = true;
				this.expect(8);
				return this.finishNode(node, "JSXSpreadAttribute");
			}
			node.name = this.jsxParseNamespacedName();
			node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
			return this.finishNode(node, "JSXAttribute");
		}
		jsxParseOpeningElementAt(startLoc) {
			const node = this.startNodeAt(startLoc);
			if (this.eat(144)) return this.finishNode(node, "JSXOpeningFragment");
			node.name = this.jsxParseElementName();
			return this.jsxParseOpeningElementAfterName(node);
		}
		jsxParseOpeningElementAfterName(node) {
			const attributes = [];
			while (!this.match(56) && !this.match(144)) attributes.push(this.jsxParseAttribute());
			node.attributes = attributes;
			node.selfClosing = this.eat(56);
			this.expect(144);
			return this.finishNode(node, "JSXOpeningElement");
		}
		jsxParseClosingElementAt(startLoc) {
			const node = this.startNodeAt(startLoc);
			if (this.eat(144)) return this.finishNode(node, "JSXClosingFragment");
			node.name = this.jsxParseElementName();
			this.expect(144);
			return this.finishNode(node, "JSXClosingElement");
		}
		jsxParseElementAt(startLoc) {
			const node = this.startNodeAt(startLoc);
			const children = [];
			const openingElement = this.jsxParseOpeningElementAt(startLoc);
			let closingElement = null;
			if (!openingElement.selfClosing) {
				contents: for (;;) switch (this.state.type) {
					case 143:
						startLoc = this.state.startLoc;
						this.next();
						if (this.eat(56)) {
							closingElement = this.jsxParseClosingElementAt(startLoc);
							break contents;
						}
						children.push(this.jsxParseElementAt(startLoc));
						break;
					case 142:
						children.push(this.parseLiteral(this.state.value, "JSXText"));
						break;
					case 5: {
						const node$1 = this.startNode();
						this.setContext(types.brace);
						this.next();
						if (this.match(21)) children.push(this.jsxParseSpreadChild(node$1));
						else children.push(this.jsxParseExpressionContainer(node$1, types.j_expr));
						break;
					}
					default: this.unexpected();
				}
				if (isFragment$1(openingElement) && !isFragment$1(closingElement) && closingElement !== null) this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
				else if (!isFragment$1(openingElement) && isFragment$1(closingElement)) this.raise(JsxErrors.MissingClosingTagElement, closingElement, { openingTagName: getQualifiedJSXName(openingElement.name) });
				else if (!isFragment$1(openingElement) && !isFragment$1(closingElement)) {
					if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) this.raise(JsxErrors.MissingClosingTagElement, closingElement, { openingTagName: getQualifiedJSXName(openingElement.name) });
				}
			}
			if (isFragment$1(openingElement)) {
				node.openingFragment = openingElement;
				node.closingFragment = closingElement;
			} else {
				node.openingElement = openingElement;
				node.closingElement = closingElement;
			}
			node.children = children;
			if (this.match(47)) throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
			return isFragment$1(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
		}
		jsxParseElement() {
			const startLoc = this.state.startLoc;
			this.next();
			return this.jsxParseElementAt(startLoc);
		}
		setContext(newContext) {
			const { context } = this.state;
			context[context.length - 1] = newContext;
		}
		parseExprAtom(refExpressionErrors) {
			if (this.match(143)) return this.jsxParseElement();
			else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
				this.replaceToken(143);
				return this.jsxParseElement();
			} else return super.parseExprAtom(refExpressionErrors);
		}
		skipSpace() {
			const curContext = this.curContext();
			if (!curContext.preserveSpace) super.skipSpace();
		}
		getTokenFromCode(code$1) {
			const context = this.curContext();
			if (context === types.j_expr) {
				this.jsxReadToken();
				return;
			}
			if (context === types.j_oTag || context === types.j_cTag) {
				if (isIdentifierStart(code$1)) {
					this.jsxReadWord();
					return;
				}
				if (code$1 === 62) {
					++this.state.pos;
					this.finishToken(144);
					return;
				}
				if ((code$1 === 34 || code$1 === 39) && context === types.j_oTag) {
					this.jsxReadString(code$1);
					return;
				}
			}
			if (code$1 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
				++this.state.pos;
				this.finishToken(143);
				return;
			}
			super.getTokenFromCode(code$1);
		}
		updateContext(prevType) {
			const { context, type } = this.state;
			if (type === 56 && prevType === 143) {
				context.splice(-2, 2, types.j_cTag);
				this.state.canStartJSXElement = false;
			} else if (type === 143) context.push(types.j_oTag);
			else if (type === 144) {
				const out = context[context.length - 1];
				if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
					context.pop();
					this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
				} else {
					this.setContext(types.j_expr);
					this.state.canStartJSXElement = true;
				}
			} else this.state.canStartJSXElement = tokenComesBeforeExpression(type);
		}
	};
	var TypeScriptScope = class extends Scope {
		constructor(...args) {
			super(...args);
			this.tsNames = /* @__PURE__ */ new Map();
		}
	};
	var TypeScriptScopeHandler = class extends ScopeHandler {
		constructor(...args) {
			super(...args);
			this.importsStack = [];
		}
		createScope(flags) {
			this.importsStack.push(/* @__PURE__ */ new Set());
			return new TypeScriptScope(flags);
		}
		enter(flags) {
			if (flags === 1024) this.importsStack.push(/* @__PURE__ */ new Set());
			super.enter(flags);
		}
		exit() {
			const flags = super.exit();
			if (flags === 1024) this.importsStack.pop();
			return flags;
		}
		hasImport(name, allowShadow) {
			const len = this.importsStack.length;
			if (this.importsStack[len - 1].has(name)) return true;
			if (!allowShadow && len > 1) {
				for (let i = 0; i < len - 1; i++) if (this.importsStack[i].has(name)) return true;
			}
			return false;
		}
		declareName(name, bindingType, loc) {
			if (bindingType & 4096) {
				if (this.hasImport(name, true)) this.parser.raise(Errors.VarRedeclaration, loc, { identifierName: name });
				this.importsStack[this.importsStack.length - 1].add(name);
				return;
			}
			const scope = this.currentScope();
			let type = scope.tsNames.get(name) || 0;
			if (bindingType & 1024) {
				this.maybeExportDefined(scope, name);
				scope.tsNames.set(name, type | 16);
				return;
			}
			super.declareName(name, bindingType, loc);
			if (bindingType & 2) {
				if (!(bindingType & 1)) {
					this.checkRedeclarationInScope(scope, name, bindingType, loc);
					this.maybeExportDefined(scope, name);
				}
				type = type | 1;
			}
			if (bindingType & 256) type = type | 2;
			if (bindingType & 512) type = type | 4;
			if (bindingType & 128) type = type | 8;
			if (type) scope.tsNames.set(name, type);
		}
		isRedeclaredInScope(scope, name, bindingType) {
			const type = scope.tsNames.get(name);
			if ((type & 2) > 0) {
				if (bindingType & 256) {
					const isConst$1 = !!(bindingType & 512);
					const wasConst = (type & 4) > 0;
					return isConst$1 !== wasConst;
				}
				return true;
			}
			if (bindingType & 128 && (type & 8) > 0) if (scope.names.get(name) & 2) return !!(bindingType & 1);
			else return false;
			if (bindingType & 2 && (type & 1) > 0) return true;
			return super.isRedeclaredInScope(scope, name, bindingType);
		}
		checkLocalExport(id) {
			const { name } = id;
			if (this.hasImport(name)) return;
			const len = this.scopeStack.length;
			for (let i = len - 1; i >= 0; i--) {
				const scope = this.scopeStack[i];
				const type = scope.tsNames.get(name);
				if ((type & 1) > 0 || (type & 16) > 0) return;
			}
			super.checkLocalExport(id);
		}
	};
	var ProductionParameterHandler = class {
		constructor() {
			this.stacks = [];
		}
		enter(flags) {
			this.stacks.push(flags);
		}
		exit() {
			this.stacks.pop();
		}
		currentFlags() {
			return this.stacks[this.stacks.length - 1];
		}
		get hasAwait() {
			return (this.currentFlags() & 2) > 0;
		}
		get hasYield() {
			return (this.currentFlags() & 1) > 0;
		}
		get hasReturn() {
			return (this.currentFlags() & 4) > 0;
		}
		get hasIn() {
			return (this.currentFlags() & 8) > 0;
		}
	};
	function functionFlags(isAsync, isGenerator) {
		return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
	}
	var BaseParser = class {
		constructor() {
			this.sawUnambiguousESM = false;
			this.ambiguousScriptDifferentAst = false;
		}
		sourceToOffsetPos(sourcePos) {
			return sourcePos + this.startIndex;
		}
		offsetToSourcePos(offsetPos) {
			return offsetPos - this.startIndex;
		}
		hasPlugin(pluginConfig) {
			if (typeof pluginConfig === "string") return this.plugins.has(pluginConfig);
			else {
				const [pluginName, pluginOptions] = pluginConfig;
				if (!this.hasPlugin(pluginName)) return false;
				const actualOptions = this.plugins.get(pluginName);
				for (const key of Object.keys(pluginOptions)) if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) return false;
				return true;
			}
		}
		getPluginOption(plugin$14, name) {
			var _this$plugins$get;
			return (_this$plugins$get = this.plugins.get(plugin$14)) == null ? void 0 : _this$plugins$get[name];
		}
	};
	function setTrailingComments(node, comments) {
		if (node.trailingComments === void 0) node.trailingComments = comments;
		else node.trailingComments.unshift(...comments);
	}
	function setLeadingComments(node, comments) {
		if (node.leadingComments === void 0) node.leadingComments = comments;
		else node.leadingComments.unshift(...comments);
	}
	function setInnerComments(node, comments) {
		if (node.innerComments === void 0) node.innerComments = comments;
		else node.innerComments.unshift(...comments);
	}
	function adjustInnerComments(node, elements, commentWS) {
		let lastElement = null;
		let i = elements.length;
		while (lastElement === null && i > 0) lastElement = elements[--i];
		if (lastElement === null || lastElement.start > commentWS.start) setInnerComments(node, commentWS.comments);
		else setTrailingComments(lastElement, commentWS.comments);
	}
	var CommentsParser = class extends BaseParser {
		addComment(comment) {
			if (this.filename) comment.loc.filename = this.filename;
			const { commentsLen } = this.state;
			if (this.comments.length !== commentsLen) this.comments.length = commentsLen;
			this.comments.push(comment);
			this.state.commentsLen++;
		}
		processComment(node) {
			const { commentStack } = this.state;
			const commentStackLength = commentStack.length;
			if (commentStackLength === 0) return;
			let i = commentStackLength - 1;
			const lastCommentWS = commentStack[i];
			if (lastCommentWS.start === node.end) {
				lastCommentWS.leadingNode = node;
				i--;
			}
			const { start: nodeStart } = node;
			for (; i >= 0; i--) {
				const commentWS = commentStack[i];
				const commentEnd = commentWS.end;
				if (commentEnd > nodeStart) {
					commentWS.containingNode = node;
					this.finalizeComment(commentWS);
					commentStack.splice(i, 1);
				} else {
					if (commentEnd === nodeStart) commentWS.trailingNode = node;
					break;
				}
			}
		}
		finalizeComment(commentWS) {
			var _node$options;
			const { comments } = commentWS;
			if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
				if (commentWS.leadingNode !== null) setTrailingComments(commentWS.leadingNode, comments);
				if (commentWS.trailingNode !== null) setLeadingComments(commentWS.trailingNode, comments);
			} else {
				const node = commentWS.containingNode;
				const commentStart = commentWS.start;
				if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) switch (node.type) {
					case "ObjectExpression":
					case "ObjectPattern":
					case "RecordExpression":
						adjustInnerComments(node, node.properties, commentWS);
						break;
					case "CallExpression":
					case "OptionalCallExpression":
						adjustInnerComments(node, node.arguments, commentWS);
						break;
					case "ImportExpression":
						adjustInnerComments(node, [node.source, (_node$options = node.options) != null ? _node$options : null], commentWS);
						break;
					case "FunctionDeclaration":
					case "FunctionExpression":
					case "ArrowFunctionExpression":
					case "ObjectMethod":
					case "ClassMethod":
					case "ClassPrivateMethod":
						adjustInnerComments(node, node.params, commentWS);
						break;
					case "ArrayExpression":
					case "ArrayPattern":
					case "TupleExpression":
						adjustInnerComments(node, node.elements, commentWS);
						break;
					case "ExportNamedDeclaration":
					case "ImportDeclaration":
						adjustInnerComments(node, node.specifiers, commentWS);
						break;
					case "TSEnumDeclaration":
						adjustInnerComments(node, node.members, commentWS);
						break;
					case "TSEnumBody":
						adjustInnerComments(node, node.members, commentWS);
						break;
					default: setInnerComments(node, comments);
				}
				else setInnerComments(node, comments);
			}
		}
		finalizeRemainingComments() {
			const { commentStack } = this.state;
			for (let i = commentStack.length - 1; i >= 0; i--) this.finalizeComment(commentStack[i]);
			this.state.commentStack = [];
		}
		resetPreviousNodeTrailingComments(node) {
			const { commentStack } = this.state;
			const { length } = commentStack;
			if (length === 0) return;
			const commentWS = commentStack[length - 1];
			if (commentWS.leadingNode === node) commentWS.leadingNode = null;
		}
		takeSurroundingComments(node, start, end) {
			const { commentStack } = this.state;
			const commentStackLength = commentStack.length;
			if (commentStackLength === 0) return;
			let i = commentStackLength - 1;
			for (; i >= 0; i--) {
				const commentWS = commentStack[i];
				const commentEnd = commentWS.end;
				const commentStart = commentWS.start;
				if (commentStart === end) commentWS.leadingNode = node;
				else if (commentEnd === start) commentWS.trailingNode = node;
				else if (commentEnd < start) break;
			}
		}
	};
	var State = class State {
		constructor() {
			this.flags = 1024;
			this.startIndex = void 0;
			this.curLine = void 0;
			this.lineStart = void 0;
			this.startLoc = void 0;
			this.endLoc = void 0;
			this.errors = [];
			this.potentialArrowAt = -1;
			this.noArrowAt = [];
			this.noArrowParamsConversionAt = [];
			this.topicContext = {
				maxNumOfResolvableTopics: 0,
				maxTopicIndex: null
			};
			this.labels = [];
			this.commentsLen = 0;
			this.commentStack = [];
			this.pos = 0;
			this.type = 140;
			this.value = null;
			this.start = 0;
			this.end = 0;
			this.lastTokEndLoc = null;
			this.lastTokStartLoc = null;
			this.context = [types.brace];
			this.firstInvalidTemplateEscapePos = null;
			this.strictErrors = /* @__PURE__ */ new Map();
			this.tokensLength = 0;
		}
		get strict() {
			return (this.flags & 1) > 0;
		}
		set strict(v) {
			if (v) this.flags |= 1;
			else this.flags &= -2;
		}
		init({ strictMode, sourceType, startIndex, startLine, startColumn }) {
			this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
			this.startIndex = startIndex;
			this.curLine = startLine;
			this.lineStart = -startColumn;
			this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
		}
		get maybeInArrowParameters() {
			return (this.flags & 2) > 0;
		}
		set maybeInArrowParameters(v) {
			if (v) this.flags |= 2;
			else this.flags &= -3;
		}
		get inType() {
			return (this.flags & 4) > 0;
		}
		set inType(v) {
			if (v) this.flags |= 4;
			else this.flags &= -5;
		}
		get noAnonFunctionType() {
			return (this.flags & 8) > 0;
		}
		set noAnonFunctionType(v) {
			if (v) this.flags |= 8;
			else this.flags &= -9;
		}
		get hasFlowComment() {
			return (this.flags & 16) > 0;
		}
		set hasFlowComment(v) {
			if (v) this.flags |= 16;
			else this.flags &= -17;
		}
		get isAmbientContext() {
			return (this.flags & 32) > 0;
		}
		set isAmbientContext(v) {
			if (v) this.flags |= 32;
			else this.flags &= -33;
		}
		get inAbstractClass() {
			return (this.flags & 64) > 0;
		}
		set inAbstractClass(v) {
			if (v) this.flags |= 64;
			else this.flags &= -65;
		}
		get inDisallowConditionalTypesContext() {
			return (this.flags & 128) > 0;
		}
		set inDisallowConditionalTypesContext(v) {
			if (v) this.flags |= 128;
			else this.flags &= -129;
		}
		get soloAwait() {
			return (this.flags & 256) > 0;
		}
		set soloAwait(v) {
			if (v) this.flags |= 256;
			else this.flags &= -257;
		}
		get inFSharpPipelineDirectBody() {
			return (this.flags & 512) > 0;
		}
		set inFSharpPipelineDirectBody(v) {
			if (v) this.flags |= 512;
			else this.flags &= -513;
		}
		get canStartJSXElement() {
			return (this.flags & 1024) > 0;
		}
		set canStartJSXElement(v) {
			if (v) this.flags |= 1024;
			else this.flags &= -1025;
		}
		get containsEsc() {
			return (this.flags & 2048) > 0;
		}
		set containsEsc(v) {
			if (v) this.flags |= 2048;
			else this.flags &= -2049;
		}
		get hasTopLevelAwait() {
			return (this.flags & 4096) > 0;
		}
		set hasTopLevelAwait(v) {
			if (v) this.flags |= 4096;
			else this.flags &= -4097;
		}
		curPosition() {
			return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
		}
		clone() {
			const state = new State();
			state.flags = this.flags;
			state.startIndex = this.startIndex;
			state.curLine = this.curLine;
			state.lineStart = this.lineStart;
			state.startLoc = this.startLoc;
			state.endLoc = this.endLoc;
			state.errors = this.errors.slice();
			state.potentialArrowAt = this.potentialArrowAt;
			state.noArrowAt = this.noArrowAt.slice();
			state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
			state.topicContext = this.topicContext;
			state.labels = this.labels.slice();
			state.commentsLen = this.commentsLen;
			state.commentStack = this.commentStack.slice();
			state.pos = this.pos;
			state.type = this.type;
			state.value = this.value;
			state.start = this.start;
			state.end = this.end;
			state.lastTokEndLoc = this.lastTokEndLoc;
			state.lastTokStartLoc = this.lastTokStartLoc;
			state.context = this.context.slice();
			state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
			state.strictErrors = this.strictErrors;
			state.tokensLength = this.tokensLength;
			return state;
		}
	};
	var _isDigit = function isDigit(code$1) {
		return code$1 >= 48 && code$1 <= 57;
	};
	const forbiddenNumericSeparatorSiblings = {
		decBinOct: new Set([
			46,
			66,
			69,
			79,
			95,
			98,
			101,
			111
		]),
		hex: new Set([
			46,
			88,
			95,
			120
		])
	};
	const isAllowedNumericSeparatorSibling = {
		bin: (ch) => ch === 48 || ch === 49,
		oct: (ch) => ch >= 48 && ch <= 55,
		dec: (ch) => ch >= 48 && ch <= 57,
		hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
	};
	function readStringContents(type, input, pos, lineStart, curLine, errors) {
		const initialPos = pos;
		const initialLineStart = lineStart;
		const initialCurLine = curLine;
		let out = "";
		let firstInvalidLoc = null;
		let chunkStart = pos;
		const { length } = input;
		for (;;) {
			if (pos >= length) {
				errors.unterminated(initialPos, initialLineStart, initialCurLine);
				out += input.slice(chunkStart, pos);
				break;
			}
			const ch = input.charCodeAt(pos);
			if (isStringEnd(type, ch, input, pos)) {
				out += input.slice(chunkStart, pos);
				break;
			}
			if (ch === 92) {
				out += input.slice(chunkStart, pos);
				const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
				if (res.ch === null && !firstInvalidLoc) firstInvalidLoc = {
					pos,
					lineStart,
					curLine
				};
				else out += res.ch;
				({pos, lineStart, curLine} = res);
				chunkStart = pos;
			} else if (ch === 8232 || ch === 8233) {
				++pos;
				++curLine;
				lineStart = pos;
			} else if (ch === 10 || ch === 13) if (type === "template") {
				out += input.slice(chunkStart, pos) + "\n";
				++pos;
				if (ch === 13 && input.charCodeAt(pos) === 10) ++pos;
				++curLine;
				chunkStart = lineStart = pos;
			} else errors.unterminated(initialPos, initialLineStart, initialCurLine);
			else ++pos;
		}
		return {
			pos,
			str: out,
			firstInvalidLoc,
			lineStart,
			curLine,
			containsInvalid: !!firstInvalidLoc
		};
	}
	function isStringEnd(type, ch, input, pos) {
		if (type === "template") return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
		return ch === (type === "double" ? 34 : 39);
	}
	function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
		const throwOnInvalid = !inTemplate;
		pos++;
		const res = (ch$1) => ({
			pos,
			ch: ch$1,
			lineStart,
			curLine
		});
		const ch = input.charCodeAt(pos++);
		switch (ch) {
			case 110: return res("\n");
			case 114: return res("\r");
			case 120: {
				let code$1;
				({code: code$1, pos} = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
				return res(code$1 === null ? null : String.fromCharCode(code$1));
			}
			case 117: {
				let code$1;
				({code: code$1, pos} = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
				return res(code$1 === null ? null : String.fromCodePoint(code$1));
			}
			case 116: return res("	");
			case 98: return res("\b");
			case 118: return res("\v");
			case 102: return res("\f");
			case 13: if (input.charCodeAt(pos) === 10) ++pos;
			case 10:
				lineStart = pos;
				++curLine;
			case 8232:
			case 8233: return res("");
			case 56:
			case 57: if (inTemplate) return res(null);
			else errors.strictNumericEscape(pos - 1, lineStart, curLine);
			default:
				if (ch >= 48 && ch <= 55) {
					const startPos = pos - 1;
					const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
					let octalStr = match[0];
					let octal = parseInt(octalStr, 8);
					if (octal > 255) {
						octalStr = octalStr.slice(0, -1);
						octal = parseInt(octalStr, 8);
					}
					pos += octalStr.length - 1;
					const next = input.charCodeAt(pos);
					if (octalStr !== "0" || next === 56 || next === 57) if (inTemplate) return res(null);
					else errors.strictNumericEscape(startPos, lineStart, curLine);
					return res(String.fromCharCode(octal));
				}
				return res(String.fromCharCode(ch));
		}
	}
	function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
		const initialPos = pos;
		let n;
		({n, pos} = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
		if (n === null) if (throwOnInvalid) errors.invalidEscapeSequence(initialPos, lineStart, curLine);
		else pos = initialPos - 1;
		return {
			code: n,
			pos
		};
	}
	function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
		const start = pos;
		const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
		const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
		let invalid = false;
		let total = 0;
		for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
			const code$1 = input.charCodeAt(pos);
			let val;
			if (code$1 === 95 && allowNumSeparator !== "bail") {
				const prev = input.charCodeAt(pos - 1);
				const next = input.charCodeAt(pos + 1);
				if (!allowNumSeparator) {
					if (bailOnError) return {
						n: null,
						pos
					};
					errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
				} else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
					if (bailOnError) return {
						n: null,
						pos
					};
					errors.unexpectedNumericSeparator(pos, lineStart, curLine);
				}
				++pos;
				continue;
			}
			if (code$1 >= 97) val = code$1 - 97 + 10;
			else if (code$1 >= 65) val = code$1 - 65 + 10;
			else if (_isDigit(code$1)) val = code$1 - 48;
			else val = Infinity;
			if (val >= radix) if (val <= 9 && bailOnError) return {
				n: null,
				pos
			};
			else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) val = 0;
			else if (forceLen) {
				val = 0;
				invalid = true;
			} else break;
			++pos;
			total = total * radix + val;
		}
		if (pos === start || len != null && pos - start !== len || invalid) return {
			n: null,
			pos
		};
		return {
			n: total,
			pos
		};
	}
	function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
		const ch = input.charCodeAt(pos);
		let code$1;
		if (ch === 123) {
			++pos;
			({code: code$1, pos} = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
			++pos;
			if (code$1 !== null && code$1 > 1114111) if (throwOnInvalid) errors.invalidCodePoint(pos, lineStart, curLine);
			else return {
				code: null,
				pos
			};
		} else ({code: code$1, pos} = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
		return {
			code: code$1,
			pos
		};
	}
	function buildPosition(pos, lineStart, curLine) {
		return new Position(curLine, pos - lineStart, pos);
	}
	const VALID_REGEX_FLAGS = new Set([
		103,
		109,
		115,
		105,
		121,
		117,
		100,
		118
	]);
	var Token = class {
		constructor(state) {
			const startIndex = state.startIndex || 0;
			this.type = state.type;
			this.value = state.value;
			this.start = startIndex + state.start;
			this.end = startIndex + state.end;
			this.loc = new SourceLocation(state.startLoc, state.endLoc);
		}
	};
	var Tokenizer$1 = class extends CommentsParser {
		constructor(options, input) {
			super();
			this.isLookahead = void 0;
			this.tokens = [];
			this.errorHandlers_readInt = {
				invalidDigit: (pos, lineStart, curLine, radix) => {
					if (!(this.optionFlags & 2048)) return false;
					this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), { radix });
					return true;
				},
				numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
				unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
			};
			this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
				invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
				invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
			});
			this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
				strictNumericEscape: (pos, lineStart, curLine) => {
					this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
				},
				unterminated: (pos, lineStart, curLine) => {
					throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
				}
			});
			this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
				strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
				unterminated: (pos, lineStart, curLine) => {
					throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
				}
			});
			this.state = new State();
			this.state.init(options);
			this.input = input;
			this.length = input.length;
			this.comments = [];
			this.isLookahead = false;
		}
		pushToken(token) {
			this.tokens.length = this.state.tokensLength;
			this.tokens.push(token);
			++this.state.tokensLength;
		}
		next() {
			this.checkKeywordEscapes();
			if (this.optionFlags & 256) this.pushToken(new Token(this.state));
			this.state.lastTokEndLoc = this.state.endLoc;
			this.state.lastTokStartLoc = this.state.startLoc;
			this.nextToken();
		}
		eat(type) {
			if (this.match(type)) {
				this.next();
				return true;
			} else return false;
		}
		match(type) {
			return this.state.type === type;
		}
		createLookaheadState(state) {
			return {
				pos: state.pos,
				value: null,
				type: state.type,
				start: state.start,
				end: state.end,
				context: [this.curContext()],
				inType: state.inType,
				startLoc: state.startLoc,
				lastTokEndLoc: state.lastTokEndLoc,
				curLine: state.curLine,
				lineStart: state.lineStart,
				curPosition: state.curPosition
			};
		}
		lookahead() {
			const old = this.state;
			this.state = this.createLookaheadState(old);
			this.isLookahead = true;
			this.nextToken();
			this.isLookahead = false;
			const curr = this.state;
			this.state = old;
			return curr;
		}
		nextTokenStart() {
			return this.nextTokenStartSince(this.state.pos);
		}
		nextTokenStartSince(pos) {
			skipWhiteSpace.lastIndex = pos;
			return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
		}
		lookaheadCharCode() {
			return this.lookaheadCharCodeSince(this.state.pos);
		}
		lookaheadCharCodeSince(pos) {
			return this.input.charCodeAt(this.nextTokenStartSince(pos));
		}
		nextTokenInLineStart() {
			return this.nextTokenInLineStartSince(this.state.pos);
		}
		nextTokenInLineStartSince(pos) {
			skipWhiteSpaceInLine.lastIndex = pos;
			return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
		}
		lookaheadInLineCharCode() {
			return this.input.charCodeAt(this.nextTokenInLineStart());
		}
		codePointAtPos(pos) {
			let cp = this.input.charCodeAt(pos);
			if ((cp & 64512) === 55296 && ++pos < this.input.length) {
				const trail = this.input.charCodeAt(pos);
				if ((trail & 64512) === 56320) cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
			}
			return cp;
		}
		setStrict(strict) {
			this.state.strict = strict;
			if (strict) {
				this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));
				this.state.strictErrors.clear();
			}
		}
		curContext() {
			return this.state.context[this.state.context.length - 1];
		}
		nextToken() {
			this.skipSpace();
			this.state.start = this.state.pos;
			if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
			if (this.state.pos >= this.length) {
				this.finishToken(140);
				return;
			}
			this.getTokenFromCode(this.codePointAtPos(this.state.pos));
		}
		skipBlockComment(commentEnd) {
			let startLoc;
			if (!this.isLookahead) startLoc = this.state.curPosition();
			const start = this.state.pos;
			const end = this.input.indexOf(commentEnd, start + 2);
			if (end === -1) throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
			this.state.pos = end + commentEnd.length;
			lineBreakG.lastIndex = start + 2;
			while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
				++this.state.curLine;
				this.state.lineStart = lineBreakG.lastIndex;
			}
			if (this.isLookahead) return;
			const comment = {
				type: "CommentBlock",
				value: this.input.slice(start + 2, end),
				start: this.sourceToOffsetPos(start),
				end: this.sourceToOffsetPos(end + commentEnd.length),
				loc: new SourceLocation(startLoc, this.state.curPosition())
			};
			if (this.optionFlags & 256) this.pushToken(comment);
			return comment;
		}
		skipLineComment(startSkip) {
			const start = this.state.pos;
			let startLoc;
			if (!this.isLookahead) startLoc = this.state.curPosition();
			let ch = this.input.charCodeAt(this.state.pos += startSkip);
			if (this.state.pos < this.length) while (!isNewLine(ch) && ++this.state.pos < this.length) ch = this.input.charCodeAt(this.state.pos);
			if (this.isLookahead) return;
			const end = this.state.pos;
			const value = this.input.slice(start + startSkip, end);
			const comment = {
				type: "CommentLine",
				value,
				start: this.sourceToOffsetPos(start),
				end: this.sourceToOffsetPos(end),
				loc: new SourceLocation(startLoc, this.state.curPosition())
			};
			if (this.optionFlags & 256) this.pushToken(comment);
			return comment;
		}
		skipSpace() {
			const spaceStart = this.state.pos;
			const comments = this.optionFlags & 4096 ? [] : null;
			loop: while (this.state.pos < this.length) {
				const ch = this.input.charCodeAt(this.state.pos);
				switch (ch) {
					case 32:
					case 160:
					case 9:
						++this.state.pos;
						break;
					case 13: if (this.input.charCodeAt(this.state.pos + 1) === 10) ++this.state.pos;
					case 10:
					case 8232:
					case 8233:
						++this.state.pos;
						++this.state.curLine;
						this.state.lineStart = this.state.pos;
						break;
					case 47:
						switch (this.input.charCodeAt(this.state.pos + 1)) {
							case 42: {
								const comment = this.skipBlockComment("*/");
								if (comment !== void 0) {
									this.addComment(comment);
									comments?.push(comment);
								}
								break;
							}
							case 47: {
								const comment = this.skipLineComment(2);
								if (comment !== void 0) {
									this.addComment(comment);
									comments?.push(comment);
								}
								break;
							}
							default: break loop;
						}
						break;
					default: if (isWhitespace$1(ch)) ++this.state.pos;
					else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {
						const pos = this.state.pos;
						if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
							const comment = this.skipLineComment(3);
							if (comment !== void 0) {
								this.addComment(comment);
								comments?.push(comment);
							}
						} else break loop;
					} else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {
						const pos = this.state.pos;
						if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
							const comment = this.skipLineComment(4);
							if (comment !== void 0) {
								this.addComment(comment);
								comments?.push(comment);
							}
						} else break loop;
					} else break loop;
				}
			}
			if ((comments == null ? void 0 : comments.length) > 0) {
				const end = this.state.pos;
				const commentWhitespace = {
					start: this.sourceToOffsetPos(spaceStart),
					end: this.sourceToOffsetPos(end),
					comments,
					leadingNode: null,
					trailingNode: null,
					containingNode: null
				};
				this.state.commentStack.push(commentWhitespace);
			}
		}
		finishToken(type, val) {
			this.state.end = this.state.pos;
			this.state.endLoc = this.state.curPosition();
			const prevType = this.state.type;
			this.state.type = type;
			this.state.value = val;
			if (!this.isLookahead) this.updateContext(prevType);
		}
		replaceToken(type) {
			this.state.type = type;
			this.updateContext();
		}
		readToken_numberSign() {
			if (this.state.pos === 0 && this.readToken_interpreter()) return;
			const nextPos = this.state.pos + 1;
			const next = this.codePointAtPos(nextPos);
			if (next >= 48 && next <= 57) throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
			if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
				this.expectPlugin("recordAndTuple");
				if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
				this.state.pos += 2;
				if (next === 123) this.finishToken(7);
				else this.finishToken(1);
			} else if (isIdentifierStart(next)) {
				++this.state.pos;
				this.finishToken(139, this.readWord1(next));
			} else if (next === 92) {
				++this.state.pos;
				this.finishToken(139, this.readWord1());
			} else this.finishOp(27, 1);
		}
		readToken_dot() {
			const next = this.input.charCodeAt(this.state.pos + 1);
			if (next >= 48 && next <= 57) {
				this.readNumber(true);
				return;
			}
			if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
				this.state.pos += 3;
				this.finishToken(21);
			} else {
				++this.state.pos;
				this.finishToken(16);
			}
		}
		readToken_slash() {
			const next = this.input.charCodeAt(this.state.pos + 1);
			if (next === 61) this.finishOp(31, 2);
			else this.finishOp(56, 1);
		}
		readToken_interpreter() {
			if (this.state.pos !== 0 || this.length < 2) return false;
			let ch = this.input.charCodeAt(this.state.pos + 1);
			if (ch !== 33) return false;
			const start = this.state.pos;
			this.state.pos += 1;
			while (!isNewLine(ch) && ++this.state.pos < this.length) ch = this.input.charCodeAt(this.state.pos);
			const value = this.input.slice(start + 2, this.state.pos);
			this.finishToken(28, value);
			return true;
		}
		readToken_mult_modulo(code$1) {
			let type = code$1 === 42 ? 55 : 54;
			let width = 1;
			let next = this.input.charCodeAt(this.state.pos + 1);
			if (code$1 === 42 && next === 42) {
				width++;
				next = this.input.charCodeAt(this.state.pos + 2);
				type = 57;
			}
			if (next === 61 && !this.state.inType) {
				width++;
				type = code$1 === 37 ? 33 : 30;
			}
			this.finishOp(type, width);
		}
		readToken_pipe_amp(code$1) {
			const next = this.input.charCodeAt(this.state.pos + 1);
			if (next === code$1) {
				if (this.input.charCodeAt(this.state.pos + 2) === 61) this.finishOp(30, 3);
				else this.finishOp(code$1 === 124 ? 41 : 42, 2);
				return;
			}
			if (code$1 === 124) {
				if (next === 62) {
					this.finishOp(39, 2);
					return;
				}
				if (this.hasPlugin("recordAndTuple") && next === 125) {
					if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
					this.state.pos += 2;
					this.finishToken(9);
					return;
				}
				if (this.hasPlugin("recordAndTuple") && next === 93) {
					if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
					this.state.pos += 2;
					this.finishToken(4);
					return;
				}
			}
			if (next === 61) {
				this.finishOp(30, 2);
				return;
			}
			this.finishOp(code$1 === 124 ? 43 : 45, 1);
		}
		readToken_caret() {
			const next = this.input.charCodeAt(this.state.pos + 1);
			if (next === 61 && !this.state.inType) this.finishOp(32, 2);
			else if (next === 94 && this.hasPlugin(["pipelineOperator", {
				proposal: "hack",
				topicToken: "^^"
			}])) {
				this.finishOp(37, 2);
				const lookaheadCh = this.input.codePointAt(this.state.pos);
				if (lookaheadCh === 94) this.unexpected();
			} else this.finishOp(44, 1);
		}
		readToken_atSign() {
			const next = this.input.charCodeAt(this.state.pos + 1);
			if (next === 64 && this.hasPlugin(["pipelineOperator", {
				proposal: "hack",
				topicToken: "@@"
			}])) this.finishOp(38, 2);
			else this.finishOp(26, 1);
		}
		readToken_plus_min(code$1) {
			const next = this.input.charCodeAt(this.state.pos + 1);
			if (next === code$1) {
				this.finishOp(34, 2);
				return;
			}
			if (next === 61) this.finishOp(30, 2);
			else this.finishOp(53, 1);
		}
		readToken_lt() {
			const { pos } = this.state;
			const next = this.input.charCodeAt(pos + 1);
			if (next === 60) {
				if (this.input.charCodeAt(pos + 2) === 61) {
					this.finishOp(30, 3);
					return;
				}
				this.finishOp(51, 2);
				return;
			}
			if (next === 61) {
				this.finishOp(49, 2);
				return;
			}
			this.finishOp(47, 1);
		}
		readToken_gt() {
			const { pos } = this.state;
			const next = this.input.charCodeAt(pos + 1);
			if (next === 62) {
				const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
				if (this.input.charCodeAt(pos + size) === 61) {
					this.finishOp(30, size + 1);
					return;
				}
				this.finishOp(52, size);
				return;
			}
			if (next === 61) {
				this.finishOp(49, 2);
				return;
			}
			this.finishOp(48, 1);
		}
		readToken_eq_excl(code$1) {
			const next = this.input.charCodeAt(this.state.pos + 1);
			if (next === 61) {
				this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
				return;
			}
			if (code$1 === 61 && next === 62) {
				this.state.pos += 2;
				this.finishToken(19);
				return;
			}
			this.finishOp(code$1 === 61 ? 29 : 35, 1);
		}
		readToken_question() {
			const next = this.input.charCodeAt(this.state.pos + 1);
			const next2 = this.input.charCodeAt(this.state.pos + 2);
			if (next === 63) if (next2 === 61) this.finishOp(30, 3);
			else this.finishOp(40, 2);
			else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
				this.state.pos += 2;
				this.finishToken(18);
			} else {
				++this.state.pos;
				this.finishToken(17);
			}
		}
		getTokenFromCode(code$1) {
			switch (code$1) {
				case 46:
					this.readToken_dot();
					return;
				case 40:
					++this.state.pos;
					this.finishToken(10);
					return;
				case 41:
					++this.state.pos;
					this.finishToken(11);
					return;
				case 59:
					++this.state.pos;
					this.finishToken(13);
					return;
				case 44:
					++this.state.pos;
					this.finishToken(12);
					return;
				case 91:
					if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
						if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
						this.state.pos += 2;
						this.finishToken(2);
					} else {
						++this.state.pos;
						this.finishToken(0);
					}
					return;
				case 93:
					++this.state.pos;
					this.finishToken(3);
					return;
				case 123:
					if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
						if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
						this.state.pos += 2;
						this.finishToken(6);
					} else {
						++this.state.pos;
						this.finishToken(5);
					}
					return;
				case 125:
					++this.state.pos;
					this.finishToken(8);
					return;
				case 58:
					if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) this.finishOp(15, 2);
					else {
						++this.state.pos;
						this.finishToken(14);
					}
					return;
				case 63:
					this.readToken_question();
					return;
				case 96:
					this.readTemplateToken();
					return;
				case 48: {
					const next = this.input.charCodeAt(this.state.pos + 1);
					if (next === 120 || next === 88) {
						this.readRadixNumber(16);
						return;
					}
					if (next === 111 || next === 79) {
						this.readRadixNumber(8);
						return;
					}
					if (next === 98 || next === 66) {
						this.readRadixNumber(2);
						return;
					}
				}
				case 49:
				case 50:
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
					this.readNumber(false);
					return;
				case 34:
				case 39:
					this.readString(code$1);
					return;
				case 47:
					this.readToken_slash();
					return;
				case 37:
				case 42:
					this.readToken_mult_modulo(code$1);
					return;
				case 124:
				case 38:
					this.readToken_pipe_amp(code$1);
					return;
				case 94:
					this.readToken_caret();
					return;
				case 43:
				case 45:
					this.readToken_plus_min(code$1);
					return;
				case 60:
					this.readToken_lt();
					return;
				case 62:
					this.readToken_gt();
					return;
				case 61:
				case 33:
					this.readToken_eq_excl(code$1);
					return;
				case 126:
					this.finishOp(36, 1);
					return;
				case 64:
					this.readToken_atSign();
					return;
				case 35:
					this.readToken_numberSign();
					return;
				case 92:
					this.readWord();
					return;
				default: if (isIdentifierStart(code$1)) {
					this.readWord(code$1);
					return;
				}
			}
			throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(code$1) });
		}
		finishOp(type, size) {
			const str = this.input.slice(this.state.pos, this.state.pos + size);
			this.state.pos += size;
			this.finishToken(type, str);
		}
		readRegexp() {
			const startLoc = this.state.startLoc;
			const start = this.state.start + 1;
			let escaped, inClass;
			let { pos } = this.state;
			for (;; ++pos) {
				if (pos >= this.length) throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
				const ch = this.input.charCodeAt(pos);
				if (isNewLine(ch)) throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
				if (escaped) escaped = false;
				else {
					if (ch === 91) inClass = true;
					else if (ch === 93 && inClass) inClass = false;
					else if (ch === 47 && !inClass) break;
					escaped = ch === 92;
				}
			}
			const content = this.input.slice(start, pos);
			++pos;
			let mods = "";
			const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
			while (pos < this.length) {
				const cp = this.codePointAtPos(pos);
				const char = String.fromCharCode(cp);
				if (VALID_REGEX_FLAGS.has(cp)) {
					if (cp === 118) {
						if (mods.includes("u")) this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
					} else if (cp === 117) {
						if (mods.includes("v")) this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
					}
					if (mods.includes(char)) this.raise(Errors.DuplicateRegExpFlags, nextPos());
				} else if (isIdentifierChar(cp) || cp === 92) this.raise(Errors.MalformedRegExpFlags, nextPos());
				else break;
				++pos;
				mods += char;
			}
			this.state.pos = pos;
			this.finishToken(138, {
				pattern: content,
				flags: mods
			});
		}
		readInt(radix, len, forceLen = false, allowNumSeparator = true) {
			const { n, pos } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
			this.state.pos = pos;
			return n;
		}
		readRadixNumber(radix) {
			const start = this.state.pos;
			const startLoc = this.state.curPosition();
			let isBigInt = false;
			this.state.pos += 2;
			const val = this.readInt(radix);
			if (val == null) this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), { radix });
			const next = this.input.charCodeAt(this.state.pos);
			if (next === 110) {
				++this.state.pos;
				isBigInt = true;
			} else if (next === 109) throw this.raise(Errors.InvalidDecimal, startLoc);
			if (isIdentifierStart(this.codePointAtPos(this.state.pos))) throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
			if (isBigInt) {
				const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
				this.finishToken(136, str);
				return;
			}
			this.finishToken(135, val);
		}
		readNumber(startsWithDot) {
			const start = this.state.pos;
			const startLoc = this.state.curPosition();
			let isFloat = false;
			let isBigInt = false;
			let hasExponent = false;
			let isOctal = false;
			if (!startsWithDot && this.readInt(10) === null) this.raise(Errors.InvalidNumber, this.state.curPosition());
			const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
			if (hasLeadingZero) {
				const integer = this.input.slice(start, this.state.pos);
				this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
				if (!this.state.strict) {
					const underscorePos = integer.indexOf("_");
					if (underscorePos > 0) this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
				}
				isOctal = hasLeadingZero && !/[89]/.test(integer);
			}
			let next = this.input.charCodeAt(this.state.pos);
			if (next === 46 && !isOctal) {
				++this.state.pos;
				this.readInt(10);
				isFloat = true;
				next = this.input.charCodeAt(this.state.pos);
			}
			if ((next === 69 || next === 101) && !isOctal) {
				next = this.input.charCodeAt(++this.state.pos);
				if (next === 43 || next === 45) ++this.state.pos;
				if (this.readInt(10) === null) this.raise(Errors.InvalidOrMissingExponent, startLoc);
				isFloat = true;
				hasExponent = true;
				next = this.input.charCodeAt(this.state.pos);
			}
			if (next === 110) {
				if (isFloat || hasLeadingZero) this.raise(Errors.InvalidBigIntLiteral, startLoc);
				++this.state.pos;
				isBigInt = true;
			}
			if (next === 109) {
				this.expectPlugin("decimal", this.state.curPosition());
				if (hasExponent || hasLeadingZero) this.raise(Errors.InvalidDecimal, startLoc);
				++this.state.pos;
				var isDecimal = true;
			}
			if (isIdentifierStart(this.codePointAtPos(this.state.pos))) throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
			const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
			if (isBigInt) {
				this.finishToken(136, str);
				return;
			}
			if (isDecimal) {
				this.finishToken(137, str);
				return;
			}
			const val = isOctal ? parseInt(str, 8) : parseFloat(str);
			this.finishToken(135, val);
		}
		readCodePoint(throwOnInvalid) {
			const { code: code$1, pos } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
			this.state.pos = pos;
			return code$1;
		}
		readString(quote) {
			const { str, pos, curLine, lineStart } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
			this.state.pos = pos + 1;
			this.state.lineStart = lineStart;
			this.state.curLine = curLine;
			this.finishToken(134, str);
		}
		readTemplateContinuation() {
			if (!this.match(8)) this.unexpected(null, 8);
			this.state.pos--;
			this.readTemplateToken();
		}
		readTemplateToken() {
			const opening = this.input[this.state.pos];
			const { str, firstInvalidLoc, pos, curLine, lineStart } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
			this.state.pos = pos + 1;
			this.state.lineStart = lineStart;
			this.state.curLine = curLine;
			if (firstInvalidLoc) this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
			if (this.input.codePointAt(pos) === 96) this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
			else {
				this.state.pos++;
				this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
			}
		}
		recordStrictModeErrors(toParseError, at) {
			const index = at.index;
			if (this.state.strict && !this.state.strictErrors.has(index)) this.raise(toParseError, at);
			else this.state.strictErrors.set(index, [toParseError, at]);
		}
		readWord1(firstCode) {
			this.state.containsEsc = false;
			let word = "";
			const start = this.state.pos;
			let chunkStart = this.state.pos;
			if (firstCode !== void 0) this.state.pos += firstCode <= 65535 ? 1 : 2;
			while (this.state.pos < this.length) {
				const ch = this.codePointAtPos(this.state.pos);
				if (isIdentifierChar(ch)) this.state.pos += ch <= 65535 ? 1 : 2;
				else if (ch === 92) {
					this.state.containsEsc = true;
					word += this.input.slice(chunkStart, this.state.pos);
					const escStart = this.state.curPosition();
					const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
					if (this.input.charCodeAt(++this.state.pos) !== 117) {
						this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
						chunkStart = this.state.pos - 1;
						continue;
					}
					++this.state.pos;
					const esc = this.readCodePoint(true);
					if (esc !== null) {
						if (!identifierCheck(esc)) this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
						word += String.fromCodePoint(esc);
					}
					chunkStart = this.state.pos;
				} else break;
			}
			return word + this.input.slice(chunkStart, this.state.pos);
		}
		readWord(firstCode) {
			const word = this.readWord1(firstCode);
			const type = keywords$1.get(word);
			if (type !== void 0) this.finishToken(type, tokenLabelName(type));
			else this.finishToken(132, word);
		}
		checkKeywordEscapes() {
			const { type } = this.state;
			if (tokenIsKeyword(type) && this.state.containsEsc) this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: tokenLabelName(type) });
		}
		raise(toParseError, at, details = {}) {
			const loc = at instanceof Position ? at : at.loc.start;
			const error = toParseError(loc, details);
			if (!(this.optionFlags & 2048)) throw error;
			if (!this.isLookahead) this.state.errors.push(error);
			return error;
		}
		raiseOverwrite(toParseError, at, details = {}) {
			const loc = at instanceof Position ? at : at.loc.start;
			const pos = loc.index;
			const errors = this.state.errors;
			for (let i = errors.length - 1; i >= 0; i--) {
				const error = errors[i];
				if (error.loc.index === pos) return errors[i] = toParseError(loc, details);
				if (error.loc.index < pos) break;
			}
			return this.raise(toParseError, at, details);
		}
		updateContext(prevType) {}
		unexpected(loc, type) {
			throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, { expected: type ? tokenLabelName(type) : null });
		}
		expectPlugin(pluginName, loc) {
			if (this.hasPlugin(pluginName)) return true;
			throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, { missingPlugin: [pluginName] });
		}
		expectOnePlugin(pluginNames) {
			if (!pluginNames.some((name) => this.hasPlugin(name))) throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: pluginNames });
		}
		errorBuilder(error) {
			return (pos, lineStart, curLine) => {
				this.raise(error, buildPosition(pos, lineStart, curLine));
			};
		}
	};
	var ClassScope = class {
		constructor() {
			this.privateNames = /* @__PURE__ */ new Set();
			this.loneAccessors = /* @__PURE__ */ new Map();
			this.undefinedPrivateNames = /* @__PURE__ */ new Map();
		}
	};
	var ClassScopeHandler = class {
		constructor(parser$1) {
			this.parser = void 0;
			this.stack = [];
			this.undefinedPrivateNames = /* @__PURE__ */ new Map();
			this.parser = parser$1;
		}
		current() {
			return this.stack[this.stack.length - 1];
		}
		enter() {
			this.stack.push(new ClassScope());
		}
		exit() {
			const oldClassScope = this.stack.pop();
			const current = this.current();
			for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) if (current) {
				if (!current.undefinedPrivateNames.has(name)) current.undefinedPrivateNames.set(name, loc);
			} else this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, { identifierName: name });
		}
		declarePrivateName(name, elementType, loc) {
			const { privateNames, loneAccessors, undefinedPrivateNames } = this.current();
			let redefined = privateNames.has(name);
			if (elementType & 3) {
				const accessor = redefined && loneAccessors.get(name);
				if (accessor) {
					const oldStatic = accessor & 4;
					const newStatic = elementType & 4;
					const oldKind = accessor & 3;
					const newKind = elementType & 3;
					redefined = oldKind === newKind || oldStatic !== newStatic;
					if (!redefined) loneAccessors.delete(name);
				} else if (!redefined) loneAccessors.set(name, elementType);
			}
			if (redefined) this.parser.raise(Errors.PrivateNameRedeclaration, loc, { identifierName: name });
			privateNames.add(name);
			undefinedPrivateNames.delete(name);
		}
		usePrivateName(name, loc) {
			let classScope;
			for (classScope of this.stack) if (classScope.privateNames.has(name)) return;
			if (classScope) classScope.undefinedPrivateNames.set(name, loc);
			else this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, { identifierName: name });
		}
	};
	var ExpressionScope = class {
		constructor(type = 0) {
			this.type = type;
		}
		canBeArrowParameterDeclaration() {
			return this.type === 2 || this.type === 1;
		}
		isCertainlyParameterDeclaration() {
			return this.type === 3;
		}
	};
	var ArrowHeadParsingScope = class extends ExpressionScope {
		constructor(type) {
			super(type);
			this.declarationErrors = /* @__PURE__ */ new Map();
		}
		recordDeclarationError(ParsingErrorClass, at) {
			const index = at.index;
			this.declarationErrors.set(index, [ParsingErrorClass, at]);
		}
		clearDeclarationError(index) {
			this.declarationErrors.delete(index);
		}
		iterateErrors(iterator) {
			this.declarationErrors.forEach(iterator);
		}
	};
	var ExpressionScopeHandler = class {
		constructor(parser$1) {
			this.parser = void 0;
			this.stack = [new ExpressionScope()];
			this.parser = parser$1;
		}
		enter(scope) {
			this.stack.push(scope);
		}
		exit() {
			this.stack.pop();
		}
		recordParameterInitializerError(toParseError, node) {
			const origin = node.loc.start;
			const { stack: stack$1 } = this;
			let i = stack$1.length - 1;
			let scope = stack$1[i];
			while (!scope.isCertainlyParameterDeclaration()) {
				if (scope.canBeArrowParameterDeclaration()) scope.recordDeclarationError(toParseError, origin);
				else return;
				scope = stack$1[--i];
			}
			this.parser.raise(toParseError, origin);
		}
		recordArrowParameterBindingError(error, node) {
			const { stack: stack$1 } = this;
			const scope = stack$1[stack$1.length - 1];
			const origin = node.loc.start;
			if (scope.isCertainlyParameterDeclaration()) this.parser.raise(error, origin);
			else if (scope.canBeArrowParameterDeclaration()) scope.recordDeclarationError(error, origin);
			else return;
		}
		recordAsyncArrowParametersError(at) {
			const { stack: stack$1 } = this;
			let i = stack$1.length - 1;
			let scope = stack$1[i];
			while (scope.canBeArrowParameterDeclaration()) {
				if (scope.type === 2) scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
				scope = stack$1[--i];
			}
		}
		validateAsPattern() {
			const { stack: stack$1 } = this;
			const currentScope = stack$1[stack$1.length - 1];
			if (!currentScope.canBeArrowParameterDeclaration()) return;
			currentScope.iterateErrors(([toParseError, loc]) => {
				this.parser.raise(toParseError, loc);
				let i = stack$1.length - 2;
				let scope = stack$1[i];
				while (scope.canBeArrowParameterDeclaration()) {
					scope.clearDeclarationError(loc.index);
					scope = stack$1[--i];
				}
			});
		}
	};
	function newParameterDeclarationScope() {
		return new ExpressionScope(3);
	}
	function newArrowHeadScope() {
		return new ArrowHeadParsingScope(1);
	}
	function newAsyncArrowScope() {
		return new ArrowHeadParsingScope(2);
	}
	function newExpressionScope() {
		return new ExpressionScope();
	}
	var UtilParser = class extends Tokenizer$1 {
		addExtra(node, key, value, enumerable = true) {
			if (!node) return;
			let { extra } = node;
			if (extra == null) {
				extra = {};
				node.extra = extra;
			}
			if (enumerable) extra[key] = value;
			else Object.defineProperty(extra, key, {
				enumerable,
				value
			});
		}
		isContextual(token) {
			return this.state.type === token && !this.state.containsEsc;
		}
		isUnparsedContextual(nameStart, name) {
			if (this.input.startsWith(name, nameStart)) {
				const nextCh = this.input.charCodeAt(nameStart + name.length);
				return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
			}
			return false;
		}
		isLookaheadContextual(name) {
			const next = this.nextTokenStart();
			return this.isUnparsedContextual(next, name);
		}
		eatContextual(token) {
			if (this.isContextual(token)) {
				this.next();
				return true;
			}
			return false;
		}
		expectContextual(token, toParseError) {
			if (!this.eatContextual(token)) {
				if (toParseError != null) throw this.raise(toParseError, this.state.startLoc);
				this.unexpected(null, token);
			}
		}
		canInsertSemicolon() {
			return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
		}
		hasPrecedingLineBreak() {
			return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
		}
		hasFollowingLineBreak() {
			return hasNewLine(this.input, this.state.end, this.nextTokenStart());
		}
		isLineTerminator() {
			return this.eat(13) || this.canInsertSemicolon();
		}
		semicolon(allowAsi = true) {
			if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
			this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
		}
		expect(type, loc) {
			if (!this.eat(type)) this.unexpected(loc, type);
		}
		tryParse(fn, oldState = this.state.clone()) {
			const abortSignal = { node: null };
			try {
				const node = fn((node$1 = null) => {
					abortSignal.node = node$1;
					throw abortSignal;
				});
				if (this.state.errors.length > oldState.errors.length) {
					const failState = this.state;
					this.state = oldState;
					this.state.tokensLength = failState.tokensLength;
					return {
						node,
						error: failState.errors[oldState.errors.length],
						thrown: false,
						aborted: false,
						failState
					};
				}
				return {
					node,
					error: null,
					thrown: false,
					aborted: false,
					failState: null
				};
			} catch (error) {
				const failState = this.state;
				this.state = oldState;
				if (error instanceof SyntaxError) return {
					node: null,
					error,
					thrown: true,
					aborted: false,
					failState
				};
				if (error === abortSignal) return {
					node: abortSignal.node,
					error: null,
					thrown: false,
					aborted: true,
					failState
				};
				throw error;
			}
		}
		checkExpressionErrors(refExpressionErrors, andThrow) {
			if (!refExpressionErrors) return false;
			const { shorthandAssignLoc, doubleProtoLoc, privateKeyLoc, optionalParametersLoc, voidPatternLoc } = refExpressionErrors;
			const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc || !!voidPatternLoc;
			if (!andThrow) return hasErrors;
			if (shorthandAssignLoc != null) this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
			if (doubleProtoLoc != null) this.raise(Errors.DuplicateProto, doubleProtoLoc);
			if (privateKeyLoc != null) this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
			if (optionalParametersLoc != null) this.unexpected(optionalParametersLoc);
			if (voidPatternLoc != null) this.raise(Errors.InvalidCoverDiscardElement, voidPatternLoc);
		}
		isLiteralPropertyName() {
			return tokenIsLiteralPropertyName(this.state.type);
		}
		isPrivateName(node) {
			return node.type === "PrivateName";
		}
		getPrivateNameSV(node) {
			return node.id.name;
		}
		hasPropertyAsPrivateName(node) {
			return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
		}
		isObjectProperty(node) {
			return node.type === "ObjectProperty";
		}
		isObjectMethod(node) {
			return node.type === "ObjectMethod";
		}
		initializeScopes(inModule = this.options.sourceType === "module") {
			const oldLabels = this.state.labels;
			this.state.labels = [];
			const oldExportedIdentifiers = this.exportedIdentifiers;
			this.exportedIdentifiers = /* @__PURE__ */ new Set();
			const oldInModule = this.inModule;
			this.inModule = inModule;
			const oldScope = this.scope;
			const ScopeHandler$1 = this.getScopeHandler();
			this.scope = new ScopeHandler$1(this, inModule);
			const oldProdParam = this.prodParam;
			this.prodParam = new ProductionParameterHandler();
			const oldClassScope = this.classScope;
			this.classScope = new ClassScopeHandler(this);
			const oldExpressionScope = this.expressionScope;
			this.expressionScope = new ExpressionScopeHandler(this);
			return () => {
				this.state.labels = oldLabels;
				this.exportedIdentifiers = oldExportedIdentifiers;
				this.inModule = oldInModule;
				this.scope = oldScope;
				this.prodParam = oldProdParam;
				this.classScope = oldClassScope;
				this.expressionScope = oldExpressionScope;
			};
		}
		enterInitialScopes() {
			let paramFlags = 0;
			if (this.inModule || this.optionFlags & 1) paramFlags |= 2;
			if (this.optionFlags & 32) paramFlags |= 1;
			const isCommonJS = !this.inModule && this.options.sourceType === "commonjs";
			if (isCommonJS || this.optionFlags & 2) paramFlags |= 4;
			this.prodParam.enter(paramFlags);
			let scopeFlags = isCommonJS ? 514 : 1;
			if (this.optionFlags & 4) scopeFlags |= 512;
			this.scope.enter(scopeFlags);
		}
		checkDestructuringPrivate(refExpressionErrors) {
			const { privateKeyLoc } = refExpressionErrors;
			if (privateKeyLoc !== null) this.expectPlugin("destructuringPrivate", privateKeyLoc);
		}
	};
	var ExpressionErrors = class {
		constructor() {
			this.shorthandAssignLoc = null;
			this.doubleProtoLoc = null;
			this.privateKeyLoc = null;
			this.optionalParametersLoc = null;
			this.voidPatternLoc = null;
		}
	};
	var Node = class {
		constructor(parser$1, pos, loc) {
			this.type = "";
			this.start = pos;
			this.end = 0;
			this.loc = new SourceLocation(loc);
			if ((parser$1 == null ? void 0 : parser$1.optionFlags) & 128) this.range = [pos, 0];
			if (parser$1 != null && parser$1.filename) this.loc.filename = parser$1.filename;
		}
	};
	const NodePrototype = Node.prototype;
	NodePrototype.__clone = function() {
		const newNode = new Node(void 0, this.start, this.loc.start);
		const keys = Object.keys(this);
		for (let i = 0, length = keys.length; i < length; i++) {
			const key = keys[i];
			if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") newNode[key] = this[key];
		}
		return newNode;
	};
	var NodeUtils = class extends UtilParser {
		startNode() {
			const loc = this.state.startLoc;
			return new Node(this, loc.index, loc);
		}
		startNodeAt(loc) {
			return new Node(this, loc.index, loc);
		}
		startNodeAtNode(type) {
			return this.startNodeAt(type.loc.start);
		}
		finishNode(node, type) {
			return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
		}
		finishNodeAt(node, type, endLoc) {
			node.type = type;
			node.end = endLoc.index;
			node.loc.end = endLoc;
			if (this.optionFlags & 128) node.range[1] = endLoc.index;
			if (this.optionFlags & 4096) this.processComment(node);
			return node;
		}
		resetStartLocation(node, startLoc) {
			node.start = startLoc.index;
			node.loc.start = startLoc;
			if (this.optionFlags & 128) node.range[0] = startLoc.index;
		}
		resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
			node.end = endLoc.index;
			node.loc.end = endLoc;
			if (this.optionFlags & 128) node.range[1] = endLoc.index;
		}
		resetStartLocationFromNode(node, locationNode) {
			this.resetStartLocation(node, locationNode.loc.start);
		}
		castNodeTo(node, type) {
			node.type = type;
			return node;
		}
		cloneIdentifier(node) {
			const { type, start, end, loc, range: range$1, name } = node;
			const cloned = Object.create(NodePrototype);
			cloned.type = type;
			cloned.start = start;
			cloned.end = end;
			cloned.loc = loc;
			cloned.range = range$1;
			cloned.name = name;
			if (node.extra) cloned.extra = node.extra;
			return cloned;
		}
		cloneStringLiteral(node) {
			const { type, start, end, loc, range: range$1, extra } = node;
			const cloned = Object.create(NodePrototype);
			cloned.type = type;
			cloned.start = start;
			cloned.end = end;
			cloned.loc = loc;
			cloned.range = range$1;
			cloned.extra = extra;
			cloned.value = node.value;
			return cloned;
		}
	};
	const unwrapParenthesizedExpression = (node) => {
		return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
	};
	var LValParser = class extends NodeUtils {
		toAssignable(node, isLHS = false) {
			var _node$extra, _node$extra3;
			let parenthesized = void 0;
			if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
				parenthesized = unwrapParenthesizedExpression(node);
				if (isLHS) {
					if (parenthesized.type === "Identifier") this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
					else if (parenthesized.type !== "CallExpression" && parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) this.raise(Errors.InvalidParenthesizedAssignment, node);
				} else this.raise(Errors.InvalidParenthesizedAssignment, node);
			}
			switch (node.type) {
				case "Identifier":
				case "ObjectPattern":
				case "ArrayPattern":
				case "AssignmentPattern":
				case "RestElement":
				case "VoidPattern": break;
				case "ObjectExpression":
					this.castNodeTo(node, "ObjectPattern");
					for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
						var _node$extra2;
						const prop = node.properties[i];
						const isLast = i === last;
						this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
						if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
					}
					break;
				case "ObjectProperty": {
					const { key, value } = node;
					if (this.isPrivateName(key)) this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
					this.toAssignable(value, isLHS);
					break;
				}
				case "SpreadElement": throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
				case "ArrayExpression":
					this.castNodeTo(node, "ArrayPattern");
					this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
					break;
				case "AssignmentExpression":
					if (node.operator !== "=") this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
					this.castNodeTo(node, "AssignmentPattern");
					delete node.operator;
					if (node.left.type === "VoidPattern") this.raise(Errors.VoidPatternInitializer, node.left);
					this.toAssignable(node.left, isLHS);
					break;
				case "ParenthesizedExpression":
					this.toAssignable(parenthesized, isLHS);
					break;
			}
		}
		toAssignableObjectExpressionProp(prop, isLast, isLHS) {
			if (prop.type === "ObjectMethod") this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
			else if (prop.type === "SpreadElement") {
				this.castNodeTo(prop, "RestElement");
				const arg = prop.argument;
				this.checkToRestConversion(arg, false);
				this.toAssignable(arg, isLHS);
				if (!isLast) this.raise(Errors.RestTrailingComma, prop);
			} else this.toAssignable(prop, isLHS);
		}
		toAssignableList(exprList, trailingCommaLoc, isLHS) {
			const end = exprList.length - 1;
			for (let i = 0; i <= end; i++) {
				const elt = exprList[i];
				if (!elt) continue;
				this.toAssignableListItem(exprList, i, isLHS);
				if (elt.type === "RestElement") {
					if (i < end) this.raise(Errors.RestTrailingComma, elt);
					else if (trailingCommaLoc) this.raise(Errors.RestTrailingComma, trailingCommaLoc);
				}
			}
		}
		toAssignableListItem(exprList, index, isLHS) {
			const node = exprList[index];
			if (node.type === "SpreadElement") {
				this.castNodeTo(node, "RestElement");
				const arg = node.argument;
				this.checkToRestConversion(arg, true);
				this.toAssignable(arg, isLHS);
			} else this.toAssignable(node, isLHS);
		}
		isAssignable(node, isBinding) {
			switch (node.type) {
				case "Identifier":
				case "ObjectPattern":
				case "ArrayPattern":
				case "AssignmentPattern":
				case "RestElement":
				case "VoidPattern": return true;
				case "ObjectExpression": {
					const last = node.properties.length - 1;
					return node.properties.every((prop, i) => {
						return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
					});
				}
				case "ObjectProperty": return this.isAssignable(node.value);
				case "SpreadElement": return this.isAssignable(node.argument);
				case "ArrayExpression": return node.elements.every((element) => element === null || this.isAssignable(element));
				case "AssignmentExpression": return node.operator === "=";
				case "ParenthesizedExpression": return this.isAssignable(node.expression);
				case "MemberExpression":
				case "OptionalMemberExpression": return !isBinding;
				default: return false;
			}
		}
		toReferencedList(exprList, isParenthesizedExpr) {
			return exprList;
		}
		toReferencedListDeep(exprList, isParenthesizedExpr) {
			this.toReferencedList(exprList, isParenthesizedExpr);
			for (const expr of exprList) if ((expr == null ? void 0 : expr.type) === "ArrayExpression") this.toReferencedListDeep(expr.elements);
		}
		parseSpread(refExpressionErrors) {
			const node = this.startNode();
			this.next();
			node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
			return this.finishNode(node, "SpreadElement");
		}
		parseRestBinding() {
			const node = this.startNode();
			this.next();
			const argument = this.parseBindingAtom();
			if (argument.type === "VoidPattern") this.raise(Errors.UnexpectedVoidPattern, argument);
			node.argument = argument;
			return this.finishNode(node, "RestElement");
		}
		parseBindingAtom() {
			switch (this.state.type) {
				case 0: {
					const node = this.startNode();
					this.next();
					node.elements = this.parseBindingList(3, 93, 1);
					return this.finishNode(node, "ArrayPattern");
				}
				case 5: return this.parseObjectLike(8, true);
				case 88: return this.parseVoidPattern(null);
			}
			return this.parseIdentifier();
		}
		parseBindingList(close, closeCharCode, flags) {
			const allowEmpty = flags & 1;
			const elts = [];
			let first = true;
			while (!this.eat(close)) {
				if (first) first = false;
				else this.expect(12);
				if (allowEmpty && this.match(12)) elts.push(null);
				else if (this.eat(close)) break;
				else if (this.match(21)) {
					let rest = this.parseRestBinding();
					if (this.hasPlugin("flow") || flags & 2) rest = this.parseFunctionParamType(rest);
					elts.push(rest);
					if (!this.checkCommaAfterRest(closeCharCode)) {
						this.expect(close);
						break;
					}
				} else {
					const decorators = [];
					if (flags & 2) {
						if (this.match(26) && this.hasPlugin("decorators")) this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
						while (this.match(26)) decorators.push(this.parseDecorator());
					}
					elts.push(this.parseBindingElement(flags, decorators));
				}
			}
			return elts;
		}
		parseBindingRestProperty(prop) {
			this.next();
			if (this.hasPlugin("discardBinding") && this.match(88)) {
				prop.argument = this.parseVoidPattern(null);
				this.raise(Errors.UnexpectedVoidPattern, prop.argument);
			} else prop.argument = this.parseIdentifier();
			this.checkCommaAfterRest(125);
			return this.finishNode(prop, "RestElement");
		}
		parseBindingProperty() {
			const { type, startLoc } = this.state;
			if (type === 21) return this.parseBindingRestProperty(this.startNode());
			const prop = this.startNode();
			if (type === 139) {
				this.expectPlugin("destructuringPrivate", startLoc);
				this.classScope.usePrivateName(this.state.value, startLoc);
				prop.key = this.parsePrivateName();
			} else this.parsePropertyName(prop);
			prop.method = false;
			return this.parseObjPropValue(prop, startLoc, false, false, true, false);
		}
		parseBindingElement(flags, decorators) {
			const left = this.parseMaybeDefault();
			if (this.hasPlugin("flow") || flags & 2) this.parseFunctionParamType(left);
			if (decorators.length) {
				left.decorators = decorators;
				this.resetStartLocationFromNode(left, decorators[0]);
			}
			const elt = this.parseMaybeDefault(left.loc.start, left);
			return elt;
		}
		parseFunctionParamType(param) {
			return param;
		}
		parseMaybeDefault(startLoc, left) {
			startLoc != null || (startLoc = this.state.startLoc);
			left = left != null ? left : this.parseBindingAtom();
			if (!this.eat(29)) return left;
			const node = this.startNodeAt(startLoc);
			if (left.type === "VoidPattern") this.raise(Errors.VoidPatternInitializer, left);
			node.left = left;
			node.right = this.parseMaybeAssignAllowIn();
			return this.finishNode(node, "AssignmentPattern");
		}
		isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {
			switch (type) {
				case "AssignmentPattern": return "left";
				case "RestElement": return "argument";
				case "ObjectProperty": return "value";
				case "ParenthesizedExpression": return "expression";
				case "ArrayPattern": return "elements";
				case "ObjectPattern": return "properties";
				case "VoidPattern": return true;
				case "CallExpression": if (!disallowCallExpression && !this.state.strict && this.optionFlags & 8192) return true;
			}
			return false;
		}
		isOptionalMemberExpression(expression) {
			return expression.type === "OptionalMemberExpression";
		}
		checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false, disallowCallExpression = false) {
			var _expression$extra;
			const type = expression.type;
			if (this.isObjectMethod(expression)) return;
			const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
			if (isOptionalMemberExpression || type === "MemberExpression") {
				if (isOptionalMemberExpression) {
					this.expectPlugin("optionalChainingAssign", expression.loc.start);
					if (ancestor.type !== "AssignmentExpression") this.raise(Errors.InvalidLhsOptionalChaining, expression, { ancestor });
				}
				if (binding !== 64) this.raise(Errors.InvalidPropertyBindingPattern, expression);
				return;
			}
			if (type === "Identifier") {
				this.checkIdentifier(expression, binding, strictModeChanged);
				const { name } = expression;
				if (checkClashes) if (checkClashes.has(name)) this.raise(Errors.ParamDupe, expression);
				else checkClashes.add(name);
				return;
			} else if (type === "VoidPattern" && ancestor.type === "CatchClause") this.raise(Errors.VoidPatternCatchClauseParam, expression);
			const unwrappedExpression = unwrapParenthesizedExpression(expression);
			disallowCallExpression || (disallowCallExpression = unwrappedExpression.type === "CallExpression" && (unwrappedExpression.callee.type === "Import" || unwrappedExpression.callee.type === "Super"));
			const validity = this.isValidLVal(type, disallowCallExpression, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
			if (validity === true) return;
			if (validity === false) {
				const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
				this.raise(ParseErrorClass, expression, { ancestor });
				return;
			}
			let key, isParenthesizedExpression;
			if (typeof validity === "string") {
				key = validity;
				isParenthesizedExpression = type === "ParenthesizedExpression";
			} else [key, isParenthesizedExpression] = validity;
			const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? { type } : ancestor;
			const val = expression[key];
			if (Array.isArray(val)) {
				for (const child of val) if (child) this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression, true);
			} else if (val) this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression, disallowCallExpression);
		}
		checkIdentifier(at, bindingType, strictModeChanged = false) {
			if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) if (bindingType === 64) this.raise(Errors.StrictEvalArguments, at, { referenceName: at.name });
			else this.raise(Errors.StrictEvalArgumentsBinding, at, { bindingName: at.name });
			if (bindingType & 8192 && at.name === "let") this.raise(Errors.LetInLexicalBinding, at);
			if (!(bindingType & 64)) this.declareNameFromIdentifier(at, bindingType);
		}
		declareNameFromIdentifier(identifier, binding) {
			this.scope.declareName(identifier.name, binding, identifier.loc.start);
		}
		checkToRestConversion(node, allowPattern) {
			switch (node.type) {
				case "ParenthesizedExpression":
					this.checkToRestConversion(node.expression, allowPattern);
					break;
				case "Identifier":
				case "MemberExpression": break;
				case "ArrayExpression":
				case "ObjectExpression": if (allowPattern) break;
				default: this.raise(Errors.InvalidRestAssignmentPattern, node);
			}
		}
		checkCommaAfterRest(close) {
			if (!this.match(12)) return false;
			this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
			return true;
		}
	};
	const keywordAndTSRelationalOperator = /in(?:stanceof)?|as|satisfies/y;
	function nonNull(x) {
		if (x == null) throw new Error(`Unexpected ${x} value.`);
		return x;
	}
	function assert$1(x) {
		if (!x) throw new Error("Assert fail");
	}
	const TSErrors = ParseErrorEnum`typescript`({
		AbstractMethodHasImplementation: ({ methodName }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
		AbstractPropertyHasInitializer: ({ propertyName }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
		AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
		AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
		AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
		ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
		ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
		ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
		ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
		DeclareAccessor: ({ kind }) => `'declare' is not allowed in ${kind}ters.`,
		DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
		DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
		DuplicateAccessibilityModifier: ({ modifier }) => `Accessibility modifier already seen: '${modifier}'.`,
		DuplicateModifier: ({ modifier }) => `Duplicate modifier: '${modifier}'.`,
		EmptyHeritageClauseType: ({ token }) => `'${token}' list cannot be empty.`,
		EmptyTypeArguments: "Type argument list cannot be empty.",
		EmptyTypeParameters: "Type parameter list cannot be empty.",
		ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
		ImportAliasHasImportType: "An import alias can not use 'import type'.",
		ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
		IncompatibleModifiers: ({ modifiers }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
		IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
		IndexSignatureHasAccessibility: ({ modifier }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
		IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
		IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
		IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
		InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
		InvalidHeritageClauseType: ({ token }) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,
		InvalidModifierOnAwaitUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on an await using declaration.`,
		InvalidModifierOnTypeMember: ({ modifier }) => `'${modifier}' modifier cannot appear on a type member.`,
		InvalidModifierOnTypeParameter: ({ modifier }) => `'${modifier}' modifier cannot appear on a type parameter.`,
		InvalidModifierOnTypeParameterPositions: ({ modifier }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
		InvalidModifierOnUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on a using declaration.`,
		InvalidModifiersOrder: ({ orderedModifiers }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
		InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
		InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
		MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
		NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
		NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.",
		OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
		OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
		PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
		PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
		PrivateElementHasAccessibility: ({ modifier }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
		ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
		ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
		ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
		SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
		SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
		SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
		SingleTypeParameterWithoutTrailingComma: ({ typeParameterName }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
		StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
		TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
		TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
		TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
		TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
		TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
		UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
		UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
		UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
		UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
		UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
		UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
		UnsupportedSignatureParameterKind: ({ type }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
		UsingDeclarationInAmbientContext: (kind) => `'${kind}' declarations are not allowed in ambient contexts.`
	});
	function keywordTypeFromName(value) {
		switch (value) {
			case "any": return "TSAnyKeyword";
			case "boolean": return "TSBooleanKeyword";
			case "bigint": return "TSBigIntKeyword";
			case "never": return "TSNeverKeyword";
			case "number": return "TSNumberKeyword";
			case "object": return "TSObjectKeyword";
			case "string": return "TSStringKeyword";
			case "symbol": return "TSSymbolKeyword";
			case "undefined": return "TSUndefinedKeyword";
			case "unknown": return "TSUnknownKeyword";
			default: return void 0;
		}
	}
	function tsIsAccessModifier(modifier) {
		return modifier === "private" || modifier === "public" || modifier === "protected";
	}
	function tsIsVarianceAnnotations(modifier) {
		return modifier === "in" || modifier === "out";
	}
	var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
		constructor(...args) {
			super(...args);
			this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
				allowedModifiers: ["in", "out"],
				disallowedModifiers: [
					"const",
					"public",
					"private",
					"protected",
					"readonly",
					"declare",
					"abstract",
					"override"
				],
				errorTemplate: TSErrors.InvalidModifierOnTypeParameter
			});
			this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
				allowedModifiers: ["const"],
				disallowedModifiers: ["in", "out"],
				errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
			});
			this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
				allowedModifiers: [
					"in",
					"out",
					"const"
				],
				disallowedModifiers: [
					"public",
					"private",
					"protected",
					"readonly",
					"declare",
					"abstract",
					"override"
				],
				errorTemplate: TSErrors.InvalidModifierOnTypeParameter
			});
		}
		getScopeHandler() {
			return TypeScriptScopeHandler;
		}
		tsIsIdentifier() {
			return tokenIsIdentifier(this.state.type);
		}
		tsTokenCanFollowModifier() {
			return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
		}
		tsNextTokenOnSameLineAndCanFollowModifier() {
			this.next();
			if (this.hasPrecedingLineBreak()) return false;
			return this.tsTokenCanFollowModifier();
		}
		tsNextTokenCanFollowModifier() {
			if (this.match(106)) {
				this.next();
				return this.tsTokenCanFollowModifier();
			}
			return this.tsNextTokenOnSameLineAndCanFollowModifier();
		}
		tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
			if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return void 0;
			const modifier = this.state.value;
			if (allowedModifiers.includes(modifier)) {
				if (hasSeenStaticModifier && this.match(106)) return void 0;
				if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) return void 0;
				if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return modifier;
			}
			return void 0;
		}
		tsParseModifiers({ allowedModifiers, disallowedModifiers, stopOnStartOfClassStaticBlock, errorTemplate = TSErrors.InvalidModifierOnTypeMember }, modified) {
			const enforceOrder = (loc, modifier, before, after) => {
				if (modifier === before && modified[after]) this.raise(TSErrors.InvalidModifiersOrder, loc, { orderedModifiers: [before, after] });
			};
			const incompatible = (loc, modifier, mod1, mod2) => {
				if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) this.raise(TSErrors.IncompatibleModifiers, loc, { modifiers: [mod1, mod2] });
			};
			for (;;) {
				const { startLoc } = this.state;
				const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock, modified.static);
				if (!modifier) break;
				if (tsIsAccessModifier(modifier)) if (modified.accessibility) this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, { modifier });
				else {
					enforceOrder(startLoc, modifier, modifier, "override");
					enforceOrder(startLoc, modifier, modifier, "static");
					enforceOrder(startLoc, modifier, modifier, "readonly");
					modified.accessibility = modifier;
				}
				else if (tsIsVarianceAnnotations(modifier)) {
					if (modified[modifier]) this.raise(TSErrors.DuplicateModifier, startLoc, { modifier });
					modified[modifier] = true;
					enforceOrder(startLoc, modifier, "in", "out");
				} else {
					if (hasOwnProperty.call(modified, modifier)) this.raise(TSErrors.DuplicateModifier, startLoc, { modifier });
					else {
						enforceOrder(startLoc, modifier, "static", "readonly");
						enforceOrder(startLoc, modifier, "static", "override");
						enforceOrder(startLoc, modifier, "override", "readonly");
						enforceOrder(startLoc, modifier, "abstract", "override");
						incompatible(startLoc, modifier, "declare", "override");
						incompatible(startLoc, modifier, "static", "abstract");
					}
					modified[modifier] = true;
				}
				if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) this.raise(errorTemplate, startLoc, { modifier });
			}
		}
		tsIsListTerminator(kind) {
			switch (kind) {
				case "EnumMembers":
				case "TypeMembers": return this.match(8);
				case "HeritageClauseElement": return this.match(5);
				case "TupleElementTypes": return this.match(3);
				case "TypeParametersOrArguments": return this.match(48);
			}
		}
		tsParseList(kind, parseElement) {
			const result = [];
			while (!this.tsIsListTerminator(kind)) result.push(parseElement());
			return result;
		}
		tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
			return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
		}
		tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
			const result = [];
			let trailingCommaPos = -1;
			for (;;) {
				if (this.tsIsListTerminator(kind)) break;
				trailingCommaPos = -1;
				const element = parseElement();
				if (element == null) return void 0;
				result.push(element);
				if (this.eat(12)) {
					trailingCommaPos = this.state.lastTokStartLoc.index;
					continue;
				}
				if (this.tsIsListTerminator(kind)) break;
				if (expectSuccess) this.expect(12);
				return void 0;
			}
			if (refTrailingCommaPos) refTrailingCommaPos.value = trailingCommaPos;
			return result;
		}
		tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
			if (!skipFirstToken) if (bracket) this.expect(0);
			else this.expect(47);
			const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
			if (bracket) this.expect(3);
			else this.expect(48);
			return result;
		}
		tsParseImportType() {
			const node = this.startNode();
			this.expect(83);
			this.expect(10);
			if (!this.match(134)) {
				this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
				node.argument = super.parseExprAtom();
			} else node.argument = this.parseStringLiteral(this.state.value);
			if (this.eat(12)) node.options = this.tsParseImportTypeOptions();
			else node.options = null;
			this.expect(11);
			if (this.eat(16)) node.qualifier = this.tsParseEntityName(3);
			if (this.match(47)) node.typeParameters = this.tsParseTypeArguments();
			return this.finishNode(node, "TSImportType");
		}
		tsParseImportTypeOptions() {
			const node = this.startNode();
			this.expect(5);
			const withProperty = this.startNode();
			if (this.isContextual(76)) {
				withProperty.method = false;
				withProperty.key = this.parseIdentifier(true);
				withProperty.computed = false;
				withProperty.shorthand = false;
			} else this.unexpected(null, 76);
			this.expect(14);
			withProperty.value = this.tsParseImportTypeWithPropertyValue();
			node.properties = [this.finishObjectProperty(withProperty)];
			this.eat(12);
			this.expect(8);
			return this.finishNode(node, "ObjectExpression");
		}
		tsParseImportTypeWithPropertyValue() {
			const node = this.startNode();
			const properties = [];
			this.expect(5);
			while (!this.match(8)) {
				const type = this.state.type;
				if (tokenIsIdentifier(type) || type === 134) properties.push(super.parsePropertyDefinition(null));
				else this.unexpected();
				this.eat(12);
			}
			node.properties = properties;
			this.next();
			return this.finishNode(node, "ObjectExpression");
		}
		tsParseEntityName(flags) {
			let entity;
			if (flags & 1 && this.match(78)) if (flags & 2) entity = this.parseIdentifier(true);
			else {
				const node = this.startNode();
				this.next();
				entity = this.finishNode(node, "ThisExpression");
			}
			else entity = this.parseIdentifier(!!(flags & 1));
			while (this.eat(16)) {
				const node = this.startNodeAtNode(entity);
				node.left = entity;
				node.right = this.parseIdentifier(!!(flags & 1));
				entity = this.finishNode(node, "TSQualifiedName");
			}
			return entity;
		}
		tsParseTypeReference() {
			const node = this.startNode();
			node.typeName = this.tsParseEntityName(1);
			if (!this.hasPrecedingLineBreak() && this.match(47)) node.typeParameters = this.tsParseTypeArguments();
			return this.finishNode(node, "TSTypeReference");
		}
		tsParseThisTypePredicate(lhs) {
			this.next();
			const node = this.startNodeAtNode(lhs);
			node.parameterName = lhs;
			node.typeAnnotation = this.tsParseTypeAnnotation(false);
			node.asserts = false;
			return this.finishNode(node, "TSTypePredicate");
		}
		tsParseThisTypeNode() {
			const node = this.startNode();
			this.next();
			return this.finishNode(node, "TSThisType");
		}
		tsParseTypeQuery() {
			const node = this.startNode();
			this.expect(87);
			if (this.match(83)) node.exprName = this.tsParseImportType();
			else node.exprName = this.tsParseEntityName(3);
			if (!this.hasPrecedingLineBreak() && this.match(47)) node.typeParameters = this.tsParseTypeArguments();
			return this.finishNode(node, "TSTypeQuery");
		}
		tsParseTypeParameter(parseModifiers) {
			const node = this.startNode();
			parseModifiers(node);
			node.name = this.tsParseTypeParameterName();
			node.constraint = this.tsEatThenParseType(81);
			node.default = this.tsEatThenParseType(29);
			return this.finishNode(node, "TSTypeParameter");
		}
		tsTryParseTypeParameters(parseModifiers) {
			if (this.match(47)) return this.tsParseTypeParameters(parseModifiers);
		}
		tsParseTypeParameters(parseModifiers) {
			const node = this.startNode();
			if (this.match(47) || this.match(143)) this.next();
			else this.unexpected();
			const refTrailingCommaPos = { value: -1 };
			node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
			if (node.params.length === 0) this.raise(TSErrors.EmptyTypeParameters, node);
			if (refTrailingCommaPos.value !== -1) this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
			return this.finishNode(node, "TSTypeParameterDeclaration");
		}
		tsFillSignature(returnToken, signature) {
			const returnTokenRequired = returnToken === 19;
			const paramsKey = "parameters";
			const returnTypeKey = "typeAnnotation";
			signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
			this.expect(10);
			signature[paramsKey] = this.tsParseBindingListForSignature();
			if (returnTokenRequired) signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
			else if (this.match(returnToken)) signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
		}
		tsParseBindingListForSignature() {
			const list = super.parseBindingList(11, 41, 2);
			for (const pattern of list) {
				const { type } = pattern;
				if (type === "AssignmentPattern" || type === "TSParameterProperty") this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, { type });
			}
			return list;
		}
		tsParseTypeMemberSemicolon() {
			if (!this.eat(12) && !this.isLineTerminator()) this.expect(13);
		}
		tsParseSignatureMember(kind, node) {
			this.tsFillSignature(14, node);
			this.tsParseTypeMemberSemicolon();
			return this.finishNode(node, kind);
		}
		tsIsUnambiguouslyIndexSignature() {
			this.next();
			if (tokenIsIdentifier(this.state.type)) {
				this.next();
				return this.match(14);
			}
			return false;
		}
		tsTryParseIndexSignature(node) {
			if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return;
			this.expect(0);
			const id = this.parseIdentifier();
			id.typeAnnotation = this.tsParseTypeAnnotation();
			this.resetEndLocation(id);
			this.expect(3);
			node.parameters = [id];
			const type = this.tsTryParseTypeAnnotation();
			if (type) node.typeAnnotation = type;
			this.tsParseTypeMemberSemicolon();
			return this.finishNode(node, "TSIndexSignature");
		}
		tsParsePropertyOrMethodSignature(node, readonly) {
			if (this.eat(17)) node.optional = true;
			if (this.match(10) || this.match(47)) {
				if (readonly) this.raise(TSErrors.ReadonlyForMethodSignature, node);
				const method = node;
				if (method.kind && this.match(47)) this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
				this.tsFillSignature(14, method);
				this.tsParseTypeMemberSemicolon();
				const paramsKey = "parameters";
				const returnTypeKey = "typeAnnotation";
				if (method.kind === "get") {
					if (method[paramsKey].length > 0) {
						this.raise(Errors.BadGetterArity, this.state.curPosition());
						if (this.isThisParam(method[paramsKey][0])) this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
					}
				} else if (method.kind === "set") {
					if (method[paramsKey].length !== 1) this.raise(Errors.BadSetterArity, this.state.curPosition());
					else {
						const firstParameter = method[paramsKey][0];
						if (this.isThisParam(firstParameter)) this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
						if (firstParameter.type === "Identifier" && firstParameter.optional) this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
						if (firstParameter.type === "RestElement") this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
					}
					if (method[returnTypeKey]) this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
				} else method.kind = "method";
				return this.finishNode(method, "TSMethodSignature");
			} else {
				const property = node;
				if (readonly) property.readonly = true;
				const type = this.tsTryParseTypeAnnotation();
				if (type) property.typeAnnotation = type;
				this.tsParseTypeMemberSemicolon();
				return this.finishNode(property, "TSPropertySignature");
			}
		}
		tsParseTypeMember() {
			const node = this.startNode();
			if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
			if (this.match(77)) {
				const id = this.startNode();
				this.next();
				if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
				else {
					node.key = this.createIdentifier(id, "new");
					return this.tsParsePropertyOrMethodSignature(node, false);
				}
			}
			this.tsParseModifiers({
				allowedModifiers: ["readonly"],
				disallowedModifiers: [
					"declare",
					"abstract",
					"private",
					"protected",
					"public",
					"static",
					"override"
				]
			}, node);
			const idx = this.tsTryParseIndexSignature(node);
			if (idx) return idx;
			super.parsePropertyName(node);
			if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
				node.kind = node.key.name;
				super.parsePropertyName(node);
				if (!this.match(10) && !this.match(47)) this.unexpected(null, 10);
			}
			return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
		}
		tsParseTypeLiteral() {
			const node = this.startNode();
			node.members = this.tsParseObjectTypeMembers();
			return this.finishNode(node, "TSTypeLiteral");
		}
		tsParseObjectTypeMembers() {
			this.expect(5);
			const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
			this.expect(8);
			return members;
		}
		tsIsStartOfMappedType() {
			this.next();
			if (this.eat(53)) return this.isContextual(122);
			if (this.isContextual(122)) this.next();
			if (!this.match(0)) return false;
			this.next();
			if (!this.tsIsIdentifier()) return false;
			this.next();
			return this.match(58);
		}
		tsParseMappedType() {
			const node = this.startNode();
			this.expect(5);
			if (this.match(53)) {
				node.readonly = this.state.value;
				this.next();
				this.expectContextual(122);
			} else if (this.eatContextual(122)) node.readonly = true;
			this.expect(0);
			{
				const typeParameter = this.startNode();
				typeParameter.name = this.tsParseTypeParameterName();
				typeParameter.constraint = this.tsExpectThenParseType(58);
				node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
			}
			node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
			this.expect(3);
			if (this.match(53)) {
				node.optional = this.state.value;
				this.next();
				this.expect(17);
			} else if (this.eat(17)) node.optional = true;
			node.typeAnnotation = this.tsTryParseType();
			this.semicolon();
			this.expect(8);
			return this.finishNode(node, "TSMappedType");
		}
		tsParseTupleType() {
			const node = this.startNode();
			node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
			let seenOptionalElement = false;
			node.elementTypes.forEach((elementNode) => {
				const { type } = elementNode;
				if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
				seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
			});
			return this.finishNode(node, "TSTupleType");
		}
		tsParseTupleElementType() {
			const restStartLoc = this.state.startLoc;
			const rest = this.eat(21);
			const { startLoc } = this.state;
			let labeled;
			let label;
			let optional;
			let type;
			const isWord = tokenIsKeywordOrIdentifier(this.state.type);
			const chAfterWord = isWord ? this.lookaheadCharCode() : null;
			if (chAfterWord === 58) {
				labeled = true;
				optional = false;
				label = this.parseIdentifier(true);
				this.expect(14);
				type = this.tsParseType();
			} else if (chAfterWord === 63) {
				optional = true;
				const wordName = this.state.value;
				const typeOrLabel = this.tsParseNonArrayType();
				if (this.lookaheadCharCode() === 58) {
					labeled = true;
					label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
					this.expect(17);
					this.expect(14);
					type = this.tsParseType();
				} else {
					labeled = false;
					type = typeOrLabel;
					this.expect(17);
				}
			} else {
				type = this.tsParseType();
				optional = this.eat(17);
				labeled = this.eat(14);
			}
			if (labeled) {
				let labeledNode;
				if (label) {
					labeledNode = this.startNodeAt(startLoc);
					labeledNode.optional = optional;
					labeledNode.label = label;
					labeledNode.elementType = type;
					if (this.eat(17)) {
						labeledNode.optional = true;
						this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
					}
				} else {
					labeledNode = this.startNodeAt(startLoc);
					labeledNode.optional = optional;
					this.raise(TSErrors.InvalidTupleMemberLabel, type);
					labeledNode.label = type;
					labeledNode.elementType = this.tsParseType();
				}
				type = this.finishNode(labeledNode, "TSNamedTupleMember");
			} else if (optional) {
				const optionalTypeNode = this.startNodeAt(startLoc);
				optionalTypeNode.typeAnnotation = type;
				type = this.finishNode(optionalTypeNode, "TSOptionalType");
			}
			if (rest) {
				const restNode = this.startNodeAt(restStartLoc);
				restNode.typeAnnotation = type;
				type = this.finishNode(restNode, "TSRestType");
			}
			return type;
		}
		tsParseParenthesizedType() {
			const node = this.startNode();
			this.expect(10);
			node.typeAnnotation = this.tsParseType();
			this.expect(11);
			return this.finishNode(node, "TSParenthesizedType");
		}
		tsParseFunctionOrConstructorType(type, abstract) {
			const node = this.startNode();
			if (type === "TSConstructorType") {
				node.abstract = !!abstract;
				if (abstract) this.next();
				this.next();
			}
			this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
			return this.finishNode(node, type);
		}
		tsParseLiteralTypeNode() {
			const node = this.startNode();
			switch (this.state.type) {
				case 135:
				case 136:
				case 134:
				case 85:
				case 86:
					node.literal = super.parseExprAtom();
					break;
				default: this.unexpected();
			}
			return this.finishNode(node, "TSLiteralType");
		}
		tsParseTemplateLiteralType() {
			{
				const node = this.startNode();
				node.literal = super.parseTemplate(false);
				return this.finishNode(node, "TSLiteralType");
			}
		}
		parseTemplateSubstitution() {
			if (this.state.inType) return this.tsParseType();
			return super.parseTemplateSubstitution();
		}
		tsParseThisTypeOrThisTypePredicate() {
			const thisKeyword = this.tsParseThisTypeNode();
			if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.tsParseThisTypePredicate(thisKeyword);
			else return thisKeyword;
		}
		tsParseNonArrayType() {
			switch (this.state.type) {
				case 134:
				case 135:
				case 136:
				case 85:
				case 86: return this.tsParseLiteralTypeNode();
				case 53:
					if (this.state.value === "-") {
						const node = this.startNode();
						const nextToken = this.lookahead();
						if (nextToken.type !== 135 && nextToken.type !== 136) this.unexpected();
						node.literal = this.parseMaybeUnary();
						return this.finishNode(node, "TSLiteralType");
					}
					break;
				case 78: return this.tsParseThisTypeOrThisTypePredicate();
				case 87: return this.tsParseTypeQuery();
				case 83: return this.tsParseImportType();
				case 5: return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
				case 0: return this.tsParseTupleType();
				case 10: return this.tsParseParenthesizedType();
				case 25:
				case 24: return this.tsParseTemplateLiteralType();
				default: {
					const { type } = this.state;
					if (tokenIsIdentifier(type) || type === 88 || type === 84) {
						const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
						if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
							const node = this.startNode();
							this.next();
							return this.finishNode(node, nodeType);
						}
						return this.tsParseTypeReference();
					}
				}
			}
			throw this.unexpected();
		}
		tsParseArrayTypeOrHigher() {
			const { startLoc } = this.state;
			let type = this.tsParseNonArrayType();
			while (!this.hasPrecedingLineBreak() && this.eat(0)) if (this.match(3)) {
				const node = this.startNodeAt(startLoc);
				node.elementType = type;
				this.expect(3);
				type = this.finishNode(node, "TSArrayType");
			} else {
				const node = this.startNodeAt(startLoc);
				node.objectType = type;
				node.indexType = this.tsParseType();
				this.expect(3);
				type = this.finishNode(node, "TSIndexedAccessType");
			}
			return type;
		}
		tsParseTypeOperator() {
			const node = this.startNode();
			const operator = this.state.value;
			this.next();
			node.operator = operator;
			node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
			if (operator === "readonly") this.tsCheckTypeAnnotationForReadOnly(node);
			return this.finishNode(node, "TSTypeOperator");
		}
		tsCheckTypeAnnotationForReadOnly(node) {
			switch (node.typeAnnotation.type) {
				case "TSTupleType":
				case "TSArrayType": return;
				default: this.raise(TSErrors.UnexpectedReadonly, node);
			}
		}
		tsParseInferType() {
			const node = this.startNode();
			this.expectContextual(115);
			const typeParameter = this.startNode();
			typeParameter.name = this.tsParseTypeParameterName();
			typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
			node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
			return this.finishNode(node, "TSInferType");
		}
		tsParseConstraintForInferType() {
			if (this.eat(81)) {
				const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
				if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return constraint;
			}
		}
		tsParseTypeOperatorOrHigher() {
			const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
			return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
		}
		tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
			const node = this.startNode();
			const hasLeadingOperator = this.eat(operator);
			const types$1 = [];
			do
				types$1.push(parseConstituentType());
			while (this.eat(operator));
			if (types$1.length === 1 && !hasLeadingOperator) return types$1[0];
			node.types = types$1;
			return this.finishNode(node, kind);
		}
		tsParseIntersectionTypeOrHigher() {
			return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
		}
		tsParseUnionTypeOrHigher() {
			return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
		}
		tsIsStartOfFunctionType() {
			if (this.match(47)) return true;
			return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
		}
		tsSkipParameterStart() {
			if (tokenIsIdentifier(this.state.type) || this.match(78)) {
				this.next();
				return true;
			}
			if (this.match(5)) {
				const { errors } = this.state;
				const previousErrorCount = errors.length;
				try {
					this.parseObjectLike(8, true);
					return errors.length === previousErrorCount;
				} catch (_unused) {
					return false;
				}
			}
			if (this.match(0)) {
				this.next();
				const { errors } = this.state;
				const previousErrorCount = errors.length;
				try {
					super.parseBindingList(3, 93, 1);
					return errors.length === previousErrorCount;
				} catch (_unused2) {
					return false;
				}
			}
			return false;
		}
		tsIsUnambiguouslyStartOfFunctionType() {
			this.next();
			if (this.match(11) || this.match(21)) return true;
			if (this.tsSkipParameterStart()) {
				if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) return true;
				if (this.match(11)) {
					this.next();
					if (this.match(19)) return true;
				}
			}
			return false;
		}
		tsParseTypeOrTypePredicateAnnotation(returnToken) {
			return this.tsInType(() => {
				const t = this.startNode();
				this.expect(returnToken);
				const node = this.startNode();
				const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
				if (asserts && this.match(78)) {
					let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
					if (thisTypePredicate.type === "TSThisType") {
						node.parameterName = thisTypePredicate;
						node.asserts = true;
						node.typeAnnotation = null;
						thisTypePredicate = this.finishNode(node, "TSTypePredicate");
					} else {
						this.resetStartLocationFromNode(thisTypePredicate, node);
						thisTypePredicate.asserts = true;
					}
					t.typeAnnotation = thisTypePredicate;
					return this.finishNode(t, "TSTypeAnnotation");
				}
				const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
				if (!typePredicateVariable) {
					if (!asserts) return this.tsParseTypeAnnotation(false, t);
					node.parameterName = this.parseIdentifier();
					node.asserts = asserts;
					node.typeAnnotation = null;
					t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
					return this.finishNode(t, "TSTypeAnnotation");
				}
				const type = this.tsParseTypeAnnotation(false);
				node.parameterName = typePredicateVariable;
				node.typeAnnotation = type;
				node.asserts = asserts;
				t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
				return this.finishNode(t, "TSTypeAnnotation");
			});
		}
		tsTryParseTypeOrTypePredicateAnnotation() {
			if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
		}
		tsTryParseTypeAnnotation() {
			if (this.match(14)) return this.tsParseTypeAnnotation();
		}
		tsTryParseType() {
			return this.tsEatThenParseType(14);
		}
		tsParseTypePredicatePrefix() {
			const id = this.parseIdentifier();
			if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
				this.next();
				return id;
			}
		}
		tsParseTypePredicateAsserts() {
			if (this.state.type !== 109) return false;
			const containsEsc = this.state.containsEsc;
			this.next();
			if (!tokenIsIdentifier(this.state.type) && !this.match(78)) return false;
			if (containsEsc) this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" });
			return true;
		}
		tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
			this.tsInType(() => {
				if (eatColon) this.expect(14);
				t.typeAnnotation = this.tsParseType();
			});
			return this.finishNode(t, "TSTypeAnnotation");
		}
		tsParseType() {
			assert$1(this.state.inType);
			const type = this.tsParseNonConditionalType();
			if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return type;
			const node = this.startNodeAtNode(type);
			node.checkType = type;
			node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
			this.expect(17);
			node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
			this.expect(14);
			node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
			return this.finishNode(node, "TSConditionalType");
		}
		isAbstractConstructorSignature() {
			return this.isContextual(124) && this.isLookaheadContextual("new");
		}
		tsParseNonConditionalType() {
			if (this.tsIsStartOfFunctionType()) return this.tsParseFunctionOrConstructorType("TSFunctionType");
			if (this.match(77)) return this.tsParseFunctionOrConstructorType("TSConstructorType");
			else if (this.isAbstractConstructorSignature()) return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
			return this.tsParseUnionTypeOrHigher();
		}
		tsParseTypeAssertion() {
			if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
			const node = this.startNode();
			node.typeAnnotation = this.tsInType(() => {
				this.next();
				return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
			});
			this.expect(48);
			node.expression = this.parseMaybeUnary();
			return this.finishNode(node, "TSTypeAssertion");
		}
		tsParseHeritageClause(token) {
			const originalStartLoc = this.state.startLoc;
			const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
				{
					const node = this.startNode();
					node.expression = this.tsParseEntityName(3);
					if (this.match(47)) node.typeParameters = this.tsParseTypeArguments();
					return this.finishNode(node, "TSExpressionWithTypeArguments");
				}
			});
			if (!delimitedList.length) this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, { token });
			return delimitedList;
		}
		tsParseInterfaceDeclaration(node, properties = {}) {
			if (this.hasFollowingLineBreak()) return null;
			this.expectContextual(129);
			if (properties.declare) node.declare = true;
			if (tokenIsIdentifier(this.state.type)) {
				node.id = this.parseIdentifier();
				this.checkIdentifier(node.id, 130);
			} else {
				node.id = null;
				this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
			}
			node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
			if (this.eat(81)) node.extends = this.tsParseHeritageClause("extends");
			const body = this.startNode();
			body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
			node.body = this.finishNode(body, "TSInterfaceBody");
			return this.finishNode(node, "TSInterfaceDeclaration");
		}
		tsParseTypeAliasDeclaration(node) {
			node.id = this.parseIdentifier();
			this.checkIdentifier(node.id, 2);
			node.typeAnnotation = this.tsInType(() => {
				node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
				this.expect(29);
				if (this.isContextual(114) && this.lookaheadCharCode() !== 46) {
					const node$1 = this.startNode();
					this.next();
					return this.finishNode(node$1, "TSIntrinsicKeyword");
				}
				return this.tsParseType();
			});
			this.semicolon();
			return this.finishNode(node, "TSTypeAliasDeclaration");
		}
		tsInTopLevelContext(cb) {
			if (this.curContext() !== types.brace) {
				const oldContext = this.state.context;
				this.state.context = [oldContext[0]];
				try {
					return cb();
				} finally {
					this.state.context = oldContext;
				}
			} else return cb();
		}
		tsInType(cb) {
			const oldInType = this.state.inType;
			this.state.inType = true;
			try {
				return cb();
			} finally {
				this.state.inType = oldInType;
			}
		}
		tsInDisallowConditionalTypesContext(cb) {
			const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
			this.state.inDisallowConditionalTypesContext = true;
			try {
				return cb();
			} finally {
				this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
			}
		}
		tsInAllowConditionalTypesContext(cb) {
			const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
			this.state.inDisallowConditionalTypesContext = false;
			try {
				return cb();
			} finally {
				this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
			}
		}
		tsEatThenParseType(token) {
			if (this.match(token)) return this.tsNextThenParseType();
		}
		tsExpectThenParseType(token) {
			return this.tsInType(() => {
				this.expect(token);
				return this.tsParseType();
			});
		}
		tsNextThenParseType() {
			return this.tsInType(() => {
				this.next();
				return this.tsParseType();
			});
		}
		tsParseEnumMember() {
			const node = this.startNode();
			node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
			if (this.eat(29)) node.initializer = super.parseMaybeAssignAllowIn();
			return this.finishNode(node, "TSEnumMember");
		}
		tsParseEnumDeclaration(node, properties = {}) {
			if (properties.const) node.const = true;
			if (properties.declare) node.declare = true;
			this.expectContextual(126);
			node.id = this.parseIdentifier();
			this.checkIdentifier(node.id, node.const ? 8971 : 8459);
			{
				this.expect(5);
				node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
				this.expect(8);
			}
			return this.finishNode(node, "TSEnumDeclaration");
		}
		tsParseEnumBody() {
			const node = this.startNode();
			this.expect(5);
			node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
			this.expect(8);
			return this.finishNode(node, "TSEnumBody");
		}
		tsParseModuleBlock() {
			const node = this.startNode();
			this.scope.enter(0);
			this.expect(5);
			super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
			this.scope.exit();
			return this.finishNode(node, "TSModuleBlock");
		}
		tsParseModuleOrNamespaceDeclaration(node, nested = false) {
			node.id = this.parseIdentifier();
			if (!nested) this.checkIdentifier(node.id, 1024);
			if (this.eat(16)) {
				const inner = this.startNode();
				this.tsParseModuleOrNamespaceDeclaration(inner, true);
				node.body = inner;
			} else {
				this.scope.enter(1024);
				this.prodParam.enter(0);
				node.body = this.tsParseModuleBlock();
				this.prodParam.exit();
				this.scope.exit();
			}
			return this.finishNode(node, "TSModuleDeclaration");
		}
		tsParseAmbientExternalModuleDeclaration(node) {
			if (this.isContextual(112)) {
				node.kind = "global";
				node.global = true;
				node.id = this.parseIdentifier();
			} else if (this.match(134)) {
				node.kind = "module";
				node.id = super.parseStringLiteral(this.state.value);
			} else this.unexpected();
			if (this.match(5)) {
				this.scope.enter(1024);
				this.prodParam.enter(0);
				node.body = this.tsParseModuleBlock();
				this.prodParam.exit();
				this.scope.exit();
			} else this.semicolon();
			return this.finishNode(node, "TSModuleDeclaration");
		}
		tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
			node.isExport = isExport || false;
			node.id = maybeDefaultIdentifier || this.parseIdentifier();
			this.checkIdentifier(node.id, 4096);
			this.expect(29);
			const moduleReference = this.tsParseModuleReference();
			if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
			node.moduleReference = moduleReference;
			this.semicolon();
			return this.finishNode(node, "TSImportEqualsDeclaration");
		}
		tsIsExternalModuleReference() {
			return this.isContextual(119) && this.lookaheadCharCode() === 40;
		}
		tsParseModuleReference() {
			return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
		}
		tsParseExternalModuleReference() {
			const node = this.startNode();
			this.expectContextual(119);
			this.expect(10);
			if (!this.match(134)) this.unexpected();
			node.expression = super.parseExprAtom();
			this.expect(11);
			this.sawUnambiguousESM = true;
			return this.finishNode(node, "TSExternalModuleReference");
		}
		tsLookAhead(f) {
			const state = this.state.clone();
			const res = f();
			this.state = state;
			return res;
		}
		tsTryParseAndCatch(f) {
			const result = this.tryParse((abort) => f() || abort());
			if (result.aborted || !result.node) return;
			if (result.error) this.state = result.failState;
			return result.node;
		}
		tsTryParse(f) {
			const state = this.state.clone();
			const result = f();
			if (result !== void 0 && result !== false) return result;
			this.state = state;
		}
		tsTryParseDeclare(node) {
			if (this.isLineTerminator()) return;
			const startType = this.state.type;
			return this.tsInAmbientContext(() => {
				switch (startType) {
					case 68:
						node.declare = true;
						return super.parseFunctionStatement(node, false, false);
					case 80:
						node.declare = true;
						return this.parseClass(node, true, false);
					case 126: return this.tsParseEnumDeclaration(node, { declare: true });
					case 112: return this.tsParseAmbientExternalModuleDeclaration(node);
					case 100: if (this.state.containsEsc) return;
					case 75:
					case 74:
						if (!this.match(75) || !this.isLookaheadContextual("enum")) {
							node.declare = true;
							return this.parseVarStatement(node, this.state.value, true);
						}
						this.expect(75);
						return this.tsParseEnumDeclaration(node, {
							const: true,
							declare: true
						});
					case 107:
						if (this.isUsing()) {
							this.raise(TSErrors.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare");
							node.declare = true;
							return this.parseVarStatement(node, "using", true);
						}
						break;
					case 96:
						if (this.isAwaitUsing()) {
							this.raise(TSErrors.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare");
							node.declare = true;
							this.next();
							return this.parseVarStatement(node, "await using", true);
						}
						break;
					case 129: {
						const result = this.tsParseInterfaceDeclaration(node, { declare: true });
						if (result) return result;
					}
					default: if (tokenIsIdentifier(startType)) return this.tsParseDeclaration(node, this.state.type, true, null);
				}
			});
		}
		tsTryParseExportDeclaration() {
			return this.tsParseDeclaration(this.startNode(), this.state.type, true, null);
		}
		tsParseDeclaration(node, type, next, decorators) {
			switch (type) {
				case 124:
					if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) return this.tsParseAbstractDeclaration(node, decorators);
					break;
				case 127:
					if (this.tsCheckLineTerminator(next)) {
						if (this.match(134)) return this.tsParseAmbientExternalModuleDeclaration(node);
						else if (tokenIsIdentifier(this.state.type)) {
							node.kind = "module";
							return this.tsParseModuleOrNamespaceDeclaration(node);
						}
					}
					break;
				case 128:
					if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
						node.kind = "namespace";
						return this.tsParseModuleOrNamespaceDeclaration(node);
					}
					break;
				case 130:
					if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) return this.tsParseTypeAliasDeclaration(node);
					break;
			}
		}
		tsCheckLineTerminator(next) {
			if (next) {
				if (this.hasFollowingLineBreak()) return false;
				this.next();
				return true;
			}
			return !this.isLineTerminator();
		}
		tsTryParseGenericAsyncArrowFunction(startLoc) {
			if (!this.match(47)) return;
			const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
			this.state.maybeInArrowParameters = true;
			const res = this.tsTryParseAndCatch(() => {
				const node = this.startNodeAt(startLoc);
				node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
				super.parseFunctionParams(node);
				node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
				this.expect(19);
				return node;
			});
			this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
			if (!res) return;
			return super.parseArrowExpression(res, null, true);
		}
		tsParseTypeArgumentsInExpression() {
			if (this.reScan_lt() !== 47) return;
			return this.tsParseTypeArguments();
		}
		tsParseTypeArguments() {
			const node = this.startNode();
			node.params = this.tsInType(() => this.tsInTopLevelContext(() => {
				this.expect(47);
				return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
			}));
			if (node.params.length === 0) this.raise(TSErrors.EmptyTypeArguments, node);
			else if (!this.state.inType && this.curContext() === types.brace) this.reScan_lt_gt();
			this.expect(48);
			return this.finishNode(node, "TSTypeParameterInstantiation");
		}
		tsIsDeclarationStart() {
			return tokenIsTSDeclarationStart(this.state.type);
		}
		isExportDefaultSpecifier() {
			if (this.tsIsDeclarationStart()) return false;
			return super.isExportDefaultSpecifier();
		}
		parseBindingElement(flags, decorators) {
			const startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc;
			const modified = {};
			this.tsParseModifiers({ allowedModifiers: [
				"public",
				"private",
				"protected",
				"override",
				"readonly"
			] }, modified);
			const accessibility = modified.accessibility;
			const override = modified.override;
			const readonly = modified.readonly;
			if (!(flags & 4) && (accessibility || readonly || override)) this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
			const left = this.parseMaybeDefault();
			if (flags & 2) this.parseFunctionParamType(left);
			const elt = this.parseMaybeDefault(left.loc.start, left);
			if (accessibility || readonly || override) {
				const pp = this.startNodeAt(startLoc);
				if (decorators.length) pp.decorators = decorators;
				if (accessibility) pp.accessibility = accessibility;
				if (readonly) pp.readonly = readonly;
				if (override) pp.override = override;
				if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
				pp.parameter = elt;
				return this.finishNode(pp, "TSParameterProperty");
			}
			if (decorators.length) left.decorators = decorators;
			return elt;
		}
		isSimpleParameter(node) {
			return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
		}
		tsDisallowOptionalPattern(node) {
			for (const param of node.params) if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) this.raise(TSErrors.PatternIsOptional, param);
		}
		setArrowFunctionParameters(node, params, trailingCommaLoc) {
			super.setArrowFunctionParameters(node, params, trailingCommaLoc);
			this.tsDisallowOptionalPattern(node);
		}
		parseFunctionBodyAndFinish(node, type, isMethod = false) {
			if (this.match(14)) node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
			const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
			if (bodilessType && !this.match(5) && this.isLineTerminator()) return this.finishNode(node, bodilessType);
			if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
				this.raise(TSErrors.DeclareFunctionHasImplementation, node);
				if (node.declare) return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
			}
			this.tsDisallowOptionalPattern(node);
			return super.parseFunctionBodyAndFinish(node, type, isMethod);
		}
		registerFunctionStatementId(node) {
			if (!node.body && node.id) this.checkIdentifier(node.id, 1024);
			else super.registerFunctionStatementId(node);
		}
		tsCheckForInvalidTypeCasts(items) {
			items.forEach((node) => {
				if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
			});
		}
		toReferencedList(exprList, isInParens) {
			this.tsCheckForInvalidTypeCasts(exprList);
			return exprList;
		}
		parseArrayLike(close, isTuple, refExpressionErrors) {
			const node = super.parseArrayLike(close, isTuple, refExpressionErrors);
			if (node.type === "ArrayExpression") this.tsCheckForInvalidTypeCasts(node.elements);
			return node;
		}
		parseSubscript(base, startLoc, noCalls, state) {
			if (!this.hasPrecedingLineBreak() && this.match(35)) {
				this.state.canStartJSXElement = false;
				this.next();
				const nonNullExpression = this.startNodeAt(startLoc);
				nonNullExpression.expression = base;
				return this.finishNode(nonNullExpression, "TSNonNullExpression");
			}
			let isOptionalCall = false;
			if (this.match(18) && this.lookaheadCharCode() === 60) {
				if (noCalls) {
					state.stop = true;
					return base;
				}
				state.optionalChainMember = isOptionalCall = true;
				this.next();
			}
			if (this.match(47) || this.match(51)) {
				let missingParenErrorLoc;
				const result = this.tsTryParseAndCatch(() => {
					if (!noCalls && this.atPossibleAsyncArrow(base)) {
						const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
						if (asyncArrowFn) {
							state.stop = true;
							return asyncArrowFn;
						}
					}
					const typeArguments = this.tsParseTypeArgumentsInExpression();
					if (!typeArguments) return;
					if (isOptionalCall && !this.match(10)) {
						missingParenErrorLoc = this.state.curPosition();
						return;
					}
					if (tokenIsTemplate(this.state.type)) {
						const result$1 = super.parseTaggedTemplateExpression(base, startLoc, state);
						result$1.typeParameters = typeArguments;
						return result$1;
					}
					if (!noCalls && this.eat(10)) {
						const node$1 = this.startNodeAt(startLoc);
						node$1.callee = base;
						node$1.arguments = this.parseCallExpressionArguments();
						this.tsCheckForInvalidTypeCasts(node$1.arguments);
						node$1.typeParameters = typeArguments;
						if (state.optionalChainMember) node$1.optional = isOptionalCall;
						return this.finishCallExpression(node$1, state.optionalChainMember);
					}
					const tokenType = this.state.type;
					if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) return;
					const node = this.startNodeAt(startLoc);
					node.expression = base;
					node.typeParameters = typeArguments;
					return this.finishNode(node, "TSInstantiationExpression");
				});
				if (missingParenErrorLoc) this.unexpected(missingParenErrorLoc, 10);
				if (result) {
					if (result.type === "TSInstantiationExpression") {
						if (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
						if (!this.match(16) && !this.match(18)) result.expression = super.stopParseSubscript(base, state);
					}
					return result;
				}
			}
			return super.parseSubscript(base, startLoc, noCalls, state);
		}
		parseNewCallee(node) {
			var _callee$extra;
			super.parseNewCallee(node);
			const { callee } = node;
			if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
				node.typeParameters = callee.typeParameters;
				node.callee = callee.expression;
			}
		}
		parseExprOp(left, leftStartLoc, minPrec) {
			let isSatisfies;
			if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
				const node = this.startNodeAt(leftStartLoc);
				node.expression = left;
				node.typeAnnotation = this.tsInType(() => {
					this.next();
					if (this.match(75)) {
						if (isSatisfies) this.raise(Errors.UnexpectedKeyword, this.state.startLoc, { keyword: "const" });
						return this.tsParseTypeReference();
					}
					return this.tsParseType();
				});
				this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
				this.reScan_lt_gt();
				return this.parseExprOp(node, leftStartLoc, minPrec);
			}
			return super.parseExprOp(left, leftStartLoc, minPrec);
		}
		checkReservedWord(word, startLoc, checkKeywords, isBinding) {
			if (!this.state.isAmbientContext) super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
		}
		checkImportReflection(node) {
			super.checkImportReflection(node);
			if (node.module && node.importKind !== "value") this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
		}
		checkDuplicateExports() {}
		isPotentialImportPhase(isExport) {
			if (super.isPotentialImportPhase(isExport)) return true;
			if (this.isContextual(130)) {
				const ch = this.lookaheadCharCode();
				return isExport ? ch === 123 || ch === 42 : ch !== 61;
			}
			return !isExport && this.isContextual(87);
		}
		applyImportPhase(node, isExport, phase, loc) {
			super.applyImportPhase(node, isExport, phase, loc);
			if (isExport) node.exportKind = phase === "type" ? "type" : "value";
			else node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
		}
		parseImport(node) {
			if (this.match(134)) {
				node.importKind = "value";
				return super.parseImport(node);
			}
			let importNode;
			if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
				node.importKind = "value";
				return this.tsParseImportEqualsDeclaration(node);
			} else if (this.isContextual(130)) {
				const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
				if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
				else importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
			} else importNode = super.parseImport(node);
			if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
			return importNode;
		}
		parseExport(node, decorators) {
			if (this.match(83)) {
				const nodeImportEquals = node;
				this.next();
				let maybeDefaultIdentifier = null;
				if (this.isContextual(130) && this.isPotentialImportPhase(false)) maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
				else nodeImportEquals.importKind = "value";
				const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
				return declaration;
			} else if (this.eat(29)) {
				const assign = node;
				assign.expression = super.parseExpression();
				this.semicolon();
				this.sawUnambiguousESM = true;
				return this.finishNode(assign, "TSExportAssignment");
			} else if (this.eatContextual(93)) {
				const decl = node;
				this.expectContextual(128);
				decl.id = this.parseIdentifier();
				this.semicolon();
				return this.finishNode(decl, "TSNamespaceExportDeclaration");
			} else return super.parseExport(node, decorators);
		}
		isAbstractClass() {
			return this.isContextual(124) && this.isLookaheadContextual("class");
		}
		parseExportDefaultExpression() {
			if (this.isAbstractClass()) {
				const cls = this.startNode();
				this.next();
				cls.abstract = true;
				return this.parseClass(cls, true, true);
			}
			if (this.match(129)) {
				const result = this.tsParseInterfaceDeclaration(this.startNode());
				if (result) return result;
			}
			return super.parseExportDefaultExpression();
		}
		parseVarStatement(node, kind, allowMissingInitializer = false) {
			const { isAmbientContext } = this.state;
			const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
			if (!isAmbientContext) return declaration;
			if (!node.declare && (kind === "using" || kind === "await using")) {
				this.raiseOverwrite(TSErrors.UsingDeclarationInAmbientContext, node, kind);
				return declaration;
			}
			for (const { id, init } of declaration.declarations) {
				if (!init) continue;
				if (kind === "var" || kind === "let" || !!id.typeAnnotation) this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
				else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
			}
			return declaration;
		}
		parseStatementContent(flags, decorators) {
			if (!this.state.containsEsc) switch (this.state.type) {
				case 75: {
					if (this.isLookaheadContextual("enum")) {
						const node = this.startNode();
						this.expect(75);
						return this.tsParseEnumDeclaration(node, { const: true });
					}
					break;
				}
				case 124:
				case 125: {
					if (this.nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine()) {
						const token = this.state.type;
						const node = this.startNode();
						this.next();
						const declaration = token === 125 ? this.tsTryParseDeclare(node) : this.tsParseAbstractDeclaration(node, decorators);
						if (declaration) {
							if (token === 125) declaration.declare = true;
							return declaration;
						} else {
							node.expression = this.createIdentifier(this.startNodeAt(node.loc.start), token === 125 ? "declare" : "abstract");
							this.semicolon(false);
							return this.finishNode(node, "ExpressionStatement");
						}
					}
					break;
				}
				case 126: return this.tsParseEnumDeclaration(this.startNode());
				case 112: {
					const nextCh = this.lookaheadCharCode();
					if (nextCh === 123) {
						const node = this.startNode();
						return this.tsParseAmbientExternalModuleDeclaration(node);
					}
					break;
				}
				case 129: {
					const result = this.tsParseInterfaceDeclaration(this.startNode());
					if (result) return result;
					break;
				}
				case 127: {
					if (this.nextTokenIsIdentifierOrStringLiteralOnSameLine()) {
						const node = this.startNode();
						this.next();
						return this.tsParseDeclaration(node, 127, false, decorators);
					}
					break;
				}
				case 128: {
					if (this.nextTokenIsIdentifierOnSameLine()) {
						const node = this.startNode();
						this.next();
						return this.tsParseDeclaration(node, 128, false, decorators);
					}
					break;
				}
				case 130: {
					if (this.nextTokenIsIdentifierOnSameLine()) {
						const node = this.startNode();
						this.next();
						return this.tsParseTypeAliasDeclaration(node);
					}
					break;
				}
			}
			return super.parseStatementContent(flags, decorators);
		}
		parseAccessModifier() {
			return this.tsParseModifier([
				"public",
				"protected",
				"private"
			]);
		}
		tsHasSomeModifiers(member, modifiers) {
			return modifiers.some((modifier) => {
				if (tsIsAccessModifier(modifier)) return member.accessibility === modifier;
				return !!member[modifier];
			});
		}
		tsIsStartOfStaticBlocks() {
			return this.isContextual(106) && this.lookaheadCharCode() === 123;
		}
		parseClassMember(classBody, member, state) {
			const modifiers = [
				"declare",
				"private",
				"public",
				"protected",
				"override",
				"abstract",
				"readonly",
				"static"
			];
			this.tsParseModifiers({
				allowedModifiers: modifiers,
				disallowedModifiers: ["in", "out"],
				stopOnStartOfClassStaticBlock: true,
				errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
			}, member);
			const callParseClassMemberWithIsStatic = () => {
				if (this.tsIsStartOfStaticBlocks()) {
					this.next();
					this.next();
					if (this.tsHasSomeModifiers(member, modifiers)) this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
					super.parseClassStaticBlock(classBody, member);
				} else this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
			};
			if (member.declare) this.tsInAmbientContext(callParseClassMemberWithIsStatic);
			else callParseClassMemberWithIsStatic();
		}
		parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
			const idx = this.tsTryParseIndexSignature(member);
			if (idx) {
				classBody.body.push(idx);
				if (member.abstract) this.raise(TSErrors.IndexSignatureHasAbstract, member);
				if (member.accessibility) this.raise(TSErrors.IndexSignatureHasAccessibility, member, { modifier: member.accessibility });
				if (member.declare) this.raise(TSErrors.IndexSignatureHasDeclare, member);
				if (member.override) this.raise(TSErrors.IndexSignatureHasOverride, member);
				return;
			}
			if (!this.state.inAbstractClass && member.abstract) this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
			if (member.override) {
				if (!state.hadSuperClass) this.raise(TSErrors.OverrideNotInSubClass, member);
			}
			super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
		}
		parsePostMemberNameModifiers(methodOrProp) {
			const optional = this.eat(17);
			if (optional) methodOrProp.optional = true;
			if (methodOrProp.readonly && this.match(10)) this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
			if (methodOrProp.declare && this.match(10)) this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
		}
		shouldParseExportDeclaration() {
			if (this.tsIsDeclarationStart()) return true;
			return super.shouldParseExportDeclaration();
		}
		parseConditional(expr, startLoc, refExpressionErrors) {
			if (!this.match(17)) return expr;
			if (this.state.maybeInArrowParameters) {
				const nextCh = this.lookaheadCharCode();
				if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
					this.setOptionalParametersError(refExpressionErrors);
					return expr;
				}
			}
			return super.parseConditional(expr, startLoc, refExpressionErrors);
		}
		parseParenItem(node, startLoc) {
			const newNode = super.parseParenItem(node, startLoc);
			if (this.eat(17)) {
				newNode.optional = true;
				this.resetEndLocation(node);
			}
			if (this.match(14)) {
				const typeCastNode = this.startNodeAt(startLoc);
				typeCastNode.expression = node;
				typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
				return this.finishNode(typeCastNode, "TSTypeCastExpression");
			}
			return node;
		}
		parseExportDeclaration(node) {
			if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
			const startLoc = this.state.startLoc;
			const isDeclare = this.eatContextual(125);
			if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
			const isIdentifier = tokenIsIdentifier(this.state.type);
			const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
			if (!declaration) return null;
			if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) node.exportKind = "type";
			if (isDeclare && declaration.type !== "TSImportEqualsDeclaration") {
				this.resetStartLocation(declaration, startLoc);
				declaration.declare = true;
			}
			return declaration;
		}
		parseClassId(node, isStatement, optionalId, bindingType) {
			if ((!isStatement || optionalId) && this.isContextual(113)) return;
			super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
			const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
			if (typeParameters) node.typeParameters = typeParameters;
		}
		parseClassPropertyAnnotation(node) {
			if (!node.optional) {
				if (this.eat(35)) node.definite = true;
				else if (this.eat(17)) node.optional = true;
			}
			const type = this.tsTryParseTypeAnnotation();
			if (type) node.typeAnnotation = type;
		}
		parseClassProperty(node) {
			this.parseClassPropertyAnnotation(node);
			if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
			if (node.abstract && this.match(29)) {
				const { key } = node;
				this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]` });
			}
			return super.parseClassProperty(node);
		}
		parseClassPrivateProperty(node) {
			if (node.abstract) this.raise(TSErrors.PrivateElementHasAbstract, node);
			if (node.accessibility) this.raise(TSErrors.PrivateElementHasAccessibility, node, { modifier: node.accessibility });
			this.parseClassPropertyAnnotation(node);
			return super.parseClassPrivateProperty(node);
		}
		parseClassAccessorProperty(node) {
			this.parseClassPropertyAnnotation(node);
			if (node.optional) this.raise(TSErrors.AccessorCannotBeOptional, node);
			return super.parseClassAccessorProperty(node);
		}
		pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
			const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
			if (typeParameters && isConstructor) this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
			const { declare = false, kind } = method;
			if (declare && (kind === "get" || kind === "set")) this.raise(TSErrors.DeclareAccessor, method, { kind });
			if (typeParameters) method.typeParameters = typeParameters;
			super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
		}
		pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
			const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
			if (typeParameters) method.typeParameters = typeParameters;
			super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
		}
		declareClassPrivateMethodInScope(node, kind) {
			if (node.type === "TSDeclareMethod") return;
			if (node.type === "MethodDefinition" && node.value.body == null) return;
			super.declareClassPrivateMethodInScope(node, kind);
		}
		parseClassSuper(node) {
			super.parseClassSuper(node);
			if (node.superClass && (this.match(47) || this.match(51))) node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
			if (this.eatContextual(113)) node.implements = this.tsParseHeritageClause("implements");
		}
		parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
			const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
			if (typeParameters) prop.typeParameters = typeParameters;
			return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
		}
		parseFunctionParams(node, isConstructor) {
			const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
			if (typeParameters) node.typeParameters = typeParameters;
			super.parseFunctionParams(node, isConstructor);
		}
		parseVarId(decl, kind) {
			super.parseVarId(decl, kind);
			if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) decl.definite = true;
			const type = this.tsTryParseTypeAnnotation();
			if (type) {
				decl.id.typeAnnotation = type;
				this.resetEndLocation(decl.id);
			}
		}
		parseAsyncArrowFromCallExpression(node, call) {
			if (this.match(14)) node.returnType = this.tsParseTypeAnnotation();
			return super.parseAsyncArrowFromCallExpression(node, call);
		}
		parseMaybeAssign(refExpressionErrors, afterLeftParse) {
			var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
			let state;
			let jsx$1;
			let typeCast;
			if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
				state = this.state.clone();
				jsx$1 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
				if (!jsx$1.error) return jsx$1.node;
				const { context } = this.state;
				const currentContext = context[context.length - 1];
				if (currentContext === types.j_oTag || currentContext === types.j_expr) context.pop();
			}
			if (!((_jsx = jsx$1) != null && _jsx.error) && !this.match(47)) return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
			if (!state || state === this.state) state = this.state.clone();
			let typeParameters;
			const arrow = this.tryParse((abort) => {
				var _expr$extra, _typeParameters;
				typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
				const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
				if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) abort();
				if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) this.resetStartLocationFromNode(expr, typeParameters);
				expr.typeParameters = typeParameters;
				return expr;
			}, state);
			if (!arrow.error && !arrow.aborted) {
				if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
				return arrow.node;
			}
			if (!jsx$1) {
				assert$1(!this.hasPlugin("jsx"));
				typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
				if (!typeCast.error) return typeCast.node;
			}
			if ((_jsx2 = jsx$1) != null && _jsx2.node) {
				this.state = jsx$1.failState;
				return jsx$1.node;
			}
			if (arrow.node) {
				this.state = arrow.failState;
				if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
				return arrow.node;
			}
			if ((_typeCast = typeCast) != null && _typeCast.node) {
				this.state = typeCast.failState;
				return typeCast.node;
			}
			throw ((_jsx3 = jsx$1) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
		}
		reportReservedArrowTypeParam(node) {
			var _node$extra2;
			if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra2 = node.extra) != null && _node$extra2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) this.raise(TSErrors.ReservedArrowTypeParam, node);
		}
		parseMaybeUnary(refExpressionErrors, sawUnary) {
			if (!this.hasPlugin("jsx") && this.match(47)) return this.tsParseTypeAssertion();
			return super.parseMaybeUnary(refExpressionErrors, sawUnary);
		}
		parseArrow(node) {
			if (this.match(14)) {
				const result = this.tryParse((abort) => {
					const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
					if (this.canInsertSemicolon() || !this.match(19)) abort();
					return returnType;
				});
				if (result.aborted) return;
				if (!result.thrown) {
					if (result.error) this.state = result.failState;
					node.returnType = result.node;
				}
			}
			return super.parseArrow(node);
		}
		parseFunctionParamType(param) {
			if (this.eat(17)) param.optional = true;
			const type = this.tsTryParseTypeAnnotation();
			if (type) param.typeAnnotation = type;
			this.resetEndLocation(param);
			return param;
		}
		isAssignable(node, isBinding) {
			switch (node.type) {
				case "TSTypeCastExpression": return this.isAssignable(node.expression, isBinding);
				case "TSParameterProperty": return true;
				default: return super.isAssignable(node, isBinding);
			}
		}
		toAssignable(node, isLHS = false) {
			switch (node.type) {
				case "ParenthesizedExpression":
					this.toAssignableParenthesizedExpression(node, isLHS);
					break;
				case "TSAsExpression":
				case "TSSatisfiesExpression":
				case "TSNonNullExpression":
				case "TSTypeAssertion":
					if (isLHS) this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
					else this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
					this.toAssignable(node.expression, isLHS);
					break;
				case "AssignmentExpression": if (!isLHS && node.left.type === "TSTypeCastExpression") node.left = this.typeCastToParameter(node.left);
				default: super.toAssignable(node, isLHS);
			}
		}
		toAssignableParenthesizedExpression(node, isLHS) {
			switch (node.expression.type) {
				case "TSAsExpression":
				case "TSSatisfiesExpression":
				case "TSNonNullExpression":
				case "TSTypeAssertion":
				case "ParenthesizedExpression":
					this.toAssignable(node.expression, isLHS);
					break;
				default: super.toAssignable(node, isLHS);
			}
		}
		checkToRestConversion(node, allowPattern) {
			switch (node.type) {
				case "TSAsExpression":
				case "TSSatisfiesExpression":
				case "TSTypeAssertion":
				case "TSNonNullExpression":
					this.checkToRestConversion(node.expression, false);
					break;
				default: super.checkToRestConversion(node, allowPattern);
			}
		}
		isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {
			switch (type) {
				case "TSTypeCastExpression": return true;
				case "TSParameterProperty": return "parameter";
				case "TSNonNullExpression": return "expression";
				case "TSAsExpression":
				case "TSSatisfiesExpression":
				case "TSTypeAssertion": return (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true];
				default: return super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding);
			}
		}
		parseBindingAtom() {
			if (this.state.type === 78) return this.parseIdentifier(true);
			return super.parseBindingAtom();
		}
		parseMaybeDecoratorArguments(expr, startLoc) {
			if (this.match(47) || this.match(51)) {
				const typeArguments = this.tsParseTypeArgumentsInExpression();
				if (this.match(10)) {
					const call = super.parseMaybeDecoratorArguments(expr, startLoc);
					call.typeParameters = typeArguments;
					return call;
				}
				this.unexpected(null, 10);
			}
			return super.parseMaybeDecoratorArguments(expr, startLoc);
		}
		checkCommaAfterRest(close) {
			if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
				this.next();
				return false;
			}
			return super.checkCommaAfterRest(close);
		}
		isClassMethod() {
			return this.match(47) || super.isClassMethod();
		}
		isClassProperty() {
			return this.match(35) || this.match(14) || super.isClassProperty();
		}
		parseMaybeDefault(startLoc, left) {
			const node = super.parseMaybeDefault(startLoc, left);
			if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
			return node;
		}
		getTokenFromCode(code$1) {
			if (this.state.inType) {
				if (code$1 === 62) {
					this.finishOp(48, 1);
					return;
				}
				if (code$1 === 60) {
					this.finishOp(47, 1);
					return;
				}
			}
			super.getTokenFromCode(code$1);
		}
		reScan_lt_gt() {
			const { type } = this.state;
			if (type === 47) {
				this.state.pos -= 1;
				this.readToken_lt();
			} else if (type === 48) {
				this.state.pos -= 1;
				this.readToken_gt();
			}
		}
		reScan_lt() {
			const { type } = this.state;
			if (type === 51) {
				this.state.pos -= 2;
				this.finishOp(47, 1);
				return 47;
			}
			return type;
		}
		toAssignableListItem(exprList, index, isLHS) {
			const node = exprList[index];
			if (node.type === "TSTypeCastExpression") exprList[index] = this.typeCastToParameter(node);
			super.toAssignableListItem(exprList, index, isLHS);
		}
		typeCastToParameter(node) {
			node.expression.typeAnnotation = node.typeAnnotation;
			this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
			return node.expression;
		}
		shouldParseArrow(params) {
			if (this.match(14)) return params.every((expr) => this.isAssignable(expr, true));
			return super.shouldParseArrow(params);
		}
		shouldParseAsyncArrow() {
			return this.match(14) || super.shouldParseAsyncArrow();
		}
		canHaveLeadingDecorator() {
			return super.canHaveLeadingDecorator() || this.isAbstractClass();
		}
		jsxParseOpeningElementAfterName(node) {
			if (this.match(47) || this.match(51)) {
				const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
				if (typeArguments) node.typeParameters = typeArguments;
			}
			return super.jsxParseOpeningElementAfterName(node);
		}
		getGetterSetterExpectedParamCount(method) {
			const baseCount = super.getGetterSetterExpectedParamCount(method);
			const params = this.getObjectOrClassMethodParams(method);
			const firstParam = params[0];
			const hasContextParam = firstParam && this.isThisParam(firstParam);
			return hasContextParam ? baseCount + 1 : baseCount;
		}
		parseCatchClauseParam() {
			const param = super.parseCatchClauseParam();
			const type = this.tsTryParseTypeAnnotation();
			if (type) {
				param.typeAnnotation = type;
				this.resetEndLocation(param);
			}
			return param;
		}
		tsInAmbientContext(cb) {
			const { isAmbientContext: oldIsAmbientContext, strict: oldStrict } = this.state;
			this.state.isAmbientContext = true;
			this.state.strict = false;
			try {
				return cb();
			} finally {
				this.state.isAmbientContext = oldIsAmbientContext;
				this.state.strict = oldStrict;
			}
		}
		parseClass(node, isStatement, optionalId) {
			const oldInAbstractClass = this.state.inAbstractClass;
			this.state.inAbstractClass = !!node.abstract;
			try {
				return super.parseClass(node, isStatement, optionalId);
			} finally {
				this.state.inAbstractClass = oldInAbstractClass;
			}
		}
		tsParseAbstractDeclaration(node, decorators) {
			if (this.match(80)) {
				node.abstract = true;
				return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
			} else if (this.isContextual(129)) if (!this.hasFollowingLineBreak()) {
				node.abstract = true;
				this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node);
				return this.tsParseInterfaceDeclaration(node);
			} else return null;
			throw this.unexpected(null, 80);
		}
		parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
			const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
			if (method.abstract || method.type === "TSAbstractMethodDefinition") {
				const hasEstreePlugin = this.hasPlugin("estree");
				const methodFn = hasEstreePlugin ? method.value : method;
				if (methodFn.body) {
					const { key } = method;
					this.raise(TSErrors.AbstractMethodHasImplementation, method, { methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]` });
				}
			}
			return method;
		}
		tsParseTypeParameterName() {
			const typeName = this.parseIdentifier();
			return typeName.name;
		}
		shouldParseAsAmbientContext() {
			return !!this.getPluginOption("typescript", "dts");
		}
		parse() {
			if (this.shouldParseAsAmbientContext()) this.state.isAmbientContext = true;
			return super.parse();
		}
		getExpression() {
			if (this.shouldParseAsAmbientContext()) this.state.isAmbientContext = true;
			return super.getExpression();
		}
		parseExportSpecifier(node, isString$1, isInTypeExport, isMaybeTypeOnly) {
			if (!isString$1 && isMaybeTypeOnly) {
				this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
				return this.finishNode(node, "ExportSpecifier");
			}
			node.exportKind = "value";
			return super.parseExportSpecifier(node, isString$1, isInTypeExport, isMaybeTypeOnly);
		}
		parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
			if (!importedIsString && isMaybeTypeOnly) {
				this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
				return this.finishNode(specifier, "ImportSpecifier");
			}
			specifier.importKind = "value";
			return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
		}
		parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
			const leftOfAsKey = isImport ? "imported" : "local";
			const rightOfAsKey = isImport ? "local" : "exported";
			let leftOfAs = node[leftOfAsKey];
			let rightOfAs;
			let hasTypeSpecifier = false;
			let canParseAsKeyword = true;
			const loc = leftOfAs.loc.start;
			if (this.isContextual(93)) {
				const firstAs = this.parseIdentifier();
				if (this.isContextual(93)) {
					const secondAs = this.parseIdentifier();
					if (tokenIsKeywordOrIdentifier(this.state.type)) {
						hasTypeSpecifier = true;
						leftOfAs = firstAs;
						rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
						canParseAsKeyword = false;
					} else {
						rightOfAs = secondAs;
						canParseAsKeyword = false;
					}
				} else if (tokenIsKeywordOrIdentifier(this.state.type)) {
					canParseAsKeyword = false;
					rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
				} else {
					hasTypeSpecifier = true;
					leftOfAs = firstAs;
				}
			} else if (tokenIsKeywordOrIdentifier(this.state.type)) {
				hasTypeSpecifier = true;
				if (isImport) {
					leftOfAs = this.parseIdentifier(true);
					if (!this.isContextual(93)) this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
				} else leftOfAs = this.parseModuleExportName();
			}
			if (hasTypeSpecifier && isInTypeOnlyImportExport) this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
			node[leftOfAsKey] = leftOfAs;
			node[rightOfAsKey] = rightOfAs;
			const kindKey = isImport ? "importKind" : "exportKind";
			node[kindKey] = hasTypeSpecifier ? "type" : "value";
			if (canParseAsKeyword && this.eatContextual(93)) node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
			if (!node[rightOfAsKey]) node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey]);
			if (isImport) this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
		}
		fillOptionalPropertiesForTSESLint(node) {
			var _node$directive, _node$decorators, _node$optional, _node$typeAnnotation, _node$accessibility, _node$decorators2, _node$override, _node$readonly, _node$static, _node$declare, _node$returnType, _node$typeParameters, _node$optional2, _node$optional3, _node$accessibility2, _node$readonly2, _node$static2, _node$declare2, _node$definite, _node$readonly3, _node$typeAnnotation2, _node$accessibility3, _node$decorators3, _node$override2, _node$optional4, _node$id, _node$abstract, _node$declare3, _node$decorators4, _node$implements, _node$superTypeArgume, _node$typeParameters2, _node$declare4, _node$definite2, _node$const, _node$declare5, _node$computed, _node$qualifier, _node$options, _node$declare6, _node$extends, _node$optional5, _node$readonly4, _node$declare7, _node$global, _node$const2, _node$in, _node$out;
			switch (node.type) {
				case "ExpressionStatement":
					(_node$directive = node.directive) != null || (node.directive = void 0);
					return;
				case "RestElement": node.value = void 0;
				case "Identifier":
				case "ArrayPattern":
				case "AssignmentPattern":
				case "ObjectPattern":
					(_node$decorators = node.decorators) != null || (node.decorators = []);
					(_node$optional = node.optional) != null || (node.optional = false);
					(_node$typeAnnotation = node.typeAnnotation) != null || (node.typeAnnotation = void 0);
					return;
				case "TSParameterProperty":
					(_node$accessibility = node.accessibility) != null || (node.accessibility = void 0);
					(_node$decorators2 = node.decorators) != null || (node.decorators = []);
					(_node$override = node.override) != null || (node.override = false);
					(_node$readonly = node.readonly) != null || (node.readonly = false);
					(_node$static = node.static) != null || (node.static = false);
					return;
				case "TSEmptyBodyFunctionExpression": node.body = null;
				case "TSDeclareFunction":
				case "FunctionDeclaration":
				case "FunctionExpression":
				case "ClassMethod":
				case "ClassPrivateMethod":
					(_node$declare = node.declare) != null || (node.declare = false);
					(_node$returnType = node.returnType) != null || (node.returnType = void 0);
					(_node$typeParameters = node.typeParameters) != null || (node.typeParameters = void 0);
					return;
				case "Property":
					(_node$optional2 = node.optional) != null || (node.optional = false);
					return;
				case "TSMethodSignature":
				case "TSPropertySignature": (_node$optional3 = node.optional) != null || (node.optional = false);
				case "TSIndexSignature":
					(_node$accessibility2 = node.accessibility) != null || (node.accessibility = void 0);
					(_node$readonly2 = node.readonly) != null || (node.readonly = false);
					(_node$static2 = node.static) != null || (node.static = false);
					return;
				case "TSAbstractPropertyDefinition":
				case "PropertyDefinition":
				case "TSAbstractAccessorProperty":
				case "AccessorProperty":
					(_node$declare2 = node.declare) != null || (node.declare = false);
					(_node$definite = node.definite) != null || (node.definite = false);
					(_node$readonly3 = node.readonly) != null || (node.readonly = false);
					(_node$typeAnnotation2 = node.typeAnnotation) != null || (node.typeAnnotation = void 0);
				case "TSAbstractMethodDefinition":
				case "MethodDefinition":
					(_node$accessibility3 = node.accessibility) != null || (node.accessibility = void 0);
					(_node$decorators3 = node.decorators) != null || (node.decorators = []);
					(_node$override2 = node.override) != null || (node.override = false);
					(_node$optional4 = node.optional) != null || (node.optional = false);
					return;
				case "ClassExpression": (_node$id = node.id) != null || (node.id = null);
				case "ClassDeclaration":
					(_node$abstract = node.abstract) != null || (node.abstract = false);
					(_node$declare3 = node.declare) != null || (node.declare = false);
					(_node$decorators4 = node.decorators) != null || (node.decorators = []);
					(_node$implements = node.implements) != null || (node.implements = []);
					(_node$superTypeArgume = node.superTypeArguments) != null || (node.superTypeArguments = void 0);
					(_node$typeParameters2 = node.typeParameters) != null || (node.typeParameters = void 0);
					return;
				case "TSTypeAliasDeclaration":
				case "VariableDeclaration":
					(_node$declare4 = node.declare) != null || (node.declare = false);
					return;
				case "VariableDeclarator":
					(_node$definite2 = node.definite) != null || (node.definite = false);
					return;
				case "TSEnumDeclaration":
					(_node$const = node.const) != null || (node.const = false);
					(_node$declare5 = node.declare) != null || (node.declare = false);
					return;
				case "TSEnumMember":
					(_node$computed = node.computed) != null || (node.computed = false);
					return;
				case "TSImportType":
					(_node$qualifier = node.qualifier) != null || (node.qualifier = null);
					(_node$options = node.options) != null || (node.options = null);
					return;
				case "TSInterfaceDeclaration":
					(_node$declare6 = node.declare) != null || (node.declare = false);
					(_node$extends = node.extends) != null || (node.extends = []);
					return;
				case "TSMappedType":
					(_node$optional5 = node.optional) != null || (node.optional = false);
					(_node$readonly4 = node.readonly) != null || (node.readonly = void 0);
					return;
				case "TSModuleDeclaration":
					(_node$declare7 = node.declare) != null || (node.declare = false);
					(_node$global = node.global) != null || (node.global = node.kind === "global");
					return;
				case "TSTypeParameter":
					(_node$const2 = node.const) != null || (node.const = false);
					(_node$in = node.in) != null || (node.in = false);
					(_node$out = node.out) != null || (node.out = false);
					return;
			}
		}
		chStartsBindingIdentifierAndNotRelationalOperator(ch, pos) {
			if (isIdentifierStart(ch)) {
				keywordAndTSRelationalOperator.lastIndex = pos;
				if (keywordAndTSRelationalOperator.test(this.input)) {
					const endCh = this.codePointAtPos(keywordAndTSRelationalOperator.lastIndex);
					if (!isIdentifierChar(endCh) && endCh !== 92) return false;
				}
				return true;
			} else if (ch === 92) return true;
			else return false;
		}
		nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine() {
			const next = this.nextTokenInLineStart();
			const nextCh = this.codePointAtPos(next);
			return this.chStartsBindingIdentifierAndNotRelationalOperator(nextCh, next);
		}
		nextTokenIsIdentifierOrStringLiteralOnSameLine() {
			const next = this.nextTokenInLineStart();
			const nextCh = this.codePointAtPos(next);
			return this.chStartsBindingIdentifier(nextCh, next) || nextCh === 34 || nextCh === 39;
		}
	};
	function isPossiblyLiteralEnum(expression) {
		if (expression.type !== "MemberExpression") return false;
		const { computed: computed$1, property } = expression;
		if (computed$1 && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) return false;
		return isUncomputedMemberExpressionChain(expression.object);
	}
	function isValidAmbientConstInitializer(expression, estree$1) {
		var _expression$extra;
		const { type } = expression;
		if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) return false;
		if (estree$1) {
			if (type === "Literal") {
				const { value } = expression;
				if (typeof value === "string" || typeof value === "boolean") return true;
			}
		} else if (type === "StringLiteral" || type === "BooleanLiteral") return true;
		if (isNumber(expression, estree$1) || isNegativeNumber(expression, estree$1)) return true;
		if (type === "TemplateLiteral" && expression.expressions.length === 0) return true;
		if (isPossiblyLiteralEnum(expression)) return true;
		return false;
	}
	function isNumber(expression, estree$1) {
		if (estree$1) return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
		return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
	}
	function isNegativeNumber(expression, estree$1) {
		if (expression.type === "UnaryExpression") {
			const { operator, argument } = expression;
			if (operator === "-" && isNumber(argument, estree$1)) return true;
		}
		return false;
	}
	function isUncomputedMemberExpressionChain(expression) {
		if (expression.type === "Identifier") return true;
		if (expression.type !== "MemberExpression" || expression.computed) return false;
		return isUncomputedMemberExpressionChain(expression.object);
	}
	const PlaceholderErrors = ParseErrorEnum`placeholders`({
		ClassNameIsRequired: "A class name is required.",
		UnexpectedSpace: "Unexpected space in placeholder."
	});
	var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
		parsePlaceholder(expectedNode) {
			if (this.match(133)) {
				const node = this.startNode();
				this.next();
				this.assertNoSpace();
				node.name = super.parseIdentifier(true);
				this.assertNoSpace();
				this.expect(133);
				return this.finishPlaceholder(node, expectedNode);
			}
		}
		finishPlaceholder(node, expectedNode) {
			let placeholder = node;
			if (!placeholder.expectedNode || !placeholder.type) placeholder = this.finishNode(placeholder, "Placeholder");
			placeholder.expectedNode = expectedNode;
			return placeholder;
		}
		getTokenFromCode(code$1) {
			if (code$1 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) this.finishOp(133, 2);
			else super.getTokenFromCode(code$1);
		}
		parseExprAtom(refExpressionErrors) {
			return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
		}
		parseIdentifier(liberal) {
			return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
		}
		checkReservedWord(word, startLoc, checkKeywords, isBinding) {
			if (word !== void 0) super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
		}
		cloneIdentifier(node) {
			const cloned = super.cloneIdentifier(node);
			if (cloned.type === "Placeholder") cloned.expectedNode = node.expectedNode;
			return cloned;
		}
		cloneStringLiteral(node) {
			if (node.type === "Placeholder") return this.cloneIdentifier(node);
			return super.cloneStringLiteral(node);
		}
		parseBindingAtom() {
			return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
		}
		isValidLVal(type, disallowCallExpression, isParenthesized, binding) {
			return type === "Placeholder" || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding);
		}
		toAssignable(node, isLHS) {
			if (node && node.type === "Placeholder" && node.expectedNode === "Expression") node.expectedNode = "Pattern";
			else super.toAssignable(node, isLHS);
		}
		chStartsBindingIdentifier(ch, pos) {
			if (super.chStartsBindingIdentifier(ch, pos)) return true;
			const next = this.nextTokenStart();
			if (this.input.charCodeAt(next) === 37 && this.input.charCodeAt(next + 1) === 37) return true;
			return false;
		}
		verifyBreakContinue(node, isBreak) {
			if (node.label && node.label.type === "Placeholder") return;
			super.verifyBreakContinue(node, isBreak);
		}
		parseExpressionStatement(node, expr) {
			var _expr$extra;
			if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) return super.parseExpressionStatement(node, expr);
			if (this.match(14)) {
				const stmt = node;
				stmt.label = this.finishPlaceholder(expr, "Identifier");
				this.next();
				stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
				return this.finishNode(stmt, "LabeledStatement");
			}
			this.semicolon();
			const stmtPlaceholder = node;
			stmtPlaceholder.name = expr.name;
			return this.finishPlaceholder(stmtPlaceholder, "Statement");
		}
		parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
			return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
		}
		parseFunctionId(requireId) {
			return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
		}
		parseClass(node, isStatement, optionalId) {
			const type = isStatement ? "ClassDeclaration" : "ClassExpression";
			this.next();
			const oldStrict = this.state.strict;
			const placeholder = this.parsePlaceholder("Identifier");
			if (placeholder) if (this.match(81) || this.match(133) || this.match(5)) node.id = placeholder;
			else if (optionalId || !isStatement) {
				node.id = null;
				node.body = this.finishPlaceholder(placeholder, "ClassBody");
				return this.finishNode(node, type);
			} else throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
			else this.parseClassId(node, isStatement, optionalId);
			super.parseClassSuper(node);
			node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
			return this.finishNode(node, type);
		}
		parseExport(node, decorators) {
			const placeholder = this.parsePlaceholder("Identifier");
			if (!placeholder) return super.parseExport(node, decorators);
			const node2 = node;
			if (!this.isContextual(98) && !this.match(12)) {
				node2.specifiers = [];
				node2.source = null;
				node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
				return this.finishNode(node2, "ExportNamedDeclaration");
			}
			this.expectPlugin("exportDefaultFrom");
			const specifier = this.startNode();
			specifier.exported = placeholder;
			node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
			return super.parseExport(node2, decorators);
		}
		isExportDefaultSpecifier() {
			if (this.match(65)) {
				const next = this.nextTokenStart();
				if (this.isUnparsedContextual(next, "from")) {
					if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) return true;
				}
			}
			return super.isExportDefaultSpecifier();
		}
		maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
			var _specifiers;
			if ((_specifiers = node.specifiers) != null && _specifiers.length) return true;
			return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
		}
		checkExport(node) {
			const { specifiers } = node;
			if (specifiers != null && specifiers.length) node.specifiers = specifiers.filter((node$1) => node$1.exported.type === "Placeholder");
			super.checkExport(node);
			node.specifiers = specifiers;
		}
		parseImport(node) {
			const placeholder = this.parsePlaceholder("Identifier");
			if (!placeholder) return super.parseImport(node);
			node.specifiers = [];
			if (!this.isContextual(98) && !this.match(12)) {
				node.source = this.finishPlaceholder(placeholder, "StringLiteral");
				this.semicolon();
				return this.finishNode(node, "ImportDeclaration");
			}
			const specifier = this.startNodeAtNode(placeholder);
			specifier.local = placeholder;
			node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
			if (this.eat(12)) {
				const hasStarImport = this.maybeParseStarImportSpecifier(node);
				if (!hasStarImport) this.parseNamedImportSpecifiers(node);
			}
			this.expectContextual(98);
			node.source = this.parseImportSource();
			this.semicolon();
			return this.finishNode(node, "ImportDeclaration");
		}
		parseImportSource() {
			return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
		}
		assertNoSpace() {
			if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
		}
	};
	var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
		parseV8Intrinsic() {
			if (this.match(54)) {
				const v8IntrinsicStartLoc = this.state.startLoc;
				const node = this.startNode();
				this.next();
				if (tokenIsIdentifier(this.state.type)) {
					const name = this.parseIdentifierName();
					const identifier = this.createIdentifier(node, name);
					this.castNodeTo(identifier, "V8IntrinsicIdentifier");
					if (this.match(10)) return identifier;
				}
				this.unexpected(v8IntrinsicStartLoc);
			}
		}
		parseExprAtom(refExpressionErrors) {
			return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
		}
	};
	const PIPELINE_PROPOSALS = [
		"minimal",
		"fsharp",
		"hack",
		"smart"
	];
	const TOPIC_TOKENS = [
		"^^",
		"@@",
		"^",
		"%",
		"#"
	];
	function validatePlugins(pluginsMap) {
		if (pluginsMap.has("decorators")) {
			if (pluginsMap.has("decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
			const decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
			if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
			const allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
			if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") throw new Error("'allowCallParenthesized' must be a boolean.");
		}
		if (pluginsMap.has("flow") && pluginsMap.has("typescript")) throw new Error("Cannot combine flow and typescript plugins.");
		if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
		if (pluginsMap.has("pipelineOperator")) {
			var _pluginsMap$get2;
			const proposal = pluginsMap.get("pipelineOperator").proposal;
			if (!PIPELINE_PROPOSALS.includes(proposal)) {
				const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
				throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
			}
			if (proposal === "hack") {
				if (pluginsMap.has("placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
				if (pluginsMap.has("v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
				const topicToken = pluginsMap.get("pipelineOperator").topicToken;
				if (!TOPIC_TOKENS.includes(topicToken)) {
					const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
					throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
				}
				{
					var _pluginsMap$get;
					if (topicToken === "#" && ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash") throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
				}
			} else if (proposal === "smart" && ((_pluginsMap$get2 = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get2.syntaxType) === "hash") throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
		}
		if (pluginsMap.has("moduleAttributes")) {
			if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
			const moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;
			if (moduleAttributesVersionPluginOption !== "may-2020") throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
		}
		if (pluginsMap.has("importAssertions")) {
			if (pluginsMap.has("deprecatedImportAssert")) throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
		}
		if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) pluginsMap.set("deprecatedImportAssert", {});
		if (pluginsMap.has("recordAndTuple")) {
			const syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
			if (syntaxType != null) {
				const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
				if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
			}
		}
		if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
			const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
			error.missingPlugins = "doExpressions";
			throw error;
		}
		if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
		if (pluginsMap.has("discardBinding") && pluginsMap.get("discardBinding").syntaxType !== "void") throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
	}
	const mixinPlugins = {
		estree,
		jsx,
		flow,
		typescript,
		v8intrinsic,
		placeholders
	};
	const mixinPluginNames = Object.keys(mixinPlugins);
	var ExpressionParser = class extends LValParser {
		checkProto(prop, isRecord, sawProto, refExpressionErrors) {
			if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) return sawProto;
			const key = prop.key;
			const name = key.type === "Identifier" ? key.name : key.value;
			if (name === "__proto__") {
				if (isRecord) {
					this.raise(Errors.RecordNoProto, key);
					return true;
				}
				if (sawProto) if (refExpressionErrors) {
					if (refExpressionErrors.doubleProtoLoc === null) refExpressionErrors.doubleProtoLoc = key.loc.start;
				} else this.raise(Errors.DuplicateProto, key);
				return true;
			}
			return sawProto;
		}
		shouldExitDescending(expr, potentialArrowAt) {
			return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
		}
		getExpression() {
			this.enterInitialScopes();
			this.nextToken();
			if (this.match(140)) throw this.raise(Errors.ParseExpressionEmptyInput, this.state.startLoc);
			const expr = this.parseExpression();
			if (!this.match(140)) throw this.raise(Errors.ParseExpressionExpectsEOF, this.state.startLoc, { unexpected: this.input.codePointAt(this.state.start) });
			this.finalizeRemainingComments();
			expr.comments = this.comments;
			expr.errors = this.state.errors;
			if (this.optionFlags & 256) expr.tokens = this.tokens;
			return expr;
		}
		parseExpression(disallowIn, refExpressionErrors) {
			if (disallowIn) return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
			return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
		}
		parseExpressionBase(refExpressionErrors) {
			const startLoc = this.state.startLoc;
			const expr = this.parseMaybeAssign(refExpressionErrors);
			if (this.match(12)) {
				const node = this.startNodeAt(startLoc);
				node.expressions = [expr];
				while (this.eat(12)) node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
				this.toReferencedList(node.expressions);
				return this.finishNode(node, "SequenceExpression");
			}
			return expr;
		}
		parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
			return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
		}
		parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
			return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
		}
		setOptionalParametersError(refExpressionErrors) {
			refExpressionErrors.optionalParametersLoc = this.state.startLoc;
		}
		parseMaybeAssign(refExpressionErrors, afterLeftParse) {
			const startLoc = this.state.startLoc;
			const isYield = this.isContextual(108);
			if (isYield) {
				if (this.prodParam.hasYield) {
					this.next();
					let left$1 = this.parseYield(startLoc);
					if (afterLeftParse) left$1 = afterLeftParse.call(this, left$1, startLoc);
					return left$1;
				}
			}
			let ownExpressionErrors;
			if (refExpressionErrors) ownExpressionErrors = false;
			else {
				refExpressionErrors = new ExpressionErrors();
				ownExpressionErrors = true;
			}
			const { type } = this.state;
			if (type === 10 || tokenIsIdentifier(type)) this.state.potentialArrowAt = this.state.start;
			let left = this.parseMaybeConditional(refExpressionErrors);
			if (afterLeftParse) left = afterLeftParse.call(this, left, startLoc);
			if (tokenIsAssignment(this.state.type)) {
				const node = this.startNodeAt(startLoc);
				const operator = this.state.value;
				node.operator = operator;
				if (this.match(29)) {
					this.toAssignable(left, true);
					node.left = left;
					const startIndex = startLoc.index;
					if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) refExpressionErrors.doubleProtoLoc = null;
					if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) refExpressionErrors.shorthandAssignLoc = null;
					if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
						this.checkDestructuringPrivate(refExpressionErrors);
						refExpressionErrors.privateKeyLoc = null;
					}
					if (refExpressionErrors.voidPatternLoc != null && refExpressionErrors.voidPatternLoc.index >= startIndex) refExpressionErrors.voidPatternLoc = null;
				} else node.left = left;
				this.next();
				node.right = this.parseMaybeAssign();
				this.checkLVal(left, this.finishNode(node, "AssignmentExpression"), void 0, void 0, void 0, void 0, operator === "||=" || operator === "&&=" || operator === "??=");
				return node;
			} else if (ownExpressionErrors) this.checkExpressionErrors(refExpressionErrors, true);
			if (isYield) {
				const { type: type$1 } = this.state;
				const startsExpr$1 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type$1) : tokenCanStartExpression(type$1) && !this.match(54);
				if (startsExpr$1 && !this.isAmbiguousPrefixOrIdentifier()) {
					this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);
					return this.parseYield(startLoc);
				}
			}
			return left;
		}
		parseMaybeConditional(refExpressionErrors) {
			const startLoc = this.state.startLoc;
			const potentialArrowAt = this.state.potentialArrowAt;
			const expr = this.parseExprOps(refExpressionErrors);
			if (this.shouldExitDescending(expr, potentialArrowAt)) return expr;
			return this.parseConditional(expr, startLoc, refExpressionErrors);
		}
		parseConditional(expr, startLoc, refExpressionErrors) {
			if (this.eat(17)) {
				const node = this.startNodeAt(startLoc);
				node.test = expr;
				node.consequent = this.parseMaybeAssignAllowIn();
				this.expect(14);
				node.alternate = this.parseMaybeAssign();
				return this.finishNode(node, "ConditionalExpression");
			}
			return expr;
		}
		parseMaybeUnaryOrPrivate(refExpressionErrors) {
			return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
		}
		parseExprOps(refExpressionErrors) {
			const startLoc = this.state.startLoc;
			const potentialArrowAt = this.state.potentialArrowAt;
			const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
			if (this.shouldExitDescending(expr, potentialArrowAt)) return expr;
			return this.parseExprOp(expr, startLoc, -1);
		}
		parseExprOp(left, leftStartLoc, minPrec) {
			if (this.isPrivateName(left)) {
				const value = this.getPrivateNameSV(left);
				if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) this.raise(Errors.PrivateInExpectedIn, left, { identifierName: value });
				this.classScope.usePrivateName(value, left.loc.start);
			}
			const op = this.state.type;
			if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
				let prec = tokenOperatorPrecedence(op);
				if (prec > minPrec) {
					if (op === 39) {
						this.expectPlugin("pipelineOperator");
						if (this.state.inFSharpPipelineDirectBody) return left;
						this.checkPipelineAtInfixOperator(left, leftStartLoc);
					}
					const node = this.startNodeAt(leftStartLoc);
					node.left = left;
					node.operator = this.state.value;
					const logical = op === 41 || op === 42;
					const coalesce = op === 40;
					if (coalesce) prec = tokenOperatorPrecedence(42);
					this.next();
					if (op === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }])) {
						if (this.state.type === 96 && this.prodParam.hasAwait) throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
					}
					node.right = this.parseExprOpRightExpr(op, prec);
					const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
					const nextOp = this.state.type;
					if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
					return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
				}
			}
			return left;
		}
		parseExprOpRightExpr(op, prec) {
			const startLoc = this.state.startLoc;
			switch (op) {
				case 39:
					switch (this.getPluginOption("pipelineOperator", "proposal")) {
						case "hack": return this.withTopicBindingContext(() => {
							return this.parseHackPipeBody();
						});
						case "fsharp": return this.withSoloAwaitPermittingContext(() => {
							return this.parseFSharpPipelineBody(prec);
						});
					}
					if (this.getPluginOption("pipelineOperator", "proposal") === "smart") return this.withTopicBindingContext(() => {
						if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
						return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
					});
				default: return this.parseExprOpBaseRightExpr(op, prec);
			}
		}
		parseExprOpBaseRightExpr(op, prec) {
			const startLoc = this.state.startLoc;
			return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
		}
		parseHackPipeBody() {
			var _body$extra;
			const { startLoc } = this.state;
			const body = this.parseMaybeAssign();
			const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
			if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) this.raise(Errors.PipeUnparenthesizedBody, startLoc, { type: body.type });
			if (!this.topicReferenceWasUsedInCurrentContext()) this.raise(Errors.PipeTopicUnused, startLoc);
			return body;
		}
		checkExponentialAfterUnary(node) {
			if (this.match(57)) this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
		}
		parseMaybeUnary(refExpressionErrors, sawUnary) {
			const startLoc = this.state.startLoc;
			const isAwait = this.isContextual(96);
			if (isAwait && this.recordAwaitIfAllowed()) {
				this.next();
				const expr$1 = this.parseAwait(startLoc);
				if (!sawUnary) this.checkExponentialAfterUnary(expr$1);
				return expr$1;
			}
			const update = this.match(34);
			const node = this.startNode();
			if (tokenIsPrefix(this.state.type)) {
				node.operator = this.state.value;
				node.prefix = true;
				if (this.match(72)) this.expectPlugin("throwExpressions");
				const isDelete = this.match(89);
				this.next();
				node.argument = this.parseMaybeUnary(null, true);
				this.checkExpressionErrors(refExpressionErrors, true);
				if (this.state.strict && isDelete) {
					const arg = node.argument;
					if (arg.type === "Identifier") this.raise(Errors.StrictDelete, node);
					else if (this.hasPropertyAsPrivateName(arg)) this.raise(Errors.DeletePrivateField, node);
				}
				if (!update) {
					if (!sawUnary) this.checkExponentialAfterUnary(node);
					return this.finishNode(node, "UnaryExpression");
				}
			}
			const expr = this.parseUpdate(node, update, refExpressionErrors);
			if (isAwait) {
				const { type } = this.state;
				const startsExpr$1 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
				if (startsExpr$1 && !this.isAmbiguousPrefixOrIdentifier()) {
					this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
					return this.parseAwait(startLoc);
				}
			}
			return expr;
		}
		parseUpdate(node, update, refExpressionErrors) {
			if (update) {
				const updateExpressionNode = node;
				this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));
				return node;
			}
			const startLoc = this.state.startLoc;
			let expr = this.parseExprSubscripts(refExpressionErrors);
			if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
			while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
				const node$1 = this.startNodeAt(startLoc);
				node$1.operator = this.state.value;
				node$1.prefix = false;
				node$1.argument = expr;
				this.next();
				this.checkLVal(expr, expr = this.finishNode(node$1, "UpdateExpression"));
			}
			return expr;
		}
		parseExprSubscripts(refExpressionErrors) {
			const startLoc = this.state.startLoc;
			const potentialArrowAt = this.state.potentialArrowAt;
			const expr = this.parseExprAtom(refExpressionErrors);
			if (this.shouldExitDescending(expr, potentialArrowAt)) return expr;
			return this.parseSubscripts(expr, startLoc);
		}
		parseSubscripts(base, startLoc, noCalls) {
			const state = {
				optionalChainMember: false,
				maybeAsyncArrow: this.atPossibleAsyncArrow(base),
				stop: false
			};
			do {
				base = this.parseSubscript(base, startLoc, noCalls, state);
				state.maybeAsyncArrow = false;
			} while (!state.stop);
			return base;
		}
		parseSubscript(base, startLoc, noCalls, state) {
			const { type } = this.state;
			if (!noCalls && type === 15) return this.parseBind(base, startLoc, noCalls, state);
			else if (tokenIsTemplate(type)) return this.parseTaggedTemplateExpression(base, startLoc, state);
			let optional = false;
			if (type === 18) {
				if (noCalls) {
					this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
					if (this.lookaheadCharCode() === 40) return this.stopParseSubscript(base, state);
				}
				state.optionalChainMember = optional = true;
				this.next();
			}
			if (!noCalls && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
			else {
				const computed$1 = this.eat(0);
				if (computed$1 || optional || this.eat(16)) return this.parseMember(base, startLoc, state, computed$1, optional);
				else return this.stopParseSubscript(base, state);
			}
		}
		stopParseSubscript(base, state) {
			state.stop = true;
			return base;
		}
		parseMember(base, startLoc, state, computed$1, optional) {
			const node = this.startNodeAt(startLoc);
			node.object = base;
			node.computed = computed$1;
			if (computed$1) {
				node.property = this.parseExpression();
				this.expect(3);
			} else if (this.match(139)) {
				if (base.type === "Super") this.raise(Errors.SuperPrivateField, startLoc);
				this.classScope.usePrivateName(this.state.value, this.state.startLoc);
				node.property = this.parsePrivateName();
			} else node.property = this.parseIdentifier(true);
			if (state.optionalChainMember) {
				node.optional = optional;
				return this.finishNode(node, "OptionalMemberExpression");
			} else return this.finishNode(node, "MemberExpression");
		}
		parseBind(base, startLoc, noCalls, state) {
			const node = this.startNodeAt(startLoc);
			node.object = base;
			this.next();
			node.callee = this.parseNoCallExpr();
			state.stop = true;
			return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
		}
		parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
			const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
			let refExpressionErrors = null;
			this.state.maybeInArrowParameters = true;
			this.next();
			const node = this.startNodeAt(startLoc);
			node.callee = base;
			const { maybeAsyncArrow, optionalChainMember } = state;
			if (maybeAsyncArrow) {
				this.expressionScope.enter(newAsyncArrowScope());
				refExpressionErrors = new ExpressionErrors();
			}
			if (optionalChainMember) node.optional = optional;
			if (optional) node.arguments = this.parseCallExpressionArguments();
			else node.arguments = this.parseCallExpressionArguments(base.type !== "Super", node, refExpressionErrors);
			let finishedNode = this.finishCallExpression(node, optionalChainMember);
			if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
				state.stop = true;
				this.checkDestructuringPrivate(refExpressionErrors);
				this.expressionScope.validateAsPattern();
				this.expressionScope.exit();
				finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
			} else {
				if (maybeAsyncArrow) {
					this.checkExpressionErrors(refExpressionErrors, true);
					this.expressionScope.exit();
				}
				this.toReferencedArguments(finishedNode);
			}
			this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
			return finishedNode;
		}
		toReferencedArguments(node, isParenthesizedExpr) {
			this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
		}
		parseTaggedTemplateExpression(base, startLoc, state) {
			const node = this.startNodeAt(startLoc);
			node.tag = base;
			node.quasi = this.parseTemplate(true);
			if (state.optionalChainMember) this.raise(Errors.OptionalChainingNoTemplate, startLoc);
			return this.finishNode(node, "TaggedTemplateExpression");
		}
		atPossibleAsyncArrow(base) {
			return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
		}
		finishCallExpression(node, optional) {
			if (node.callee.type === "Import") {
				if (node.arguments.length === 0 || node.arguments.length > 2) this.raise(Errors.ImportCallArity, node);
				else for (const arg of node.arguments) if (arg.type === "SpreadElement") this.raise(Errors.ImportCallSpreadArgument, arg);
			}
			return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
		}
		parseCallExpressionArguments(allowPlaceholder, nodeForExtra, refExpressionErrors) {
			const elts = [];
			let first = true;
			const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
			this.state.inFSharpPipelineDirectBody = false;
			while (!this.eat(11)) {
				if (first) first = false;
				else {
					this.expect(12);
					if (this.match(11)) {
						if (nodeForExtra) this.addTrailingCommaExtraToNode(nodeForExtra);
						this.next();
						break;
					}
				}
				elts.push(this.parseExprListItem(11, false, refExpressionErrors, allowPlaceholder));
			}
			this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
			return elts;
		}
		shouldParseAsyncArrow() {
			return this.match(19) && !this.canInsertSemicolon();
		}
		parseAsyncArrowFromCallExpression(node, call) {
			var _call$extra;
			this.resetPreviousNodeTrailingComments(call);
			this.expect(19);
			this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
			if (call.innerComments) setInnerComments(node, call.innerComments);
			if (call.callee.trailingComments) setInnerComments(node, call.callee.trailingComments);
			return node;
		}
		parseNoCallExpr() {
			const startLoc = this.state.startLoc;
			return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
		}
		parseExprAtom(refExpressionErrors) {
			let node;
			let decorators = null;
			const { type } = this.state;
			switch (type) {
				case 79: return this.parseSuper();
				case 83:
					node = this.startNode();
					this.next();
					if (this.match(16)) return this.parseImportMetaPropertyOrPhaseCall(node);
					if (this.match(10)) if (this.optionFlags & 512) return this.parseImportCall(node);
					else return this.finishNode(node, "Import");
					else {
						this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
						return this.finishNode(node, "Import");
					}
				case 78:
					node = this.startNode();
					this.next();
					return this.finishNode(node, "ThisExpression");
				case 90: return this.parseDo(this.startNode(), false);
				case 56:
				case 31: {
					this.readRegexp();
					return this.parseRegExpLiteral(this.state.value);
				}
				case 135: return this.parseNumericLiteral(this.state.value);
				case 136: return this.parseBigIntLiteral(this.state.value);
				case 134: return this.parseStringLiteral(this.state.value);
				case 84: return this.parseNullLiteral();
				case 85: return this.parseBooleanLiteral(true);
				case 86: return this.parseBooleanLiteral(false);
				case 10: {
					const canBeArrow = this.state.potentialArrowAt === this.state.start;
					return this.parseParenAndDistinguishExpression(canBeArrow);
				}
				case 0: return this.parseArrayLike(3, false, refExpressionErrors);
				case 5: return this.parseObjectLike(8, false, false, refExpressionErrors);
				case 68: return this.parseFunctionOrFunctionSent();
				case 26: decorators = this.parseDecorators();
				case 80: return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
				case 77: return this.parseNewOrNewTarget();
				case 25:
				case 24: return this.parseTemplate(false);
				case 15: {
					node = this.startNode();
					this.next();
					node.object = null;
					const callee = node.callee = this.parseNoCallExpr();
					if (callee.type === "MemberExpression") return this.finishNode(node, "BindExpression");
					else throw this.raise(Errors.UnsupportedBind, callee);
				}
				case 139: {
					this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value });
					return this.parsePrivateName();
				}
				case 33: return this.parseTopicReferenceThenEqualsSign(54, "%");
				case 32: return this.parseTopicReferenceThenEqualsSign(44, "^");
				case 37:
				case 38: return this.parseTopicReference("hack");
				case 44:
				case 54:
				case 27: {
					const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
					if (pipeProposal) return this.parseTopicReference(pipeProposal);
					throw this.unexpected();
				}
				case 47: {
					const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
					if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) throw this.expectOnePlugin([
						"jsx",
						"flow",
						"typescript"
					]);
					throw this.unexpected();
				}
				default:
					if (type === 137) return this.parseDecimalLiteral(this.state.value);
					else if (type === 2 || type === 1) return this.parseArrayLike(this.state.type === 2 ? 4 : 3, true);
					else if (type === 6 || type === 7) return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
					if (tokenIsIdentifier(type)) {
						if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) return this.parseModuleExpression();
						const canBeArrow = this.state.potentialArrowAt === this.state.start;
						const containsEsc = this.state.containsEsc;
						const id = this.parseIdentifier();
						if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
							const { type: type$1 } = this.state;
							if (type$1 === 68) {
								this.resetPreviousNodeTrailingComments(id);
								this.next();
								return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
							} else if (tokenIsIdentifier(type$1)) if (this.lookaheadCharCode() === 61) return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
							else return id;
							else if (type$1 === 90) {
								this.resetPreviousNodeTrailingComments(id);
								return this.parseDo(this.startNodeAtNode(id), true);
							}
						}
						if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
							this.next();
							return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
						}
						return id;
					} else throw this.unexpected();
			}
		}
		parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
			const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
			if (pipeProposal) {
				this.state.type = topicTokenType;
				this.state.value = topicTokenValue;
				this.state.pos--;
				this.state.end--;
				this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
				return this.parseTopicReference(pipeProposal);
			}
			throw this.unexpected();
		}
		parseTopicReference(pipeProposal) {
			const node = this.startNode();
			const startLoc = this.state.startLoc;
			const tokenType = this.state.type;
			this.next();
			return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
		}
		finishTopicReference(node, startLoc, pipeProposal, tokenType) {
			if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) if (pipeProposal === "hack") {
				if (!this.topicReferenceIsAllowedInCurrentContext()) this.raise(Errors.PipeTopicUnbound, startLoc);
				this.registerTopicReference();
				return this.finishNode(node, "TopicReference");
			} else {
				if (!this.topicReferenceIsAllowedInCurrentContext()) this.raise(Errors.PrimaryTopicNotAllowed, startLoc);
				this.registerTopicReference();
				return this.finishNode(node, "PipelinePrimaryTopicReference");
			}
			else throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, { token: tokenLabelName(tokenType) });
		}
		testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
			switch (pipeProposal) {
				case "hack": return this.hasPlugin(["pipelineOperator", { topicToken: tokenLabelName(tokenType) }]);
				case "smart": return tokenType === 27;
				default: throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
			}
		}
		parseAsyncArrowUnaryFunction(node) {
			this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
			const params = [this.parseIdentifier()];
			this.prodParam.exit();
			if (this.hasPrecedingLineBreak()) this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
			this.expect(19);
			return this.parseArrowExpression(node, params, true);
		}
		parseDo(node, isAsync) {
			this.expectPlugin("doExpressions");
			if (isAsync) this.expectPlugin("asyncDoExpressions");
			node.async = isAsync;
			this.next();
			const oldLabels = this.state.labels;
			this.state.labels = [];
			if (isAsync) {
				this.prodParam.enter(2);
				node.body = this.parseBlock();
				this.prodParam.exit();
			} else node.body = this.parseBlock();
			this.state.labels = oldLabels;
			return this.finishNode(node, "DoExpression");
		}
		parseSuper() {
			const node = this.startNode();
			this.next();
			if (this.match(10) && !this.scope.allowDirectSuper) {
				if (!(this.optionFlags & 16)) this.raise(Errors.SuperNotAllowed, node);
			} else if (!this.scope.allowSuper) {
				if (!(this.optionFlags & 16)) this.raise(Errors.UnexpectedSuper, node);
			}
			if (!this.match(10) && !this.match(0) && !this.match(16)) this.raise(Errors.UnsupportedSuper, node);
			return this.finishNode(node, "Super");
		}
		parsePrivateName() {
			const node = this.startNode();
			const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
			const name = this.state.value;
			this.next();
			node.id = this.createIdentifier(id, name);
			return this.finishNode(node, "PrivateName");
		}
		parseFunctionOrFunctionSent() {
			const node = this.startNode();
			this.next();
			if (this.prodParam.hasYield && this.match(16)) {
				const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
				this.next();
				if (this.match(103)) this.expectPlugin("functionSent");
				else if (!this.hasPlugin("functionSent")) this.unexpected();
				return this.parseMetaProperty(node, meta, "sent");
			}
			return this.parseFunction(node);
		}
		parseMetaProperty(node, meta, propertyName) {
			node.meta = meta;
			const containsEsc = this.state.containsEsc;
			node.property = this.parseIdentifier(true);
			if (node.property.name !== propertyName || containsEsc) this.raise(Errors.UnsupportedMetaProperty, node.property, {
				target: meta.name,
				onlyValidPropertyName: propertyName
			});
			return this.finishNode(node, "MetaProperty");
		}
		parseImportMetaPropertyOrPhaseCall(node) {
			this.next();
			if (this.isContextual(105) || this.isContextual(97)) {
				const isSource = this.isContextual(105);
				this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
				this.next();
				node.phase = isSource ? "source" : "defer";
				return this.parseImportCall(node);
			} else {
				const id = this.createIdentifierAt(this.startNodeAtNode(node), "import", this.state.lastTokStartLoc);
				if (this.isContextual(101)) {
					if (!this.inModule) this.raise(Errors.ImportMetaOutsideModule, id);
					this.sawUnambiguousESM = true;
				}
				return this.parseMetaProperty(node, id, "meta");
			}
		}
		parseLiteralAtNode(value, type, node) {
			this.addExtra(node, "rawValue", value);
			this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
			node.value = value;
			this.next();
			return this.finishNode(node, type);
		}
		parseLiteral(value, type) {
			const node = this.startNode();
			return this.parseLiteralAtNode(value, type, node);
		}
		parseStringLiteral(value) {
			return this.parseLiteral(value, "StringLiteral");
		}
		parseNumericLiteral(value) {
			return this.parseLiteral(value, "NumericLiteral");
		}
		parseBigIntLiteral(value) {
			return this.parseLiteral(value, "BigIntLiteral");
		}
		parseDecimalLiteral(value) {
			return this.parseLiteral(value, "DecimalLiteral");
		}
		parseRegExpLiteral(value) {
			const node = this.startNode();
			this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
			node.pattern = value.pattern;
			node.flags = value.flags;
			this.next();
			return this.finishNode(node, "RegExpLiteral");
		}
		parseBooleanLiteral(value) {
			const node = this.startNode();
			node.value = value;
			this.next();
			return this.finishNode(node, "BooleanLiteral");
		}
		parseNullLiteral() {
			const node = this.startNode();
			this.next();
			return this.finishNode(node, "NullLiteral");
		}
		parseParenAndDistinguishExpression(canBeArrow) {
			const startLoc = this.state.startLoc;
			let val;
			this.next();
			this.expressionScope.enter(newArrowHeadScope());
			const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
			const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
			this.state.maybeInArrowParameters = true;
			this.state.inFSharpPipelineDirectBody = false;
			const innerStartLoc = this.state.startLoc;
			const exprList = [];
			const refExpressionErrors = new ExpressionErrors();
			let first = true;
			let spreadStartLoc;
			let optionalCommaStartLoc;
			while (!this.match(11)) {
				if (first) first = false;
				else {
					this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
					if (this.match(11)) {
						optionalCommaStartLoc = this.state.startLoc;
						break;
					}
				}
				if (this.match(21)) {
					const spreadNodeStartLoc = this.state.startLoc;
					spreadStartLoc = this.state.startLoc;
					exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
					if (!this.checkCommaAfterRest(41)) break;
				} else exprList.push(this.parseMaybeAssignAllowInOrVoidPattern(11, refExpressionErrors, this.parseParenItem));
			}
			const innerEndLoc = this.state.lastTokEndLoc;
			this.expect(11);
			this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
			this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
			let arrowNode = this.startNodeAt(startLoc);
			if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
				this.checkDestructuringPrivate(refExpressionErrors);
				this.expressionScope.validateAsPattern();
				this.expressionScope.exit();
				this.parseArrowExpression(arrowNode, exprList, false);
				return arrowNode;
			}
			this.expressionScope.exit();
			if (!exprList.length) this.unexpected(this.state.lastTokStartLoc);
			if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
			if (spreadStartLoc) this.unexpected(spreadStartLoc);
			this.checkExpressionErrors(refExpressionErrors, true);
			this.toReferencedListDeep(exprList, true);
			if (exprList.length > 1) {
				val = this.startNodeAt(innerStartLoc);
				val.expressions = exprList;
				this.finishNode(val, "SequenceExpression");
				this.resetEndLocation(val, innerEndLoc);
			} else val = exprList[0];
			return this.wrapParenthesis(startLoc, val);
		}
		wrapParenthesis(startLoc, expression) {
			if (!(this.optionFlags & 1024)) {
				this.addExtra(expression, "parenthesized", true);
				this.addExtra(expression, "parenStart", startLoc.index);
				this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
				return expression;
			}
			const parenExpression = this.startNodeAt(startLoc);
			parenExpression.expression = expression;
			return this.finishNode(parenExpression, "ParenthesizedExpression");
		}
		shouldParseArrow(params) {
			return !this.canInsertSemicolon();
		}
		parseArrow(node) {
			if (this.eat(19)) return node;
		}
		parseParenItem(node, startLoc) {
			return node;
		}
		parseNewOrNewTarget() {
			const node = this.startNode();
			this.next();
			if (this.match(16)) {
				const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
				this.next();
				const metaProp = this.parseMetaProperty(node, meta, "target");
				if (!this.scope.allowNewTarget) this.raise(Errors.UnexpectedNewTarget, metaProp);
				return metaProp;
			}
			return this.parseNew(node);
		}
		parseNew(node) {
			this.parseNewCallee(node);
			if (this.eat(10)) {
				const args = this.parseExprList(11);
				this.toReferencedList(args);
				node.arguments = args;
			} else node.arguments = [];
			return this.finishNode(node, "NewExpression");
		}
		parseNewCallee(node) {
			const isImport = this.match(83);
			const callee = this.parseNoCallExpr();
			node.callee = callee;
			if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) this.raise(Errors.ImportCallNotNewExpression, callee);
		}
		parseTemplateElement(isTagged) {
			const { start, startLoc, end, value } = this.state;
			const elemStart = start + 1;
			const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
			if (value === null) {
				if (!isTagged) this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
			}
			const isTail = this.match(24);
			const endOffset = isTail ? -1 : -2;
			const elemEnd = end + endOffset;
			elem.value = {
				raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
				cooked: value === null ? null : value.slice(1, endOffset)
			};
			elem.tail = isTail;
			this.next();
			const finishedNode = this.finishNode(elem, "TemplateElement");
			this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
			return finishedNode;
		}
		parseTemplate(isTagged) {
			const node = this.startNode();
			let curElt = this.parseTemplateElement(isTagged);
			const quasis = [curElt];
			const substitutions = [];
			while (!curElt.tail) {
				substitutions.push(this.parseTemplateSubstitution());
				this.readTemplateContinuation();
				quasis.push(curElt = this.parseTemplateElement(isTagged));
			}
			node.expressions = substitutions;
			node.quasis = quasis;
			return this.finishNode(node, "TemplateLiteral");
		}
		parseTemplateSubstitution() {
			return this.parseExpression();
		}
		parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
			if (isRecord) this.expectPlugin("recordAndTuple");
			const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
			this.state.inFSharpPipelineDirectBody = false;
			let sawProto = false;
			let first = true;
			const node = this.startNode();
			node.properties = [];
			this.next();
			while (!this.match(close)) {
				if (first) first = false;
				else {
					this.expect(12);
					if (this.match(close)) {
						this.addTrailingCommaExtraToNode(node);
						break;
					}
				}
				let prop;
				if (isPattern) prop = this.parseBindingProperty();
				else {
					prop = this.parsePropertyDefinition(refExpressionErrors);
					sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);
				}
				if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") this.raise(Errors.InvalidRecordProperty, prop);
				if (prop.shorthand) this.addExtra(prop, "shorthand", true);
				node.properties.push(prop);
			}
			this.next();
			this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
			let type = "ObjectExpression";
			if (isPattern) type = "ObjectPattern";
			else if (isRecord) type = "RecordExpression";
			return this.finishNode(node, type);
		}
		addTrailingCommaExtraToNode(node) {
			this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
			this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
		}
		maybeAsyncOrAccessorProp(prop) {
			return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
		}
		parsePropertyDefinition(refExpressionErrors) {
			let decorators = [];
			if (this.match(26)) {
				if (this.hasPlugin("decorators")) this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
				while (this.match(26)) decorators.push(this.parseDecorator());
			}
			const prop = this.startNode();
			let isAsync = false;
			let isAccessor = false;
			let startLoc;
			if (this.match(21)) {
				if (decorators.length) this.unexpected();
				return this.parseSpread();
			}
			if (decorators.length) {
				prop.decorators = decorators;
				decorators = [];
			}
			prop.method = false;
			if (refExpressionErrors) startLoc = this.state.startLoc;
			let isGenerator = this.eat(55);
			this.parsePropertyNamePrefixOperator(prop);
			const containsEsc = this.state.containsEsc;
			this.parsePropertyName(prop, refExpressionErrors);
			if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
				const { key } = prop;
				const keyName = key.name;
				if (keyName === "async" && !this.hasPrecedingLineBreak()) {
					isAsync = true;
					this.resetPreviousNodeTrailingComments(key);
					isGenerator = this.eat(55);
					this.parsePropertyName(prop);
				}
				if (keyName === "get" || keyName === "set") {
					isAccessor = true;
					this.resetPreviousNodeTrailingComments(key);
					prop.kind = keyName;
					if (this.match(55)) {
						isGenerator = true;
						this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), { kind: keyName });
						this.next();
					}
					this.parsePropertyName(prop);
				}
			}
			return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
		}
		getGetterSetterExpectedParamCount(method) {
			return method.kind === "get" ? 0 : 1;
		}
		getObjectOrClassMethodParams(method) {
			return method.params;
		}
		checkGetterSetterParams(method) {
			var _params;
			const paramCount = this.getGetterSetterExpectedParamCount(method);
			const params = this.getObjectOrClassMethodParams(method);
			if (params.length !== paramCount) this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
			if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") this.raise(Errors.BadSetterRestParameter, method);
		}
		parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
			if (isAccessor) {
				const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
				this.checkGetterSetterParams(finishedProp);
				return finishedProp;
			}
			if (isAsync || isGenerator || this.match(10)) {
				if (isPattern) this.unexpected();
				prop.kind = "method";
				prop.method = true;
				return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
			}
		}
		parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
			prop.shorthand = false;
			if (this.eat(14)) {
				prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, refExpressionErrors);
				return this.finishObjectProperty(prop);
			}
			if (!prop.computed && prop.key.type === "Identifier") {
				this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
				if (isPattern) prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
				else if (this.match(29)) {
					const shorthandAssignLoc = this.state.startLoc;
					if (refExpressionErrors != null) {
						if (refExpressionErrors.shorthandAssignLoc === null) refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
					} else this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
					prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
				} else prop.value = this.cloneIdentifier(prop.key);
				prop.shorthand = true;
				return this.finishObjectProperty(prop);
			}
		}
		finishObjectProperty(node) {
			return this.finishNode(node, "ObjectProperty");
		}
		parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
			const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
			if (!node) this.unexpected();
			return node;
		}
		parsePropertyName(prop, refExpressionErrors) {
			if (this.eat(0)) {
				prop.computed = true;
				prop.key = this.parseMaybeAssignAllowIn();
				this.expect(3);
			} else {
				const { type, value } = this.state;
				let key;
				if (tokenIsKeywordOrIdentifier(type)) key = this.parseIdentifier(true);
				else switch (type) {
					case 135:
						key = this.parseNumericLiteral(value);
						break;
					case 134:
						key = this.parseStringLiteral(value);
						break;
					case 136:
						key = this.parseBigIntLiteral(value);
						break;
					case 139: {
						const privateKeyLoc = this.state.startLoc;
						if (refExpressionErrors != null) {
							if (refExpressionErrors.privateKeyLoc === null) refExpressionErrors.privateKeyLoc = privateKeyLoc;
						} else this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
						key = this.parsePrivateName();
						break;
					}
					default:
						if (type === 137) {
							key = this.parseDecimalLiteral(value);
							break;
						}
						this.unexpected();
				}
				prop.key = key;
				if (type !== 139) prop.computed = false;
			}
		}
		initFunction(node, isAsync) {
			node.id = null;
			node.generator = false;
			node.async = isAsync;
		}
		parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
			this.initFunction(node, isAsync);
			node.generator = isGenerator;
			this.scope.enter(530 | (inClassScope ? 576 : 0) | (allowDirectSuper ? 32 : 0));
			this.prodParam.enter(functionFlags(isAsync, node.generator));
			this.parseFunctionParams(node, isConstructor);
			const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
			this.prodParam.exit();
			this.scope.exit();
			return finishedNode;
		}
		parseArrayLike(close, isTuple, refExpressionErrors) {
			if (isTuple) this.expectPlugin("recordAndTuple");
			const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
			this.state.inFSharpPipelineDirectBody = false;
			const node = this.startNode();
			this.next();
			node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
			this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
			return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
		}
		parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
			this.scope.enter(518);
			let flags = functionFlags(isAsync, false);
			if (!this.match(5) && this.prodParam.hasIn) flags |= 8;
			this.prodParam.enter(flags);
			this.initFunction(node, isAsync);
			const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
			if (params) {
				this.state.maybeInArrowParameters = true;
				this.setArrowFunctionParameters(node, params, trailingCommaLoc);
			}
			this.state.maybeInArrowParameters = false;
			this.parseFunctionBody(node, true);
			this.prodParam.exit();
			this.scope.exit();
			this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
			return this.finishNode(node, "ArrowFunctionExpression");
		}
		setArrowFunctionParameters(node, params, trailingCommaLoc) {
			this.toAssignableList(params, trailingCommaLoc, false);
			node.params = params;
		}
		parseFunctionBodyAndFinish(node, type, isMethod = false) {
			this.parseFunctionBody(node, false, isMethod);
			return this.finishNode(node, type);
		}
		parseFunctionBody(node, allowExpression, isMethod = false) {
			const isExpression = allowExpression && !this.match(5);
			this.expressionScope.enter(newExpressionScope());
			if (isExpression) {
				node.body = this.parseMaybeAssign();
				this.checkParams(node, false, allowExpression, false);
			} else {
				const oldStrict = this.state.strict;
				const oldLabels = this.state.labels;
				this.state.labels = [];
				this.prodParam.enter(this.prodParam.currentFlags() | 4);
				node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
					const nonSimple = !this.isSimpleParamList(node.params);
					if (hasStrictModeDirective && nonSimple) this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
					const strictModeChanged = !oldStrict && this.state.strict;
					this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
					if (this.state.strict && node.id) this.checkIdentifier(node.id, 65, strictModeChanged);
				});
				this.prodParam.exit();
				this.state.labels = oldLabels;
			}
			this.expressionScope.exit();
		}
		isSimpleParameter(node) {
			return node.type === "Identifier";
		}
		isSimpleParamList(params) {
			for (let i = 0, len = params.length; i < len; i++) if (!this.isSimpleParameter(params[i])) return false;
			return true;
		}
		checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
			const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
			const formalParameters = { type: "FormalParameters" };
			for (const param of node.params) this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
		}
		parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
			const elts = [];
			let first = true;
			while (!this.eat(close)) {
				if (first) first = false;
				else {
					this.expect(12);
					if (this.match(close)) {
						if (nodeForExtra) this.addTrailingCommaExtraToNode(nodeForExtra);
						this.next();
						break;
					}
				}
				elts.push(this.parseExprListItem(close, allowEmpty, refExpressionErrors));
			}
			return elts;
		}
		parseExprListItem(close, allowEmpty, refExpressionErrors, allowPlaceholder) {
			let elt;
			if (this.match(12)) {
				if (!allowEmpty) this.raise(Errors.UnexpectedToken, this.state.curPosition(), { unexpected: "," });
				elt = null;
			} else if (this.match(21)) {
				const spreadNodeStartLoc = this.state.startLoc;
				elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
			} else if (this.match(17)) {
				this.expectPlugin("partialApplication");
				if (!allowPlaceholder) this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
				const node = this.startNode();
				this.next();
				elt = this.finishNode(node, "ArgumentPlaceholder");
			} else elt = this.parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, this.parseParenItem);
			return elt;
		}
		parseIdentifier(liberal) {
			const node = this.startNode();
			const name = this.parseIdentifierName(liberal);
			return this.createIdentifier(node, name);
		}
		createIdentifier(node, name) {
			node.name = name;
			node.loc.identifierName = name;
			return this.finishNode(node, "Identifier");
		}
		createIdentifierAt(node, name, endLoc) {
			node.name = name;
			node.loc.identifierName = name;
			return this.finishNodeAt(node, "Identifier", endLoc);
		}
		parseIdentifierName(liberal) {
			let name;
			const { startLoc, type } = this.state;
			if (tokenIsKeywordOrIdentifier(type)) name = this.state.value;
			else this.unexpected();
			const tokenIsKeyword$1 = tokenKeywordOrIdentifierIsKeyword(type);
			if (liberal) {
				if (tokenIsKeyword$1) this.replaceToken(132);
			} else this.checkReservedWord(name, startLoc, tokenIsKeyword$1, false);
			this.next();
			return name;
		}
		checkReservedWord(word, startLoc, checkKeywords, isBinding) {
			if (word.length > 10) return;
			if (!canBeReservedWord(word)) return;
			if (checkKeywords && isKeyword(word)) {
				this.raise(Errors.UnexpectedKeyword, startLoc, { keyword: word });
				return;
			}
			const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
			if (reservedTest(word, this.inModule)) {
				this.raise(Errors.UnexpectedReservedWord, startLoc, { reservedWord: word });
				return;
			} else if (word === "yield") {
				if (this.prodParam.hasYield) {
					this.raise(Errors.YieldBindingIdentifier, startLoc);
					return;
				}
			} else if (word === "await") {
				if (this.prodParam.hasAwait) {
					this.raise(Errors.AwaitBindingIdentifier, startLoc);
					return;
				}
				if (this.scope.inStaticBlock) {
					this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
					return;
				}
				this.expressionScope.recordAsyncArrowParametersError(startLoc);
			} else if (word === "arguments") {
				if (this.scope.inClassAndNotInNonArrowFunction) {
					this.raise(Errors.ArgumentsInClass, startLoc);
					return;
				}
			}
		}
		recordAwaitIfAllowed() {
			const isAwaitAllowed = this.prodParam.hasAwait;
			if (isAwaitAllowed && !this.scope.inFunction) this.state.hasTopLevelAwait = true;
			return isAwaitAllowed;
		}
		parseAwait(startLoc) {
			const node = this.startNodeAt(startLoc);
			this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
			if (this.eat(55)) this.raise(Errors.ObsoleteAwaitStar, node);
			if (!this.scope.inFunction && !(this.optionFlags & 1)) if (this.isAmbiguousPrefixOrIdentifier()) this.ambiguousScriptDifferentAst = true;
			else this.sawUnambiguousESM = true;
			if (!this.state.soloAwait) node.argument = this.parseMaybeUnary(null, true);
			return this.finishNode(node, "AwaitExpression");
		}
		isAmbiguousPrefixOrIdentifier() {
			if (this.hasPrecedingLineBreak()) return true;
			const { type } = this.state;
			return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
		}
		parseYield(startLoc) {
			const node = this.startNodeAt(startLoc);
			this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
			let delegating = false;
			let argument = null;
			if (!this.hasPrecedingLineBreak()) {
				delegating = this.eat(55);
				switch (this.state.type) {
					case 13:
					case 140:
					case 8:
					case 11:
					case 3:
					case 9:
					case 14:
					case 12: if (!delegating) break;
					default: argument = this.parseMaybeAssign();
				}
			}
			node.delegate = delegating;
			node.argument = argument;
			return this.finishNode(node, "YieldExpression");
		}
		parseImportCall(node) {
			this.next();
			node.source = this.parseMaybeAssignAllowIn();
			node.options = null;
			if (this.eat(12)) if (!this.match(11)) {
				node.options = this.parseMaybeAssignAllowIn();
				if (this.eat(12)) {
					this.addTrailingCommaExtraToNode(node.options);
					if (!this.match(11)) {
						do
							this.parseMaybeAssignAllowIn();
						while (this.eat(12) && !this.match(11));
						this.raise(Errors.ImportCallArity, node);
					}
				}
			} else this.addTrailingCommaExtraToNode(node.source);
			this.expect(11);
			return this.finishNode(node, "ImportExpression");
		}
		checkPipelineAtInfixOperator(left, leftStartLoc) {
			if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
				if (left.type === "SequenceExpression") this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
			}
		}
		parseSmartPipelineBodyInStyle(childExpr, startLoc) {
			if (this.isSimpleReference(childExpr)) {
				const bodyNode = this.startNodeAt(startLoc);
				bodyNode.callee = childExpr;
				return this.finishNode(bodyNode, "PipelineBareFunction");
			} else {
				const bodyNode = this.startNodeAt(startLoc);
				this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
				bodyNode.expression = childExpr;
				return this.finishNode(bodyNode, "PipelineTopicExpression");
			}
		}
		isSimpleReference(expression) {
			switch (expression.type) {
				case "MemberExpression": return !expression.computed && this.isSimpleReference(expression.object);
				case "Identifier": return true;
				default: return false;
			}
		}
		checkSmartPipeTopicBodyEarlyErrors(startLoc) {
			if (this.match(19)) throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
			if (!this.topicReferenceWasUsedInCurrentContext()) this.raise(Errors.PipelineTopicUnused, startLoc);
		}
		withTopicBindingContext(callback) {
			const outerContextTopicState = this.state.topicContext;
			this.state.topicContext = {
				maxNumOfResolvableTopics: 1,
				maxTopicIndex: null
			};
			try {
				return callback();
			} finally {
				this.state.topicContext = outerContextTopicState;
			}
		}
		withSmartMixTopicForbiddingContext(callback) {
			if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
				const outerContextTopicState = this.state.topicContext;
				this.state.topicContext = {
					maxNumOfResolvableTopics: 0,
					maxTopicIndex: null
				};
				try {
					return callback();
				} finally {
					this.state.topicContext = outerContextTopicState;
				}
			} else return callback();
		}
		withSoloAwaitPermittingContext(callback) {
			const outerContextSoloAwaitState = this.state.soloAwait;
			this.state.soloAwait = true;
			try {
				return callback();
			} finally {
				this.state.soloAwait = outerContextSoloAwaitState;
			}
		}
		allowInAnd(callback) {
			const flags = this.prodParam.currentFlags();
			const prodParamToSet = 8 & ~flags;
			if (prodParamToSet) {
				this.prodParam.enter(flags | 8);
				try {
					return callback();
				} finally {
					this.prodParam.exit();
				}
			}
			return callback();
		}
		disallowInAnd(callback) {
			const flags = this.prodParam.currentFlags();
			const prodParamToClear = 8 & flags;
			if (prodParamToClear) {
				this.prodParam.enter(flags & -9);
				try {
					return callback();
				} finally {
					this.prodParam.exit();
				}
			}
			return callback();
		}
		registerTopicReference() {
			this.state.topicContext.maxTopicIndex = 0;
		}
		topicReferenceIsAllowedInCurrentContext() {
			return this.state.topicContext.maxNumOfResolvableTopics >= 1;
		}
		topicReferenceWasUsedInCurrentContext() {
			return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
		}
		parseFSharpPipelineBody(prec) {
			const startLoc = this.state.startLoc;
			this.state.potentialArrowAt = this.state.start;
			const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
			this.state.inFSharpPipelineDirectBody = true;
			const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
			this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
			return ret;
		}
		parseModuleExpression() {
			this.expectPlugin("moduleBlocks");
			const node = this.startNode();
			this.next();
			if (!this.match(5)) this.unexpected(null, 5);
			const program = this.startNodeAt(this.state.endLoc);
			this.next();
			const revertScopes = this.initializeScopes(true);
			this.enterInitialScopes();
			try {
				node.body = this.parseProgram(program, 8, "module");
			} finally {
				revertScopes();
			}
			return this.finishNode(node, "ModuleExpression");
		}
		parseVoidPattern(refExpressionErrors) {
			this.expectPlugin("discardBinding");
			const node = this.startNode();
			if (refExpressionErrors != null) refExpressionErrors.voidPatternLoc = this.state.startLoc;
			this.next();
			return this.finishNode(node, "VoidPattern");
		}
		parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, afterLeftParse) {
			if (refExpressionErrors != null && this.match(88)) {
				const nextCode = this.lookaheadCharCode();
				if (nextCode === 44 || nextCode === (close === 3 ? 93 : close === 8 ? 125 : 41) || nextCode === 61) return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(refExpressionErrors));
			}
			return this.parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse);
		}
		parsePropertyNamePrefixOperator(prop) {}
	};
	const loopLabel = { kind: 1 }, switchLabel = { kind: 2 };
	const loneSurrogate = /[\uD800-\uDFFF]/u;
	const keywordRelationalOperator = /in(?:stanceof)?/y;
	function babel7CompatTokens(tokens, input, startIndex) {
		for (let i = 0; i < tokens.length; i++) {
			const token = tokens[i];
			const { type } = token;
			if (typeof type === "number") {
				{
					if (type === 139) {
						const { loc, start, value, end } = token;
						const hashEndPos = start + 1;
						const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
						tokens.splice(i, 1, new Token({
							type: getExportedToken(27),
							value: "#",
							start,
							end: hashEndPos,
							startLoc: loc.start,
							endLoc: hashEndLoc
						}), new Token({
							type: getExportedToken(132),
							value,
							start: hashEndPos,
							end,
							startLoc: hashEndLoc,
							endLoc: loc.end
						}));
						i++;
						continue;
					}
					if (tokenIsTemplate(type)) {
						const { loc, start, value, end } = token;
						const backquoteEnd = start + 1;
						const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
						let startToken;
						if (input.charCodeAt(start - startIndex) === 96) startToken = new Token({
							type: getExportedToken(22),
							value: "`",
							start,
							end: backquoteEnd,
							startLoc: loc.start,
							endLoc: backquoteEndLoc
						});
						else startToken = new Token({
							type: getExportedToken(8),
							value: "}",
							start,
							end: backquoteEnd,
							startLoc: loc.start,
							endLoc: backquoteEndLoc
						});
						let templateValue, templateElementEnd, templateElementEndLoc, endToken;
						if (type === 24) {
							templateElementEnd = end - 1;
							templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
							templateValue = value === null ? null : value.slice(1, -1);
							endToken = new Token({
								type: getExportedToken(22),
								value: "`",
								start: templateElementEnd,
								end,
								startLoc: templateElementEndLoc,
								endLoc: loc.end
							});
						} else {
							templateElementEnd = end - 2;
							templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
							templateValue = value === null ? null : value.slice(1, -2);
							endToken = new Token({
								type: getExportedToken(23),
								value: "${",
								start: templateElementEnd,
								end,
								startLoc: templateElementEndLoc,
								endLoc: loc.end
							});
						}
						tokens.splice(i, 1, startToken, new Token({
							type: getExportedToken(20),
							value: templateValue,
							start: backquoteEnd,
							end: templateElementEnd,
							startLoc: backquoteEndLoc,
							endLoc: templateElementEndLoc
						}), endToken);
						i += 2;
						continue;
					}
				}
				token.type = getExportedToken(type);
			}
		}
		return tokens;
	}
	var StatementParser = class extends ExpressionParser {
		parseTopLevel(file, program) {
			file.program = this.parseProgram(program, 140, this.options.sourceType === "module" ? "module" : "script");
			file.comments = this.comments;
			if (this.optionFlags & 256) file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
			return this.finishNode(file, "File");
		}
		parseProgram(program, end, sourceType) {
			program.sourceType = sourceType;
			program.interpreter = this.parseInterpreterDirective();
			this.parseBlockBody(program, true, true, end);
			if (this.inModule) {
				if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) for (const [localName, at] of Array.from(this.scope.undefinedExports)) this.raise(Errors.ModuleExportUndefined, at, { localName });
				this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
			}
			let finishedProgram;
			if (end === 140) finishedProgram = this.finishNode(program, "Program");
			else finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
			return finishedProgram;
		}
		stmtToDirective(stmt) {
			const directive = this.castNodeTo(stmt, "Directive");
			const directiveLiteral = this.castNodeTo(stmt.expression, "DirectiveLiteral");
			const expressionValue = directiveLiteral.value;
			const raw$1 = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));
			const val = directiveLiteral.value = raw$1.slice(1, -1);
			this.addExtra(directiveLiteral, "raw", raw$1);
			this.addExtra(directiveLiteral, "rawValue", val);
			this.addExtra(directiveLiteral, "expressionValue", expressionValue);
			directive.value = directiveLiteral;
			delete stmt.expression;
			return directive;
		}
		parseInterpreterDirective() {
			if (!this.match(28)) return null;
			const node = this.startNode();
			node.value = this.state.value;
			this.next();
			return this.finishNode(node, "InterpreterDirective");
		}
		isLet() {
			if (!this.isContextual(100)) return false;
			return this.hasFollowingBindingAtom();
		}
		isUsing() {
			if (!this.isContextual(107)) return false;
			return this.nextTokenIsIdentifierOnSameLine();
		}
		isForUsing() {
			if (!this.isContextual(107)) return false;
			const next = this.nextTokenInLineStart();
			const nextCh = this.codePointAtPos(next);
			if (this.isUnparsedContextual(next, "of")) {
				const nextCharAfterOf = this.lookaheadCharCodeSince(next + 2);
				if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59) return false;
			}
			if (this.chStartsBindingIdentifier(nextCh, next) || this.isUnparsedContextual(next, "void")) return true;
			return false;
		}
		nextTokenIsIdentifierOnSameLine() {
			const next = this.nextTokenInLineStart();
			const nextCh = this.codePointAtPos(next);
			return this.chStartsBindingIdentifier(nextCh, next);
		}
		isAwaitUsing() {
			if (!this.isContextual(96)) return false;
			let next = this.nextTokenInLineStart();
			if (this.isUnparsedContextual(next, "using")) {
				next = this.nextTokenInLineStartSince(next + 5);
				const nextCh = this.codePointAtPos(next);
				if (this.chStartsBindingIdentifier(nextCh, next)) return true;
			}
			return false;
		}
		chStartsBindingIdentifier(ch, pos) {
			if (isIdentifierStart(ch)) {
				keywordRelationalOperator.lastIndex = pos;
				if (keywordRelationalOperator.test(this.input)) {
					const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
					if (!isIdentifierChar(endCh) && endCh !== 92) return false;
				}
				return true;
			} else if (ch === 92) return true;
			else return false;
		}
		chStartsBindingPattern(ch) {
			return ch === 91 || ch === 123;
		}
		hasFollowingBindingAtom() {
			const next = this.nextTokenStart();
			const nextCh = this.codePointAtPos(next);
			return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
		}
		hasInLineFollowingBindingIdentifierOrBrace() {
			const next = this.nextTokenInLineStart();
			const nextCh = this.codePointAtPos(next);
			return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
		}
		allowsUsing() {
			return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
		}
		parseModuleItem() {
			return this.parseStatementLike(15);
		}
		parseStatementListItem() {
			return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
		}
		parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
			let flags = 0;
			if (this.options.annexB && !this.state.strict) {
				flags |= 4;
				if (allowLabeledFunction) flags |= 8;
			}
			return this.parseStatementLike(flags);
		}
		parseStatement() {
			return this.parseStatementLike(0);
		}
		parseStatementLike(flags) {
			let decorators = null;
			if (this.match(26)) decorators = this.parseDecorators(true);
			return this.parseStatementContent(flags, decorators);
		}
		parseStatementContent(flags, decorators) {
			const startType = this.state.type;
			const node = this.startNode();
			const allowDeclaration = !!(flags & 2);
			const allowFunctionDeclaration = !!(flags & 4);
			const topLevel = flags & 1;
			switch (startType) {
				case 60: return this.parseBreakContinueStatement(node, true);
				case 63: return this.parseBreakContinueStatement(node, false);
				case 64: return this.parseDebuggerStatement(node);
				case 90: return this.parseDoWhileStatement(node);
				case 91: return this.parseForStatement(node);
				case 68:
					if (this.lookaheadCharCode() === 46) break;
					if (!allowFunctionDeclaration) this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
					return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
				case 80:
					if (!allowDeclaration) this.unexpected();
					return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
				case 69: return this.parseIfStatement(node);
				case 70: return this.parseReturnStatement(node);
				case 71: return this.parseSwitchStatement(node);
				case 72: return this.parseThrowStatement(node);
				case 73: return this.parseTryStatement(node);
				case 96:
					if (this.isAwaitUsing()) {
						if (!this.allowsUsing()) this.raise(Errors.UnexpectedUsingDeclaration, node);
						else if (!allowDeclaration) this.raise(Errors.UnexpectedLexicalDeclaration, node);
						else if (!this.recordAwaitIfAllowed()) this.raise(Errors.AwaitUsingNotInAsyncContext, node);
						this.next();
						return this.parseVarStatement(node, "await using");
					}
					break;
				case 107:
					if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
					if (!this.allowsUsing()) this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
					else if (!allowDeclaration) this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
					return this.parseVarStatement(node, "using");
				case 100: {
					if (this.state.containsEsc) break;
					const next = this.nextTokenStart();
					const nextCh = this.codePointAtPos(next);
					if (nextCh !== 91) {
						if (!allowDeclaration && this.hasFollowingLineBreak()) break;
						if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) break;
					}
				}
				case 75: if (!allowDeclaration) this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
				case 74: {
					const kind = this.state.value;
					return this.parseVarStatement(node, kind);
				}
				case 92: return this.parseWhileStatement(node);
				case 76: return this.parseWithStatement(node);
				case 5: return this.parseBlock();
				case 13: return this.parseEmptyStatement(node);
				case 83: {
					const nextTokenCharCode = this.lookaheadCharCode();
					if (nextTokenCharCode === 40 || nextTokenCharCode === 46) break;
				}
				case 82: {
					if (!(this.optionFlags & 8) && !topLevel) this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
					this.next();
					let result;
					if (startType === 83) result = this.parseImport(node);
					else result = this.parseExport(node, decorators);
					this.assertModuleNodeAllowed(result);
					return result;
				}
				default: if (this.isAsyncFunction()) {
					if (!allowDeclaration) this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
					this.next();
					return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
				}
			}
			const maybeName = this.state.value;
			const expr = this.parseExpression();
			if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) return this.parseLabeledStatement(node, maybeName, expr, flags);
			else return this.parseExpressionStatement(node, expr, decorators);
		}
		assertModuleNodeAllowed(node) {
			if (!(this.optionFlags & 8) && !this.inModule) this.raise(Errors.ImportOutsideModule, node);
		}
		decoratorsEnabledBeforeExport() {
			if (this.hasPlugin("decorators-legacy")) return true;
			return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
		}
		maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
			if (maybeDecorators) {
				var _classNode$decorators;
				if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {
					if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
					classNode.decorators.unshift(...maybeDecorators);
				} else classNode.decorators = maybeDecorators;
				this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
				if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
			}
			return classNode;
		}
		canHaveLeadingDecorator() {
			return this.match(80);
		}
		parseDecorators(allowExport) {
			const decorators = [];
			do
				decorators.push(this.parseDecorator());
			while (this.match(26));
			if (this.match(82)) {
				if (!allowExport) this.unexpected();
				if (!this.decoratorsEnabledBeforeExport()) this.raise(Errors.DecoratorExportClass, this.state.startLoc);
			} else if (!this.canHaveLeadingDecorator()) throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
			return decorators;
		}
		parseDecorator() {
			this.expectOnePlugin(["decorators", "decorators-legacy"]);
			const node = this.startNode();
			this.next();
			if (this.hasPlugin("decorators")) {
				const startLoc = this.state.startLoc;
				let expr;
				if (this.match(10)) {
					const startLoc$1 = this.state.startLoc;
					this.next();
					expr = this.parseExpression();
					this.expect(11);
					expr = this.wrapParenthesis(startLoc$1, expr);
					const paramsStartLoc = this.state.startLoc;
					node.expression = this.parseMaybeDecoratorArguments(expr, startLoc$1);
					if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
				} else {
					expr = this.parseIdentifier(false);
					while (this.eat(16)) {
						const node$1 = this.startNodeAt(startLoc);
						node$1.object = expr;
						if (this.match(139)) {
							this.classScope.usePrivateName(this.state.value, this.state.startLoc);
							node$1.property = this.parsePrivateName();
						} else node$1.property = this.parseIdentifier(true);
						node$1.computed = false;
						expr = this.finishNode(node$1, "MemberExpression");
					}
					node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
				}
			} else node.expression = this.parseExprSubscripts();
			return this.finishNode(node, "Decorator");
		}
		parseMaybeDecoratorArguments(expr, startLoc) {
			if (this.eat(10)) {
				const node = this.startNodeAt(startLoc);
				node.callee = expr;
				node.arguments = this.parseCallExpressionArguments();
				this.toReferencedList(node.arguments);
				return this.finishNode(node, "CallExpression");
			}
			return expr;
		}
		parseBreakContinueStatement(node, isBreak) {
			this.next();
			if (this.isLineTerminator()) node.label = null;
			else {
				node.label = this.parseIdentifier();
				this.semicolon();
			}
			this.verifyBreakContinue(node, isBreak);
			return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
		}
		verifyBreakContinue(node, isBreak) {
			let i;
			for (i = 0; i < this.state.labels.length; ++i) {
				const lab = this.state.labels[i];
				if (node.label == null || lab.name === node.label.name) {
					if (lab.kind != null && (isBreak || lab.kind === 1)) break;
					if (node.label && isBreak) break;
				}
			}
			if (i === this.state.labels.length) {
				const type = isBreak ? "BreakStatement" : "ContinueStatement";
				this.raise(Errors.IllegalBreakContinue, node, { type });
			}
		}
		parseDebuggerStatement(node) {
			this.next();
			this.semicolon();
			return this.finishNode(node, "DebuggerStatement");
		}
		parseHeaderExpression() {
			this.expect(10);
			const val = this.parseExpression();
			this.expect(11);
			return val;
		}
		parseDoWhileStatement(node) {
			this.next();
			this.state.labels.push(loopLabel);
			node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
			this.state.labels.pop();
			this.expect(92);
			node.test = this.parseHeaderExpression();
			this.eat(13);
			return this.finishNode(node, "DoWhileStatement");
		}
		parseForStatement(node) {
			this.next();
			this.state.labels.push(loopLabel);
			let awaitAt = null;
			if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
				awaitAt = this.state.startLoc;
				this.next();
			}
			this.scope.enter(0);
			this.expect(10);
			if (this.match(13)) {
				if (awaitAt !== null) this.unexpected(awaitAt);
				return this.parseFor(node, null);
			}
			const startsWithLet = this.isContextual(100);
			{
				const startsWithAwaitUsing = this.isAwaitUsing();
				const starsWithUsingDeclaration = startsWithAwaitUsing || this.isForUsing();
				const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
				if (this.match(74) || this.match(75) || isLetOrUsing) {
					const initNode = this.startNode();
					let kind;
					if (startsWithAwaitUsing) {
						kind = "await using";
						if (!this.recordAwaitIfAllowed()) this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
						this.next();
					} else kind = this.state.value;
					this.next();
					this.parseVar(initNode, true, kind);
					const init$1 = this.finishNode(initNode, "VariableDeclaration");
					const isForIn = this.match(58);
					if (isForIn && starsWithUsingDeclaration) this.raise(Errors.ForInUsing, init$1);
					if ((isForIn || this.isContextual(102)) && init$1.declarations.length === 1) return this.parseForIn(node, init$1, awaitAt);
					if (awaitAt !== null) this.unexpected(awaitAt);
					return this.parseFor(node, init$1);
				}
			}
			const startsWithAsync = this.isContextual(95);
			const refExpressionErrors = new ExpressionErrors();
			const init = this.parseExpression(true, refExpressionErrors);
			const isForOf = this.isContextual(102);
			if (isForOf) {
				if (startsWithLet) this.raise(Errors.ForOfLet, init);
				if (awaitAt === null && startsWithAsync && init.type === "Identifier") this.raise(Errors.ForOfAsync, init);
			}
			if (isForOf || this.match(58)) {
				this.checkDestructuringPrivate(refExpressionErrors);
				this.toAssignable(init, true);
				const type = isForOf ? "ForOfStatement" : "ForInStatement";
				this.checkLVal(init, { type });
				return this.parseForIn(node, init, awaitAt);
			} else this.checkExpressionErrors(refExpressionErrors, true);
			if (awaitAt !== null) this.unexpected(awaitAt);
			return this.parseFor(node, init);
		}
		parseFunctionStatement(node, isAsync, isHangingDeclaration) {
			this.next();
			return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
		}
		parseIfStatement(node) {
			this.next();
			node.test = this.parseHeaderExpression();
			node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
			node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
			return this.finishNode(node, "IfStatement");
		}
		parseReturnStatement(node) {
			if (!this.prodParam.hasReturn) this.raise(Errors.IllegalReturn, this.state.startLoc);
			this.next();
			if (this.isLineTerminator()) node.argument = null;
			else {
				node.argument = this.parseExpression();
				this.semicolon();
			}
			return this.finishNode(node, "ReturnStatement");
		}
		parseSwitchStatement(node) {
			this.next();
			node.discriminant = this.parseHeaderExpression();
			const cases = node.cases = [];
			this.expect(5);
			this.state.labels.push(switchLabel);
			this.scope.enter(256);
			let cur;
			for (let sawDefault; !this.match(8);) if (this.match(61) || this.match(65)) {
				const isCase = this.match(61);
				if (cur) this.finishNode(cur, "SwitchCase");
				cases.push(cur = this.startNode());
				cur.consequent = [];
				this.next();
				if (isCase) cur.test = this.parseExpression();
				else {
					if (sawDefault) this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
					sawDefault = true;
					cur.test = null;
				}
				this.expect(14);
			} else if (cur) cur.consequent.push(this.parseStatementListItem());
			else this.unexpected();
			this.scope.exit();
			if (cur) this.finishNode(cur, "SwitchCase");
			this.next();
			this.state.labels.pop();
			return this.finishNode(node, "SwitchStatement");
		}
		parseThrowStatement(node) {
			this.next();
			if (this.hasPrecedingLineBreak()) this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
			node.argument = this.parseExpression();
			this.semicolon();
			return this.finishNode(node, "ThrowStatement");
		}
		parseCatchClauseParam() {
			const param = this.parseBindingAtom();
			this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
			this.checkLVal(param, { type: "CatchClause" }, 9);
			return param;
		}
		parseTryStatement(node) {
			this.next();
			node.block = this.parseBlock();
			node.handler = null;
			if (this.match(62)) {
				const clause = this.startNode();
				this.next();
				if (this.match(10)) {
					this.expect(10);
					clause.param = this.parseCatchClauseParam();
					this.expect(11);
				} else {
					clause.param = null;
					this.scope.enter(0);
				}
				clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
				this.scope.exit();
				node.handler = this.finishNode(clause, "CatchClause");
			}
			node.finalizer = this.eat(67) ? this.parseBlock() : null;
			if (!node.handler && !node.finalizer) this.raise(Errors.NoCatchOrFinally, node);
			return this.finishNode(node, "TryStatement");
		}
		parseVarStatement(node, kind, allowMissingInitializer = false) {
			this.next();
			this.parseVar(node, false, kind, allowMissingInitializer);
			this.semicolon();
			return this.finishNode(node, "VariableDeclaration");
		}
		parseWhileStatement(node) {
			this.next();
			node.test = this.parseHeaderExpression();
			this.state.labels.push(loopLabel);
			node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
			this.state.labels.pop();
			return this.finishNode(node, "WhileStatement");
		}
		parseWithStatement(node) {
			if (this.state.strict) this.raise(Errors.StrictWith, this.state.startLoc);
			this.next();
			node.object = this.parseHeaderExpression();
			node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
			return this.finishNode(node, "WithStatement");
		}
		parseEmptyStatement(node) {
			this.next();
			return this.finishNode(node, "EmptyStatement");
		}
		parseLabeledStatement(node, maybeName, expr, flags) {
			for (const label of this.state.labels) if (label.name === maybeName) this.raise(Errors.LabelRedeclaration, expr, { labelName: maybeName });
			const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
			for (let i = this.state.labels.length - 1; i >= 0; i--) {
				const label = this.state.labels[i];
				if (label.statementStart === node.start) {
					label.statementStart = this.sourceToOffsetPos(this.state.start);
					label.kind = kind;
				} else break;
			}
			this.state.labels.push({
				name: maybeName,
				kind,
				statementStart: this.sourceToOffsetPos(this.state.start)
			});
			node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
			this.state.labels.pop();
			node.label = expr;
			return this.finishNode(node, "LabeledStatement");
		}
		parseExpressionStatement(node, expr, decorators) {
			node.expression = expr;
			this.semicolon();
			return this.finishNode(node, "ExpressionStatement");
		}
		parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
			const node = this.startNode();
			if (allowDirectives) this.state.strictErrors.clear();
			this.expect(5);
			if (createNewLexicalScope) this.scope.enter(0);
			this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
			if (createNewLexicalScope) this.scope.exit();
			return this.finishNode(node, "BlockStatement");
		}
		isValidDirective(stmt) {
			return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
		}
		parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
			const body = node.body = [];
			const directives = node.directives = [];
			this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
		}
		parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
			const oldStrict = this.state.strict;
			let hasStrictModeDirective = false;
			let parsedNonDirective = false;
			while (!this.match(end)) {
				const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
				if (directives && !parsedNonDirective) {
					if (this.isValidDirective(stmt)) {
						const directive = this.stmtToDirective(stmt);
						directives.push(directive);
						if (!hasStrictModeDirective && directive.value.value === "use strict") {
							hasStrictModeDirective = true;
							this.setStrict(true);
						}
						continue;
					}
					parsedNonDirective = true;
					this.state.strictErrors.clear();
				}
				body.push(stmt);
			}
			afterBlockParse?.call(this, hasStrictModeDirective);
			if (!oldStrict) this.setStrict(false);
			this.next();
		}
		parseFor(node, init) {
			node.init = init;
			this.semicolon(false);
			node.test = this.match(13) ? null : this.parseExpression();
			this.semicolon(false);
			node.update = this.match(11) ? null : this.parseExpression();
			this.expect(11);
			node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
			this.scope.exit();
			this.state.labels.pop();
			return this.finishNode(node, "ForStatement");
		}
		parseForIn(node, init, awaitAt) {
			const isForIn = this.match(58);
			this.next();
			if (isForIn) {
				if (awaitAt !== null) this.unexpected(awaitAt);
			} else node.await = awaitAt !== null;
			if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) this.raise(Errors.ForInOfLoopInitializer, init, { type: isForIn ? "ForInStatement" : "ForOfStatement" });
			if (init.type === "AssignmentPattern") this.raise(Errors.InvalidLhs, init, { ancestor: { type: "ForStatement" } });
			node.left = init;
			node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
			this.expect(11);
			node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
			this.scope.exit();
			this.state.labels.pop();
			return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
		}
		parseVar(node, isFor, kind, allowMissingInitializer = false) {
			const declarations = node.declarations = [];
			node.kind = kind;
			for (;;) {
				const decl = this.startNode();
				this.parseVarId(decl, kind);
				decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
				if (decl.init === null && !allowMissingInitializer) {
					if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" });
					else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind });
				}
				declarations.push(this.finishNode(decl, "VariableDeclarator"));
				if (!this.eat(12)) break;
			}
			return node;
		}
		parseVarId(decl, kind) {
			const id = this.parseBindingAtom();
			if (kind === "using" || kind === "await using") {
				if (id.type === "ArrayPattern" || id.type === "ObjectPattern") this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
			} else if (id.type === "VoidPattern") this.raise(Errors.UnexpectedVoidPattern, id.loc.start);
			this.checkLVal(id, { type: "VariableDeclarator" }, kind === "var" ? 5 : 8201);
			decl.id = id;
		}
		parseAsyncFunctionExpression(node) {
			return this.parseFunction(node, 8);
		}
		parseFunction(node, flags = 0) {
			const hangingDeclaration = flags & 2;
			const isDeclaration = !!(flags & 1);
			const requireId = isDeclaration && !(flags & 4);
			const isAsync = !!(flags & 8);
			this.initFunction(node, isAsync);
			if (this.match(55)) {
				if (hangingDeclaration) this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
				this.next();
				node.generator = true;
			}
			if (isDeclaration) node.id = this.parseFunctionId(requireId);
			const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
			this.state.maybeInArrowParameters = false;
			this.scope.enter(514);
			this.prodParam.enter(functionFlags(isAsync, node.generator));
			if (!isDeclaration) node.id = this.parseFunctionId();
			this.parseFunctionParams(node, false);
			this.withSmartMixTopicForbiddingContext(() => {
				this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
			});
			this.prodParam.exit();
			this.scope.exit();
			if (isDeclaration && !hangingDeclaration) this.registerFunctionStatementId(node);
			this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
			return node;
		}
		parseFunctionId(requireId) {
			return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
		}
		parseFunctionParams(node, isConstructor) {
			this.expect(10);
			this.expressionScope.enter(newParameterDeclarationScope());
			node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
			this.expressionScope.exit();
		}
		registerFunctionStatementId(node) {
			if (!node.id) return;
			this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
		}
		parseClass(node, isStatement, optionalId) {
			this.next();
			const oldStrict = this.state.strict;
			this.state.strict = true;
			this.parseClassId(node, isStatement, optionalId);
			this.parseClassSuper(node);
			node.body = this.parseClassBody(!!node.superClass, oldStrict);
			return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
		}
		isClassProperty() {
			return this.match(29) || this.match(13) || this.match(8);
		}
		isClassMethod() {
			return this.match(10);
		}
		nameIsConstructor(key) {
			return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
		}
		isNonstaticConstructor(method) {
			return !method.computed && !method.static && this.nameIsConstructor(method.key);
		}
		parseClassBody(hadSuperClass, oldStrict) {
			this.classScope.enter();
			const state = {
				hadConstructor: false,
				hadSuperClass
			};
			let decorators = [];
			const classBody = this.startNode();
			classBody.body = [];
			this.expect(5);
			this.withSmartMixTopicForbiddingContext(() => {
				while (!this.match(8)) {
					if (this.eat(13)) {
						if (decorators.length > 0) throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
						continue;
					}
					if (this.match(26)) {
						decorators.push(this.parseDecorator());
						continue;
					}
					const member = this.startNode();
					if (decorators.length) {
						member.decorators = decorators;
						this.resetStartLocationFromNode(member, decorators[0]);
						decorators = [];
					}
					this.parseClassMember(classBody, member, state);
					if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) this.raise(Errors.DecoratorConstructor, member);
				}
			});
			this.state.strict = oldStrict;
			this.next();
			if (decorators.length) throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
			this.classScope.exit();
			return this.finishNode(classBody, "ClassBody");
		}
		parseClassMemberFromModifier(classBody, member) {
			const key = this.parseIdentifier(true);
			if (this.isClassMethod()) {
				const method = member;
				method.kind = "method";
				method.computed = false;
				method.key = key;
				method.static = false;
				this.pushClassMethod(classBody, method, false, false, false, false);
				return true;
			} else if (this.isClassProperty()) {
				const prop = member;
				prop.computed = false;
				prop.key = key;
				prop.static = false;
				classBody.body.push(this.parseClassProperty(prop));
				return true;
			}
			this.resetPreviousNodeTrailingComments(key);
			return false;
		}
		parseClassMember(classBody, member, state) {
			const isStatic = this.isContextual(106);
			if (isStatic) {
				if (this.parseClassMemberFromModifier(classBody, member)) return;
				if (this.eat(5)) {
					this.parseClassStaticBlock(classBody, member);
					return;
				}
			}
			this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
		}
		parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
			const publicMethod = member;
			const privateMethod = member;
			const publicProp = member;
			const privateProp = member;
			const accessorProp = member;
			const method = publicMethod;
			const publicMember = publicMethod;
			member.static = isStatic;
			this.parsePropertyNamePrefixOperator(member);
			if (this.eat(55)) {
				method.kind = "method";
				const isPrivateName = this.match(139);
				this.parseClassElementName(method);
				this.parsePostMemberNameModifiers(method);
				if (isPrivateName) {
					this.pushClassPrivateMethod(classBody, privateMethod, true, false);
					return;
				}
				if (this.isNonstaticConstructor(publicMethod)) this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
				this.pushClassMethod(classBody, publicMethod, true, false, false, false);
				return;
			}
			const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
			const key = this.parseClassElementName(member);
			const maybeContextualKw = isContextual ? key.name : null;
			const isPrivate = this.isPrivateName(key);
			const maybeQuestionTokenStartLoc = this.state.startLoc;
			this.parsePostMemberNameModifiers(publicMember);
			if (this.isClassMethod()) {
				method.kind = "method";
				if (isPrivate) {
					this.pushClassPrivateMethod(classBody, privateMethod, false, false);
					return;
				}
				const isConstructor = this.isNonstaticConstructor(publicMethod);
				let allowsDirectSuper = false;
				if (isConstructor) {
					publicMethod.kind = "constructor";
					if (state.hadConstructor && !this.hasPlugin("typescript")) this.raise(Errors.DuplicateConstructor, key);
					if (isConstructor && this.hasPlugin("typescript") && member.override) this.raise(Errors.OverrideOnConstructor, key);
					state.hadConstructor = true;
					allowsDirectSuper = state.hadSuperClass;
				}
				this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
			} else if (this.isClassProperty()) if (isPrivate) this.pushClassPrivateProperty(classBody, privateProp);
			else this.pushClassProperty(classBody, publicProp);
			else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
				this.resetPreviousNodeTrailingComments(key);
				const isGenerator = this.eat(55);
				if (publicMember.optional) this.unexpected(maybeQuestionTokenStartLoc);
				method.kind = "method";
				const isPrivate$1 = this.match(139);
				this.parseClassElementName(method);
				this.parsePostMemberNameModifiers(publicMember);
				if (isPrivate$1) this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
				else {
					if (this.isNonstaticConstructor(publicMethod)) this.raise(Errors.ConstructorIsAsync, publicMethod.key);
					this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
				}
			} else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
				this.resetPreviousNodeTrailingComments(key);
				method.kind = maybeContextualKw;
				const isPrivate$1 = this.match(139);
				this.parseClassElementName(publicMethod);
				if (isPrivate$1) this.pushClassPrivateMethod(classBody, privateMethod, false, false);
				else {
					if (this.isNonstaticConstructor(publicMethod)) this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
					this.pushClassMethod(classBody, publicMethod, false, false, false, false);
				}
				this.checkGetterSetterParams(publicMethod);
			} else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
				this.expectPlugin("decoratorAutoAccessors");
				this.resetPreviousNodeTrailingComments(key);
				const isPrivate$1 = this.match(139);
				this.parseClassElementName(publicProp);
				this.pushClassAccessorProperty(classBody, accessorProp, isPrivate$1);
			} else if (this.isLineTerminator()) if (isPrivate) this.pushClassPrivateProperty(classBody, privateProp);
			else this.pushClassProperty(classBody, publicProp);
			else this.unexpected();
		}
		parseClassElementName(member) {
			const { type, value } = this.state;
			if ((type === 132 || type === 134) && member.static && value === "prototype") this.raise(Errors.StaticPrototype, this.state.startLoc);
			if (type === 139) {
				if (value === "constructor") this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
				const key = this.parsePrivateName();
				member.key = key;
				return key;
			}
			this.parsePropertyName(member);
			return member.key;
		}
		parseClassStaticBlock(classBody, member) {
			var _member$decorators;
			this.scope.enter(720);
			const oldLabels = this.state.labels;
			this.state.labels = [];
			this.prodParam.enter(0);
			const body = member.body = [];
			this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
			this.prodParam.exit();
			this.scope.exit();
			this.state.labels = oldLabels;
			classBody.body.push(this.finishNode(member, "StaticBlock"));
			if ((_member$decorators = member.decorators) != null && _member$decorators.length) this.raise(Errors.DecoratorStaticBlock, member);
		}
		pushClassProperty(classBody, prop) {
			if (!prop.computed && this.nameIsConstructor(prop.key)) this.raise(Errors.ConstructorClassField, prop.key);
			classBody.body.push(this.parseClassProperty(prop));
		}
		pushClassPrivateProperty(classBody, prop) {
			const node = this.parseClassPrivateProperty(prop);
			classBody.body.push(node);
			this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
		}
		pushClassAccessorProperty(classBody, prop, isPrivate) {
			if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) this.raise(Errors.ConstructorClassField, prop.key);
			const node = this.parseClassAccessorProperty(prop);
			classBody.body.push(node);
			if (isPrivate) this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
		}
		pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
			classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
		}
		pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
			const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
			classBody.body.push(node);
			const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
			this.declareClassPrivateMethodInScope(node, kind);
		}
		declareClassPrivateMethodInScope(node, kind) {
			this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
		}
		parsePostMemberNameModifiers(methodOrProp) {}
		parseClassPrivateProperty(node) {
			this.parseInitializer(node);
			this.semicolon();
			return this.finishNode(node, "ClassPrivateProperty");
		}
		parseClassProperty(node) {
			this.parseInitializer(node);
			this.semicolon();
			return this.finishNode(node, "ClassProperty");
		}
		parseClassAccessorProperty(node) {
			this.parseInitializer(node);
			this.semicolon();
			return this.finishNode(node, "ClassAccessorProperty");
		}
		parseInitializer(node) {
			this.scope.enter(592);
			this.expressionScope.enter(newExpressionScope());
			this.prodParam.enter(0);
			node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
			this.expressionScope.exit();
			this.prodParam.exit();
			this.scope.exit();
		}
		parseClassId(node, isStatement, optionalId, bindingType = 8331) {
			if (tokenIsIdentifier(this.state.type)) {
				node.id = this.parseIdentifier();
				if (isStatement) this.declareNameFromIdentifier(node.id, bindingType);
			} else if (optionalId || !isStatement) node.id = null;
			else throw this.raise(Errors.MissingClassName, this.state.startLoc);
		}
		parseClassSuper(node) {
			node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
		}
		parseExport(node, decorators) {
			const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
			const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
			const parseAfterDefault = !hasDefault || this.eat(12);
			const hasStar = parseAfterDefault && this.eatExportStar(node);
			const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
			const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
			const isFromRequired = hasDefault || hasStar;
			if (hasStar && !hasNamespace) {
				if (hasDefault) this.unexpected();
				if (decorators) throw this.raise(Errors.UnsupportedDecoratorExport, node);
				this.parseExportFrom(node, true);
				this.sawUnambiguousESM = true;
				return this.finishNode(node, "ExportAllDeclaration");
			}
			const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
			if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) this.unexpected(null, 5);
			if (hasNamespace && parseAfterNamespace) this.unexpected(null, 98);
			let hasDeclaration;
			if (isFromRequired || hasSpecifiers) {
				hasDeclaration = false;
				if (decorators) throw this.raise(Errors.UnsupportedDecoratorExport, node);
				this.parseExportFrom(node, isFromRequired);
			} else hasDeclaration = this.maybeParseExportDeclaration(node);
			if (isFromRequired || hasSpecifiers || hasDeclaration) {
				var _node2$declaration;
				const node2 = node;
				this.checkExport(node2, true, false, !!node2.source);
				if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") this.maybeTakeDecorators(decorators, node2.declaration, node2);
				else if (decorators) throw this.raise(Errors.UnsupportedDecoratorExport, node);
				this.sawUnambiguousESM = true;
				return this.finishNode(node2, "ExportNamedDeclaration");
			}
			if (this.eat(65)) {
				const node2 = node;
				const decl = this.parseExportDefaultExpression();
				node2.declaration = decl;
				if (decl.type === "ClassDeclaration") this.maybeTakeDecorators(decorators, decl, node2);
				else if (decorators) throw this.raise(Errors.UnsupportedDecoratorExport, node);
				this.checkExport(node2, true, true);
				this.sawUnambiguousESM = true;
				return this.finishNode(node2, "ExportDefaultDeclaration");
			}
			throw this.unexpected(null, 5);
		}
		eatExportStar(node) {
			return this.eat(55);
		}
		maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
			if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
				this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
				const id = maybeDefaultIdentifier || this.parseIdentifier(true);
				const specifier = this.startNodeAtNode(id);
				specifier.exported = id;
				node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
				return true;
			}
			return false;
		}
		maybeParseExportNamespaceSpecifier(node) {
			if (this.isContextual(93)) {
				var _ref, _ref$specifiers;
				(_ref$specifiers = (_ref = node).specifiers) != null || (_ref.specifiers = []);
				const specifier = this.startNodeAt(this.state.lastTokStartLoc);
				this.next();
				specifier.exported = this.parseModuleExportName();
				node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
				return true;
			}
			return false;
		}
		maybeParseExportNamedSpecifiers(node) {
			if (this.match(5)) {
				const node2 = node;
				if (!node2.specifiers) node2.specifiers = [];
				const isTypeExport = node2.exportKind === "type";
				node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
				node2.source = null;
				if (this.hasPlugin("importAssertions")) node2.assertions = [];
				else node2.attributes = [];
				node2.declaration = null;
				return true;
			}
			return false;
		}
		maybeParseExportDeclaration(node) {
			if (this.shouldParseExportDeclaration()) {
				node.specifiers = [];
				node.source = null;
				if (this.hasPlugin("importAssertions")) node.assertions = [];
				else node.attributes = [];
				node.declaration = this.parseExportDeclaration(node);
				return true;
			}
			return false;
		}
		isAsyncFunction() {
			if (!this.isContextual(95)) return false;
			const next = this.nextTokenInLineStart();
			return this.isUnparsedContextual(next, "function");
		}
		parseExportDefaultExpression() {
			const expr = this.startNode();
			if (this.match(68)) {
				this.next();
				return this.parseFunction(expr, 5);
			} else if (this.isAsyncFunction()) {
				this.next();
				this.next();
				return this.parseFunction(expr, 13);
			}
			if (this.match(80)) return this.parseClass(expr, true, true);
			if (this.match(26)) {
				if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
				return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
			}
			if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
			const res = this.parseMaybeAssignAllowIn();
			this.semicolon();
			return res;
		}
		parseExportDeclaration(node) {
			if (this.match(80)) {
				const node$1 = this.parseClass(this.startNode(), true, false);
				return node$1;
			}
			return this.parseStatementListItem();
		}
		isExportDefaultSpecifier() {
			const { type } = this.state;
			if (tokenIsIdentifier(type)) {
				if (type === 95 && !this.state.containsEsc || type === 100) return false;
				if ((type === 130 || type === 129) && !this.state.containsEsc) {
					const next$1 = this.nextTokenStart();
					const nextChar = this.input.charCodeAt(next$1);
					if (nextChar === 123 || this.chStartsBindingIdentifier(nextChar, next$1) && !this.input.startsWith("from", next$1)) {
						this.expectOnePlugin(["flow", "typescript"]);
						return false;
					}
				}
			} else if (!this.match(65)) return false;
			const next = this.nextTokenStart();
			const hasFrom = this.isUnparsedContextual(next, "from");
			if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) return true;
			if (this.match(65) && hasFrom) {
				const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
				return nextAfterFrom === 34 || nextAfterFrom === 39;
			}
			return false;
		}
		parseExportFrom(node, expect) {
			if (this.eatContextual(98)) {
				node.source = this.parseImportSource();
				this.checkExport(node);
				this.maybeParseImportAttributes(node);
				this.checkJSONModuleImport(node);
			} else if (expect) this.unexpected();
			this.semicolon();
		}
		shouldParseExportDeclaration() {
			const { type } = this.state;
			if (type === 26) {
				this.expectOnePlugin(["decorators", "decorators-legacy"]);
				if (this.hasPlugin("decorators")) {
					if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
					return true;
				}
			}
			if (this.isUsing()) {
				this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
				return true;
			}
			if (this.isAwaitUsing()) {
				this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
				return true;
			}
			return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
		}
		checkExport(node, checkNames, isDefault, isFrom) {
			if (checkNames) {
				var _node$specifiers;
				if (isDefault) {
					this.checkDuplicateExports(node, "default");
					if (this.hasPlugin("exportDefaultFrom")) {
						var _declaration$extra;
						const declaration = node.declaration;
						if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
					}
				} else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) for (const specifier of node.specifiers) {
					const { exported } = specifier;
					const exportName = exported.type === "Identifier" ? exported.name : exported.value;
					this.checkDuplicateExports(specifier, exportName);
					if (!isFrom && specifier.local) {
						const { local } = specifier;
						if (local.type !== "Identifier") this.raise(Errors.ExportBindingIsString, specifier, {
							localName: local.value,
							exportName
						});
						else {
							this.checkReservedWord(local.name, local.loc.start, true, false);
							this.scope.checkLocalExport(local);
						}
					}
				}
				else if (node.declaration) {
					const decl = node.declaration;
					if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
						const { id } = decl;
						if (!id) throw new Error("Assertion failure");
						this.checkDuplicateExports(node, id.name);
					} else if (decl.type === "VariableDeclaration") for (const declaration of decl.declarations) this.checkDeclaration(declaration.id);
				}
			}
		}
		checkDeclaration(node) {
			if (node.type === "Identifier") this.checkDuplicateExports(node, node.name);
			else if (node.type === "ObjectPattern") for (const prop of node.properties) this.checkDeclaration(prop);
			else if (node.type === "ArrayPattern") {
				for (const elem of node.elements) if (elem) this.checkDeclaration(elem);
			} else if (node.type === "ObjectProperty") this.checkDeclaration(node.value);
			else if (node.type === "RestElement") this.checkDeclaration(node.argument);
			else if (node.type === "AssignmentPattern") this.checkDeclaration(node.left);
		}
		checkDuplicateExports(node, exportName) {
			if (this.exportedIdentifiers.has(exportName)) if (exportName === "default") this.raise(Errors.DuplicateDefaultExport, node);
			else this.raise(Errors.DuplicateExport, node, { exportName });
			this.exportedIdentifiers.add(exportName);
		}
		parseExportSpecifiers(isInTypeExport) {
			const nodes = [];
			let first = true;
			this.expect(5);
			while (!this.eat(8)) {
				if (first) first = false;
				else {
					this.expect(12);
					if (this.eat(8)) break;
				}
				const isMaybeTypeOnly = this.isContextual(130);
				const isString$1 = this.match(134);
				const node = this.startNode();
				node.local = this.parseModuleExportName();
				nodes.push(this.parseExportSpecifier(node, isString$1, isInTypeExport, isMaybeTypeOnly));
			}
			return nodes;
		}
		parseExportSpecifier(node, isString$1, isInTypeExport, isMaybeTypeOnly) {
			if (this.eatContextual(93)) node.exported = this.parseModuleExportName();
			else if (isString$1) node.exported = this.cloneStringLiteral(node.local);
			else if (!node.exported) node.exported = this.cloneIdentifier(node.local);
			return this.finishNode(node, "ExportSpecifier");
		}
		parseModuleExportName() {
			if (this.match(134)) {
				const result = this.parseStringLiteral(this.state.value);
				const surrogate = loneSurrogate.exec(result.value);
				if (surrogate) this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, { surrogateCharCode: surrogate[0].charCodeAt(0) });
				return result;
			}
			return this.parseIdentifier(true);
		}
		isJSONModuleImport(node) {
			if (node.assertions != null) return node.assertions.some(({ key, value }) => {
				return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
			});
			return false;
		}
		checkImportReflection(node) {
			const { specifiers } = node;
			const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
			if (node.phase === "source") {
				if (singleBindingType !== "ImportDefaultSpecifier") this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
			} else if (node.phase === "defer") {
				if (singleBindingType !== "ImportNamespaceSpecifier") this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
			} else if (node.module) {
				var _node$assertions;
				if (singleBindingType !== "ImportDefaultSpecifier") this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
				if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
			}
		}
		checkJSONModuleImport(node) {
			if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
				const { specifiers } = node;
				if (specifiers != null) {
					const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
						let imported;
						if (specifier.type === "ExportSpecifier") imported = specifier.local;
						else if (specifier.type === "ImportSpecifier") imported = specifier.imported;
						if (imported !== void 0) return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
					});
					if (nonDefaultNamedSpecifier !== void 0) this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
				}
			}
		}
		isPotentialImportPhase(isExport) {
			if (isExport) return false;
			return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
		}
		applyImportPhase(node, isExport, phase, loc) {
			if (isExport) return;
			if (phase === "module") {
				this.expectPlugin("importReflection", loc);
				node.module = true;
			} else if (this.hasPlugin("importReflection")) node.module = false;
			if (phase === "source") {
				this.expectPlugin("sourcePhaseImports", loc);
				node.phase = "source";
			} else if (phase === "defer") {
				this.expectPlugin("deferredImportEvaluation", loc);
				node.phase = "defer";
			} else if (this.hasPlugin("sourcePhaseImports")) node.phase = null;
		}
		parseMaybeImportPhase(node, isExport) {
			if (!this.isPotentialImportPhase(isExport)) {
				this.applyImportPhase(node, isExport, null);
				return null;
			}
			const phaseIdentifier = this.startNode();
			const phaseIdentifierName = this.parseIdentifierName(true);
			const { type } = this.state;
			const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
			if (isImportPhase) {
				this.applyImportPhase(node, isExport, phaseIdentifierName, phaseIdentifier.loc.start);
				return null;
			} else {
				this.applyImportPhase(node, isExport, null);
				return this.createIdentifier(phaseIdentifier, phaseIdentifierName);
			}
		}
		isPrecedingIdImportPhase(phase) {
			const { type } = this.state;
			return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
		}
		parseImport(node) {
			if (this.match(134)) return this.parseImportSourceAndAttributes(node);
			return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
		}
		parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
			node.specifiers = [];
			const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
			const parseNext = !hasDefault || this.eat(12);
			const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
			if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
			this.expectContextual(98);
			return this.parseImportSourceAndAttributes(node);
		}
		parseImportSourceAndAttributes(node) {
			var _node$specifiers2;
			(_node$specifiers2 = node.specifiers) != null || (node.specifiers = []);
			node.source = this.parseImportSource();
			this.maybeParseImportAttributes(node);
			this.checkImportReflection(node);
			this.checkJSONModuleImport(node);
			this.semicolon();
			this.sawUnambiguousESM = true;
			return this.finishNode(node, "ImportDeclaration");
		}
		parseImportSource() {
			if (!this.match(134)) this.unexpected();
			return this.parseExprAtom();
		}
		parseImportSpecifierLocal(node, specifier, type) {
			specifier.local = this.parseIdentifier();
			node.specifiers.push(this.finishImportSpecifier(specifier, type));
		}
		finishImportSpecifier(specifier, type, bindingType = 8201) {
			this.checkLVal(specifier.local, { type }, bindingType);
			return this.finishNode(specifier, type);
		}
		parseImportAttributes() {
			this.expect(5);
			const attrs = [];
			const attrNames = /* @__PURE__ */ new Set();
			do {
				if (this.match(8)) break;
				const node = this.startNode();
				const keyName = this.state.value;
				if (attrNames.has(keyName)) this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: keyName });
				attrNames.add(keyName);
				if (this.match(134)) node.key = this.parseStringLiteral(keyName);
				else node.key = this.parseIdentifier(true);
				this.expect(14);
				if (!this.match(134)) throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
				node.value = this.parseStringLiteral(this.state.value);
				attrs.push(this.finishNode(node, "ImportAttribute"));
			} while (this.eat(12));
			this.expect(8);
			return attrs;
		}
		parseModuleAttributes() {
			const attrs = [];
			const attributes = /* @__PURE__ */ new Set();
			do {
				const node = this.startNode();
				node.key = this.parseIdentifier(true);
				if (node.key.name !== "type") this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
				if (attributes.has(node.key.name)) this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, { key: node.key.name });
				attributes.add(node.key.name);
				this.expect(14);
				if (!this.match(134)) throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
				node.value = this.parseStringLiteral(this.state.value);
				attrs.push(this.finishNode(node, "ImportAttribute"));
			} while (this.eat(12));
			return attrs;
		}
		maybeParseImportAttributes(node) {
			let attributes;
			var useWith = false;
			if (this.match(76)) {
				if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
				this.next();
				if (this.hasPlugin("moduleAttributes")) {
					attributes = this.parseModuleAttributes();
					this.addExtra(node, "deprecatedWithLegacySyntax", true);
				} else attributes = this.parseImportAttributes();
				useWith = true;
			} else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
				if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
				if (!this.hasPlugin("importAssertions")) this.addExtra(node, "deprecatedAssertSyntax", true);
				this.next();
				attributes = this.parseImportAttributes();
			} else attributes = [];
			if (!useWith && this.hasPlugin("importAssertions")) node.assertions = attributes;
			else node.attributes = attributes;
		}
		maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
			if (maybeDefaultIdentifier) {
				const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
				specifier.local = maybeDefaultIdentifier;
				node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
				return true;
			} else if (tokenIsKeywordOrIdentifier(this.state.type)) {
				this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
				return true;
			}
			return false;
		}
		maybeParseStarImportSpecifier(node) {
			if (this.match(55)) {
				const specifier = this.startNode();
				this.next();
				this.expectContextual(93);
				this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
				return true;
			}
			return false;
		}
		parseNamedImportSpecifiers(node) {
			let first = true;
			this.expect(5);
			while (!this.eat(8)) {
				if (first) first = false;
				else {
					if (this.eat(14)) throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
					this.expect(12);
					if (this.eat(8)) break;
				}
				const specifier = this.startNode();
				const importedIsString = this.match(134);
				const isMaybeTypeOnly = this.isContextual(130);
				specifier.imported = this.parseModuleExportName();
				const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
				node.specifiers.push(importSpecifier);
			}
		}
		parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
			if (this.eatContextual(93)) specifier.local = this.parseIdentifier();
			else {
				const { imported } = specifier;
				if (importedIsString) throw this.raise(Errors.ImportBindingIsString, specifier, { importName: imported.value });
				this.checkReservedWord(imported.name, specifier.loc.start, true, true);
				if (!specifier.local) specifier.local = this.cloneIdentifier(imported);
			}
			return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
		}
		isThisParam(param) {
			return param.type === "Identifier" && param.name === "this";
		}
	};
	var Parser = class extends StatementParser {
		constructor(options, input, pluginsMap) {
			const normalizedOptions = getOptions(options);
			super(normalizedOptions, input);
			this.options = normalizedOptions;
			this.initializeScopes();
			this.plugins = pluginsMap;
			this.filename = normalizedOptions.sourceFilename;
			this.startIndex = normalizedOptions.startIndex;
			let optionFlags = 0;
			if (normalizedOptions.allowAwaitOutsideFunction) optionFlags |= 1;
			if (normalizedOptions.allowReturnOutsideFunction) optionFlags |= 2;
			if (normalizedOptions.allowImportExportEverywhere) optionFlags |= 8;
			if (normalizedOptions.allowSuperOutsideMethod) optionFlags |= 16;
			if (normalizedOptions.allowUndeclaredExports) optionFlags |= 64;
			if (normalizedOptions.allowNewTargetOutsideFunction) optionFlags |= 4;
			if (normalizedOptions.allowYieldOutsideFunction) optionFlags |= 32;
			if (normalizedOptions.ranges) optionFlags |= 128;
			if (normalizedOptions.tokens) optionFlags |= 256;
			if (normalizedOptions.createImportExpressions) optionFlags |= 512;
			if (normalizedOptions.createParenthesizedExpressions) optionFlags |= 1024;
			if (normalizedOptions.errorRecovery) optionFlags |= 2048;
			if (normalizedOptions.attachComment) optionFlags |= 4096;
			if (normalizedOptions.annexB) optionFlags |= 8192;
			this.optionFlags = optionFlags;
		}
		getScopeHandler() {
			return ScopeHandler;
		}
		parse() {
			this.enterInitialScopes();
			const file = this.startNode();
			const program = this.startNode();
			this.nextToken();
			file.errors = null;
			const result = this.parseTopLevel(file, program);
			result.errors = this.state.errors;
			result.comments.length = this.state.commentsLen;
			return result;
		}
	};
	function parse$4(input, options) {
		var _options;
		if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
			options = Object.assign({}, options);
			try {
				options.sourceType = "module";
				const parser$1 = getParser(options, input);
				const ast = parser$1.parse();
				if (parser$1.sawUnambiguousESM) return ast;
				if (parser$1.ambiguousScriptDifferentAst) try {
					options.sourceType = "script";
					return getParser(options, input).parse();
				} catch (_unused) {}
				else ast.program.sourceType = "script";
				return ast;
			} catch (moduleError) {
				try {
					options.sourceType = "script";
					return getParser(options, input).parse();
				} catch (_unused2) {}
				throw moduleError;
			}
		} else return getParser(options, input).parse();
	}
	function parseExpression(input, options) {
		const parser$1 = getParser(options, input);
		if (parser$1.options.strictMode) parser$1.state.strict = true;
		return parser$1.getExpression();
	}
	function generateExportedTokenTypes(internalTokenTypes) {
		const tokenTypes$1 = {};
		for (const typeName of Object.keys(internalTokenTypes)) tokenTypes$1[typeName] = getExportedToken(internalTokenTypes[typeName]);
		return tokenTypes$1;
	}
	const tokTypes = generateExportedTokenTypes(tt);
	function getParser(options, input) {
		let cls = Parser;
		const pluginsMap = /* @__PURE__ */ new Map();
		if (options != null && options.plugins) {
			for (const plugin$14 of options.plugins) {
				let name, opts;
				if (typeof plugin$14 === "string") name = plugin$14;
				else [name, opts] = plugin$14;
				if (!pluginsMap.has(name)) pluginsMap.set(name, opts || {});
			}
			validatePlugins(pluginsMap);
			cls = getParserClass(pluginsMap);
		}
		return new cls(options, input, pluginsMap);
	}
	const parserClassCache = /* @__PURE__ */ new Map();
	function getParserClass(pluginsMap) {
		const pluginList = [];
		for (const name of mixinPluginNames) if (pluginsMap.has(name)) pluginList.push(name);
		const key = pluginList.join("|");
		let cls = parserClassCache.get(key);
		if (!cls) {
			cls = Parser;
			for (const plugin$14 of pluginList) cls = mixinPlugins[plugin$14](cls);
			parserClassCache.set(key, cls);
		}
		return cls;
	}
	exports.parse = parse$4;
	exports.parseExpression = parseExpression;
	exports.tokTypes = tokTypes;
} });

//#endregion
//#region node_modules/estree-walker/dist/umd/estree-walker.js
var require_estree_walker = __commonJS({ "node_modules/estree-walker/dist/umd/estree-walker.js"(exports, module) {
	(function(global$1, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global$1 = global$1 || self, factory(global$1.estreeWalker = {}));
	})(void 0, function(exports$1) {
		"use strict";
		/** @typedef { import('estree').BaseNode} BaseNode */
		/** @typedef {{
		skip: () => void;
		remove: () => void;
		replace: (node: BaseNode) => void;
		}} WalkerContext */
		class WalkerBase {
			constructor() {
				/** @type {boolean} */
				this.should_skip = false;
				/** @type {boolean} */
				this.should_remove = false;
				/** @type {BaseNode | null} */
				this.replacement = null;
				/** @type {WalkerContext} */
				this.context = {
					skip: () => this.should_skip = true,
					remove: () => this.should_remove = true,
					replace: (node) => this.replacement = node
				};
			}
			/**
			*
			* @param {any} parent
			* @param {string} prop
			* @param {number} index
			* @param {BaseNode} node
			*/
			replace(parent, prop, index, node) {
				if (parent) if (index !== null) parent[prop][index] = node;
				else parent[prop] = node;
			}
			/**
			*
			* @param {any} parent
			* @param {string} prop
			* @param {number} index
			*/
			remove(parent, prop, index) {
				if (parent) if (index !== null) parent[prop].splice(index, 1);
				else delete parent[prop];
			}
		}
		/** @typedef { import('estree').BaseNode} BaseNode */
		/** @typedef { import('./walker.js').WalkerContext} WalkerContext */
		/** @typedef {(
		*    this: WalkerContext,
		*    node: BaseNode,
		*    parent: BaseNode,
		*    key: string,
		*    index: number
		* ) => void} SyncHandler */
		class SyncWalker extends WalkerBase {
			/**
			*
			* @param {SyncHandler} enter
			* @param {SyncHandler} leave
			*/
			constructor(enter, leave) {
				super();
				/** @type {SyncHandler} */
				this.enter = enter;
				/** @type {SyncHandler} */
				this.leave = leave;
			}
			/**
			*
			* @param {BaseNode} node
			* @param {BaseNode} parent
			* @param {string} [prop]
			* @param {number} [index]
			* @returns {BaseNode}
			*/
			visit(node, parent, prop, index) {
				if (node) {
					if (this.enter) {
						const _should_skip = this.should_skip;
						const _should_remove = this.should_remove;
						const _replacement = this.replacement;
						this.should_skip = false;
						this.should_remove = false;
						this.replacement = null;
						this.enter.call(this.context, node, parent, prop, index);
						if (this.replacement) {
							node = this.replacement;
							this.replace(parent, prop, index, node);
						}
						if (this.should_remove) this.remove(parent, prop, index);
						const skipped = this.should_skip;
						const removed = this.should_remove;
						this.should_skip = _should_skip;
						this.should_remove = _should_remove;
						this.replacement = _replacement;
						if (skipped) return node;
						if (removed) return null;
					}
					for (const key in node) {
						const value = node[key];
						if (typeof value !== "object") continue;
						else if (Array.isArray(value)) {
							for (let i = 0; i < value.length; i += 1) if (value[i] !== null && typeof value[i].type === "string") {
								if (!this.visit(value[i], node, key, i)) i--;
							}
						} else if (value !== null && typeof value.type === "string") this.visit(value, node, key, null);
					}
					if (this.leave) {
						const _replacement = this.replacement;
						const _should_remove = this.should_remove;
						this.replacement = null;
						this.should_remove = false;
						this.leave.call(this.context, node, parent, prop, index);
						if (this.replacement) {
							node = this.replacement;
							this.replace(parent, prop, index, node);
						}
						if (this.should_remove) this.remove(parent, prop, index);
						const removed = this.should_remove;
						this.replacement = _replacement;
						this.should_remove = _should_remove;
						if (removed) return null;
					}
				}
				return node;
			}
		}
		/** @typedef { import('estree').BaseNode} BaseNode */
		/** @typedef { import('./walker').WalkerContext} WalkerContext */
		/** @typedef {(
		*    this: WalkerContext,
		*    node: BaseNode,
		*    parent: BaseNode,
		*    key: string,
		*    index: number
		* ) => Promise<void>} AsyncHandler */
		class AsyncWalker extends WalkerBase {
			/**
			*
			* @param {AsyncHandler} enter
			* @param {AsyncHandler} leave
			*/
			constructor(enter, leave) {
				super();
				/** @type {AsyncHandler} */
				this.enter = enter;
				/** @type {AsyncHandler} */
				this.leave = leave;
			}
			/**
			*
			* @param {BaseNode} node
			* @param {BaseNode} parent
			* @param {string} [prop]
			* @param {number} [index]
			* @returns {Promise<BaseNode>}
			*/
			async visit(node, parent, prop, index) {
				if (node) {
					if (this.enter) {
						const _should_skip = this.should_skip;
						const _should_remove = this.should_remove;
						const _replacement = this.replacement;
						this.should_skip = false;
						this.should_remove = false;
						this.replacement = null;
						await this.enter.call(this.context, node, parent, prop, index);
						if (this.replacement) {
							node = this.replacement;
							this.replace(parent, prop, index, node);
						}
						if (this.should_remove) this.remove(parent, prop, index);
						const skipped = this.should_skip;
						const removed = this.should_remove;
						this.should_skip = _should_skip;
						this.should_remove = _should_remove;
						this.replacement = _replacement;
						if (skipped) return node;
						if (removed) return null;
					}
					for (const key in node) {
						const value = node[key];
						if (typeof value !== "object") continue;
						else if (Array.isArray(value)) {
							for (let i = 0; i < value.length; i += 1) if (value[i] !== null && typeof value[i].type === "string") {
								if (!await this.visit(value[i], node, key, i)) i--;
							}
						} else if (value !== null && typeof value.type === "string") await this.visit(value, node, key, null);
					}
					if (this.leave) {
						const _replacement = this.replacement;
						const _should_remove = this.should_remove;
						this.replacement = null;
						this.should_remove = false;
						await this.leave.call(this.context, node, parent, prop, index);
						if (this.replacement) {
							node = this.replacement;
							this.replace(parent, prop, index, node);
						}
						if (this.should_remove) this.remove(parent, prop, index);
						const removed = this.should_remove;
						this.replacement = _replacement;
						this.should_remove = _should_remove;
						if (removed) return null;
					}
				}
				return node;
			}
		}
		/** @typedef { import('estree').BaseNode} BaseNode */
		/** @typedef { import('./sync.js').SyncHandler} SyncHandler */
		/** @typedef { import('./async.js').AsyncHandler} AsyncHandler */
		/**
		*
		* @param {BaseNode} ast
		* @param {{
		*   enter?: SyncHandler
		*   leave?: SyncHandler
		* }} walker
		* @returns {BaseNode}
		*/
		function walk$1(ast, { enter, leave }) {
			const instance = new SyncWalker(enter, leave);
			return instance.visit(ast, null);
		}
		/**
		*
		* @param {BaseNode} ast
		* @param {{
		*   enter?: AsyncHandler
		*   leave?: AsyncHandler
		* }} walker
		* @returns {Promise<BaseNode>}
		*/
		async function asyncWalk(ast, { enter, leave }) {
			const instance = new AsyncWalker(enter, leave);
			return await instance.visit(ast, null);
		}
		exports$1.asyncWalk = asyncWalk;
		exports$1.walk = walk$1;
		Object.defineProperty(exports$1, "__esModule", { value: true });
	});
} });

//#endregion
//#region node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS({ "node_modules/source-map-js/lib/base64.js"(exports) {
	var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
	/**
	* Encode an integer in the range of 0 to 63 to a single base 64 digit.
	*/
	exports.encode = function(number) {
		if (0 <= number && number < intToCharMap.length) return intToCharMap[number];
		throw new TypeError("Must be between 0 and 63: " + number);
	};
	/**
	* Decode a single base 64 character code digit to an integer. Returns -1 on
	* failure.
	*/
	exports.decode = function(charCode) {
		var bigA = 65;
		var bigZ = 90;
		var littleA = 97;
		var littleZ = 122;
		var zero = 48;
		var nine = 57;
		var plus = 43;
		var slash = 47;
		var littleOffset = 26;
		var numberOffset = 52;
		if (bigA <= charCode && charCode <= bigZ) return charCode - bigA;
		if (littleA <= charCode && charCode <= littleZ) return charCode - littleA + littleOffset;
		if (zero <= charCode && charCode <= nine) return charCode - zero + numberOffset;
		if (charCode == plus) return 62;
		if (charCode == slash) return 63;
		return -1;
	};
} });

//#endregion
//#region node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS({ "node_modules/source-map-js/lib/base64-vlq.js"(exports) {
	var base64 = require_base64();
	var VLQ_BASE_SHIFT = 5;
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	/**
	* Converts from a two-complement value to a value where the sign bit is
	* placed in the least significant bit.  For example, as decimals:
	*   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	*   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	*/
	function toVLQSigned(aValue) {
		return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
	}
	/**
	* Converts to a two-complement value from a value where the sign bit is
	* placed in the least significant bit.  For example, as decimals:
	*   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	*   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	*/
	function fromVLQSigned(aValue) {
		var isNegative = (aValue & 1) === 1;
		var shifted = aValue >> 1;
		return isNegative ? -shifted : shifted;
	}
	/**
	* Returns the base 64 VLQ encoded value.
	*/
	exports.encode = function base64VLQ_encode(aValue) {
		var encoded = "";
		var digit;
		var vlq = toVLQSigned(aValue);
		do {
			digit = vlq & VLQ_BASE_MASK;
			vlq >>>= VLQ_BASE_SHIFT;
			if (vlq > 0) digit |= VLQ_CONTINUATION_BIT;
			encoded += base64.encode(digit);
		} while (vlq > 0);
		return encoded;
	};
	/**
	* Decodes the next base 64 VLQ value from the given string and returns the
	* value and the rest of the string via the out parameter.
	*/
	exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
		var strLen = aStr.length;
		var result = 0;
		var shift = 0;
		var continuation, digit;
		do {
			if (aIndex >= strLen) throw new Error("Expected more digits in base 64 VLQ value.");
			digit = base64.decode(aStr.charCodeAt(aIndex++));
			if (digit === -1) throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
			continuation = !!(digit & VLQ_CONTINUATION_BIT);
			digit &= VLQ_BASE_MASK;
			result = result + (digit << shift);
			shift += VLQ_BASE_SHIFT;
		} while (continuation);
		aOutParam.value = fromVLQSigned(result);
		aOutParam.rest = aIndex;
	};
} });

//#endregion
//#region node_modules/source-map-js/lib/util.js
var require_util = __commonJS({ "node_modules/source-map-js/lib/util.js"(exports) {
	/**
	* This is a helper function for getting values from parameter/options
	* objects.
	*
	* @param args The object we are extracting values from
	* @param name The name of the property we are getting.
	* @param defaultValue An optional value to return if the property is missing
	* from the object. If this is not specified and the property is missing, an
	* error will be thrown.
	*/
	function getArg(aArgs, aName, aDefaultValue) {
		if (aName in aArgs) return aArgs[aName];
		else if (arguments.length === 3) return aDefaultValue;
		else throw new Error("\"" + aName + "\" is a required argument.");
	}
	exports.getArg = getArg;
	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;
	function urlParse(aUrl) {
		var match = aUrl.match(urlRegexp);
		if (!match) return null;
		return {
			scheme: match[1],
			auth: match[2],
			host: match[3],
			port: match[4],
			path: match[5]
		};
	}
	exports.urlParse = urlParse;
	function urlGenerate(aParsedUrl) {
		var url = "";
		if (aParsedUrl.scheme) url += aParsedUrl.scheme + ":";
		url += "//";
		if (aParsedUrl.auth) url += aParsedUrl.auth + "@";
		if (aParsedUrl.host) url += aParsedUrl.host;
		if (aParsedUrl.port) url += ":" + aParsedUrl.port;
		if (aParsedUrl.path) url += aParsedUrl.path;
		return url;
	}
	exports.urlGenerate = urlGenerate;
	var MAX_CACHED_INPUTS = 32;
	/**
	* Takes some function `f(input) -> result` and returns a memoized version of
	* `f`.
	*
	* We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
	* memoization is a dumb-simple, linear least-recently-used cache.
	*/
	function lruMemoize(f) {
		var cache = [];
		return function(input) {
			for (var i = 0; i < cache.length; i++) if (cache[i].input === input) {
				var temp = cache[0];
				cache[0] = cache[i];
				cache[i] = temp;
				return cache[0].result;
			}
			var result = f(input);
			cache.unshift({
				input,
				result
			});
			if (cache.length > MAX_CACHED_INPUTS) cache.pop();
			return result;
		};
	}
	/**
	* Normalizes a path, or the path portion of a URL:
	*
	* - Replaces consecutive slashes with one slash.
	* - Removes unnecessary '.' parts.
	* - Removes unnecessary '<dir>/..' parts.
	*
	* Based on code in the Node.js 'path' core module.
	*
	* @param aPath The path or url to normalize.
	*/
	var normalize = lruMemoize(function normalize$1(aPath) {
		var path$4 = aPath;
		var url = urlParse(aPath);
		if (url) {
			if (!url.path) return aPath;
			path$4 = url.path;
		}
		var isAbsolute = exports.isAbsolute(path$4);
		var parts = [];
		var start = 0;
		var i = 0;
		while (true) {
			start = i;
			i = path$4.indexOf("/", start);
			if (i === -1) {
				parts.push(path$4.slice(start));
				break;
			} else {
				parts.push(path$4.slice(start, i));
				while (i < path$4.length && path$4[i] === "/") i++;
			}
		}
		for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
			part = parts[i];
			if (part === ".") parts.splice(i, 1);
			else if (part === "..") up++;
			else if (up > 0) if (part === "") {
				parts.splice(i + 1, up);
				up = 0;
			} else {
				parts.splice(i, 2);
				up--;
			}
		}
		path$4 = parts.join("/");
		if (path$4 === "") path$4 = isAbsolute ? "/" : ".";
		if (url) {
			url.path = path$4;
			return urlGenerate(url);
		}
		return path$4;
	});
	exports.normalize = normalize;
	/**
	* Joins two paths/URLs.
	*
	* @param aRoot The root path or URL.
	* @param aPath The path or URL to be joined with the root.
	*
	* - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	*   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	*   first.
	* - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	*   is updated with the result and aRoot is returned. Otherwise the result
	*   is returned.
	*   - If aPath is absolute, the result is aPath.
	*   - Otherwise the two paths are joined with a slash.
	* - Joining for example 'http://' and 'www.example.com' is also supported.
	*/
	function join(aRoot, aPath) {
		if (aRoot === "") aRoot = ".";
		if (aPath === "") aPath = ".";
		var aPathUrl = urlParse(aPath);
		var aRootUrl = urlParse(aRoot);
		if (aRootUrl) aRoot = aRootUrl.path || "/";
		if (aPathUrl && !aPathUrl.scheme) {
			if (aRootUrl) aPathUrl.scheme = aRootUrl.scheme;
			return urlGenerate(aPathUrl);
		}
		if (aPathUrl || aPath.match(dataUrlRegexp)) return aPath;
		if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
			aRootUrl.host = aPath;
			return urlGenerate(aRootUrl);
		}
		var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
		if (aRootUrl) {
			aRootUrl.path = joined;
			return urlGenerate(aRootUrl);
		}
		return joined;
	}
	exports.join = join;
	exports.isAbsolute = function(aPath) {
		return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
	};
	/**
	* Make a path relative to a URL or another path.
	*
	* @param aRoot The root path or URL.
	* @param aPath The path or URL to be made relative to aRoot.
	*/
	function relative(aRoot, aPath) {
		if (aRoot === "") aRoot = ".";
		aRoot = aRoot.replace(/\/$/, "");
		var level = 0;
		while (aPath.indexOf(aRoot + "/") !== 0) {
			var index = aRoot.lastIndexOf("/");
			if (index < 0) return aPath;
			aRoot = aRoot.slice(0, index);
			if (aRoot.match(/^([^\/]+:\/)?\/*$/)) return aPath;
			++level;
		}
		return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;
	var supportsNullProto = function() {
		var obj = Object.create(null);
		return !("__proto__" in obj);
	}();
	function identity(s) {
		return s;
	}
	/**
	* Because behavior goes wacky when you set `__proto__` on objects, we
	* have to prefix all the strings in our set with an arbitrary character.
	*
	* See https://github.com/mozilla/source-map/pull/31 and
	* https://github.com/mozilla/source-map/issues/30
	*
	* @param String aStr
	*/
	function toSetString(aStr) {
		if (isProtoString(aStr)) return "$" + aStr;
		return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;
	function fromSetString(aStr) {
		if (isProtoString(aStr)) return aStr.slice(1);
		return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;
	function isProtoString(s) {
		if (!s) return false;
		var length = s.length;
		if (length < 9) return false;
		if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) return false;
		for (var i = length - 10; i >= 0; i--) if (s.charCodeAt(i) !== 36) return false;
		return true;
	}
	/**
	* Comparator between two mappings where the original positions are compared.
	*
	* Optionally pass in `true` as `onlyCompareGenerated` to consider two
	* mappings with the same original source/line/column, but different generated
	* line and column the same. Useful when searching for a mapping with a
	* stubbed out mapping.
	*/
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		var cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0 || onlyCompareOriginal) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;
	function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
		var cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0 || onlyCompareOriginal) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
	/**
	* Comparator between two mappings with deflated source and name indices where
	* the generated positions are compared.
	*
	* Optionally pass in `true` as `onlyCompareGenerated` to consider two
	* mappings with the same generated line and column, but different
	* source/name/original line and column the same. Useful when searching for a
	* mapping with a stubbed out mapping.
	*/
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		var cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0 || onlyCompareGenerated) return cmp;
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
		var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0 || onlyCompareGenerated) return cmp;
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
	function strcmp(aStr1, aStr2) {
		if (aStr1 === aStr2) return 0;
		if (aStr1 === null) return 1;
		if (aStr2 === null) return -1;
		if (aStr1 > aStr2) return 1;
		return -1;
	}
	/**
	* Comparator between two mappings with inflated source and name strings where
	* the generated positions are compared.
	*/
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		var cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) return cmp;
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	/**
	* Strip any JSON XSSI avoidance prefix from the string (as documented
	* in the source maps specification), and then parse the string as
	* JSON.
	*/
	function parseSourceMapInput(str) {
		return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
	}
	exports.parseSourceMapInput = parseSourceMapInput;
	/**
	* Compute the URL of a source given the the source root, the source's
	* URL, and the source map's URL.
	*/
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		sourceURL = sourceURL || "";
		if (sourceRoot) {
			if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") sourceRoot += "/";
			sourceURL = sourceRoot + sourceURL;
		}
		if (sourceMapURL) {
			var parsed = urlParse(sourceMapURL);
			if (!parsed) throw new Error("sourceMapURL could not be parsed");
			if (parsed.path) {
				var index = parsed.path.lastIndexOf("/");
				if (index >= 0) parsed.path = parsed.path.substring(0, index + 1);
			}
			sourceURL = join(urlGenerate(parsed), sourceURL);
		}
		return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
} });

//#endregion
//#region node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS({ "node_modules/source-map-js/lib/array-set.js"(exports) {
	var util$4 = require_util();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";
	/**
	* A data structure which is a combination of an array and a set. Adding a new
	* member is O(1), testing for membership is O(1), and finding the index of an
	* element is O(1). Removing elements from the set is not supported. Only
	* strings are supported for membership.
	*/
	function ArraySet$2() {
		this._array = [];
		this._set = hasNativeMap ? /* @__PURE__ */ new Map() : Object.create(null);
	}
	/**
	* Static method for creating ArraySet instances from an existing array.
	*/
	ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
		var set = new ArraySet$2();
		for (var i = 0, len = aArray.length; i < len; i++) set.add(aArray[i], aAllowDuplicates);
		return set;
	};
	/**
	* Return how many unique items are in this ArraySet. If duplicates have been
	* added, than those do not count towards the size.
	*
	* @returns Number
	*/
	ArraySet$2.prototype.size = function ArraySet_size() {
		return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};
	/**
	* Add the given string to this set.
	*
	* @param String aStr
	*/
	ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
		var sStr = hasNativeMap ? aStr : util$4.toSetString(aStr);
		var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
		var idx = this._array.length;
		if (!isDuplicate || aAllowDuplicates) this._array.push(aStr);
		if (!isDuplicate) if (hasNativeMap) this._set.set(aStr, idx);
		else this._set[sStr] = idx;
	};
	/**
	* Is the given string a member of this set?
	*
	* @param String aStr
	*/
	ArraySet$2.prototype.has = function ArraySet_has(aStr) {
		if (hasNativeMap) return this._set.has(aStr);
		else {
			var sStr = util$4.toSetString(aStr);
			return has.call(this._set, sStr);
		}
	};
	/**
	* What is the index of the given string in the array?
	*
	* @param String aStr
	*/
	ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
		if (hasNativeMap) {
			var idx = this._set.get(aStr);
			if (idx >= 0) return idx;
		} else {
			var sStr = util$4.toSetString(aStr);
			if (has.call(this._set, sStr)) return this._set[sStr];
		}
		throw new Error("\"" + aStr + "\" is not in the set.");
	};
	/**
	* What is the element at the given index?
	*
	* @param Number aIdx
	*/
	ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
		if (aIdx >= 0 && aIdx < this._array.length) return this._array[aIdx];
		throw new Error("No element indexed by " + aIdx);
	};
	/**
	* Returns the array representation of this set (which has the proper indices
	* indicated by indexOf). Note that this is a copy of the internal array used
	* for storing the members so that no one can mess with internal state.
	*/
	ArraySet$2.prototype.toArray = function ArraySet_toArray() {
		return this._array.slice();
	};
	exports.ArraySet = ArraySet$2;
} });

//#endregion
//#region node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS({ "node_modules/source-map-js/lib/mapping-list.js"(exports) {
	var util$3 = require_util();
	/**
	* Determine whether mappingB is after mappingA with respect to generated
	* position.
	*/
	function generatedPositionAfter(mappingA, mappingB) {
		var lineA = mappingA.generatedLine;
		var lineB = mappingB.generatedLine;
		var columnA = mappingA.generatedColumn;
		var columnB = mappingB.generatedColumn;
		return lineB > lineA || lineB == lineA && columnB >= columnA || util$3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}
	/**
	* A data structure to provide a sorted view of accumulated mappings in a
	* performance conscious manner. It trades a neglibable overhead in general
	* case for a large speedup in case of mappings being added in order.
	*/
	function MappingList$1() {
		this._array = [];
		this._sorted = true;
		this._last = {
			generatedLine: -1,
			generatedColumn: 0
		};
	}
	/**
	* Iterate through internal items. This method takes the same arguments that
	* `Array.prototype.forEach` takes.
	*
	* NOTE: The order of the mappings is NOT guaranteed.
	*/
	MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
		this._array.forEach(aCallback, aThisArg);
	};
	/**
	* Add the given source mapping.
	*
	* @param Object aMapping
	*/
	MappingList$1.prototype.add = function MappingList_add(aMapping) {
		if (generatedPositionAfter(this._last, aMapping)) {
			this._last = aMapping;
			this._array.push(aMapping);
		} else {
			this._sorted = false;
			this._array.push(aMapping);
		}
	};
	/**
	* Returns the flat, sorted array of mappings. The mappings are sorted by
	* generated position.
	*
	* WARNING: This method returns internal data without copying, for
	* performance. The return value must NOT be mutated, and should be treated as
	* an immutable borrow. If you want to take ownership, you must make your own
	* copy.
	*/
	MappingList$1.prototype.toArray = function MappingList_toArray() {
		if (!this._sorted) {
			this._array.sort(util$3.compareByGeneratedPositionsInflated);
			this._sorted = true;
		}
		return this._array;
	};
	exports.MappingList = MappingList$1;
} });

//#endregion
//#region node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS({ "node_modules/source-map-js/lib/source-map-generator.js"(exports) {
	var base64VLQ$1 = require_base64_vlq();
	var util$2 = require_util();
	var ArraySet$1 = require_array_set().ArraySet;
	var MappingList = require_mapping_list().MappingList;
	/**
	* An instance of the SourceMapGenerator represents a source map which is
	* being built incrementally. You may pass an object with the following
	* properties:
	*
	*   - file: The filename of the generated source.
	*   - sourceRoot: A root for all relative URLs in this source map.
	*/
	function SourceMapGenerator$1(aArgs) {
		if (!aArgs) aArgs = {};
		this._file = util$2.getArg(aArgs, "file", null);
		this._sourceRoot = util$2.getArg(aArgs, "sourceRoot", null);
		this._skipValidation = util$2.getArg(aArgs, "skipValidation", false);
		this._ignoreInvalidMapping = util$2.getArg(aArgs, "ignoreInvalidMapping", false);
		this._sources = new ArraySet$1();
		this._names = new ArraySet$1();
		this._mappings = new MappingList();
		this._sourcesContents = null;
	}
	SourceMapGenerator$1.prototype._version = 3;
	/**
	* Creates a new SourceMapGenerator based on a SourceMapConsumer
	*
	* @param aSourceMapConsumer The SourceMap.
	*/
	SourceMapGenerator$1.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
		var sourceRoot = aSourceMapConsumer.sourceRoot;
		var generator = new SourceMapGenerator$1(Object.assign(generatorOps || {}, {
			file: aSourceMapConsumer.file,
			sourceRoot
		}));
		aSourceMapConsumer.eachMapping(function(mapping) {
			var newMapping = { generated: {
				line: mapping.generatedLine,
				column: mapping.generatedColumn
			} };
			if (mapping.source != null) {
				newMapping.source = mapping.source;
				if (sourceRoot != null) newMapping.source = util$2.relative(sourceRoot, newMapping.source);
				newMapping.original = {
					line: mapping.originalLine,
					column: mapping.originalColumn
				};
				if (mapping.name != null) newMapping.name = mapping.name;
			}
			generator.addMapping(newMapping);
		});
		aSourceMapConsumer.sources.forEach(function(sourceFile) {
			var sourceRelative = sourceFile;
			if (sourceRoot !== null) sourceRelative = util$2.relative(sourceRoot, sourceFile);
			if (!generator._sources.has(sourceRelative)) generator._sources.add(sourceRelative);
			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) generator.setSourceContent(sourceFile, content);
		});
		return generator;
	};
	/**
	* Add a single mapping from original source line and column to the generated
	* source's line and column for this source map being created. The mapping
	* object should have the following properties:
	*
	*   - generated: An object with the generated line and column positions.
	*   - original: An object with the original line and column positions.
	*   - source: The original source file (relative to the sourceRoot).
	*   - name: An optional original token name for this mapping.
	*/
	SourceMapGenerator$1.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
		var generated = util$2.getArg(aArgs, "generated");
		var original = util$2.getArg(aArgs, "original", null);
		var source = util$2.getArg(aArgs, "source", null);
		var name = util$2.getArg(aArgs, "name", null);
		if (!this._skipValidation) {
			if (this._validateMapping(generated, original, source, name) === false) return;
		}
		if (source != null) {
			source = String(source);
			if (!this._sources.has(source)) this._sources.add(source);
		}
		if (name != null) {
			name = String(name);
			if (!this._names.has(name)) this._names.add(name);
		}
		this._mappings.add({
			generatedLine: generated.line,
			generatedColumn: generated.column,
			originalLine: original != null && original.line,
			originalColumn: original != null && original.column,
			source,
			name
		});
	};
	/**
	* Set the source content for a source file.
	*/
	SourceMapGenerator$1.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
		var source = aSourceFile;
		if (this._sourceRoot != null) source = util$2.relative(this._sourceRoot, source);
		if (aSourceContent != null) {
			if (!this._sourcesContents) this._sourcesContents = Object.create(null);
			this._sourcesContents[util$2.toSetString(source)] = aSourceContent;
		} else if (this._sourcesContents) {
			delete this._sourcesContents[util$2.toSetString(source)];
			if (Object.keys(this._sourcesContents).length === 0) this._sourcesContents = null;
		}
	};
	/**
	* Applies the mappings of a sub-source-map for a specific source file to the
	* source map being generated. Each mapping to the supplied source file is
	* rewritten using the supplied source map. Note: The resolution for the
	* resulting mappings is the minimium of this map and the supplied map.
	*
	* @param aSourceMapConsumer The source map to be applied.
	* @param aSourceFile Optional. The filename of the source file.
	*        If omitted, SourceMapConsumer's file property will be used.
	* @param aSourceMapPath Optional. The dirname of the path to the source map
	*        to be applied. If relative, it is relative to the SourceMapConsumer.
	*        This parameter is needed when the two source maps aren't in the same
	*        directory, and the source map to be applied contains relative source
	*        paths. If so, those relative source paths need to be rewritten
	*        relative to the SourceMapGenerator.
	*/
	SourceMapGenerator$1.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
		var sourceFile = aSourceFile;
		if (aSourceFile == null) {
			if (aSourceMapConsumer.file == null) throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's \"file\" property. Both were omitted.");
			sourceFile = aSourceMapConsumer.file;
		}
		var sourceRoot = this._sourceRoot;
		if (sourceRoot != null) sourceFile = util$2.relative(sourceRoot, sourceFile);
		var newSources = new ArraySet$1();
		var newNames = new ArraySet$1();
		this._mappings.unsortedForEach(function(mapping) {
			if (mapping.source === sourceFile && mapping.originalLine != null) {
				var original = aSourceMapConsumer.originalPositionFor({
					line: mapping.originalLine,
					column: mapping.originalColumn
				});
				if (original.source != null) {
					mapping.source = original.source;
					if (aSourceMapPath != null) mapping.source = util$2.join(aSourceMapPath, mapping.source);
					if (sourceRoot != null) mapping.source = util$2.relative(sourceRoot, mapping.source);
					mapping.originalLine = original.line;
					mapping.originalColumn = original.column;
					if (original.name != null) mapping.name = original.name;
				}
			}
			var source = mapping.source;
			if (source != null && !newSources.has(source)) newSources.add(source);
			var name = mapping.name;
			if (name != null && !newNames.has(name)) newNames.add(name);
		}, this);
		this._sources = newSources;
		this._names = newNames;
		aSourceMapConsumer.sources.forEach(function(sourceFile$1) {
			var content = aSourceMapConsumer.sourceContentFor(sourceFile$1);
			if (content != null) {
				if (aSourceMapPath != null) sourceFile$1 = util$2.join(aSourceMapPath, sourceFile$1);
				if (sourceRoot != null) sourceFile$1 = util$2.relative(sourceRoot, sourceFile$1);
				this.setSourceContent(sourceFile$1, content);
			}
		}, this);
	};
	/**
	* A mapping can have one of the three levels of data:
	*
	*   1. Just the generated position.
	*   2. The Generated position, original position, and original source.
	*   3. Generated and original position, original source, as well as a name
	*      token.
	*
	* To maintain consistency, we validate that any new mapping being added falls
	* in to one of these categories.
	*/
	SourceMapGenerator$1.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
		if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
			var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
			if (this._ignoreInvalidMapping) {
				if (typeof console !== "undefined" && console.warn) console.warn(message);
				return false;
			} else throw new Error(message);
		}
		if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) return;
		else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) return;
		else {
			var message = "Invalid mapping: " + JSON.stringify({
				generated: aGenerated,
				source: aSource,
				original: aOriginal,
				name: aName
			});
			if (this._ignoreInvalidMapping) {
				if (typeof console !== "undefined" && console.warn) console.warn(message);
				return false;
			} else throw new Error(message);
		}
	};
	/**
	* Serialize the accumulated mappings in to the stream of base 64 VLQs
	* specified by the source map format.
	*/
	SourceMapGenerator$1.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
		var previousGeneratedColumn = 0;
		var previousGeneratedLine = 1;
		var previousOriginalColumn = 0;
		var previousOriginalLine = 0;
		var previousName = 0;
		var previousSource = 0;
		var result = "";
		var next;
		var mapping;
		var nameIdx;
		var sourceIdx;
		var mappings = this._mappings.toArray();
		for (var i = 0, len = mappings.length; i < len; i++) {
			mapping = mappings[i];
			next = "";
			if (mapping.generatedLine !== previousGeneratedLine) {
				previousGeneratedColumn = 0;
				while (mapping.generatedLine !== previousGeneratedLine) {
					next += ";";
					previousGeneratedLine++;
				}
			} else if (i > 0) {
				if (!util$2.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) continue;
				next += ",";
			}
			next += base64VLQ$1.encode(mapping.generatedColumn - previousGeneratedColumn);
			previousGeneratedColumn = mapping.generatedColumn;
			if (mapping.source != null) {
				sourceIdx = this._sources.indexOf(mapping.source);
				next += base64VLQ$1.encode(sourceIdx - previousSource);
				previousSource = sourceIdx;
				next += base64VLQ$1.encode(mapping.originalLine - 1 - previousOriginalLine);
				previousOriginalLine = mapping.originalLine - 1;
				next += base64VLQ$1.encode(mapping.originalColumn - previousOriginalColumn);
				previousOriginalColumn = mapping.originalColumn;
				if (mapping.name != null) {
					nameIdx = this._names.indexOf(mapping.name);
					next += base64VLQ$1.encode(nameIdx - previousName);
					previousName = nameIdx;
				}
			}
			result += next;
		}
		return result;
	};
	SourceMapGenerator$1.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
		return aSources.map(function(source) {
			if (!this._sourcesContents) return null;
			if (aSourceRoot != null) source = util$2.relative(aSourceRoot, source);
			var key = util$2.toSetString(source);
			return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
		}, this);
	};
	/**
	* Externalize the source map.
	*/
	SourceMapGenerator$1.prototype.toJSON = function SourceMapGenerator_toJSON() {
		var map = {
			version: this._version,
			sources: this._sources.toArray(),
			names: this._names.toArray(),
			mappings: this._serializeMappings()
		};
		if (this._file != null) map.file = this._file;
		if (this._sourceRoot != null) map.sourceRoot = this._sourceRoot;
		if (this._sourcesContents) map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
		return map;
	};
	/**
	* Render the source map being generated to a string.
	*/
	SourceMapGenerator$1.prototype.toString = function SourceMapGenerator_toString() {
		return JSON.stringify(this.toJSON());
	};
	exports.SourceMapGenerator = SourceMapGenerator$1;
} });

//#endregion
//#region node_modules/source-map-js/lib/binary-search.js
var require_binary_search = __commonJS({ "node_modules/source-map-js/lib/binary-search.js"(exports) {
	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;
	/**
	* Recursive implementation of binary search.
	*
	* @param aLow Indices here and lower do not contain the needle.
	* @param aHigh Indices here and higher do not contain the needle.
	* @param aNeedle The element being searched for.
	* @param aHaystack The non-empty array being searched.
	* @param aCompare Function which takes two elements and returns -1, 0, or 1.
	* @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	*     closest element that is smaller than or greater than the one we are
	*     searching for, respectively, if the exact element cannot be found.
	*/
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
		var mid = Math.floor((aHigh - aLow) / 2) + aLow;
		var cmp = aCompare(aNeedle, aHaystack[mid], true);
		if (cmp === 0) return mid;
		else if (cmp > 0) {
			if (aHigh - mid > 1) return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
			if (aBias == exports.LEAST_UPPER_BOUND) return aHigh < aHaystack.length ? aHigh : -1;
			else return mid;
		} else {
			if (mid - aLow > 1) return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
			if (aBias == exports.LEAST_UPPER_BOUND) return mid;
			else return aLow < 0 ? -1 : aLow;
		}
	}
	/**
	* This is an implementation of binary search which will always try and return
	* the index of the closest element if there is no exact hit. This is because
	* mappings between original and generated line/col pairs are single points,
	* and there is an implicit region between each of them, so a miss just means
	* that you aren't on the very start of a region.
	*
	* @param aNeedle The element you are looking for.
	* @param aHaystack The array that is being searched.
	* @param aCompare A function which takes the needle and an element in the
	*     array and returns -1, 0, or 1 depending on whether the needle is less
	*     than, equal to, or greater than the element, respectively.
	* @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	*     closest element that is smaller than or greater than the one we are
	*     searching for, respectively, if the exact element cannot be found.
	*     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	*/
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
		if (aHaystack.length === 0) return -1;
		var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
		if (index < 0) return -1;
		while (index - 1 >= 0) {
			if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) break;
			--index;
		}
		return index;
	};
} });

//#endregion
//#region node_modules/source-map-js/lib/quick-sort.js
var require_quick_sort = __commonJS({ "node_modules/source-map-js/lib/quick-sort.js"(exports) {
	function SortTemplate(comparator) {
		/**
		* Swap the elements indexed by `x` and `y` in the array `ary`.
		*
		* @param {Array} ary
		*        The array.
		* @param {Number} x
		*        The index of the first item.
		* @param {Number} y
		*        The index of the second item.
		*/
		function swap(ary, x, y) {
			var temp = ary[x];
			ary[x] = ary[y];
			ary[y] = temp;
		}
		/**
		* Returns a random integer within the range `low .. high` inclusive.
		*
		* @param {Number} low
		*        The lower bound on the range.
		* @param {Number} high
		*        The upper bound on the range.
		*/
		function randomIntInRange(low, high) {
			return Math.round(low + Math.random() * (high - low));
		}
		/**
		* The Quick Sort algorithm.
		*
		* @param {Array} ary
		*        An array to sort.
		* @param {function} comparator
		*        Function to use to compare two items.
		* @param {Number} p
		*        Start index of the array
		* @param {Number} r
		*        End index of the array
		*/
		function doQuickSort(ary, comparator$1, p, r) {
			if (p < r) {
				var pivotIndex = randomIntInRange(p, r);
				var i = p - 1;
				swap(ary, pivotIndex, r);
				var pivot = ary[r];
				for (var j = p; j < r; j++) if (comparator$1(ary[j], pivot, false) <= 0) {
					i += 1;
					swap(ary, i, j);
				}
				swap(ary, i + 1, j);
				var q = i + 1;
				doQuickSort(ary, comparator$1, p, q - 1);
				doQuickSort(ary, comparator$1, q + 1, r);
			}
		}
		return doQuickSort;
	}
	function cloneSort(comparator) {
		let template = SortTemplate.toString();
		let templateFn = new Function(`return ${template}`)();
		return templateFn(comparator);
	}
	/**
	* Sort the given array in-place with the given comparator function.
	*
	* @param {Array} ary
	*        An array to sort.
	* @param {function} comparator
	*        Function to use to compare two items.
	*/
	let sortCache = /* @__PURE__ */ new WeakMap();
	exports.quickSort = function(ary, comparator, start = 0) {
		let doQuickSort = sortCache.get(comparator);
		if (doQuickSort === void 0) {
			doQuickSort = cloneSort(comparator);
			sortCache.set(comparator, doQuickSort);
		}
		doQuickSort(ary, comparator, start, ary.length - 1);
	};
} });

//#endregion
//#region node_modules/source-map-js/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({ "node_modules/source-map-js/lib/source-map-consumer.js"(exports) {
	var util$1 = require_util();
	var binarySearch$1 = require_binary_search();
	var ArraySet = require_array_set().ArraySet;
	var base64VLQ = require_base64_vlq();
	var quickSort = require_quick_sort().quickSort;
	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") sourceMap = util$1.parseSourceMapInput(aSourceMap);
		return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}
	SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
		return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	};
	/**
	* The version of the source mapping spec that we are consuming.
	*/
	SourceMapConsumer.prototype._version = 3;
	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
		configurable: true,
		enumerable: true,
		get: function() {
			if (!this.__generatedMappings) this._parseMappings(this._mappings, this.sourceRoot);
			return this.__generatedMappings;
		}
	});
	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
		configurable: true,
		enumerable: true,
		get: function() {
			if (!this.__originalMappings) this._parseMappings(this._mappings, this.sourceRoot);
			return this.__originalMappings;
		}
	});
	SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
		var c = aStr.charAt(index);
		return c === ";" || c === ",";
	};
	/**
	* Parse the mappings in a string in to a data structure which we can easily
	* query (the ordered arrays in the `this.__generatedMappings` and
	* `this.__originalMappings` properties).
	*/
	SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		throw new Error("Subclasses must implement _parseMappings");
	};
	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;
	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	/**
	* Iterate over each mapping between an original source/line/column and a
	* generated line/column in this source map.
	*
	* @param Function aCallback
	*        The function that is called with each mapping.
	* @param Object aContext
	*        Optional. If specified, this object will be the value of `this` every
	*        time that `aCallback` is called.
	* @param aOrder
	*        Either `SourceMapConsumer.GENERATED_ORDER` or
	*        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	*        iterate over the mappings sorted by the generated file's line/column
	*        order or the original's source/line/column order, respectively. Defaults to
	*        `SourceMapConsumer.GENERATED_ORDER`.
	*/
	SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
		var context = aContext || null;
		var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
		var mappings;
		switch (order) {
			case SourceMapConsumer.GENERATED_ORDER:
				mappings = this._generatedMappings;
				break;
			case SourceMapConsumer.ORIGINAL_ORDER:
				mappings = this._originalMappings;
				break;
			default: throw new Error("Unknown order of iteration.");
		}
		var sourceRoot = this.sourceRoot;
		var boundCallback = aCallback.bind(context);
		var names = this._names;
		var sources = this._sources;
		var sourceMapURL = this._sourceMapURL;
		for (var i = 0, n = mappings.length; i < n; i++) {
			var mapping = mappings[i];
			var source = mapping.source === null ? null : sources.at(mapping.source);
			if (source !== null) source = util$1.computeSourceURL(sourceRoot, source, sourceMapURL);
			boundCallback({
				source,
				generatedLine: mapping.generatedLine,
				generatedColumn: mapping.generatedColumn,
				originalLine: mapping.originalLine,
				originalColumn: mapping.originalColumn,
				name: mapping.name === null ? null : names.at(mapping.name)
			});
		}
	};
	/**
	* Returns all generated line and column information for the original source,
	* line, and column provided. If no column is provided, returns all mappings
	* corresponding to a either the line we are searching for or the next
	* closest line that has any mappings. Otherwise, returns all mappings
	* corresponding to the given line and either the column we are searching for
	* or the next closest column that has any offsets.
	*
	* The only argument is an object with the following properties:
	*
	*   - source: The filename of the original source.
	*   - line: The line number in the original source.  The line number is 1-based.
	*   - column: Optional. the column number in the original source.
	*    The column number is 0-based.
	*
	* and an array of objects is returned, each with the following properties:
	*
	*   - line: The line number in the generated source, or null.  The
	*    line number is 1-based.
	*   - column: The column number in the generated source, or null.
	*    The column number is 0-based.
	*/
	SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
		var line = util$1.getArg(aArgs, "line");
		var needle = {
			source: util$1.getArg(aArgs, "source"),
			originalLine: line,
			originalColumn: util$1.getArg(aArgs, "column", 0)
		};
		needle.source = this._findSourceIndex(needle.source);
		if (needle.source < 0) return [];
		var mappings = [];
		var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, binarySearch$1.LEAST_UPPER_BOUND);
		if (index >= 0) {
			var mapping = this._originalMappings[index];
			if (aArgs.column === void 0) {
				var originalLine = mapping.originalLine;
				while (mapping && mapping.originalLine === originalLine) {
					mappings.push({
						line: util$1.getArg(mapping, "generatedLine", null),
						column: util$1.getArg(mapping, "generatedColumn", null),
						lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
					});
					mapping = this._originalMappings[++index];
				}
			} else {
				var originalColumn = mapping.originalColumn;
				while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
					mappings.push({
						line: util$1.getArg(mapping, "generatedLine", null),
						column: util$1.getArg(mapping, "generatedColumn", null),
						lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
					});
					mapping = this._originalMappings[++index];
				}
			}
		}
		return mappings;
	};
	exports.SourceMapConsumer = SourceMapConsumer;
	/**
	* A BasicSourceMapConsumer instance represents a parsed source map which we can
	* query for information about the original file positions by giving it a file
	* position in the generated source.
	*
	* The first parameter is the raw source map (either as a JSON string, or
	* already parsed to an object). According to the spec, source maps have the
	* following attributes:
	*
	*   - version: Which version of the source map spec this map is following.
	*   - sources: An array of URLs to the original source files.
	*   - names: An array of identifiers which can be referrenced by individual mappings.
	*   - sourceRoot: Optional. The URL root from which all sources are relative.
	*   - sourcesContent: Optional. An array of contents of the original source files.
	*   - mappings: A string of base64 VLQs which contain the actual mappings.
	*   - file: Optional. The generated file this source map is associated with.
	*
	* Here is an example source map, taken from the source map spec[0]:
	*
	*     {
	*       version : 3,
	*       file: "out.js",
	*       sourceRoot : "",
	*       sources: ["foo.js", "bar.js"],
	*       names: ["src", "maps", "are", "fun"],
	*       mappings: "AA,AB;;ABCDE;"
	*     }
	*
	* The second parameter, if given, is a string whose value is the URL
	* at which the source map was found.  This URL is used to compute the
	* sources array.
	*
	* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	*/
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") sourceMap = util$1.parseSourceMapInput(aSourceMap);
		var version = util$1.getArg(sourceMap, "version");
		var sources = util$1.getArg(sourceMap, "sources");
		var names = util$1.getArg(sourceMap, "names", []);
		var sourceRoot = util$1.getArg(sourceMap, "sourceRoot", null);
		var sourcesContent = util$1.getArg(sourceMap, "sourcesContent", null);
		var mappings = util$1.getArg(sourceMap, "mappings");
		var file = util$1.getArg(sourceMap, "file", null);
		if (version != this._version) throw new Error("Unsupported version: " + version);
		if (sourceRoot) sourceRoot = util$1.normalize(sourceRoot);
		sources = sources.map(String).map(util$1.normalize).map(function(source) {
			return sourceRoot && util$1.isAbsolute(sourceRoot) && util$1.isAbsolute(source) ? util$1.relative(sourceRoot, source) : source;
		});
		this._names = ArraySet.fromArray(names.map(String), true);
		this._sources = ArraySet.fromArray(sources, true);
		this._absoluteSources = this._sources.toArray().map(function(s) {
			return util$1.computeSourceURL(sourceRoot, s, aSourceMapURL);
		});
		this.sourceRoot = sourceRoot;
		this.sourcesContent = sourcesContent;
		this._mappings = mappings;
		this._sourceMapURL = aSourceMapURL;
		this.file = file;
	}
	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	/**
	* Utility function to find the index of a source.  Returns -1 if not
	* found.
	*/
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
		var relativeSource = aSource;
		if (this.sourceRoot != null) relativeSource = util$1.relative(this.sourceRoot, relativeSource);
		if (this._sources.has(relativeSource)) return this._sources.indexOf(relativeSource);
		var i;
		for (i = 0; i < this._absoluteSources.length; ++i) if (this._absoluteSources[i] == aSource) return i;
		return -1;
	};
	/**
	* Create a BasicSourceMapConsumer from a SourceMapGenerator.
	*
	* @param SourceMapGenerator aSourceMap
	*        The source map that will be consumed.
	* @param String aSourceMapURL
	*        The URL at which the source map can be found (optional)
	* @returns BasicSourceMapConsumer
	*/
	BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
		var smc = Object.create(BasicSourceMapConsumer.prototype);
		var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
		var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
		smc.sourceRoot = aSourceMap._sourceRoot;
		smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
		smc.file = aSourceMap._file;
		smc._sourceMapURL = aSourceMapURL;
		smc._absoluteSources = smc._sources.toArray().map(function(s) {
			return util$1.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
		});
		var generatedMappings = aSourceMap._mappings.toArray().slice();
		var destGeneratedMappings = smc.__generatedMappings = [];
		var destOriginalMappings = smc.__originalMappings = [];
		for (var i = 0, length = generatedMappings.length; i < length; i++) {
			var srcMapping = generatedMappings[i];
			var destMapping = new Mapping();
			destMapping.generatedLine = srcMapping.generatedLine;
			destMapping.generatedColumn = srcMapping.generatedColumn;
			if (srcMapping.source) {
				destMapping.source = sources.indexOf(srcMapping.source);
				destMapping.originalLine = srcMapping.originalLine;
				destMapping.originalColumn = srcMapping.originalColumn;
				if (srcMapping.name) destMapping.name = names.indexOf(srcMapping.name);
				destOriginalMappings.push(destMapping);
			}
			destGeneratedMappings.push(destMapping);
		}
		quickSort(smc.__originalMappings, util$1.compareByOriginalPositions);
		return smc;
	};
	/**
	* The version of the source mapping spec that we are consuming.
	*/
	BasicSourceMapConsumer.prototype._version = 3;
	/**
	* The list of original sources.
	*/
	Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", { get: function() {
		return this._absoluteSources.slice();
	} });
	/**
	* Provide the JIT with a nice shape / hidden class.
	*/
	function Mapping() {
		this.generatedLine = 0;
		this.generatedColumn = 0;
		this.source = null;
		this.originalLine = null;
		this.originalColumn = null;
		this.name = null;
	}
	/**
	* Parse the mappings in a string in to a data structure which we can easily
	* query (the ordered arrays in the `this.__generatedMappings` and
	* `this.__originalMappings` properties).
	*/
	const compareGenerated = util$1.compareByGeneratedPositionsDeflatedNoLine;
	function sortGenerated(array, start) {
		let l = array.length;
		let n = array.length - start;
		if (n <= 1) return;
		else if (n == 2) {
			let a = array[start];
			let b = array[start + 1];
			if (compareGenerated(a, b) > 0) {
				array[start] = b;
				array[start + 1] = a;
			}
		} else if (n < 20) for (let i = start; i < l; i++) for (let j = i; j > start; j--) {
			let a = array[j - 1];
			let b = array[j];
			if (compareGenerated(a, b) <= 0) break;
			array[j - 1] = b;
			array[j] = a;
		}
		else quickSort(array, compareGenerated, start);
	}
	BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		var generatedLine = 1;
		var previousGeneratedColumn = 0;
		var previousOriginalLine = 0;
		var previousOriginalColumn = 0;
		var previousSource = 0;
		var previousName = 0;
		var length = aStr.length;
		var index = 0;
		var cachedSegments = {};
		var temp = {};
		var originalMappings = [];
		var generatedMappings = [];
		var mapping, str, segment, end, value;
		let subarrayStart = 0;
		while (index < length) if (aStr.charAt(index) === ";") {
			generatedLine++;
			index++;
			previousGeneratedColumn = 0;
			sortGenerated(generatedMappings, subarrayStart);
			subarrayStart = generatedMappings.length;
		} else if (aStr.charAt(index) === ",") index++;
		else {
			mapping = new Mapping();
			mapping.generatedLine = generatedLine;
			for (end = index; end < length; end++) if (this._charIsMappingSeparator(aStr, end)) break;
			str = aStr.slice(index, end);
			segment = [];
			while (index < end) {
				base64VLQ.decode(aStr, index, temp);
				value = temp.value;
				index = temp.rest;
				segment.push(value);
			}
			if (segment.length === 2) throw new Error("Found a source, but no line and column");
			if (segment.length === 3) throw new Error("Found a source and line, but no column");
			mapping.generatedColumn = previousGeneratedColumn + segment[0];
			previousGeneratedColumn = mapping.generatedColumn;
			if (segment.length > 1) {
				mapping.source = previousSource + segment[1];
				previousSource += segment[1];
				mapping.originalLine = previousOriginalLine + segment[2];
				previousOriginalLine = mapping.originalLine;
				mapping.originalLine += 1;
				mapping.originalColumn = previousOriginalColumn + segment[3];
				previousOriginalColumn = mapping.originalColumn;
				if (segment.length > 4) {
					mapping.name = previousName + segment[4];
					previousName += segment[4];
				}
			}
			generatedMappings.push(mapping);
			if (typeof mapping.originalLine === "number") {
				let currentSource = mapping.source;
				while (originalMappings.length <= currentSource) originalMappings.push(null);
				if (originalMappings[currentSource] === null) originalMappings[currentSource] = [];
				originalMappings[currentSource].push(mapping);
			}
		}
		sortGenerated(generatedMappings, subarrayStart);
		this.__generatedMappings = generatedMappings;
		for (var i = 0; i < originalMappings.length; i++) if (originalMappings[i] != null) quickSort(originalMappings[i], util$1.compareByOriginalPositionsNoSource);
		this.__originalMappings = [].concat(...originalMappings);
	};
	/**
	* Find the mapping that best matches the hypothetical "needle" mapping that
	* we are searching for in the given "haystack" of mappings.
	*/
	BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
		if (aNeedle[aLineName] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
		if (aNeedle[aColumnName] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
		return binarySearch$1.search(aNeedle, aMappings, aComparator, aBias);
	};
	/**
	* Compute the last column for each generated mapping. The last column is
	* inclusive.
	*/
	BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
		for (var index = 0; index < this._generatedMappings.length; ++index) {
			var mapping = this._generatedMappings[index];
			if (index + 1 < this._generatedMappings.length) {
				var nextMapping = this._generatedMappings[index + 1];
				if (mapping.generatedLine === nextMapping.generatedLine) {
					mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
					continue;
				}
			}
			mapping.lastGeneratedColumn = Infinity;
		}
	};
	/**
	* Returns the original source, line, and column information for the generated
	* source's line and column positions provided. The only argument is an object
	* with the following properties:
	*
	*   - line: The line number in the generated source.  The line number
	*     is 1-based.
	*   - column: The column number in the generated source.  The column
	*     number is 0-based.
	*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	*     closest element that is smaller than or greater than the one we are
	*     searching for, respectively, if the exact element cannot be found.
	*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	*
	* and an object is returned with the following properties:
	*
	*   - source: The original source file, or null.
	*   - line: The line number in the original source, or null.  The
	*     line number is 1-based.
	*   - column: The column number in the original source, or null.  The
	*     column number is 0-based.
	*   - name: The original identifier, or null.
	*/
	BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
		var needle = {
			generatedLine: util$1.getArg(aArgs, "line"),
			generatedColumn: util$1.getArg(aArgs, "column")
		};
		var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$1.compareByGeneratedPositionsDeflated, util$1.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
		if (index >= 0) {
			var mapping = this._generatedMappings[index];
			if (mapping.generatedLine === needle.generatedLine) {
				var source = util$1.getArg(mapping, "source", null);
				if (source !== null) {
					source = this._sources.at(source);
					source = util$1.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
				}
				var name = util$1.getArg(mapping, "name", null);
				if (name !== null) name = this._names.at(name);
				return {
					source,
					line: util$1.getArg(mapping, "originalLine", null),
					column: util$1.getArg(mapping, "originalColumn", null),
					name
				};
			}
		}
		return {
			source: null,
			line: null,
			column: null,
			name: null
		};
	};
	/**
	* Return true if we have the source content for every source in the source
	* map, false otherwise.
	*/
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
		if (!this.sourcesContent) return false;
		return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
			return sc == null;
		});
	};
	/**
	* Returns the original source content. The only argument is the url of the
	* original source file. Returns null if no original source content is
	* available.
	*/
	BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		if (!this.sourcesContent) return null;
		var index = this._findSourceIndex(aSource);
		if (index >= 0) return this.sourcesContent[index];
		var relativeSource = aSource;
		if (this.sourceRoot != null) relativeSource = util$1.relative(this.sourceRoot, relativeSource);
		var url;
		if (this.sourceRoot != null && (url = util$1.urlParse(this.sourceRoot))) {
			var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
			if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
			if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
		}
		if (nullOnMissing) return null;
		else throw new Error("\"" + relativeSource + "\" is not in the SourceMap.");
	};
	/**
	* Returns the generated line and column information for the original source,
	* line, and column positions provided. The only argument is an object with
	* the following properties:
	*
	*   - source: The filename of the original source.
	*   - line: The line number in the original source.  The line number
	*     is 1-based.
	*   - column: The column number in the original source.  The column
	*     number is 0-based.
	*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	*     closest element that is smaller than or greater than the one we are
	*     searching for, respectively, if the exact element cannot be found.
	*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	*
	* and an object is returned with the following properties:
	*
	*   - line: The line number in the generated source, or null.  The
	*     line number is 1-based.
	*   - column: The column number in the generated source, or null.
	*     The column number is 0-based.
	*/
	BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
		var source = util$1.getArg(aArgs, "source");
		source = this._findSourceIndex(source);
		if (source < 0) return {
			line: null,
			column: null,
			lastColumn: null
		};
		var needle = {
			source,
			originalLine: util$1.getArg(aArgs, "line"),
			originalColumn: util$1.getArg(aArgs, "column")
		};
		var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, util$1.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
		if (index >= 0) {
			var mapping = this._originalMappings[index];
			if (mapping.source === needle.source) return {
				line: util$1.getArg(mapping, "generatedLine", null),
				column: util$1.getArg(mapping, "generatedColumn", null),
				lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
			};
		}
		return {
			line: null,
			column: null,
			lastColumn: null
		};
	};
	exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	/**
	* An IndexedSourceMapConsumer instance represents a parsed source map which
	* we can query for information. It differs from BasicSourceMapConsumer in
	* that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	* input.
	*
	* The first parameter is a raw source map (either as a JSON string, or already
	* parsed to an object). According to the spec for indexed source maps, they
	* have the following attributes:
	*
	*   - version: Which version of the source map spec this map is following.
	*   - file: Optional. The generated file this source map is associated with.
	*   - sections: A list of section definitions.
	*
	* Each value under the "sections" field has two fields:
	*   - offset: The offset into the original specified at which this section
	*       begins to apply, defined as an object with a "line" and "column"
	*       field.
	*   - map: A source map definition. This source map could also be indexed,
	*       but doesn't have to be.
	*
	* Instead of the "map" field, it's also possible to have a "url" field
	* specifying a URL to retrieve a source map from, but that's currently
	* unsupported.
	*
	* Here's an example source map, taken from the source map spec[0], but
	* modified to omit a section which uses the "url" field.
	*
	*  {
	*    version : 3,
	*    file: "app.js",
	*    sections: [{
	*      offset: {line:100, column:10},
	*      map: {
	*        version : 3,
	*        file: "section.js",
	*        sources: ["foo.js", "bar.js"],
	*        names: ["src", "maps", "are", "fun"],
	*        mappings: "AAAA,E;;ABCDE;"
	*      }
	*    }],
	*  }
	*
	* The second parameter, if given, is a string whose value is the URL
	* at which the source map was found.  This URL is used to compute the
	* sources array.
	*
	* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	*/
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") sourceMap = util$1.parseSourceMapInput(aSourceMap);
		var version = util$1.getArg(sourceMap, "version");
		var sections = util$1.getArg(sourceMap, "sections");
		if (version != this._version) throw new Error("Unsupported version: " + version);
		this._sources = new ArraySet();
		this._names = new ArraySet();
		var lastOffset = {
			line: -1,
			column: 0
		};
		this._sections = sections.map(function(s) {
			if (s.url) throw new Error("Support for url field in sections not implemented.");
			var offset = util$1.getArg(s, "offset");
			var offsetLine = util$1.getArg(offset, "line");
			var offsetColumn = util$1.getArg(offset, "column");
			if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) throw new Error("Section offsets must be ordered and non-overlapping.");
			lastOffset = offset;
			return {
				generatedOffset: {
					generatedLine: offsetLine + 1,
					generatedColumn: offsetColumn + 1
				},
				consumer: new SourceMapConsumer(util$1.getArg(s, "map"), aSourceMapURL)
			};
		});
	}
	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	/**
	* The version of the source mapping spec that we are consuming.
	*/
	IndexedSourceMapConsumer.prototype._version = 3;
	/**
	* The list of original sources.
	*/
	Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", { get: function() {
		var sources = [];
		for (var i = 0; i < this._sections.length; i++) for (var j = 0; j < this._sections[i].consumer.sources.length; j++) sources.push(this._sections[i].consumer.sources[j]);
		return sources;
	} });
	/**
	* Returns the original source, line, and column information for the generated
	* source's line and column positions provided. The only argument is an object
	* with the following properties:
	*
	*   - line: The line number in the generated source.  The line number
	*     is 1-based.
	*   - column: The column number in the generated source.  The column
	*     number is 0-based.
	*
	* and an object is returned with the following properties:
	*
	*   - source: The original source file, or null.
	*   - line: The line number in the original source, or null.  The
	*     line number is 1-based.
	*   - column: The column number in the original source, or null.  The
	*     column number is 0-based.
	*   - name: The original identifier, or null.
	*/
	IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
		var needle = {
			generatedLine: util$1.getArg(aArgs, "line"),
			generatedColumn: util$1.getArg(aArgs, "column")
		};
		var sectionIndex = binarySearch$1.search(needle, this._sections, function(needle$1, section$1) {
			var cmp = needle$1.generatedLine - section$1.generatedOffset.generatedLine;
			if (cmp) return cmp;
			return needle$1.generatedColumn - section$1.generatedOffset.generatedColumn;
		});
		var section = this._sections[sectionIndex];
		if (!section) return {
			source: null,
			line: null,
			column: null,
			name: null
		};
		return section.consumer.originalPositionFor({
			line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
			column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
			bias: aArgs.bias
		});
	};
	/**
	* Return true if we have the source content for every source in the source
	* map, false otherwise.
	*/
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
		return this._sections.every(function(s) {
			return s.consumer.hasContentsOfAllSources();
		});
	};
	/**
	* Returns the original source content. The only argument is the url of the
	* original source file. Returns null if no original source content is
	* available.
	*/
	IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		for (var i = 0; i < this._sections.length; i++) {
			var section = this._sections[i];
			var content = section.consumer.sourceContentFor(aSource, true);
			if (content || content === "") return content;
		}
		if (nullOnMissing) return null;
		else throw new Error("\"" + aSource + "\" is not in the SourceMap.");
	};
	/**
	* Returns the generated line and column information for the original source,
	* line, and column positions provided. The only argument is an object with
	* the following properties:
	*
	*   - source: The filename of the original source.
	*   - line: The line number in the original source.  The line number
	*     is 1-based.
	*   - column: The column number in the original source.  The column
	*     number is 0-based.
	*
	* and an object is returned with the following properties:
	*
	*   - line: The line number in the generated source, or null.  The
	*     line number is 1-based. 
	*   - column: The column number in the generated source, or null.
	*     The column number is 0-based.
	*/
	IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
		for (var i = 0; i < this._sections.length; i++) {
			var section = this._sections[i];
			if (section.consumer._findSourceIndex(util$1.getArg(aArgs, "source")) === -1) continue;
			var generatedPosition = section.consumer.generatedPositionFor(aArgs);
			if (generatedPosition) {
				var ret = {
					line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
					column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
				};
				return ret;
			}
		}
		return {
			line: null,
			column: null
		};
	};
	/**
	* Parse the mappings in a string in to a data structure which we can easily
	* query (the ordered arrays in the `this.__generatedMappings` and
	* `this.__originalMappings` properties).
	*/
	IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		this.__generatedMappings = [];
		this.__originalMappings = [];
		for (var i = 0; i < this._sections.length; i++) {
			var section = this._sections[i];
			var sectionMappings = section.consumer._generatedMappings;
			for (var j = 0; j < sectionMappings.length; j++) {
				var mapping = sectionMappings[j];
				var source = section.consumer._sources.at(mapping.source);
				if (source !== null) source = util$1.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
				this._sources.add(source);
				source = this._sources.indexOf(source);
				var name = null;
				if (mapping.name) {
					name = section.consumer._names.at(mapping.name);
					this._names.add(name);
					name = this._names.indexOf(name);
				}
				var adjustedMapping = {
					source,
					generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
					generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
					originalLine: mapping.originalLine,
					originalColumn: mapping.originalColumn,
					name
				};
				this.__generatedMappings.push(adjustedMapping);
				if (typeof adjustedMapping.originalLine === "number") this.__originalMappings.push(adjustedMapping);
			}
		}
		quickSort(this.__generatedMappings, util$1.compareByGeneratedPositionsDeflated);
		quickSort(this.__originalMappings, util$1.compareByOriginalPositions);
	};
	exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
} });

//#endregion
//#region node_modules/source-map-js/lib/source-node.js
var require_source_node = __commonJS({ "node_modules/source-map-js/lib/source-node.js"(exports) {
	var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
	var util = require_util();
	var REGEX_NEWLINE = /(\r?\n)/;
	var NEWLINE_CODE = 10;
	var isSourceNode = "$$$isSourceNode$$$";
	/**
	* SourceNodes provide a way to abstract over interpolating/concatenating
	* snippets of generated JavaScript source code while maintaining the line and
	* column information associated with the original source code.
	*
	* @param aLine The original line number.
	* @param aColumn The original column number.
	* @param aSource The original source's filename.
	* @param aChunks Optional. An array of strings which are snippets of
	*        generated JS, or other SourceNodes.
	* @param aName The original identifier.
	*/
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
		this.children = [];
		this.sourceContents = {};
		this.line = aLine == null ? null : aLine;
		this.column = aColumn == null ? null : aColumn;
		this.source = aSource == null ? null : aSource;
		this.name = aName == null ? null : aName;
		this[isSourceNode] = true;
		if (aChunks != null) this.add(aChunks);
	}
	/**
	* Creates a SourceNode from generated code and a SourceMapConsumer.
	*
	* @param aGeneratedCode The generated code
	* @param aSourceMapConsumer The SourceMap for the generated code
	* @param aRelativePath Optional. The path that relative sources in the
	*        SourceMapConsumer should be relative to.
	*/
	SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
		var node = new SourceNode();
		var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
		var remainingLinesIndex = 0;
		var shiftNextLine = function() {
			var lineContents = getNextLine();
			var newLine = getNextLine() || "";
			return lineContents + newLine;
			function getNextLine() {
				return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
			}
		};
		var lastGeneratedLine = 1, lastGeneratedColumn = 0;
		var lastMapping = null;
		aSourceMapConsumer.eachMapping(function(mapping) {
			if (lastMapping !== null) if (lastGeneratedLine < mapping.generatedLine) {
				addMappingWithCode(lastMapping, shiftNextLine());
				lastGeneratedLine++;
				lastGeneratedColumn = 0;
			} else {
				var nextLine = remainingLines[remainingLinesIndex] || "";
				var code$1 = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
				remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
				lastGeneratedColumn = mapping.generatedColumn;
				addMappingWithCode(lastMapping, code$1);
				lastMapping = mapping;
				return;
			}
			while (lastGeneratedLine < mapping.generatedLine) {
				node.add(shiftNextLine());
				lastGeneratedLine++;
			}
			if (lastGeneratedColumn < mapping.generatedColumn) {
				var nextLine = remainingLines[remainingLinesIndex] || "";
				node.add(nextLine.substr(0, mapping.generatedColumn));
				remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
				lastGeneratedColumn = mapping.generatedColumn;
			}
			lastMapping = mapping;
		}, this);
		if (remainingLinesIndex < remainingLines.length) {
			if (lastMapping) addMappingWithCode(lastMapping, shiftNextLine());
			node.add(remainingLines.splice(remainingLinesIndex).join(""));
		}
		aSourceMapConsumer.sources.forEach(function(sourceFile) {
			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) {
				if (aRelativePath != null) sourceFile = util.join(aRelativePath, sourceFile);
				node.setSourceContent(sourceFile, content);
			}
		});
		return node;
		function addMappingWithCode(mapping, code$1) {
			if (mapping === null || mapping.source === void 0) node.add(code$1);
			else {
				var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
				node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code$1, mapping.name));
			}
		}
	};
	/**
	* Add a chunk of generated JS to this source node.
	*
	* @param aChunk A string snippet of generated JS code, another instance of
	*        SourceNode, or an array where each member is one of those things.
	*/
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
		if (Array.isArray(aChunk)) aChunk.forEach(function(chunk) {
			this.add(chunk);
		}, this);
		else if (aChunk[isSourceNode] || typeof aChunk === "string") {
			if (aChunk) this.children.push(aChunk);
		} else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
		return this;
	};
	/**
	* Add a chunk of generated JS to the beginning of this source node.
	*
	* @param aChunk A string snippet of generated JS code, another instance of
	*        SourceNode, or an array where each member is one of those things.
	*/
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
		if (Array.isArray(aChunk)) for (var i = aChunk.length - 1; i >= 0; i--) this.prepend(aChunk[i]);
		else if (aChunk[isSourceNode] || typeof aChunk === "string") this.children.unshift(aChunk);
		else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
		return this;
	};
	/**
	* Walk over the tree of JS snippets in this node and its children. The
	* walking function is called once for each snippet of JS and is passed that
	* snippet and the its original associated source's line/column location.
	*
	* @param aFn The traversal function.
	*/
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
		var chunk;
		for (var i = 0, len = this.children.length; i < len; i++) {
			chunk = this.children[i];
			if (chunk[isSourceNode]) chunk.walk(aFn);
			else if (chunk !== "") aFn(chunk, {
				source: this.source,
				line: this.line,
				column: this.column,
				name: this.name
			});
		}
	};
	/**
	* Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	* each of `this.children`.
	*
	* @param aSep The separator.
	*/
	SourceNode.prototype.join = function SourceNode_join(aSep) {
		var newChildren;
		var i;
		var len = this.children.length;
		if (len > 0) {
			newChildren = [];
			for (i = 0; i < len - 1; i++) {
				newChildren.push(this.children[i]);
				newChildren.push(aSep);
			}
			newChildren.push(this.children[i]);
			this.children = newChildren;
		}
		return this;
	};
	/**
	* Call String.prototype.replace on the very right-most source snippet. Useful
	* for trimming whitespace from the end of a source node, etc.
	*
	* @param aPattern The pattern to replace.
	* @param aReplacement The thing to replace the pattern with.
	*/
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
		var lastChild = this.children[this.children.length - 1];
		if (lastChild[isSourceNode]) lastChild.replaceRight(aPattern, aReplacement);
		else if (typeof lastChild === "string") this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
		else this.children.push("".replace(aPattern, aReplacement));
		return this;
	};
	/**
	* Set the source content for a source file. This will be added to the SourceMapGenerator
	* in the sourcesContent field.
	*
	* @param aSourceFile The filename of the source file
	* @param aSourceContent The content of the source file
	*/
	SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
		this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	};
	/**
	* Walk over the tree of SourceNodes. The walking function is called for each
	* source file content and is passed the filename and source content.
	*
	* @param aFn The traversal function.
	*/
	SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
		for (var i = 0, len = this.children.length; i < len; i++) if (this.children[i][isSourceNode]) this.children[i].walkSourceContents(aFn);
		var sources = Object.keys(this.sourceContents);
		for (var i = 0, len = sources.length; i < len; i++) aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	};
	/**
	* Return the string representation of this source node. Walks over the tree
	* and concatenates all the various snippets together to one string.
	*/
	SourceNode.prototype.toString = function SourceNode_toString() {
		var str = "";
		this.walk(function(chunk) {
			str += chunk;
		});
		return str;
	};
	/**
	* Returns the string representation of this source node along with a source
	* map.
	*/
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
		var generated = {
			code: "",
			line: 1,
			column: 0
		};
		var map = new SourceMapGenerator(aArgs);
		var sourceMappingActive = false;
		var lastOriginalSource = null;
		var lastOriginalLine = null;
		var lastOriginalColumn = null;
		var lastOriginalName = null;
		this.walk(function(chunk, original) {
			generated.code += chunk;
			if (original.source !== null && original.line !== null && original.column !== null) {
				if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) map.addMapping({
					source: original.source,
					original: {
						line: original.line,
						column: original.column
					},
					generated: {
						line: generated.line,
						column: generated.column
					},
					name: original.name
				});
				lastOriginalSource = original.source;
				lastOriginalLine = original.line;
				lastOriginalColumn = original.column;
				lastOriginalName = original.name;
				sourceMappingActive = true;
			} else if (sourceMappingActive) {
				map.addMapping({ generated: {
					line: generated.line,
					column: generated.column
				} });
				lastOriginalSource = null;
				sourceMappingActive = false;
			}
			for (var idx = 0, length = chunk.length; idx < length; idx++) if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
				generated.line++;
				generated.column = 0;
				if (idx + 1 === length) {
					lastOriginalSource = null;
					sourceMappingActive = false;
				} else if (sourceMappingActive) map.addMapping({
					source: original.source,
					original: {
						line: original.line,
						column: original.column
					},
					generated: {
						line: generated.line,
						column: generated.column
					},
					name: original.name
				});
			} else generated.column++;
		});
		this.walkSourceContents(function(sourceFile, sourceContent) {
			map.setSourceContent(sourceFile, sourceContent);
		});
		return {
			code: generated.code,
			map
		};
	};
	exports.SourceNode = SourceNode;
} });

//#endregion
//#region node_modules/source-map-js/source-map.js
var require_source_map = __commonJS({ "node_modules/source-map-js/source-map.js"(exports) {
	exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
	exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
	exports.SourceNode = require_source_node().SourceNode;
} });

//#endregion
//#region node_modules/@vue/compiler-core/dist/compiler-core.cjs.prod.js
var require_compiler_core_cjs_prod = __commonJS({ "node_modules/@vue/compiler-core/dist/compiler-core.cjs.prod.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var shared$1 = require_shared$2();
	var decode_js = require_decode();
	var parser = require_lib();
	var estreeWalker = require_estree_walker();
	var sourceMapJs = require_source_map();
	const FRAGMENT = Symbol(``);
	const TELEPORT = Symbol(``);
	const SUSPENSE = Symbol(``);
	const KEEP_ALIVE = Symbol(``);
	const BASE_TRANSITION = Symbol(``);
	const OPEN_BLOCK = Symbol(``);
	const CREATE_BLOCK = Symbol(``);
	const CREATE_ELEMENT_BLOCK = Symbol(``);
	const CREATE_VNODE = Symbol(``);
	const CREATE_ELEMENT_VNODE = Symbol(``);
	const CREATE_COMMENT = Symbol(``);
	const CREATE_TEXT = Symbol(``);
	const CREATE_STATIC = Symbol(``);
	const RESOLVE_COMPONENT = Symbol(``);
	const RESOLVE_DYNAMIC_COMPONENT = Symbol(``);
	const RESOLVE_DIRECTIVE = Symbol(``);
	const RESOLVE_FILTER = Symbol(``);
	const WITH_DIRECTIVES = Symbol(``);
	const RENDER_LIST = Symbol(``);
	const RENDER_SLOT = Symbol(``);
	const CREATE_SLOTS = Symbol(``);
	const TO_DISPLAY_STRING = Symbol(``);
	const MERGE_PROPS = Symbol(``);
	const NORMALIZE_CLASS = Symbol(``);
	const NORMALIZE_STYLE = Symbol(``);
	const NORMALIZE_PROPS = Symbol(``);
	const GUARD_REACTIVE_PROPS = Symbol(``);
	const TO_HANDLERS = Symbol(``);
	const CAMELIZE = Symbol(``);
	const CAPITALIZE = Symbol(``);
	const TO_HANDLER_KEY = Symbol(``);
	const SET_BLOCK_TRACKING = Symbol(``);
	const PUSH_SCOPE_ID = Symbol(``);
	const POP_SCOPE_ID = Symbol(``);
	const WITH_CTX = Symbol(``);
	const UNREF = Symbol(``);
	const IS_REF = Symbol(``);
	const WITH_MEMO = Symbol(``);
	const IS_MEMO_SAME = Symbol(``);
	const helperNameMap = {
		[FRAGMENT]: `Fragment`,
		[TELEPORT]: `Teleport`,
		[SUSPENSE]: `Suspense`,
		[KEEP_ALIVE]: `KeepAlive`,
		[BASE_TRANSITION]: `BaseTransition`,
		[OPEN_BLOCK]: `openBlock`,
		[CREATE_BLOCK]: `createBlock`,
		[CREATE_ELEMENT_BLOCK]: `createElementBlock`,
		[CREATE_VNODE]: `createVNode`,
		[CREATE_ELEMENT_VNODE]: `createElementVNode`,
		[CREATE_COMMENT]: `createCommentVNode`,
		[CREATE_TEXT]: `createTextVNode`,
		[CREATE_STATIC]: `createStaticVNode`,
		[RESOLVE_COMPONENT]: `resolveComponent`,
		[RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
		[RESOLVE_DIRECTIVE]: `resolveDirective`,
		[RESOLVE_FILTER]: `resolveFilter`,
		[WITH_DIRECTIVES]: `withDirectives`,
		[RENDER_LIST]: `renderList`,
		[RENDER_SLOT]: `renderSlot`,
		[CREATE_SLOTS]: `createSlots`,
		[TO_DISPLAY_STRING]: `toDisplayString`,
		[MERGE_PROPS]: `mergeProps`,
		[NORMALIZE_CLASS]: `normalizeClass`,
		[NORMALIZE_STYLE]: `normalizeStyle`,
		[NORMALIZE_PROPS]: `normalizeProps`,
		[GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
		[TO_HANDLERS]: `toHandlers`,
		[CAMELIZE]: `camelize`,
		[CAPITALIZE]: `capitalize`,
		[TO_HANDLER_KEY]: `toHandlerKey`,
		[SET_BLOCK_TRACKING]: `setBlockTracking`,
		[PUSH_SCOPE_ID]: `pushScopeId`,
		[POP_SCOPE_ID]: `popScopeId`,
		[WITH_CTX]: `withCtx`,
		[UNREF]: `unref`,
		[IS_REF]: `isRef`,
		[WITH_MEMO]: `withMemo`,
		[IS_MEMO_SAME]: `isMemoSame`
	};
	function registerRuntimeHelpers(helpers) {
		Object.getOwnPropertySymbols(helpers).forEach((s) => {
			helperNameMap[s] = helpers[s];
		});
	}
	const Namespaces = {
		"HTML": 0,
		"0": "HTML",
		"SVG": 1,
		"1": "SVG",
		"MATH_ML": 2,
		"2": "MATH_ML"
	};
	const NodeTypes = {
		"ROOT": 0,
		"0": "ROOT",
		"ELEMENT": 1,
		"1": "ELEMENT",
		"TEXT": 2,
		"2": "TEXT",
		"COMMENT": 3,
		"3": "COMMENT",
		"SIMPLE_EXPRESSION": 4,
		"4": "SIMPLE_EXPRESSION",
		"INTERPOLATION": 5,
		"5": "INTERPOLATION",
		"ATTRIBUTE": 6,
		"6": "ATTRIBUTE",
		"DIRECTIVE": 7,
		"7": "DIRECTIVE",
		"COMPOUND_EXPRESSION": 8,
		"8": "COMPOUND_EXPRESSION",
		"IF": 9,
		"9": "IF",
		"IF_BRANCH": 10,
		"10": "IF_BRANCH",
		"FOR": 11,
		"11": "FOR",
		"TEXT_CALL": 12,
		"12": "TEXT_CALL",
		"VNODE_CALL": 13,
		"13": "VNODE_CALL",
		"JS_CALL_EXPRESSION": 14,
		"14": "JS_CALL_EXPRESSION",
		"JS_OBJECT_EXPRESSION": 15,
		"15": "JS_OBJECT_EXPRESSION",
		"JS_PROPERTY": 16,
		"16": "JS_PROPERTY",
		"JS_ARRAY_EXPRESSION": 17,
		"17": "JS_ARRAY_EXPRESSION",
		"JS_FUNCTION_EXPRESSION": 18,
		"18": "JS_FUNCTION_EXPRESSION",
		"JS_CONDITIONAL_EXPRESSION": 19,
		"19": "JS_CONDITIONAL_EXPRESSION",
		"JS_CACHE_EXPRESSION": 20,
		"20": "JS_CACHE_EXPRESSION",
		"JS_BLOCK_STATEMENT": 21,
		"21": "JS_BLOCK_STATEMENT",
		"JS_TEMPLATE_LITERAL": 22,
		"22": "JS_TEMPLATE_LITERAL",
		"JS_IF_STATEMENT": 23,
		"23": "JS_IF_STATEMENT",
		"JS_ASSIGNMENT_EXPRESSION": 24,
		"24": "JS_ASSIGNMENT_EXPRESSION",
		"JS_SEQUENCE_EXPRESSION": 25,
		"25": "JS_SEQUENCE_EXPRESSION",
		"JS_RETURN_STATEMENT": 26,
		"26": "JS_RETURN_STATEMENT"
	};
	const ElementTypes = {
		"ELEMENT": 0,
		"0": "ELEMENT",
		"COMPONENT": 1,
		"1": "COMPONENT",
		"SLOT": 2,
		"2": "SLOT",
		"TEMPLATE": 3,
		"3": "TEMPLATE"
	};
	const ConstantTypes = {
		"NOT_CONSTANT": 0,
		"0": "NOT_CONSTANT",
		"CAN_SKIP_PATCH": 1,
		"1": "CAN_SKIP_PATCH",
		"CAN_CACHE": 2,
		"2": "CAN_CACHE",
		"CAN_STRINGIFY": 3,
		"3": "CAN_STRINGIFY"
	};
	const locStub = {
		start: {
			line: 1,
			column: 1,
			offset: 0
		},
		end: {
			line: 1,
			column: 1,
			offset: 0
		},
		source: ""
	};
	function createRoot(children, source = "") {
		return {
			type: 0,
			source,
			children,
			helpers: /* @__PURE__ */ new Set(),
			components: [],
			directives: [],
			hoists: [],
			imports: [],
			cached: [],
			temps: 0,
			codegenNode: void 0,
			loc: locStub
		};
	}
	function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent$1 = false, loc = locStub) {
		if (context) {
			if (isBlock) {
				context.helper(OPEN_BLOCK);
				context.helper(getVNodeBlockHelper(context.inSSR, isComponent$1));
			} else context.helper(getVNodeHelper(context.inSSR, isComponent$1));
			if (directives) context.helper(WITH_DIRECTIVES);
		}
		return {
			type: 13,
			tag,
			props,
			children,
			patchFlag,
			dynamicProps,
			directives,
			isBlock,
			disableTracking,
			isComponent: isComponent$1,
			loc
		};
	}
	function createArrayExpression(elements, loc = locStub) {
		return {
			type: 17,
			loc,
			elements
		};
	}
	function createObjectExpression(properties, loc = locStub) {
		return {
			type: 15,
			loc,
			properties
		};
	}
	function createObjectProperty(key, value) {
		return {
			type: 16,
			loc: locStub,
			key: shared$1.isString(key) ? createSimpleExpression(key, true) : key,
			value
		};
	}
	function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
		return {
			type: 4,
			loc,
			content,
			isStatic,
			constType: isStatic ? 3 : constType
		};
	}
	function createInterpolation(content, loc) {
		return {
			type: 5,
			loc,
			content: shared$1.isString(content) ? createSimpleExpression(content, false, loc) : content
		};
	}
	function createCompoundExpression(children, loc = locStub) {
		return {
			type: 8,
			loc,
			children
		};
	}
	function createCallExpression(callee, args = [], loc = locStub) {
		return {
			type: 14,
			loc,
			callee,
			arguments: args
		};
	}
	function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
		return {
			type: 18,
			params,
			returns,
			newline,
			isSlot,
			loc
		};
	}
	function createConditionalExpression(test, consequent, alternate, newline = true) {
		return {
			type: 19,
			test,
			consequent,
			alternate,
			newline,
			loc: locStub
		};
	}
	function createCacheExpression(index, value, needPauseTracking = false, inVOnce = false) {
		return {
			type: 20,
			index,
			value,
			needPauseTracking,
			inVOnce,
			needArraySpread: false,
			loc: locStub
		};
	}
	function createBlockStatement(body) {
		return {
			type: 21,
			body,
			loc: locStub
		};
	}
	function createTemplateLiteral(elements) {
		return {
			type: 22,
			elements,
			loc: locStub
		};
	}
	function createIfStatement(test, consequent, alternate) {
		return {
			type: 23,
			test,
			consequent,
			alternate,
			loc: locStub
		};
	}
	function createAssignmentExpression(left, right) {
		return {
			type: 24,
			left,
			right,
			loc: locStub
		};
	}
	function createSequenceExpression(expressions) {
		return {
			type: 25,
			expressions,
			loc: locStub
		};
	}
	function createReturnStatement(returns) {
		return {
			type: 26,
			returns,
			loc: locStub
		};
	}
	function getVNodeHelper(ssr, isComponent$1) {
		return ssr || isComponent$1 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
	}
	function getVNodeBlockHelper(ssr, isComponent$1) {
		return ssr || isComponent$1 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
	}
	function convertToBlock(node, { helper, removeHelper, inSSR }) {
		if (!node.isBlock) {
			node.isBlock = true;
			removeHelper(getVNodeHelper(inSSR, node.isComponent));
			helper(OPEN_BLOCK);
			helper(getVNodeBlockHelper(inSSR, node.isComponent));
		}
	}
	const defaultDelimitersOpen = new Uint8Array([123, 123]);
	const defaultDelimitersClose = new Uint8Array([125, 125]);
	function isTagStartChar(c) {
		return c >= 97 && c <= 122 || c >= 65 && c <= 90;
	}
	function isWhitespace(c) {
		return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
	}
	function isEndOfTagSection(c) {
		return c === 47 || c === 62 || isWhitespace(c);
	}
	function toCharCodes(str) {
		const ret = new Uint8Array(str.length);
		for (let i = 0; i < str.length; i++) ret[i] = str.charCodeAt(i);
		return ret;
	}
	const Sequences = {
		Cdata: new Uint8Array([
			67,
			68,
			65,
			84,
			65,
			91
		]),
		CdataEnd: new Uint8Array([
			93,
			93,
			62
		]),
		CommentEnd: new Uint8Array([
			45,
			45,
			62
		]),
		ScriptEnd: new Uint8Array([
			60,
			47,
			115,
			99,
			114,
			105,
			112,
			116
		]),
		StyleEnd: new Uint8Array([
			60,
			47,
			115,
			116,
			121,
			108,
			101
		]),
		TitleEnd: new Uint8Array([
			60,
			47,
			116,
			105,
			116,
			108,
			101
		]),
		TextareaEnd: new Uint8Array([
			60,
			47,
			116,
			101,
			120,
			116,
			97,
			114,
			101,
			97
		])
	};
	var Tokenizer = class {
		constructor(stack$1, cbs) {
			this.stack = stack$1;
			this.cbs = cbs;
			/** The current state the tokenizer is in. */
			this.state = 1;
			/** The read buffer. */
			this.buffer = "";
			/** The beginning of the section that is currently being read. */
			this.sectionStart = 0;
			/** The index within the buffer that we are currently looking at. */
			this.index = 0;
			/** The start of the last entity. */
			this.entityStart = 0;
			/** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
			this.baseState = 1;
			/** For special parsing behavior inside of script and style tags. */
			this.inRCDATA = false;
			/** For disabling RCDATA tags handling */
			this.inXML = false;
			/** For disabling interpolation parsing in v-pre */
			this.inVPre = false;
			/** Record newline positions for fast line / column calculation */
			this.newlines = [];
			this.mode = 0;
			this.delimiterOpen = defaultDelimitersOpen;
			this.delimiterClose = defaultDelimitersClose;
			this.delimiterIndex = -1;
			this.currentSequence = void 0;
			this.sequenceIndex = 0;
			this.entityDecoder = new decode_js.EntityDecoder(decode_js.htmlDecodeTree, (cp, consumed) => this.emitCodePoint(cp, consumed));
		}
		get inSFCRoot() {
			return this.mode === 2 && this.stack.length === 0;
		}
		reset() {
			this.state = 1;
			this.mode = 0;
			this.buffer = "";
			this.sectionStart = 0;
			this.index = 0;
			this.baseState = 1;
			this.inRCDATA = false;
			this.currentSequence = void 0;
			this.newlines.length = 0;
			this.delimiterOpen = defaultDelimitersOpen;
			this.delimiterClose = defaultDelimitersClose;
		}
		/**
		* Generate Position object with line / column information using recorded
		* newline positions. We know the index is always going to be an already
		* processed index, so all the newlines up to this index should have been
		* recorded.
		*/
		getPos(index) {
			let line = 1;
			let column = index + 1;
			for (let i = this.newlines.length - 1; i >= 0; i--) {
				const newlineIndex = this.newlines[i];
				if (index > newlineIndex) {
					line = i + 2;
					column = index - newlineIndex;
					break;
				}
			}
			return {
				column,
				line,
				offset: index
			};
		}
		peek() {
			return this.buffer.charCodeAt(this.index + 1);
		}
		stateText(c) {
			if (c === 60) {
				if (this.index > this.sectionStart) this.cbs.ontext(this.sectionStart, this.index);
				this.state = 5;
				this.sectionStart = this.index;
			} else if (c === 38) this.startEntity();
			else if (!this.inVPre && c === this.delimiterOpen[0]) {
				this.state = 2;
				this.delimiterIndex = 0;
				this.stateInterpolationOpen(c);
			}
		}
		stateInterpolationOpen(c) {
			if (c === this.delimiterOpen[this.delimiterIndex]) if (this.delimiterIndex === this.delimiterOpen.length - 1) {
				const start = this.index + 1 - this.delimiterOpen.length;
				if (start > this.sectionStart) this.cbs.ontext(this.sectionStart, start);
				this.state = 3;
				this.sectionStart = start;
			} else this.delimiterIndex++;
			else if (this.inRCDATA) {
				this.state = 32;
				this.stateInRCDATA(c);
			} else {
				this.state = 1;
				this.stateText(c);
			}
		}
		stateInterpolation(c) {
			if (c === this.delimiterClose[0]) {
				this.state = 4;
				this.delimiterIndex = 0;
				this.stateInterpolationClose(c);
			}
		}
		stateInterpolationClose(c) {
			if (c === this.delimiterClose[this.delimiterIndex]) if (this.delimiterIndex === this.delimiterClose.length - 1) {
				this.cbs.oninterpolation(this.sectionStart, this.index + 1);
				if (this.inRCDATA) this.state = 32;
				else this.state = 1;
				this.sectionStart = this.index + 1;
			} else this.delimiterIndex++;
			else {
				this.state = 3;
				this.stateInterpolation(c);
			}
		}
		stateSpecialStartSequence(c) {
			const isEnd = this.sequenceIndex === this.currentSequence.length;
			const isMatch = isEnd ? isEndOfTagSection(c) : (c | 32) === this.currentSequence[this.sequenceIndex];
			if (!isMatch) this.inRCDATA = false;
			else if (!isEnd) {
				this.sequenceIndex++;
				return;
			}
			this.sequenceIndex = 0;
			this.state = 6;
			this.stateInTagName(c);
		}
		/** Look for an end tag. For <title> and <textarea>, also decode entities. */
		stateInRCDATA(c) {
			if (this.sequenceIndex === this.currentSequence.length) {
				if (c === 62 || isWhitespace(c)) {
					const endOfText = this.index - this.currentSequence.length;
					if (this.sectionStart < endOfText) {
						const actualIndex = this.index;
						this.index = endOfText;
						this.cbs.ontext(this.sectionStart, endOfText);
						this.index = actualIndex;
					}
					this.sectionStart = endOfText + 2;
					this.stateInClosingTagName(c);
					this.inRCDATA = false;
					return;
				}
				this.sequenceIndex = 0;
			}
			if ((c | 32) === this.currentSequence[this.sequenceIndex]) this.sequenceIndex += 1;
			else if (this.sequenceIndex === 0) {
				if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
					if (c === 38) this.startEntity();
					else if (!this.inVPre && c === this.delimiterOpen[0]) {
						this.state = 2;
						this.delimiterIndex = 0;
						this.stateInterpolationOpen(c);
					}
				} else if (this.fastForwardTo(60)) this.sequenceIndex = 1;
			} else this.sequenceIndex = Number(c === 60);
		}
		stateCDATASequence(c) {
			if (c === Sequences.Cdata[this.sequenceIndex]) {
				if (++this.sequenceIndex === Sequences.Cdata.length) {
					this.state = 28;
					this.currentSequence = Sequences.CdataEnd;
					this.sequenceIndex = 0;
					this.sectionStart = this.index + 1;
				}
			} else {
				this.sequenceIndex = 0;
				this.state = 23;
				this.stateInDeclaration(c);
			}
		}
		/**
		* When we wait for one specific character, we can speed things up
		* by skipping through the buffer until we find it.
		*
		* @returns Whether the character was found.
		*/
		fastForwardTo(c) {
			while (++this.index < this.buffer.length) {
				const cc = this.buffer.charCodeAt(this.index);
				if (cc === 10) this.newlines.push(this.index);
				if (cc === c) return true;
			}
			this.index = this.buffer.length - 1;
			return false;
		}
		/**
		* Comments and CDATA end with `-->` and `]]>`.
		*
		* Their common qualities are:
		* - Their end sequences have a distinct character they start with.
		* - That character is then repeated, so we have to check multiple repeats.
		* - All characters but the start character of the sequence can be skipped.
		*/
		stateInCommentLike(c) {
			if (c === this.currentSequence[this.sequenceIndex]) {
				if (++this.sequenceIndex === this.currentSequence.length) {
					if (this.currentSequence === Sequences.CdataEnd) this.cbs.oncdata(this.sectionStart, this.index - 2);
					else this.cbs.oncomment(this.sectionStart, this.index - 2);
					this.sequenceIndex = 0;
					this.sectionStart = this.index + 1;
					this.state = 1;
				}
			} else if (this.sequenceIndex === 0) {
				if (this.fastForwardTo(this.currentSequence[0])) this.sequenceIndex = 1;
			} else if (c !== this.currentSequence[this.sequenceIndex - 1]) this.sequenceIndex = 0;
		}
		startSpecial(sequence, offset) {
			this.enterRCDATA(sequence, offset);
			this.state = 31;
		}
		enterRCDATA(sequence, offset) {
			this.inRCDATA = true;
			this.currentSequence = sequence;
			this.sequenceIndex = offset;
		}
		stateBeforeTagName(c) {
			if (c === 33) {
				this.state = 22;
				this.sectionStart = this.index + 1;
			} else if (c === 63) {
				this.state = 24;
				this.sectionStart = this.index + 1;
			} else if (isTagStartChar(c)) {
				this.sectionStart = this.index;
				if (this.mode === 0) this.state = 6;
				else if (this.inSFCRoot) this.state = 34;
				else if (!this.inXML) if (c === 116) this.state = 30;
				else this.state = c === 115 ? 29 : 6;
				else this.state = 6;
			} else if (c === 47) this.state = 8;
			else {
				this.state = 1;
				this.stateText(c);
			}
		}
		stateInTagName(c) {
			if (isEndOfTagSection(c)) this.handleTagName(c);
		}
		stateInSFCRootTagName(c) {
			if (isEndOfTagSection(c)) {
				const tag = this.buffer.slice(this.sectionStart, this.index);
				if (tag !== "template") this.enterRCDATA(toCharCodes(`</` + tag), 0);
				this.handleTagName(c);
			}
		}
		handleTagName(c) {
			this.cbs.onopentagname(this.sectionStart, this.index);
			this.sectionStart = -1;
			this.state = 11;
			this.stateBeforeAttrName(c);
		}
		stateBeforeClosingTagName(c) {
			if (isWhitespace(c));
			else if (c === 62) {
				this.cbs.onerr(14, this.index);
				this.state = 1;
				this.sectionStart = this.index + 1;
			} else {
				this.state = isTagStartChar(c) ? 9 : 27;
				this.sectionStart = this.index;
			}
		}
		stateInClosingTagName(c) {
			if (c === 62 || isWhitespace(c)) {
				this.cbs.onclosetag(this.sectionStart, this.index);
				this.sectionStart = -1;
				this.state = 10;
				this.stateAfterClosingTagName(c);
			}
		}
		stateAfterClosingTagName(c) {
			if (c === 62) {
				this.state = 1;
				this.sectionStart = this.index + 1;
			}
		}
		stateBeforeAttrName(c) {
			if (c === 62) {
				this.cbs.onopentagend(this.index);
				if (this.inRCDATA) this.state = 32;
				else this.state = 1;
				this.sectionStart = this.index + 1;
			} else if (c === 47) {
				this.state = 7;
				if (this.peek() !== 62) this.cbs.onerr(22, this.index);
			} else if (c === 60 && this.peek() === 47) {
				this.cbs.onopentagend(this.index);
				this.state = 5;
				this.sectionStart = this.index;
			} else if (!isWhitespace(c)) {
				if (c === 61) this.cbs.onerr(19, this.index);
				this.handleAttrStart(c);
			}
		}
		handleAttrStart(c) {
			if (c === 118 && this.peek() === 45) {
				this.state = 13;
				this.sectionStart = this.index;
			} else if (c === 46 || c === 58 || c === 64 || c === 35) {
				this.cbs.ondirname(this.index, this.index + 1);
				this.state = 14;
				this.sectionStart = this.index + 1;
			} else {
				this.state = 12;
				this.sectionStart = this.index;
			}
		}
		stateInSelfClosingTag(c) {
			if (c === 62) {
				this.cbs.onselfclosingtag(this.index);
				this.state = 1;
				this.sectionStart = this.index + 1;
				this.inRCDATA = false;
			} else if (!isWhitespace(c)) {
				this.state = 11;
				this.stateBeforeAttrName(c);
			}
		}
		stateInAttrName(c) {
			if (c === 61 || isEndOfTagSection(c)) {
				this.cbs.onattribname(this.sectionStart, this.index);
				this.handleAttrNameEnd(c);
			} else if (c === 34 || c === 39 || c === 60) this.cbs.onerr(17, this.index);
		}
		stateInDirName(c) {
			if (c === 61 || isEndOfTagSection(c)) {
				this.cbs.ondirname(this.sectionStart, this.index);
				this.handleAttrNameEnd(c);
			} else if (c === 58) {
				this.cbs.ondirname(this.sectionStart, this.index);
				this.state = 14;
				this.sectionStart = this.index + 1;
			} else if (c === 46) {
				this.cbs.ondirname(this.sectionStart, this.index);
				this.state = 16;
				this.sectionStart = this.index + 1;
			}
		}
		stateInDirArg(c) {
			if (c === 61 || isEndOfTagSection(c)) {
				this.cbs.ondirarg(this.sectionStart, this.index);
				this.handleAttrNameEnd(c);
			} else if (c === 91) this.state = 15;
			else if (c === 46) {
				this.cbs.ondirarg(this.sectionStart, this.index);
				this.state = 16;
				this.sectionStart = this.index + 1;
			}
		}
		stateInDynamicDirArg(c) {
			if (c === 93) this.state = 14;
			else if (c === 61 || isEndOfTagSection(c)) {
				this.cbs.ondirarg(this.sectionStart, this.index + 1);
				this.handleAttrNameEnd(c);
				this.cbs.onerr(27, this.index);
			}
		}
		stateInDirModifier(c) {
			if (c === 61 || isEndOfTagSection(c)) {
				this.cbs.ondirmodifier(this.sectionStart, this.index);
				this.handleAttrNameEnd(c);
			} else if (c === 46) {
				this.cbs.ondirmodifier(this.sectionStart, this.index);
				this.sectionStart = this.index + 1;
			}
		}
		handleAttrNameEnd(c) {
			this.sectionStart = this.index;
			this.state = 17;
			this.cbs.onattribnameend(this.index);
			this.stateAfterAttrName(c);
		}
		stateAfterAttrName(c) {
			if (c === 61) this.state = 18;
			else if (c === 47 || c === 62) {
				this.cbs.onattribend(0, this.sectionStart);
				this.sectionStart = -1;
				this.state = 11;
				this.stateBeforeAttrName(c);
			} else if (!isWhitespace(c)) {
				this.cbs.onattribend(0, this.sectionStart);
				this.handleAttrStart(c);
			}
		}
		stateBeforeAttrValue(c) {
			if (c === 34) {
				this.state = 19;
				this.sectionStart = this.index + 1;
			} else if (c === 39) {
				this.state = 20;
				this.sectionStart = this.index + 1;
			} else if (!isWhitespace(c)) {
				this.sectionStart = this.index;
				this.state = 21;
				this.stateInAttrValueNoQuotes(c);
			}
		}
		handleInAttrValue(c, quote) {
			if (c === quote || false) {
				this.cbs.onattribdata(this.sectionStart, this.index);
				this.sectionStart = -1;
				this.cbs.onattribend(quote === 34 ? 3 : 2, this.index + 1);
				this.state = 11;
			} else if (c === 38) this.startEntity();
		}
		stateInAttrValueDoubleQuotes(c) {
			this.handleInAttrValue(c, 34);
		}
		stateInAttrValueSingleQuotes(c) {
			this.handleInAttrValue(c, 39);
		}
		stateInAttrValueNoQuotes(c) {
			if (isWhitespace(c) || c === 62) {
				this.cbs.onattribdata(this.sectionStart, this.index);
				this.sectionStart = -1;
				this.cbs.onattribend(1, this.index);
				this.state = 11;
				this.stateBeforeAttrName(c);
			} else if (c === 34 || c === 39 || c === 60 || c === 61 || c === 96) this.cbs.onerr(18, this.index);
			else if (c === 38) this.startEntity();
		}
		stateBeforeDeclaration(c) {
			if (c === 91) {
				this.state = 26;
				this.sequenceIndex = 0;
			} else this.state = c === 45 ? 25 : 23;
		}
		stateInDeclaration(c) {
			if (c === 62 || this.fastForwardTo(62)) {
				this.state = 1;
				this.sectionStart = this.index + 1;
			}
		}
		stateInProcessingInstruction(c) {
			if (c === 62 || this.fastForwardTo(62)) {
				this.cbs.onprocessinginstruction(this.sectionStart, this.index);
				this.state = 1;
				this.sectionStart = this.index + 1;
			}
		}
		stateBeforeComment(c) {
			if (c === 45) {
				this.state = 28;
				this.currentSequence = Sequences.CommentEnd;
				this.sequenceIndex = 2;
				this.sectionStart = this.index + 1;
			} else this.state = 23;
		}
		stateInSpecialComment(c) {
			if (c === 62 || this.fastForwardTo(62)) {
				this.cbs.oncomment(this.sectionStart, this.index);
				this.state = 1;
				this.sectionStart = this.index + 1;
			}
		}
		stateBeforeSpecialS(c) {
			if (c === Sequences.ScriptEnd[3]) this.startSpecial(Sequences.ScriptEnd, 4);
			else if (c === Sequences.StyleEnd[3]) this.startSpecial(Sequences.StyleEnd, 4);
			else {
				this.state = 6;
				this.stateInTagName(c);
			}
		}
		stateBeforeSpecialT(c) {
			if (c === Sequences.TitleEnd[3]) this.startSpecial(Sequences.TitleEnd, 4);
			else if (c === Sequences.TextareaEnd[3]) this.startSpecial(Sequences.TextareaEnd, 4);
			else {
				this.state = 6;
				this.stateInTagName(c);
			}
		}
		startEntity() {
			{
				this.baseState = this.state;
				this.state = 33;
				this.entityStart = this.index;
				this.entityDecoder.startEntity(this.baseState === 1 || this.baseState === 32 ? decode_js.DecodingMode.Legacy : decode_js.DecodingMode.Attribute);
			}
		}
		stateInEntity() {
			{
				const length = this.entityDecoder.write(this.buffer, this.index);
				if (length >= 0) {
					this.state = this.baseState;
					if (length === 0) this.index = this.entityStart;
				} else this.index = this.buffer.length - 1;
			}
		}
		/**
		* Iterates through the buffer, calling the function corresponding to the current state.
		*
		* States that are more likely to be hit are higher up, as a performance improvement.
		*/
		parse(input) {
			this.buffer = input;
			while (this.index < this.buffer.length) {
				const c = this.buffer.charCodeAt(this.index);
				if (c === 10 && this.state !== 33) this.newlines.push(this.index);
				switch (this.state) {
					case 1: {
						this.stateText(c);
						break;
					}
					case 2: {
						this.stateInterpolationOpen(c);
						break;
					}
					case 3: {
						this.stateInterpolation(c);
						break;
					}
					case 4: {
						this.stateInterpolationClose(c);
						break;
					}
					case 31: {
						this.stateSpecialStartSequence(c);
						break;
					}
					case 32: {
						this.stateInRCDATA(c);
						break;
					}
					case 26: {
						this.stateCDATASequence(c);
						break;
					}
					case 19: {
						this.stateInAttrValueDoubleQuotes(c);
						break;
					}
					case 12: {
						this.stateInAttrName(c);
						break;
					}
					case 13: {
						this.stateInDirName(c);
						break;
					}
					case 14: {
						this.stateInDirArg(c);
						break;
					}
					case 15: {
						this.stateInDynamicDirArg(c);
						break;
					}
					case 16: {
						this.stateInDirModifier(c);
						break;
					}
					case 28: {
						this.stateInCommentLike(c);
						break;
					}
					case 27: {
						this.stateInSpecialComment(c);
						break;
					}
					case 11: {
						this.stateBeforeAttrName(c);
						break;
					}
					case 6: {
						this.stateInTagName(c);
						break;
					}
					case 34: {
						this.stateInSFCRootTagName(c);
						break;
					}
					case 9: {
						this.stateInClosingTagName(c);
						break;
					}
					case 5: {
						this.stateBeforeTagName(c);
						break;
					}
					case 17: {
						this.stateAfterAttrName(c);
						break;
					}
					case 20: {
						this.stateInAttrValueSingleQuotes(c);
						break;
					}
					case 18: {
						this.stateBeforeAttrValue(c);
						break;
					}
					case 8: {
						this.stateBeforeClosingTagName(c);
						break;
					}
					case 10: {
						this.stateAfterClosingTagName(c);
						break;
					}
					case 29: {
						this.stateBeforeSpecialS(c);
						break;
					}
					case 30: {
						this.stateBeforeSpecialT(c);
						break;
					}
					case 21: {
						this.stateInAttrValueNoQuotes(c);
						break;
					}
					case 7: {
						this.stateInSelfClosingTag(c);
						break;
					}
					case 23: {
						this.stateInDeclaration(c);
						break;
					}
					case 22: {
						this.stateBeforeDeclaration(c);
						break;
					}
					case 25: {
						this.stateBeforeComment(c);
						break;
					}
					case 24: {
						this.stateInProcessingInstruction(c);
						break;
					}
					case 33: {
						this.stateInEntity();
						break;
					}
				}
				this.index++;
			}
			this.cleanup();
			this.finish();
		}
		/**
		* Remove data that has already been consumed from the buffer.
		*/
		cleanup() {
			if (this.sectionStart !== this.index) {
				if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
					this.cbs.ontext(this.sectionStart, this.index);
					this.sectionStart = this.index;
				} else if (this.state === 19 || this.state === 20 || this.state === 21) {
					this.cbs.onattribdata(this.sectionStart, this.index);
					this.sectionStart = this.index;
				}
			}
		}
		finish() {
			if (this.state === 33) {
				this.entityDecoder.end();
				this.state = this.baseState;
			}
			this.handleTrailingData();
			this.cbs.onend();
		}
		/** Handle any trailing data. */
		handleTrailingData() {
			const endIndex = this.buffer.length;
			if (this.sectionStart >= endIndex) return;
			if (this.state === 28) if (this.currentSequence === Sequences.CdataEnd) this.cbs.oncdata(this.sectionStart, endIndex);
			else this.cbs.oncomment(this.sectionStart, endIndex);
			else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9);
			else this.cbs.ontext(this.sectionStart, endIndex);
		}
		emitCodePoint(cp, consumed) {
			if (this.baseState !== 1 && this.baseState !== 32) {
				if (this.sectionStart < this.entityStart) this.cbs.onattribdata(this.sectionStart, this.entityStart);
				this.sectionStart = this.entityStart + consumed;
				this.index = this.sectionStart - 1;
				this.cbs.onattribentity(decode_js.fromCodePoint(cp), this.entityStart, this.sectionStart);
			} else {
				if (this.sectionStart < this.entityStart) this.cbs.ontext(this.sectionStart, this.entityStart);
				this.sectionStart = this.entityStart + consumed;
				this.index = this.sectionStart - 1;
				this.cbs.ontextentity(decode_js.fromCodePoint(cp), this.entityStart, this.sectionStart);
			}
		}
	};
	const CompilerDeprecationTypes = {
		"COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
		"COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
		"COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
		"COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
		"COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
		"COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
		"COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
		"COMPILER_FILTERS": "COMPILER_FILTERS"
	};
	const deprecationData = {
		["COMPILER_IS_ON_ELEMENT"]: {
			message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
			link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
		},
		["COMPILER_V_BIND_SYNC"]: {
			message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
			link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
		},
		["COMPILER_V_BIND_OBJECT_ORDER"]: {
			message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
			link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
		},
		["COMPILER_V_ON_NATIVE"]: {
			message: `.native modifier for v-on has been removed as is no longer necessary.`,
			link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
		},
		["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
			message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
			link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
		},
		["COMPILER_NATIVE_TEMPLATE"]: { message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.` },
		["COMPILER_INLINE_TEMPLATE"]: {
			message: `"inline-template" has been removed in Vue 3.`,
			link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
		},
		["COMPILER_FILTERS"]: {
			message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
			link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
		}
	};
	function getCompatValue(key, { compatConfig }) {
		const value = compatConfig && compatConfig[key];
		if (key === "MODE") return value || 3;
		else return value;
	}
	function isCompatEnabled(key, context) {
		const mode = getCompatValue("MODE", context);
		const value = getCompatValue(key, context);
		return mode === 3 ? value === true : value !== false;
	}
	function checkCompatEnabled(key, context, loc, ...args) {
		const enabled = isCompatEnabled(key, context);
		return enabled;
	}
	function warnDeprecation(key, context, loc, ...args) {
		const val = getCompatValue(key, context);
		if (val === "suppress-warning") return;
		const { message, link: link$1 } = deprecationData[key];
		const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link$1 ? `
  Details: ${link$1}` : ``}`;
		const err = new SyntaxError(msg);
		err.code = key;
		if (loc) err.loc = loc;
		context.onWarn(err);
	}
	function defaultOnError(error) {
		throw error;
	}
	function defaultOnWarn(msg) {}
	function createCompilerError(code$1, loc, messages, additionalMessage) {
		const msg = (messages || errorMessages)[code$1] + (additionalMessage || ``);
		const error = new SyntaxError(String(msg));
		error.code = code$1;
		error.loc = loc;
		return error;
	}
	const ErrorCodes = {
		"ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
		"0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
		"CDATA_IN_HTML_CONTENT": 1,
		"1": "CDATA_IN_HTML_CONTENT",
		"DUPLICATE_ATTRIBUTE": 2,
		"2": "DUPLICATE_ATTRIBUTE",
		"END_TAG_WITH_ATTRIBUTES": 3,
		"3": "END_TAG_WITH_ATTRIBUTES",
		"END_TAG_WITH_TRAILING_SOLIDUS": 4,
		"4": "END_TAG_WITH_TRAILING_SOLIDUS",
		"EOF_BEFORE_TAG_NAME": 5,
		"5": "EOF_BEFORE_TAG_NAME",
		"EOF_IN_CDATA": 6,
		"6": "EOF_IN_CDATA",
		"EOF_IN_COMMENT": 7,
		"7": "EOF_IN_COMMENT",
		"EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
		"8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
		"EOF_IN_TAG": 9,
		"9": "EOF_IN_TAG",
		"INCORRECTLY_CLOSED_COMMENT": 10,
		"10": "INCORRECTLY_CLOSED_COMMENT",
		"INCORRECTLY_OPENED_COMMENT": 11,
		"11": "INCORRECTLY_OPENED_COMMENT",
		"INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
		"12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
		"MISSING_ATTRIBUTE_VALUE": 13,
		"13": "MISSING_ATTRIBUTE_VALUE",
		"MISSING_END_TAG_NAME": 14,
		"14": "MISSING_END_TAG_NAME",
		"MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
		"15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
		"NESTED_COMMENT": 16,
		"16": "NESTED_COMMENT",
		"UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
		"17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
		"UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
		"18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
		"UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
		"19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
		"UNEXPECTED_NULL_CHARACTER": 20,
		"20": "UNEXPECTED_NULL_CHARACTER",
		"UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
		"21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
		"UNEXPECTED_SOLIDUS_IN_TAG": 22,
		"22": "UNEXPECTED_SOLIDUS_IN_TAG",
		"X_INVALID_END_TAG": 23,
		"23": "X_INVALID_END_TAG",
		"X_MISSING_END_TAG": 24,
		"24": "X_MISSING_END_TAG",
		"X_MISSING_INTERPOLATION_END": 25,
		"25": "X_MISSING_INTERPOLATION_END",
		"X_MISSING_DIRECTIVE_NAME": 26,
		"26": "X_MISSING_DIRECTIVE_NAME",
		"X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
		"27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
		"X_V_IF_NO_EXPRESSION": 28,
		"28": "X_V_IF_NO_EXPRESSION",
		"X_V_IF_SAME_KEY": 29,
		"29": "X_V_IF_SAME_KEY",
		"X_V_ELSE_NO_ADJACENT_IF": 30,
		"30": "X_V_ELSE_NO_ADJACENT_IF",
		"X_V_FOR_NO_EXPRESSION": 31,
		"31": "X_V_FOR_NO_EXPRESSION",
		"X_V_FOR_MALFORMED_EXPRESSION": 32,
		"32": "X_V_FOR_MALFORMED_EXPRESSION",
		"X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
		"33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
		"X_V_BIND_NO_EXPRESSION": 34,
		"34": "X_V_BIND_NO_EXPRESSION",
		"X_V_ON_NO_EXPRESSION": 35,
		"35": "X_V_ON_NO_EXPRESSION",
		"X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
		"36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
		"X_V_SLOT_MIXED_SLOT_USAGE": 37,
		"37": "X_V_SLOT_MIXED_SLOT_USAGE",
		"X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
		"38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
		"X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
		"39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
		"X_V_SLOT_MISPLACED": 40,
		"40": "X_V_SLOT_MISPLACED",
		"X_V_MODEL_NO_EXPRESSION": 41,
		"41": "X_V_MODEL_NO_EXPRESSION",
		"X_V_MODEL_MALFORMED_EXPRESSION": 42,
		"42": "X_V_MODEL_MALFORMED_EXPRESSION",
		"X_V_MODEL_ON_SCOPE_VARIABLE": 43,
		"43": "X_V_MODEL_ON_SCOPE_VARIABLE",
		"X_V_MODEL_ON_PROPS": 44,
		"44": "X_V_MODEL_ON_PROPS",
		"X_INVALID_EXPRESSION": 45,
		"45": "X_INVALID_EXPRESSION",
		"X_KEEP_ALIVE_INVALID_CHILDREN": 46,
		"46": "X_KEEP_ALIVE_INVALID_CHILDREN",
		"X_PREFIX_ID_NOT_SUPPORTED": 47,
		"47": "X_PREFIX_ID_NOT_SUPPORTED",
		"X_MODULE_MODE_NOT_SUPPORTED": 48,
		"48": "X_MODULE_MODE_NOT_SUPPORTED",
		"X_CACHE_HANDLER_NOT_SUPPORTED": 49,
		"49": "X_CACHE_HANDLER_NOT_SUPPORTED",
		"X_SCOPE_ID_NOT_SUPPORTED": 50,
		"50": "X_SCOPE_ID_NOT_SUPPORTED",
		"X_VNODE_HOOKS": 51,
		"51": "X_VNODE_HOOKS",
		"X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 52,
		"52": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
		"__EXTEND_POINT__": 53,
		"53": "__EXTEND_POINT__"
	};
	const errorMessages = {
		[0]: "Illegal comment.",
		[1]: "CDATA section is allowed only in XML context.",
		[2]: "Duplicate attribute.",
		[3]: "End tag cannot have attributes.",
		[4]: "Illegal '/' in tags.",
		[5]: "Unexpected EOF in tag.",
		[6]: "Unexpected EOF in CDATA section.",
		[7]: "Unexpected EOF in comment.",
		[8]: "Unexpected EOF in script.",
		[9]: "Unexpected EOF in tag.",
		[10]: "Incorrectly closed comment.",
		[11]: "Incorrectly opened comment.",
		[12]: "Illegal tag name. Use '&lt;' to print '<'.",
		[13]: "Attribute value was expected.",
		[14]: "End tag name was expected.",
		[15]: "Whitespace was expected.",
		[16]: "Unexpected '<!--' in comment.",
		[17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
		[18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
		[19]: "Attribute name cannot start with '='.",
		[21]: "'<?' is allowed only in XML context.",
		[20]: `Unexpected null character.`,
		[22]: "Illegal '/' in tags.",
		[23]: "Invalid end tag.",
		[24]: "Element is missing end tag.",
		[25]: "Interpolation end sign was not found.",
		[27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
		[26]: "Legal directive name was expected.",
		[28]: `v-if/v-else-if is missing expression.`,
		[29]: `v-if/else branches must use unique keys.`,
		[30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
		[31]: `v-for is missing expression.`,
		[32]: `v-for has invalid expression.`,
		[33]: `<template v-for> key should be placed on the <template> tag.`,
		[34]: `v-bind is missing expression.`,
		[52]: `v-bind with same-name shorthand only allows static argument.`,
		[35]: `v-on is missing expression.`,
		[36]: `Unexpected custom directive on <slot> outlet.`,
		[37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
		[38]: `Duplicate slot names found. `,
		[39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
		[40]: `v-slot can only be used on components or <template> tags.`,
		[41]: `v-model is missing expression.`,
		[42]: `v-model value must be a valid JavaScript member expression.`,
		[43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
		[44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
		[45]: `Error parsing JavaScript expression: `,
		[46]: `<KeepAlive> expects exactly one child component.`,
		[51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
		[47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
		[48]: `ES module mode is not supported in this build of compiler.`,
		[49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
		[50]: `"scopeId" option is only supported in module mode.`,
		[53]: ``
	};
	function walkIdentifiers$1(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
		const rootExp = root.type === "Program" ? root.body[0].type === "ExpressionStatement" && root.body[0].expression : root;
		estreeWalker.walk(root, {
			enter(node, parent) {
				parent && parentStack.push(parent);
				if (parent && parent.type.startsWith("TS") && !TS_NODE_TYPES.includes(parent.type)) return this.skip();
				if (node.type === "Identifier") {
					const isLocal = !!knownIds[node.name];
					const isRefed = isReferencedIdentifier(node, parent, parentStack);
					if (includeAll || isRefed && !isLocal) onIdentifier(node, parent, parentStack, isRefed, isLocal);
				} else if (node.type === "ObjectProperty" && (parent == null ? void 0 : parent.type) === "ObjectPattern") node.inPattern = true;
				else if (isFunctionType(node)) if (node.scopeIds) node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
				else walkFunctionParams(node, (id) => markScopeIdentifier(node, id, knownIds));
				else if (node.type === "BlockStatement") if (node.scopeIds) node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
				else walkBlockDeclarations(node, (id) => markScopeIdentifier(node, id, knownIds));
				else if (node.type === "SwitchStatement") if (node.scopeIds) node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
				else walkSwitchStatement(node, false, (id) => markScopeIdentifier(node, id, knownIds));
				else if (node.type === "CatchClause" && node.param) if (node.scopeIds) node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
				else for (const id of extractIdentifiers(node.param)) markScopeIdentifier(node, id, knownIds);
				else if (isForStatement(node)) if (node.scopeIds) node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
				else walkForStatement(node, false, (id) => markScopeIdentifier(node, id, knownIds));
			},
			leave(node, parent) {
				parent && parentStack.pop();
				if (node !== rootExp && node.scopeIds) for (const id of node.scopeIds) {
					knownIds[id]--;
					if (knownIds[id] === 0) delete knownIds[id];
				}
			}
		});
	}
	function isReferencedIdentifier(id, parent, parentStack) {
		if (!parent) return true;
		if (id.name === "arguments") return false;
		if (isReferenced(id, parent, parentStack[parentStack.length - 2])) return true;
		switch (parent.type) {
			case "AssignmentExpression":
			case "AssignmentPattern": return true;
			case "ObjectProperty": return parent.key !== id && isInDestructureAssignment(parent, parentStack);
			case "ArrayPattern": return isInDestructureAssignment(parent, parentStack);
		}
		return false;
	}
	function isInDestructureAssignment(parent, parentStack) {
		if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
			let i = parentStack.length;
			while (i--) {
				const p = parentStack[i];
				if (p.type === "AssignmentExpression") return true;
				else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) break;
			}
		}
		return false;
	}
	function isInNewExpression(parentStack) {
		let i = parentStack.length;
		while (i--) {
			const p = parentStack[i];
			if (p.type === "NewExpression") return true;
			else if (p.type !== "MemberExpression") break;
		}
		return false;
	}
	function walkFunctionParams(node, onIdent) {
		for (const p of node.params) for (const id of extractIdentifiers(p)) onIdent(id);
	}
	function walkBlockDeclarations(block, onIdent) {
		const body = block.type === "SwitchCase" ? block.consequent : block.body;
		for (const stmt of body) if (stmt.type === "VariableDeclaration") {
			if (stmt.declare) continue;
			for (const decl of stmt.declarations) for (const id of extractIdentifiers(decl.id)) onIdent(id);
		} else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
			if (stmt.declare || !stmt.id) continue;
			onIdent(stmt.id);
		} else if (isForStatement(stmt)) walkForStatement(stmt, true, onIdent);
		else if (stmt.type === "SwitchStatement") walkSwitchStatement(stmt, true, onIdent);
	}
	function isForStatement(stmt) {
		return stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement";
	}
	function walkForStatement(stmt, isVar, onIdent) {
		const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
		if (variable && variable.type === "VariableDeclaration" && (variable.kind === "var" ? isVar : !isVar)) for (const decl of variable.declarations) for (const id of extractIdentifiers(decl.id)) onIdent(id);
	}
	function walkSwitchStatement(stmt, isVar, onIdent) {
		for (const cs of stmt.cases) {
			for (const stmt2 of cs.consequent) if (stmt2.type === "VariableDeclaration" && (stmt2.kind === "var" ? isVar : !isVar)) for (const decl of stmt2.declarations) for (const id of extractIdentifiers(decl.id)) onIdent(id);
			walkBlockDeclarations(cs, onIdent);
		}
	}
	function extractIdentifiers(param, nodes = []) {
		switch (param.type) {
			case "Identifier":
				nodes.push(param);
				break;
			case "MemberExpression":
				let object = param;
				while (object.type === "MemberExpression") object = object.object;
				nodes.push(object);
				break;
			case "ObjectPattern":
				for (const prop of param.properties) if (prop.type === "RestElement") extractIdentifiers(prop.argument, nodes);
				else extractIdentifiers(prop.value, nodes);
				break;
			case "ArrayPattern":
				param.elements.forEach((element) => {
					if (element) extractIdentifiers(element, nodes);
				});
				break;
			case "RestElement":
				extractIdentifiers(param.argument, nodes);
				break;
			case "AssignmentPattern":
				extractIdentifiers(param.left, nodes);
				break;
		}
		return nodes;
	}
	function markKnownIds(name, knownIds) {
		if (name in knownIds) knownIds[name]++;
		else knownIds[name] = 1;
	}
	function markScopeIdentifier(node, child, knownIds) {
		const { name } = child;
		if (node.scopeIds && node.scopeIds.has(name)) return;
		markKnownIds(name, knownIds);
		(node.scopeIds || (node.scopeIds = /* @__PURE__ */ new Set())).add(name);
	}
	const isFunctionType = (node) => {
		return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
	};
	const isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
	const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
	function isReferenced(node, parent, grandparent) {
		switch (parent.type) {
			case "MemberExpression":
			case "OptionalMemberExpression":
				if (parent.property === node) return !!parent.computed;
				return parent.object === node;
			case "JSXMemberExpression": return parent.object === node;
			case "VariableDeclarator": return parent.init === node;
			case "ArrowFunctionExpression": return parent.body === node;
			case "PrivateName": return false;
			case "ClassMethod":
			case "ClassPrivateMethod":
			case "ObjectMethod":
				if (parent.key === node) return !!parent.computed;
				return false;
			case "ObjectProperty":
				if (parent.key === node) return !!parent.computed;
				return !grandparent || grandparent.type !== "ObjectPattern";
			case "ClassProperty":
				if (parent.key === node) return !!parent.computed;
				return true;
			case "ClassPrivateProperty": return parent.key !== node;
			case "ClassDeclaration":
			case "ClassExpression": return parent.superClass === node;
			case "AssignmentExpression": return parent.right === node;
			case "AssignmentPattern": return parent.right === node;
			case "LabeledStatement": return false;
			case "CatchClause": return false;
			case "RestElement": return false;
			case "BreakStatement":
			case "ContinueStatement": return false;
			case "FunctionDeclaration":
			case "FunctionExpression": return false;
			case "ExportNamespaceSpecifier":
			case "ExportDefaultSpecifier": return false;
			case "ExportSpecifier":
				if (grandparent == null ? void 0 : grandparent.source) return false;
				return parent.local === node;
			case "ImportDefaultSpecifier":
			case "ImportNamespaceSpecifier":
			case "ImportSpecifier": return false;
			case "ImportAttribute": return false;
			case "JSXAttribute": return false;
			case "ObjectPattern":
			case "ArrayPattern": return false;
			case "MetaProperty": return false;
			case "ObjectTypeProperty": return parent.key !== node;
			case "TSEnumMember": return parent.id !== node;
			case "TSPropertySignature":
				if (parent.key === node) return !!parent.computed;
				return true;
		}
		return true;
	}
	const TS_NODE_TYPES = [
		"TSAsExpression",
		"TSTypeAssertion",
		"TSNonNullExpression",
		"TSInstantiationExpression",
		"TSSatisfiesExpression"
	];
	function unwrapTSNode(node) {
		if (TS_NODE_TYPES.includes(node.type)) return unwrapTSNode(node.expression);
		else return node;
	}
	const isStaticExp = (p) => p.type === 4 && p.isStatic;
	function isCoreComponent(tag) {
		switch (tag) {
			case "Teleport":
			case "teleport": return TELEPORT;
			case "Suspense":
			case "suspense": return SUSPENSE;
			case "KeepAlive":
			case "keep-alive": return KEEP_ALIVE;
			case "BaseTransition":
			case "base-transition": return BASE_TRANSITION;
		}
	}
	const nonIdentifierRE = /^$|^\d|[^\$\w\xA0-\uFFFF]/;
	const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
	const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
	const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
	const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
	const getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
	const isMemberExpressionBrowser = (exp) => {
		const path$4 = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
		let state = 0;
		let stateStack = [];
		let currentOpenBracketCount = 0;
		let currentOpenParensCount = 0;
		let currentStringType = null;
		for (let i = 0; i < path$4.length; i++) {
			const char = path$4.charAt(i);
			switch (state) {
				case 0:
					if (char === "[") {
						stateStack.push(state);
						state = 1;
						currentOpenBracketCount++;
					} else if (char === "(") {
						stateStack.push(state);
						state = 2;
						currentOpenParensCount++;
					} else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) return false;
					break;
				case 1:
					if (char === `'` || char === `"` || char === "`") {
						stateStack.push(state);
						state = 3;
						currentStringType = char;
					} else if (char === `[`) currentOpenBracketCount++;
					else if (char === `]`) {
						if (!--currentOpenBracketCount) state = stateStack.pop();
					}
					break;
				case 2:
					if (char === `'` || char === `"` || char === "`") {
						stateStack.push(state);
						state = 3;
						currentStringType = char;
					} else if (char === `(`) currentOpenParensCount++;
					else if (char === `)`) {
						if (i === path$4.length - 1) return false;
						if (!--currentOpenParensCount) state = stateStack.pop();
					}
					break;
				case 3:
					if (char === currentStringType) {
						state = stateStack.pop();
						currentStringType = null;
					}
					break;
			}
		}
		return !currentOpenBracketCount && !currentOpenParensCount;
	};
	const isMemberExpressionNode = (exp, context) => {
		try {
			let ret = exp.ast || parser.parseExpression(getExpSource(exp), { plugins: context.expressionPlugins ? [...context.expressionPlugins, "typescript"] : ["typescript"] });
			ret = unwrapTSNode(ret);
			return ret.type === "MemberExpression" || ret.type === "OptionalMemberExpression" || ret.type === "Identifier" && ret.name !== "undefined";
		} catch (e) {
			return false;
		}
	};
	const isMemberExpression = isMemberExpressionNode;
	const fnExpRE = /^\s*(?:async\s*)?(?:\([^)]*?\)|[\w$_]+)\s*(?::[^=]+)?=>|^\s*(?:async\s+)?function(?:\s+[\w$]+)?\s*\(/;
	const isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
	const isFnExpressionNode = (exp, context) => {
		try {
			let ret = exp.ast || parser.parseExpression(getExpSource(exp), { plugins: context.expressionPlugins ? [...context.expressionPlugins, "typescript"] : ["typescript"] });
			if (ret.type === "Program") {
				ret = ret.body[0];
				if (ret.type === "ExpressionStatement") ret = ret.expression;
			}
			ret = unwrapTSNode(ret);
			return ret.type === "FunctionExpression" || ret.type === "ArrowFunctionExpression";
		} catch (e) {
			return false;
		}
	};
	const isFnExpression = isFnExpressionNode;
	function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
		return advancePositionWithMutation({
			offset: pos.offset,
			line: pos.line,
			column: pos.column
		}, source, numberOfCharacters);
	}
	function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
		let linesCount = 0;
		let lastNewLinePos = -1;
		for (let i = 0; i < numberOfCharacters; i++) if (source.charCodeAt(i) === 10) {
			linesCount++;
			lastNewLinePos = i;
		}
		pos.offset += numberOfCharacters;
		pos.line += linesCount;
		pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
		return pos;
	}
	function assert(condition, msg) {
		if (!condition) throw new Error(msg || `unexpected compiler condition`);
	}
	function findDir(node, name, allowEmpty = false) {
		for (let i = 0; i < node.props.length; i++) {
			const p = node.props[i];
			if (p.type === 7 && (allowEmpty || p.exp) && (shared$1.isString(name) ? p.name === name : name.test(p.name))) return p;
		}
	}
	function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
		for (let i = 0; i < node.props.length; i++) {
			const p = node.props[i];
			if (p.type === 6) {
				if (dynamicOnly) continue;
				if (p.name === name && (p.value || allowEmpty)) return p;
			} else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) return p;
		}
	}
	function isStaticArgOf(arg, name) {
		return !!(arg && isStaticExp(arg) && arg.content === name);
	}
	function hasDynamicKeyVBind(node) {
		return node.props.some((p) => p.type === 7 && p.name === "bind" && (!p.arg || p.arg.type !== 4 || !p.arg.isStatic));
	}
	function isText$1(node) {
		return node.type === 5 || node.type === 2;
	}
	function isVPre(p) {
		return p.type === 7 && p.name === "pre";
	}
	function isVSlot(p) {
		return p.type === 7 && p.name === "slot";
	}
	function isTemplateNode(node) {
		return node.type === 1 && node.tagType === 3;
	}
	function isSlotOutlet(node) {
		return node.type === 1 && node.tagType === 2;
	}
	const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
	function getUnnormalizedProps(props, callPath = []) {
		if (props && !shared$1.isString(props) && props.type === 14) {
			const callee = props.callee;
			if (!shared$1.isString(callee) && propsHelperSet.has(callee)) return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
		}
		return [props, callPath];
	}
	function injectProp(node, prop, context) {
		let propsWithInjection;
		let props = node.type === 13 ? node.props : node.arguments[2];
		let callPath = [];
		let parentCall;
		if (props && !shared$1.isString(props) && props.type === 14) {
			const ret = getUnnormalizedProps(props);
			props = ret[0];
			callPath = ret[1];
			parentCall = callPath[callPath.length - 1];
		}
		if (props == null || shared$1.isString(props)) propsWithInjection = createObjectExpression([prop]);
		else if (props.type === 14) {
			const first = props.arguments[0];
			if (!shared$1.isString(first) && first.type === 15) {
				if (!hasProp(prop, first)) first.properties.unshift(prop);
			} else if (props.callee === TO_HANDLERS) propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);
			else props.arguments.unshift(createObjectExpression([prop]));
			!propsWithInjection && (propsWithInjection = props);
		} else if (props.type === 15) {
			if (!hasProp(prop, props)) props.properties.unshift(prop);
			propsWithInjection = props;
		} else {
			propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);
			if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) parentCall = callPath[callPath.length - 2];
		}
		if (node.type === 13) if (parentCall) parentCall.arguments[0] = propsWithInjection;
		else node.props = propsWithInjection;
		else if (parentCall) parentCall.arguments[0] = propsWithInjection;
		else node.arguments[2] = propsWithInjection;
	}
	function hasProp(prop, props) {
		let result = false;
		if (prop.key.type === 4) {
			const propKeyName = prop.key.content;
			result = props.properties.some((p) => p.key.type === 4 && p.key.content === propKeyName);
		}
		return result;
	}
	function toValidAssetId(name, type) {
		return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
			return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
		})}`;
	}
	function hasScopeRef(node, ids) {
		if (!node || Object.keys(ids).length === 0) return false;
		switch (node.type) {
			case 1:
				for (let i = 0; i < node.props.length; i++) {
					const p = node.props[i];
					if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) return true;
				}
				return node.children.some((c) => hasScopeRef(c, ids));
			case 11:
				if (hasScopeRef(node.source, ids)) return true;
				return node.children.some((c) => hasScopeRef(c, ids));
			case 9: return node.branches.some((b) => hasScopeRef(b, ids));
			case 10:
				if (hasScopeRef(node.condition, ids)) return true;
				return node.children.some((c) => hasScopeRef(c, ids));
			case 4: return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
			case 8: return node.children.some((c) => shared$1.isObject(c) && hasScopeRef(c, ids));
			case 5:
			case 12: return hasScopeRef(node.content, ids);
			case 2:
			case 3:
			case 20: return false;
			default: return false;
		}
	}
	function getMemoedVNodeCall(node) {
		if (node.type === 14 && node.callee === WITH_MEMO) return node.arguments[1].returns;
		else return node;
	}
	const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
	const defaultParserOptions = {
		parseMode: "base",
		ns: 0,
		delimiters: [`{{`, `}}`],
		getNamespace: () => 0,
		isVoidTag: shared$1.NO,
		isPreTag: shared$1.NO,
		isIgnoreNewlineTag: shared$1.NO,
		isCustomElement: shared$1.NO,
		onError: defaultOnError,
		onWarn: defaultOnWarn,
		comments: false,
		prefixIdentifiers: false
	};
	let currentOptions = defaultParserOptions;
	let currentRoot = null;
	let currentInput = "";
	let currentOpenTag = null;
	let currentProp = null;
	let currentAttrValue = "";
	let currentAttrStartIndex = -1;
	let currentAttrEndIndex = -1;
	let inPre = 0;
	let inVPre = false;
	let currentVPreBoundary = null;
	const stack = [];
	const tokenizer = new Tokenizer(stack, {
		onerr: emitError,
		ontext(start, end) {
			onText(getSlice(start, end), start, end);
		},
		ontextentity(char, start, end) {
			onText(char, start, end);
		},
		oninterpolation(start, end) {
			if (inVPre) return onText(getSlice(start, end), start, end);
			let innerStart = start + tokenizer.delimiterOpen.length;
			let innerEnd = end - tokenizer.delimiterClose.length;
			while (isWhitespace(currentInput.charCodeAt(innerStart))) innerStart++;
			while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) innerEnd--;
			let exp = getSlice(innerStart, innerEnd);
			if (exp.includes("&")) exp = decode_js.decodeHTML(exp);
			addNode({
				type: 5,
				content: createExp(exp, false, getLoc(innerStart, innerEnd)),
				loc: getLoc(start, end)
			});
		},
		onopentagname(start, end) {
			const name = getSlice(start, end);
			currentOpenTag = {
				type: 1,
				tag: name,
				ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
				tagType: 0,
				props: [],
				children: [],
				loc: getLoc(start - 1, end),
				codegenNode: void 0
			};
		},
		onopentagend(end) {
			endOpenTag(end);
		},
		onclosetag(start, end) {
			const name = getSlice(start, end);
			if (!currentOptions.isVoidTag(name)) {
				let found = false;
				for (let i = 0; i < stack.length; i++) {
					const e = stack[i];
					if (e.tag.toLowerCase() === name.toLowerCase()) {
						found = true;
						if (i > 0) emitError(24, stack[0].loc.start.offset);
						for (let j = 0; j <= i; j++) {
							const el = stack.shift();
							onCloseTag(el, end, j < i);
						}
						break;
					}
				}
				if (!found) emitError(23, backTrack(start, 60));
			}
		},
		onselfclosingtag(end) {
			const name = currentOpenTag.tag;
			currentOpenTag.isSelfClosing = true;
			endOpenTag(end);
			if (stack[0] && stack[0].tag === name) onCloseTag(stack.shift(), end);
		},
		onattribname(start, end) {
			currentProp = {
				type: 6,
				name: getSlice(start, end),
				nameLoc: getLoc(start, end),
				value: void 0,
				loc: getLoc(start)
			};
		},
		ondirname(start, end) {
			const raw$1 = getSlice(start, end);
			const name = raw$1 === "." || raw$1 === ":" ? "bind" : raw$1 === "@" ? "on" : raw$1 === "#" ? "slot" : raw$1.slice(2);
			if (!inVPre && name === "") emitError(26, start);
			if (inVPre || name === "") currentProp = {
				type: 6,
				name: raw$1,
				nameLoc: getLoc(start, end),
				value: void 0,
				loc: getLoc(start)
			};
			else {
				currentProp = {
					type: 7,
					name,
					rawName: raw$1,
					exp: void 0,
					arg: void 0,
					modifiers: raw$1 === "." ? [createSimpleExpression("prop")] : [],
					loc: getLoc(start)
				};
				if (name === "pre") {
					inVPre = tokenizer.inVPre = true;
					currentVPreBoundary = currentOpenTag;
					const props = currentOpenTag.props;
					for (let i = 0; i < props.length; i++) if (props[i].type === 7) props[i] = dirToAttr(props[i]);
				}
			}
		},
		ondirarg(start, end) {
			if (start === end) return;
			const arg = getSlice(start, end);
			if (inVPre && !isVPre(currentProp)) {
				currentProp.name += arg;
				setLocEnd(currentProp.nameLoc, end);
			} else {
				const isStatic = arg[0] !== `[`;
				currentProp.arg = createExp(isStatic ? arg : arg.slice(1, -1), isStatic, getLoc(start, end), isStatic ? 3 : 0);
			}
		},
		ondirmodifier(start, end) {
			const mod = getSlice(start, end);
			if (inVPre && !isVPre(currentProp)) {
				currentProp.name += "." + mod;
				setLocEnd(currentProp.nameLoc, end);
			} else if (currentProp.name === "slot") {
				const arg = currentProp.arg;
				if (arg) {
					arg.content += "." + mod;
					setLocEnd(arg.loc, end);
				}
			} else {
				const exp = createSimpleExpression(mod, true, getLoc(start, end));
				currentProp.modifiers.push(exp);
			}
		},
		onattribdata(start, end) {
			currentAttrValue += getSlice(start, end);
			if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
			currentAttrEndIndex = end;
		},
		onattribentity(char, start, end) {
			currentAttrValue += char;
			if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
			currentAttrEndIndex = end;
		},
		onattribnameend(end) {
			const start = currentProp.loc.start.offset;
			const name = getSlice(start, end);
			if (currentProp.type === 7) currentProp.rawName = name;
			if (currentOpenTag.props.some((p) => (p.type === 7 ? p.rawName : p.name) === name)) emitError(2, start);
		},
		onattribend(quote, end) {
			if (currentOpenTag && currentProp) {
				setLocEnd(currentProp.loc, end);
				if (quote !== 0) if (currentProp.type === 6) {
					if (currentProp.name === "class") currentAttrValue = condense(currentAttrValue).trim();
					if (quote === 1 && !currentAttrValue) emitError(13, end);
					currentProp.value = {
						type: 2,
						content: currentAttrValue,
						loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
					};
					if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
				} else {
					let expParseMode = 0;
					if (currentProp.name === "for") expParseMode = 3;
					else if (currentProp.name === "slot") expParseMode = 1;
					else if (currentProp.name === "on" && currentAttrValue.includes(";")) expParseMode = 2;
					currentProp.exp = createExp(currentAttrValue, false, getLoc(currentAttrStartIndex, currentAttrEndIndex), 0, expParseMode);
					if (currentProp.name === "for") currentProp.forParseResult = parseForExpression(currentProp.exp);
					let syncIndex = -1;
					if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex((mod) => mod.content === "sync")) > -1 && checkCompatEnabled("COMPILER_V_BIND_SYNC", currentOptions, currentProp.loc, currentProp.arg.loc.source)) {
						currentProp.name = "model";
						currentProp.modifiers.splice(syncIndex, 1);
					}
				}
				if (currentProp.type !== 7 || currentProp.name !== "pre") currentOpenTag.props.push(currentProp);
			}
			currentAttrValue = "";
			currentAttrStartIndex = currentAttrEndIndex = -1;
		},
		oncomment(start, end) {
			if (currentOptions.comments) addNode({
				type: 3,
				content: getSlice(start, end),
				loc: getLoc(start - 4, end + 3)
			});
		},
		onend() {
			const end = currentInput.length;
			if (tokenizer.state !== 1) switch (tokenizer.state) {
				case 5:
				case 8:
					emitError(5, end);
					break;
				case 3:
				case 4:
					emitError(25, tokenizer.sectionStart);
					break;
				case 28:
					if (tokenizer.currentSequence === Sequences.CdataEnd) emitError(6, end);
					else emitError(7, end);
					break;
				case 6:
				case 7:
				case 9:
				case 11:
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
				case 19:
				case 20:
				case 21:
					emitError(9, end);
					break;
			}
			for (let index = 0; index < stack.length; index++) {
				onCloseTag(stack[index], end - 1);
				emitError(24, stack[index].loc.start.offset);
			}
		},
		oncdata(start, end) {
			if (stack[0].ns !== 0) onText(getSlice(start, end), start, end);
			else emitError(1, start - 9);
		},
		onprocessinginstruction(start) {
			if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) emitError(21, start - 1);
		}
	});
	const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
	const stripParensRE = /^\(|\)$/g;
	function parseForExpression(input) {
		const loc = input.loc;
		const exp = input.content;
		const inMatch = exp.match(forAliasRE);
		if (!inMatch) return;
		const [, LHS, RHS] = inMatch;
		const createAliasExpression = (content, offset, asParam = false) => {
			const start = loc.start.offset + offset;
			const end = start + content.length;
			return createExp(content, false, getLoc(start, end), 0, asParam ? 1 : 0);
		};
		const result = {
			source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
			value: void 0,
			key: void 0,
			index: void 0,
			finalized: false
		};
		let valueContent = LHS.trim().replace(stripParensRE, "").trim();
		const trimmedOffset = LHS.indexOf(valueContent);
		const iteratorMatch = valueContent.match(forIteratorRE);
		if (iteratorMatch) {
			valueContent = valueContent.replace(forIteratorRE, "").trim();
			const keyContent = iteratorMatch[1].trim();
			let keyOffset;
			if (keyContent) {
				keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
				result.key = createAliasExpression(keyContent, keyOffset, true);
			}
			if (iteratorMatch[2]) {
				const indexContent = iteratorMatch[2].trim();
				if (indexContent) result.index = createAliasExpression(indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length), true);
			}
		}
		if (valueContent) result.value = createAliasExpression(valueContent, trimmedOffset, true);
		return result;
	}
	function getSlice(start, end) {
		return currentInput.slice(start, end);
	}
	function endOpenTag(end) {
		if (tokenizer.inSFCRoot) currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
		addNode(currentOpenTag);
		const { tag, ns } = currentOpenTag;
		if (ns === 0 && currentOptions.isPreTag(tag)) inPre++;
		if (currentOptions.isVoidTag(tag)) onCloseTag(currentOpenTag, end);
		else {
			stack.unshift(currentOpenTag);
			if (ns === 1 || ns === 2) tokenizer.inXML = true;
		}
		currentOpenTag = null;
	}
	function onText(content, start, end) {
		const parent = stack[0] || currentRoot;
		const lastNode = parent.children[parent.children.length - 1];
		if (lastNode && lastNode.type === 2) {
			lastNode.content += content;
			setLocEnd(lastNode.loc, end);
		} else parent.children.push({
			type: 2,
			content,
			loc: getLoc(start, end)
		});
	}
	function onCloseTag(el, end, isImplied = false) {
		if (isImplied) setLocEnd(el.loc, backTrack(end, 60));
		else setLocEnd(el.loc, lookAhead(end, 62) + 1);
		if (tokenizer.inSFCRoot) {
			if (el.children.length) el.innerLoc.end = shared$1.extend({}, el.children[el.children.length - 1].loc.end);
			else el.innerLoc.end = shared$1.extend({}, el.innerLoc.start);
			el.innerLoc.source = getSlice(el.innerLoc.start.offset, el.innerLoc.end.offset);
		}
		const { tag, ns, children } = el;
		if (!inVPre) {
			if (tag === "slot") el.tagType = 2;
			else if (isFragmentTemplate(el)) el.tagType = 3;
			else if (isComponent(el)) el.tagType = 1;
		}
		if (!tokenizer.inRCDATA) el.children = condenseWhitespace(children);
		if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
			const first = children[0];
			if (first && first.type === 2) first.content = first.content.replace(/^\r?\n/, "");
		}
		if (ns === 0 && currentOptions.isPreTag(tag)) inPre--;
		if (currentVPreBoundary === el) {
			inVPre = tokenizer.inVPre = false;
			currentVPreBoundary = null;
		}
		if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) tokenizer.inXML = false;
		{
			const props = el.props;
			if (!tokenizer.inSFCRoot && isCompatEnabled("COMPILER_NATIVE_TEMPLATE", currentOptions) && el.tag === "template" && !isFragmentTemplate(el)) {
				const parent = stack[0] || currentRoot;
				const index = parent.children.indexOf(el);
				parent.children.splice(index, 1, ...el.children);
			}
			const inlineTemplateProp = props.find((p) => p.type === 6 && p.name === "inline-template");
			if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", currentOptions, inlineTemplateProp.loc) && el.children.length) inlineTemplateProp.value = {
				type: 2,
				content: getSlice(el.children[0].loc.start.offset, el.children[el.children.length - 1].loc.end.offset),
				loc: inlineTemplateProp.loc
			};
		}
	}
	function lookAhead(index, c) {
		let i = index;
		while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;
		return i;
	}
	function backTrack(index, c) {
		let i = index;
		while (currentInput.charCodeAt(i) !== c && i >= 0) i--;
		return i;
	}
	const specialTemplateDir = /* @__PURE__ */ new Set([
		"if",
		"else",
		"else-if",
		"for",
		"slot"
	]);
	function isFragmentTemplate({ tag, props }) {
		if (tag === "template") {
			for (let i = 0; i < props.length; i++) if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) return true;
		}
		return false;
	}
	function isComponent({ tag, props }) {
		if (currentOptions.isCustomElement(tag)) return false;
		if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) return true;
		for (let i = 0; i < props.length; i++) {
			const p = props[i];
			if (p.type === 6) {
				if (p.name === "is" && p.value) {
					if (p.value.content.startsWith("vue:")) return true;
					else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", currentOptions, p.loc)) return true;
				}
			} else if (p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", currentOptions, p.loc)) return true;
		}
		return false;
	}
	function isUpperCase(c) {
		return c > 64 && c < 91;
	}
	const windowsNewlineRE = /\r\n/g;
	function condenseWhitespace(nodes) {
		const shouldCondense = currentOptions.whitespace !== "preserve";
		let removedWhitespace = false;
		for (let i = 0; i < nodes.length; i++) {
			const node = nodes[i];
			if (node.type === 2) if (!inPre) {
				if (isAllWhitespace(node.content)) {
					const prev = nodes[i - 1] && nodes[i - 1].type;
					const next = nodes[i + 1] && nodes[i + 1].type;
					if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
						removedWhitespace = true;
						nodes[i] = null;
					} else node.content = " ";
				} else if (shouldCondense) node.content = condense(node.content);
			} else node.content = node.content.replace(windowsNewlineRE, "\n");
		}
		return removedWhitespace ? nodes.filter(Boolean) : nodes;
	}
	function isAllWhitespace(str) {
		for (let i = 0; i < str.length; i++) if (!isWhitespace(str.charCodeAt(i))) return false;
		return true;
	}
	function hasNewlineChar(str) {
		for (let i = 0; i < str.length; i++) {
			const c = str.charCodeAt(i);
			if (c === 10 || c === 13) return true;
		}
		return false;
	}
	function condense(str) {
		let ret = "";
		let prevCharIsWhitespace = false;
		for (let i = 0; i < str.length; i++) if (isWhitespace(str.charCodeAt(i))) {
			if (!prevCharIsWhitespace) {
				ret += " ";
				prevCharIsWhitespace = true;
			}
		} else {
			ret += str[i];
			prevCharIsWhitespace = false;
		}
		return ret;
	}
	function addNode(node) {
		(stack[0] || currentRoot).children.push(node);
	}
	function getLoc(start, end) {
		return {
			start: tokenizer.getPos(start),
			end: end == null ? end : tokenizer.getPos(end),
			source: end == null ? end : getSlice(start, end)
		};
	}
	function cloneLoc(loc) {
		return getLoc(loc.start.offset, loc.end.offset);
	}
	function setLocEnd(loc, end) {
		loc.end = tokenizer.getPos(end);
		loc.source = getSlice(loc.start.offset, end);
	}
	function dirToAttr(dir) {
		const attr = {
			type: 6,
			name: dir.rawName,
			nameLoc: getLoc(dir.loc.start.offset, dir.loc.start.offset + dir.rawName.length),
			value: void 0,
			loc: dir.loc
		};
		if (dir.exp) {
			const loc = dir.exp.loc;
			if (loc.end.offset < dir.loc.end.offset) {
				loc.start.offset--;
				loc.start.column--;
				loc.end.offset++;
				loc.end.column++;
			}
			attr.value = {
				type: 2,
				content: dir.exp.content,
				loc
			};
		}
		return attr;
	}
	function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0) {
		const exp = createSimpleExpression(content, isStatic, loc, constType);
		if (!isStatic && currentOptions.prefixIdentifiers && parseMode !== 3 && content.trim()) {
			if (isSimpleIdentifier(content)) {
				exp.ast = null;
				return exp;
			}
			try {
				const plugins = currentOptions.expressionPlugins;
				const options = { plugins: plugins ? [...plugins, "typescript"] : ["typescript"] };
				if (parseMode === 2) exp.ast = parser.parse(` ${content} `, options).program;
				else if (parseMode === 1) exp.ast = parser.parseExpression(`(${content})=>{}`, options);
				else exp.ast = parser.parseExpression(`(${content})`, options);
			} catch (e) {
				exp.ast = false;
				emitError(45, loc.start.offset, e.message);
			}
		}
		return exp;
	}
	function emitError(code$1, index, message) {
		currentOptions.onError(createCompilerError(code$1, getLoc(index, index), void 0, message));
	}
	function reset() {
		tokenizer.reset();
		currentOpenTag = null;
		currentProp = null;
		currentAttrValue = "";
		currentAttrStartIndex = -1;
		currentAttrEndIndex = -1;
		stack.length = 0;
	}
	function baseParse(input, options) {
		reset();
		currentInput = input;
		currentOptions = shared$1.extend({}, defaultParserOptions);
		if (options) {
			let key;
			for (key in options) if (options[key] != null) currentOptions[key] = options[key];
		}
		tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
		tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
		const delimiters = options && options.delimiters;
		if (delimiters) {
			tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
			tokenizer.delimiterClose = toCharCodes(delimiters[1]);
		}
		const root = currentRoot = createRoot([], input);
		tokenizer.parse(currentInput);
		root.loc = getLoc(0, input.length);
		root.children = condenseWhitespace(root.children);
		currentRoot = null;
		return root;
	}
	function cacheStatic(root, context) {
		walk(root, void 0, context, !!getSingleElementRoot(root));
	}
	function getSingleElementRoot(root) {
		const children = root.children.filter((x) => x.type !== 3);
		return children.length === 1 && children[0].type === 1 && !isSlotOutlet(children[0]) ? children[0] : null;
	}
	function walk(node, parent, context, doNotHoistNode = false, inFor = false) {
		const { children } = node;
		const toCache = [];
		for (let i = 0; i < children.length; i++) {
			const child = children[i];
			if (child.type === 1 && child.tagType === 0) {
				const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
				if (constantType > 0) {
					if (constantType >= 2) {
						child.codegenNode.patchFlag = -1;
						toCache.push(child);
						continue;
					}
				} else {
					const codegenNode = child.codegenNode;
					if (codegenNode.type === 13) {
						const flag = codegenNode.patchFlag;
						if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
							const props = getNodeProps(child);
							if (props) codegenNode.props = context.hoist(props);
						}
						if (codegenNode.dynamicProps) codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
					}
				}
			} else if (child.type === 12) {
				const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
				if (constantType >= 2) {
					if (child.codegenNode.type === 14 && child.codegenNode.arguments.length > 0) child.codegenNode.arguments.push("-1");
					toCache.push(child);
					continue;
				}
			}
			if (child.type === 1) {
				const isComponent$1 = child.tagType === 1;
				if (isComponent$1) context.scopes.vSlot++;
				walk(child, node, context, false, inFor);
				if (isComponent$1) context.scopes.vSlot--;
			} else if (child.type === 11) walk(child, node, context, child.children.length === 1, true);
			else if (child.type === 9) for (let i2 = 0; i2 < child.branches.length; i2++) walk(child.branches[i2], node, context, child.branches[i2].children.length === 1, inFor);
		}
		let cachedAsArray = false;
		if (toCache.length === children.length && node.type === 1) {
			if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && shared$1.isArray(node.codegenNode.children)) {
				node.codegenNode.children = getCacheExpression(createArrayExpression(node.codegenNode.children));
				cachedAsArray = true;
			} else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !shared$1.isArray(node.codegenNode.children) && node.codegenNode.children.type === 15) {
				const slot = getSlotNode(node.codegenNode, "default");
				if (slot) {
					slot.returns = getCacheExpression(createArrayExpression(slot.returns));
					cachedAsArray = true;
				}
			} else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !shared$1.isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
				const slotName = findDir(node, "slot", true);
				const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
				if (slot) {
					slot.returns = getCacheExpression(createArrayExpression(slot.returns));
					cachedAsArray = true;
				}
			}
		}
		if (!cachedAsArray) for (const child of toCache) child.codegenNode = context.cache(child.codegenNode);
		function getCacheExpression(value) {
			const exp = context.cache(value);
			exp.needArraySpread = true;
			return exp;
		}
		function getSlotNode(node2, name) {
			if (node2.children && !shared$1.isArray(node2.children) && node2.children.type === 15) {
				const slot = node2.children.properties.find((p) => p.key === name || p.key.content === name);
				return slot && slot.value;
			}
		}
		if (toCache.length && context.transformHoist) context.transformHoist(children, context, node);
	}
	function getConstantType(node, context) {
		const { constantCache } = context;
		switch (node.type) {
			case 1:
				if (node.tagType !== 0) return 0;
				const cached = constantCache.get(node);
				if (cached !== void 0) return cached;
				const codegenNode = node.codegenNode;
				if (codegenNode.type !== 13) return 0;
				if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") return 0;
				if (codegenNode.patchFlag === void 0) {
					let returnType2 = 3;
					const generatedPropsType = getGeneratedPropsConstantType(node, context);
					if (generatedPropsType === 0) {
						constantCache.set(node, 0);
						return 0;
					}
					if (generatedPropsType < returnType2) returnType2 = generatedPropsType;
					for (let i = 0; i < node.children.length; i++) {
						const childType = getConstantType(node.children[i], context);
						if (childType === 0) {
							constantCache.set(node, 0);
							return 0;
						}
						if (childType < returnType2) returnType2 = childType;
					}
					if (returnType2 > 1) for (let i = 0; i < node.props.length; i++) {
						const p = node.props[i];
						if (p.type === 7 && p.name === "bind" && p.exp) {
							const expType = getConstantType(p.exp, context);
							if (expType === 0) {
								constantCache.set(node, 0);
								return 0;
							}
							if (expType < returnType2) returnType2 = expType;
						}
					}
					if (codegenNode.isBlock) {
						for (let i = 0; i < node.props.length; i++) {
							const p = node.props[i];
							if (p.type === 7) {
								constantCache.set(node, 0);
								return 0;
							}
						}
						context.removeHelper(OPEN_BLOCK);
						context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
						codegenNode.isBlock = false;
						context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
					}
					constantCache.set(node, returnType2);
					return returnType2;
				} else {
					constantCache.set(node, 0);
					return 0;
				}
			case 2:
			case 3: return 3;
			case 9:
			case 11:
			case 10: return 0;
			case 5:
			case 12: return getConstantType(node.content, context);
			case 4: return node.constType;
			case 8:
				let returnType = 3;
				for (let i = 0; i < node.children.length; i++) {
					const child = node.children[i];
					if (shared$1.isString(child) || shared$1.isSymbol(child)) continue;
					const childType = getConstantType(child, context);
					if (childType === 0) return 0;
					else if (childType < returnType) returnType = childType;
				}
				return returnType;
			case 20: return 2;
			default: return 0;
		}
	}
	const allowHoistedHelperSet = /* @__PURE__ */ new Set([
		NORMALIZE_CLASS,
		NORMALIZE_STYLE,
		NORMALIZE_PROPS,
		GUARD_REACTIVE_PROPS
	]);
	function getConstantTypeOfHelperCall(value, context) {
		if (value.type === 14 && !shared$1.isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
			const arg = value.arguments[0];
			if (arg.type === 4) return getConstantType(arg, context);
			else if (arg.type === 14) return getConstantTypeOfHelperCall(arg, context);
		}
		return 0;
	}
	function getGeneratedPropsConstantType(node, context) {
		let returnType = 3;
		const props = getNodeProps(node);
		if (props && props.type === 15) {
			const { properties } = props;
			for (let i = 0; i < properties.length; i++) {
				const { key, value } = properties[i];
				const keyType = getConstantType(key, context);
				if (keyType === 0) return keyType;
				if (keyType < returnType) returnType = keyType;
				let valueType;
				if (value.type === 4) valueType = getConstantType(value, context);
				else if (value.type === 14) valueType = getConstantTypeOfHelperCall(value, context);
				else valueType = 0;
				if (valueType === 0) return valueType;
				if (valueType < returnType) returnType = valueType;
			}
		}
		return returnType;
	}
	function getNodeProps(node) {
		const codegenNode = node.codegenNode;
		if (codegenNode.type === 13) return codegenNode.props;
	}
	function createTransformContext(root, { filename = "", prefixIdentifiers = false, hoistStatic = false, hmr = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = shared$1.NOOP, isCustomElement = shared$1.NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = shared$1.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
		const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
		const context = {
			filename,
			selfName: nameMatch && shared$1.capitalize(shared$1.camelize(nameMatch[1])),
			prefixIdentifiers,
			hoistStatic,
			hmr,
			cacheHandlers,
			nodeTransforms,
			directiveTransforms,
			transformHoist,
			isBuiltInComponent,
			isCustomElement,
			expressionPlugins,
			scopeId,
			slotted,
			ssr,
			inSSR,
			ssrCssVars,
			bindingMetadata,
			inline,
			isTS,
			onError,
			onWarn,
			compatConfig,
			root,
			helpers: /* @__PURE__ */ new Map(),
			components: /* @__PURE__ */ new Set(),
			directives: /* @__PURE__ */ new Set(),
			hoists: [],
			imports: [],
			cached: [],
			constantCache: /* @__PURE__ */ new WeakMap(),
			temps: 0,
			identifiers: /* @__PURE__ */ Object.create(null),
			scopes: {
				vFor: 0,
				vSlot: 0,
				vPre: 0,
				vOnce: 0
			},
			parent: null,
			grandParent: null,
			currentNode: root,
			childIndex: 0,
			inVOnce: false,
			helper(name) {
				const count = context.helpers.get(name) || 0;
				context.helpers.set(name, count + 1);
				return name;
			},
			removeHelper(name) {
				const count = context.helpers.get(name);
				if (count) {
					const currentCount = count - 1;
					if (!currentCount) context.helpers.delete(name);
					else context.helpers.set(name, currentCount);
				}
			},
			helperString(name) {
				return `_${helperNameMap[context.helper(name)]}`;
			},
			replaceNode(node) {
				context.parent.children[context.childIndex] = context.currentNode = node;
			},
			removeNode(node) {
				const list = context.parent.children;
				const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
				if (!node || node === context.currentNode) {
					context.currentNode = null;
					context.onNodeRemoved();
				} else if (context.childIndex > removalIndex) {
					context.childIndex--;
					context.onNodeRemoved();
				}
				context.parent.children.splice(removalIndex, 1);
			},
			onNodeRemoved: shared$1.NOOP,
			addIdentifiers(exp) {
				if (shared$1.isString(exp)) addId(exp);
				else if (exp.identifiers) exp.identifiers.forEach(addId);
				else if (exp.type === 4) addId(exp.content);
			},
			removeIdentifiers(exp) {
				if (shared$1.isString(exp)) removeId(exp);
				else if (exp.identifiers) exp.identifiers.forEach(removeId);
				else if (exp.type === 4) removeId(exp.content);
			},
			hoist(exp) {
				if (shared$1.isString(exp)) exp = createSimpleExpression(exp);
				context.hoists.push(exp);
				const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
				identifier.hoisted = exp;
				return identifier;
			},
			cache(exp, isVNode = false, inVOnce = false) {
				const cacheExp = createCacheExpression(context.cached.length, exp, isVNode, inVOnce);
				context.cached.push(cacheExp);
				return cacheExp;
			}
		};
		context.filters = /* @__PURE__ */ new Set();
		function addId(id) {
			const { identifiers } = context;
			if (identifiers[id] === void 0) identifiers[id] = 0;
			identifiers[id]++;
		}
		function removeId(id) {
			context.identifiers[id]--;
		}
		return context;
	}
	function transform(root, options) {
		const context = createTransformContext(root, options);
		traverseNode(root, context);
		if (options.hoistStatic) cacheStatic(root, context);
		if (!options.ssr) createRootCodegen(root, context);
		root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
		root.components = [...context.components];
		root.directives = [...context.directives];
		root.imports = context.imports;
		root.hoists = context.hoists;
		root.temps = context.temps;
		root.cached = context.cached;
		root.transformed = true;
		root.filters = [...context.filters];
	}
	function createRootCodegen(root, context) {
		const { helper } = context;
		const { children } = root;
		if (children.length === 1) {
			const singleElementRootChild = getSingleElementRoot(root);
			if (singleElementRootChild && singleElementRootChild.codegenNode) {
				const codegenNode = singleElementRootChild.codegenNode;
				if (codegenNode.type === 13) convertToBlock(codegenNode, context);
				root.codegenNode = codegenNode;
			} else root.codegenNode = children[0];
		} else if (children.length > 1) {
			let patchFlag = 64;
			root.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root.children, patchFlag, void 0, void 0, true, void 0, false);
		}
	}
	function traverseChildren(parent, context) {
		let i = 0;
		const nodeRemoved = () => {
			i--;
		};
		for (; i < parent.children.length; i++) {
			const child = parent.children[i];
			if (shared$1.isString(child)) continue;
			context.grandParent = context.parent;
			context.parent = parent;
			context.childIndex = i;
			context.onNodeRemoved = nodeRemoved;
			traverseNode(child, context);
		}
	}
	function traverseNode(node, context) {
		context.currentNode = node;
		const { nodeTransforms } = context;
		const exitFns = [];
		for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
			const onExit = nodeTransforms[i2](node, context);
			if (onExit) if (shared$1.isArray(onExit)) exitFns.push(...onExit);
			else exitFns.push(onExit);
			if (!context.currentNode) return;
			else node = context.currentNode;
		}
		switch (node.type) {
			case 3:
				if (!context.ssr) context.helper(CREATE_COMMENT);
				break;
			case 5:
				if (!context.ssr) context.helper(TO_DISPLAY_STRING);
				break;
			case 9:
				for (let i2 = 0; i2 < node.branches.length; i2++) traverseNode(node.branches[i2], context);
				break;
			case 10:
			case 11:
			case 1:
			case 0:
				traverseChildren(node, context);
				break;
		}
		context.currentNode = node;
		let i = exitFns.length;
		while (i--) exitFns[i]();
	}
	function createStructuralDirectiveTransform(name, fn) {
		const matches = shared$1.isString(name) ? (n) => n === name : (n) => name.test(n);
		return (node, context) => {
			if (node.type === 1) {
				const { props } = node;
				if (node.tagType === 3 && props.some(isVSlot)) return;
				const exitFns = [];
				for (let i = 0; i < props.length; i++) {
					const prop = props[i];
					if (prop.type === 7 && matches(prop.name)) {
						props.splice(i, 1);
						i--;
						const onExit = fn(node, prop, context);
						if (onExit) exitFns.push(onExit);
					}
				}
				return exitFns;
			}
		};
	}
	const PURE_ANNOTATION = `/*@__PURE__*/`;
	const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
	function createCodegenContext(ast, { mode = "function", prefixIdentifiers = mode === "module", sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
		const context = {
			mode,
			prefixIdentifiers,
			sourceMap,
			filename,
			scopeId,
			optimizeImports,
			runtimeGlobalName,
			runtimeModuleName,
			ssrRuntimeModuleName,
			ssr,
			isTS,
			inSSR,
			source: ast.source,
			code: ``,
			column: 1,
			line: 1,
			offset: 0,
			indentLevel: 0,
			pure: false,
			map: void 0,
			helper(key) {
				return `_${helperNameMap[key]}`;
			},
			push(code$1, newlineIndex = -2, node) {
				context.code += code$1;
				if (context.map) {
					if (node) {
						let name;
						if (node.type === 4 && !node.isStatic) {
							const content = node.content.replace(/^_ctx\./, "");
							if (content !== node.content && isSimpleIdentifier(content)) name = content;
						}
						if (node.loc.source) addMapping(node.loc.start, name);
					}
					if (newlineIndex === -3) advancePositionWithMutation(context, code$1);
					else {
						context.offset += code$1.length;
						if (newlineIndex === -2) context.column += code$1.length;
						else {
							if (newlineIndex === -1) newlineIndex = code$1.length - 1;
							context.line++;
							context.column = code$1.length - newlineIndex;
						}
					}
					if (node && node.loc !== locStub && node.loc.source) addMapping(node.loc.end);
				}
			},
			indent() {
				newline(++context.indentLevel);
			},
			deindent(withoutNewLine = false) {
				if (withoutNewLine) --context.indentLevel;
				else newline(--context.indentLevel);
			},
			newline() {
				newline(context.indentLevel);
			}
		};
		function newline(n) {
			context.push("\n" + `  `.repeat(n), 0);
		}
		function addMapping(loc, name = null) {
			const { _names, _mappings } = context.map;
			if (name !== null && !_names.has(name)) _names.add(name);
			_mappings.add({
				originalLine: loc.line,
				originalColumn: loc.column - 1,
				generatedLine: context.line,
				generatedColumn: context.column - 1,
				source: filename,
				name
			});
		}
		if (sourceMap) {
			context.map = new sourceMapJs.SourceMapGenerator();
			context.map.setSourceContent(filename, context.source);
			context.map._sources.add(filename);
		}
		return context;
	}
	function generate$3(ast, options = {}) {
		const context = createCodegenContext(ast, options);
		if (options.onContextCreated) options.onContextCreated(context);
		const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
		const helpers = Array.from(ast.helpers);
		const hasHelpers = helpers.length > 0;
		const useWithBlock = !prefixIdentifiers && mode !== "module";
		const genScopeId = scopeId != null && mode === "module";
		const isSetupInlined = !!options.inline;
		const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;
		if (mode === "module") genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);
		else genFunctionPreamble(ast, preambleContext);
		const functionName = ssr ? `ssrRender` : `render`;
		const args = ssr ? [
			"_ctx",
			"_push",
			"_parent",
			"_attrs"
		] : ["_ctx", "_cache"];
		if (options.bindingMetadata && !options.inline) args.push("$props", "$setup", "$data", "$options");
		const signature = options.isTS ? args.map((arg) => `${arg}: any`).join(",") : args.join(", ");
		if (isSetupInlined) push(`(${signature}) => {`);
		else push(`function ${functionName}(${signature}) {`);
		indent();
		if (useWithBlock) {
			push(`with (_ctx) {`);
			indent();
			if (hasHelpers) {
				push(`const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`, -1);
				newline();
			}
		}
		if (ast.components.length) {
			genAssets(ast.components, "component", context);
			if (ast.directives.length || ast.temps > 0) newline();
		}
		if (ast.directives.length) {
			genAssets(ast.directives, "directive", context);
			if (ast.temps > 0) newline();
		}
		if (ast.filters && ast.filters.length) {
			newline();
			genAssets(ast.filters, "filter", context);
			newline();
		}
		if (ast.temps > 0) {
			push(`let `);
			for (let i = 0; i < ast.temps; i++) push(`${i > 0 ? `, ` : ``}_temp${i}`);
		}
		if (ast.components.length || ast.directives.length || ast.temps) {
			push(`
`, 0);
			newline();
		}
		if (!ssr) push(`return `);
		if (ast.codegenNode) genNode(ast.codegenNode, context);
		else push(`null`);
		if (useWithBlock) {
			deindent();
			push(`}`);
		}
		deindent();
		push(`}`);
		return {
			ast,
			code: context.code,
			preamble: isSetupInlined ? preambleContext.code : ``,
			map: context.map ? context.map.toJSON() : void 0
		};
	}
	function genFunctionPreamble(ast, context) {
		const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
		const VueBinding = ssr ? `require(${JSON.stringify(runtimeModuleName)})` : runtimeGlobalName;
		const helpers = Array.from(ast.helpers);
		if (helpers.length > 0) if (prefixIdentifiers) push(`const { ${helpers.map(aliasHelper).join(", ")} } = ${VueBinding}
`, -1);
		else {
			push(`const _Vue = ${VueBinding}
`, -1);
			if (ast.hoists.length) {
				const staticHelpers = [
					CREATE_VNODE,
					CREATE_ELEMENT_VNODE,
					CREATE_COMMENT,
					CREATE_TEXT,
					CREATE_STATIC
				].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
				push(`const { ${staticHelpers} } = _Vue
`, -1);
			}
		}
		if (ast.ssrHelpers && ast.ssrHelpers.length) push(`const { ${ast.ssrHelpers.map(aliasHelper).join(", ")} } = require("${ssrRuntimeModuleName}")
`, -1);
		genHoists(ast.hoists, context);
		newline();
		push(`return `);
	}
	function genModulePreamble(ast, context, genScopeId, inline) {
		const { push, newline, optimizeImports, runtimeModuleName, ssrRuntimeModuleName } = context;
		if (ast.helpers.size) {
			const helpers = Array.from(ast.helpers);
			if (optimizeImports) {
				push(`import { ${helpers.map((s) => helperNameMap[s]).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`, -1);
				push(`
// Binding optimization for webpack code-split
const ${helpers.map((s) => `_${helperNameMap[s]} = ${helperNameMap[s]}`).join(", ")}
`, -1);
			} else push(`import { ${helpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`, -1);
		}
		if (ast.ssrHelpers && ast.ssrHelpers.length) push(`import { ${ast.ssrHelpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from "${ssrRuntimeModuleName}"
`, -1);
		if (ast.imports.length) {
			genImports(ast.imports, context);
			newline();
		}
		genHoists(ast.hoists, context);
		newline();
		if (!inline) push(`export `);
	}
	function genAssets(assets, type, { helper, push, newline, isTS }) {
		const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
		for (let i = 0; i < assets.length; i++) {
			let id = assets[i];
			const maybeSelfReference = id.endsWith("__self");
			if (maybeSelfReference) id = id.slice(0, -6);
			push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
			if (i < assets.length - 1) newline();
		}
	}
	function genHoists(hoists, context) {
		if (!hoists.length) return;
		context.pure = true;
		const { push, newline } = context;
		newline();
		for (let i = 0; i < hoists.length; i++) {
			const exp = hoists[i];
			if (exp) {
				push(`const _hoisted_${i + 1} = `);
				genNode(exp, context);
				newline();
			}
		}
		context.pure = false;
	}
	function genImports(importsOptions, context) {
		if (!importsOptions.length) return;
		importsOptions.forEach((imports) => {
			context.push(`import `);
			genNode(imports.exp, context);
			context.push(` from '${imports.path}'`);
			context.newline();
		});
	}
	function isText(n) {
		return shared$1.isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
	}
	function genNodeListAsArray(nodes, context) {
		const multilines = nodes.length > 3 || nodes.some((n) => shared$1.isArray(n) || !isText(n));
		context.push(`[`);
		multilines && context.indent();
		genNodeList(nodes, context, multilines);
		multilines && context.deindent();
		context.push(`]`);
	}
	function genNodeList(nodes, context, multilines = false, comma = true) {
		const { push, newline } = context;
		for (let i = 0; i < nodes.length; i++) {
			const node = nodes[i];
			if (shared$1.isString(node)) push(node, -3);
			else if (shared$1.isArray(node)) genNodeListAsArray(node, context);
			else genNode(node, context);
			if (i < nodes.length - 1) if (multilines) {
				comma && push(",");
				newline();
			} else comma && push(", ");
		}
	}
	function genNode(node, context) {
		if (shared$1.isString(node)) {
			context.push(node, -3);
			return;
		}
		if (shared$1.isSymbol(node)) {
			context.push(context.helper(node));
			return;
		}
		switch (node.type) {
			case 1:
			case 9:
			case 11:
				genNode(node.codegenNode, context);
				break;
			case 2:
				genText(node, context);
				break;
			case 4:
				genExpression(node, context);
				break;
			case 5:
				genInterpolation(node, context);
				break;
			case 12:
				genNode(node.codegenNode, context);
				break;
			case 8:
				genCompoundExpression(node, context);
				break;
			case 3:
				genComment(node, context);
				break;
			case 13:
				genVNodeCall(node, context);
				break;
			case 14:
				genCallExpression(node, context);
				break;
			case 15:
				genObjectExpression(node, context);
				break;
			case 17:
				genArrayExpression(node, context);
				break;
			case 18:
				genFunctionExpression(node, context);
				break;
			case 19:
				genConditionalExpression(node, context);
				break;
			case 20:
				genCacheExpression(node, context);
				break;
			case 21:
				genNodeList(node.body, context, true, false);
				break;
			case 22:
				genTemplateLiteral(node, context);
				break;
			case 23:
				genIfStatement(node, context);
				break;
			case 24:
				genAssignmentExpression(node, context);
				break;
			case 25:
				genSequenceExpression(node, context);
				break;
			case 26:
				genReturnStatement(node, context);
				break;
		}
	}
	function genText(node, context) {
		context.push(JSON.stringify(node.content), -3, node);
	}
	function genExpression(node, context) {
		const { content, isStatic } = node;
		context.push(isStatic ? JSON.stringify(content) : content, -3, node);
	}
	function genInterpolation(node, context) {
		const { push, helper, pure } = context;
		if (pure) push(PURE_ANNOTATION);
		push(`${helper(TO_DISPLAY_STRING)}(`);
		genNode(node.content, context);
		push(`)`);
	}
	function genCompoundExpression(node, context) {
		for (let i = 0; i < node.children.length; i++) {
			const child = node.children[i];
			if (shared$1.isString(child)) context.push(child, -3);
			else genNode(child, context);
		}
	}
	function genExpressionAsPropertyKey(node, context) {
		const { push } = context;
		if (node.type === 8) {
			push(`[`);
			genCompoundExpression(node, context);
			push(`]`);
		} else if (node.isStatic) {
			const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
			push(text, -2, node);
		} else push(`[${node.content}]`, -3, node);
	}
	function genComment(node, context) {
		const { push, helper, pure } = context;
		if (pure) push(PURE_ANNOTATION);
		push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, -3, node);
	}
	function genVNodeCall(node, context) {
		const { push, helper, pure } = context;
		const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent$1 } = node;
		let patchFlagString;
		if (patchFlag) patchFlagString = String(patchFlag);
		if (directives) push(helper(WITH_DIRECTIVES) + `(`);
		if (isBlock) push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
		if (pure) push(PURE_ANNOTATION);
		const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent$1) : getVNodeHelper(context.inSSR, isComponent$1);
		push(helper(callHelper) + `(`, -2, node);
		genNodeList(genNullableArgs([
			tag,
			props,
			children,
			patchFlagString,
			dynamicProps
		]), context);
		push(`)`);
		if (isBlock) push(`)`);
		if (directives) {
			push(`, `);
			genNode(directives, context);
			push(`)`);
		}
	}
	function genNullableArgs(args) {
		let i = args.length;
		while (i--) if (args[i] != null) break;
		return args.slice(0, i + 1).map((arg) => arg || `null`);
	}
	function genCallExpression(node, context) {
		const { push, helper, pure } = context;
		const callee = shared$1.isString(node.callee) ? node.callee : helper(node.callee);
		if (pure) push(PURE_ANNOTATION);
		push(callee + `(`, -2, node);
		genNodeList(node.arguments, context);
		push(`)`);
	}
	function genObjectExpression(node, context) {
		const { push, indent, deindent, newline } = context;
		const { properties } = node;
		if (!properties.length) {
			push(`{}`, -2, node);
			return;
		}
		const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
		push(multilines ? `{` : `{ `);
		multilines && indent();
		for (let i = 0; i < properties.length; i++) {
			const { key, value } = properties[i];
			genExpressionAsPropertyKey(key, context);
			push(`: `);
			genNode(value, context);
			if (i < properties.length - 1) {
				push(`,`);
				newline();
			}
		}
		multilines && deindent();
		push(multilines ? `}` : ` }`);
	}
	function genArrayExpression(node, context) {
		genNodeListAsArray(node.elements, context);
	}
	function genFunctionExpression(node, context) {
		const { push, indent, deindent } = context;
		const { params, returns, body, newline, isSlot } = node;
		if (isSlot) push(`_${helperNameMap[WITH_CTX]}(`);
		push(`(`, -2, node);
		if (shared$1.isArray(params)) genNodeList(params, context);
		else if (params) genNode(params, context);
		push(`) => `);
		if (newline || body) {
			push(`{`);
			indent();
		}
		if (returns) {
			if (newline) push(`return `);
			if (shared$1.isArray(returns)) genNodeListAsArray(returns, context);
			else genNode(returns, context);
		} else if (body) genNode(body, context);
		if (newline || body) {
			deindent();
			push(`}`);
		}
		if (isSlot) {
			if (node.isNonScopedSlot) push(`, undefined, true`);
			push(`)`);
		}
	}
	function genConditionalExpression(node, context) {
		const { test, consequent, alternate, newline: needNewline } = node;
		const { push, indent, deindent, newline } = context;
		if (test.type === 4) {
			const needsParens = !isSimpleIdentifier(test.content);
			needsParens && push(`(`);
			genExpression(test, context);
			needsParens && push(`)`);
		} else {
			push(`(`);
			genNode(test, context);
			push(`)`);
		}
		needNewline && indent();
		context.indentLevel++;
		needNewline || push(` `);
		push(`? `);
		genNode(consequent, context);
		context.indentLevel--;
		needNewline && newline();
		needNewline || push(` `);
		push(`: `);
		const isNested = alternate.type === 19;
		if (!isNested) context.indentLevel++;
		genNode(alternate, context);
		if (!isNested) context.indentLevel--;
		needNewline && deindent(true);
	}
	function genCacheExpression(node, context) {
		const { push, helper, indent, deindent, newline } = context;
		const { needPauseTracking, needArraySpread } = node;
		if (needArraySpread) push(`[...(`);
		push(`_cache[${node.index}] || (`);
		if (needPauseTracking) {
			indent();
			push(`${helper(SET_BLOCK_TRACKING)}(-1`);
			if (node.inVOnce) push(`, true`);
			push(`),`);
			newline();
			push(`(`);
		}
		push(`_cache[${node.index}] = `);
		genNode(node.value, context);
		if (needPauseTracking) {
			push(`).cacheIndex = ${node.index},`);
			newline();
			push(`${helper(SET_BLOCK_TRACKING)}(1),`);
			newline();
			push(`_cache[${node.index}]`);
			deindent();
		}
		push(`)`);
		if (needArraySpread) push(`)]`);
	}
	function genTemplateLiteral(node, context) {
		const { push, indent, deindent } = context;
		push("`");
		const l = node.elements.length;
		const multilines = l > 3;
		for (let i = 0; i < l; i++) {
			const e = node.elements[i];
			if (shared$1.isString(e)) push(e.replace(/(`|\$|\\)/g, "\\$1"), -3);
			else {
				push("${");
				if (multilines) indent();
				genNode(e, context);
				if (multilines) deindent();
				push("}");
			}
		}
		push("`");
	}
	function genIfStatement(node, context) {
		const { push, indent, deindent } = context;
		const { test, consequent, alternate } = node;
		push(`if (`);
		genNode(test, context);
		push(`) {`);
		indent();
		genNode(consequent, context);
		deindent();
		push(`}`);
		if (alternate) {
			push(` else `);
			if (alternate.type === 23) genIfStatement(alternate, context);
			else {
				push(`{`);
				indent();
				genNode(alternate, context);
				deindent();
				push(`}`);
			}
		}
	}
	function genAssignmentExpression(node, context) {
		genNode(node.left, context);
		context.push(` = `);
		genNode(node.right, context);
	}
	function genSequenceExpression(node, context) {
		context.push(`(`);
		genNodeList(node.expressions, context);
		context.push(`)`);
	}
	function genReturnStatement({ returns }, context) {
		context.push(`return `);
		if (shared$1.isArray(returns)) genNodeListAsArray(returns, context);
		else genNode(returns, context);
	}
	const isLiteralWhitelisted$1 = /* @__PURE__ */ shared$1.makeMap("true,false,null,this");
	const transformExpression = (node, context) => {
		if (node.type === 5) node.content = processExpression(node.content, context);
		else if (node.type === 1) {
			const memo = findDir(node, "memo");
			for (let i = 0; i < node.props.length; i++) {
				const dir = node.props[i];
				if (dir.type === 7 && dir.name !== "for") {
					const exp = dir.exp;
					const arg = dir.arg;
					if (exp && exp.type === 4 && !(dir.name === "on" && arg) && !(memo && arg && arg.type === 4 && arg.content === "key")) dir.exp = processExpression(exp, context, dir.name === "slot");
					if (arg && arg.type === 4 && !arg.isStatic) dir.arg = processExpression(arg, context);
				}
			}
		}
	};
	function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
		if (!context.prefixIdentifiers || !node.content.trim()) return node;
		const { inline, bindingMetadata } = context;
		const rewriteIdentifier = (raw$1, parent, id) => {
			const type = shared$1.hasOwn(bindingMetadata, raw$1) && bindingMetadata[raw$1];
			if (inline) {
				const isAssignmentLVal = parent && parent.type === "AssignmentExpression" && parent.left === id;
				const isUpdateArg = parent && parent.type === "UpdateExpression" && parent.argument === id;
				const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack);
				const isNewExpression = parent && isInNewExpression(parentStack);
				const wrapWithUnref = (raw2) => {
					const wrapped = `${context.helperString(UNREF)}(${raw2})`;
					return isNewExpression ? `(${wrapped})` : wrapped;
				};
				if (isConst(type) || type === "setup-reactive-const" || localVars[raw$1]) return raw$1;
				else if (type === "setup-ref") return `${raw$1}.value`;
				else if (type === "setup-maybe-ref") return isAssignmentLVal || isUpdateArg || isDestructureAssignment ? `${raw$1}.value` : wrapWithUnref(raw$1);
				else if (type === "setup-let") if (isAssignmentLVal) {
					const { right: rVal, operator } = parent;
					const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1);
					const rExpString = stringifyExpression(processExpression(createSimpleExpression(rExp, false), context, false, false, knownIds));
					return `${context.helperString(IS_REF)}(${raw$1})${context.isTS ? ` //@ts-ignore
` : ``} ? ${raw$1}.value ${operator} ${rExpString} : ${raw$1}`;
				} else if (isUpdateArg) {
					id.start = parent.start;
					id.end = parent.end;
					const { prefix: isPrefix, operator } = parent;
					const prefix$1 = isPrefix ? operator : ``;
					const postfix$1 = isPrefix ? `` : operator;
					return `${context.helperString(IS_REF)}(${raw$1})${context.isTS ? ` //@ts-ignore
` : ``} ? ${prefix$1}${raw$1}.value${postfix$1} : ${prefix$1}${raw$1}${postfix$1}`;
				} else if (isDestructureAssignment) return raw$1;
				else return wrapWithUnref(raw$1);
				else if (type === "props") return shared$1.genPropsAccessExp(raw$1);
				else if (type === "props-aliased") return shared$1.genPropsAccessExp(bindingMetadata.__propsAliases[raw$1]);
			} else if (type && type.startsWith("setup") || type === "literal-const") return `$setup.${raw$1}`;
			else if (type === "props-aliased") return `$props['${bindingMetadata.__propsAliases[raw$1]}']`;
			else if (type) return `$${type}.${raw$1}`;
			return `_ctx.${raw$1}`;
		};
		const rawExp = node.content;
		let ast = node.ast;
		if (ast === false) return node;
		if (ast === null || !ast && isSimpleIdentifier(rawExp)) {
			const isScopeVarReference = context.identifiers[rawExp];
			const isAllowedGlobal = shared$1.isGloballyAllowed(rawExp);
			const isLiteral = isLiteralWhitelisted$1(rawExp);
			if (!asParams && !isScopeVarReference && !isLiteral && (!isAllowedGlobal || bindingMetadata[rawExp])) {
				if (isConst(bindingMetadata[rawExp])) node.constType = 1;
				node.content = rewriteIdentifier(rawExp);
			} else if (!isScopeVarReference) if (isLiteral) node.constType = 3;
			else node.constType = 2;
			return node;
		}
		if (!ast) {
			const source = asRawStatements ? ` ${rawExp} ` : `(${rawExp})${asParams ? `=>{}` : ``}`;
			try {
				ast = parser.parseExpression(source, {
					sourceType: "module",
					plugins: context.expressionPlugins
				});
			} catch (e) {
				context.onError(createCompilerError(45, node.loc, void 0, e.message));
				return node;
			}
		}
		const ids = [];
		const parentStack = [];
		const knownIds = Object.create(context.identifiers);
		walkIdentifiers$1(ast, (node2, parent, _, isReferenced$1, isLocal) => {
			if (isStaticPropertyKey(node2, parent)) return;
			if (node2.name.startsWith("_filter_")) return;
			const needPrefix = isReferenced$1 && canPrefix(node2);
			if (needPrefix && !isLocal) {
				if (isStaticProperty(parent) && parent.shorthand) node2.prefix = `${node2.name}: `;
				node2.name = rewriteIdentifier(node2.name, parent, node2);
				ids.push(node2);
			} else {
				if (!(needPrefix && isLocal) && (!parent || parent.type !== "CallExpression" && parent.type !== "NewExpression" && parent.type !== "MemberExpression")) node2.isConstant = true;
				ids.push(node2);
			}
		}, true, parentStack, knownIds);
		const children = [];
		ids.sort((a, b) => a.start - b.start);
		ids.forEach((id, i) => {
			const start = id.start - 1;
			const end = id.end - 1;
			const last = ids[i - 1];
			const leadingText = rawExp.slice(last ? last.end - 1 : 0, start);
			if (leadingText.length || id.prefix) children.push(leadingText + (id.prefix || ``));
			const source = rawExp.slice(start, end);
			children.push(createSimpleExpression(id.name, false, {
				start: advancePositionWithClone(node.loc.start, source, start),
				end: advancePositionWithClone(node.loc.start, source, end),
				source
			}, id.isConstant ? 3 : 0));
			if (i === ids.length - 1 && end < rawExp.length) children.push(rawExp.slice(end));
		});
		let ret;
		if (children.length) {
			ret = createCompoundExpression(children, node.loc);
			ret.ast = ast;
		} else {
			ret = node;
			ret.constType = 3;
		}
		ret.identifiers = Object.keys(knownIds);
		return ret;
	}
	function canPrefix(id) {
		if (shared$1.isGloballyAllowed(id.name)) return false;
		if (id.name === "require") return false;
		return true;
	}
	function stringifyExpression(exp) {
		if (shared$1.isString(exp)) return exp;
		else if (exp.type === 4) return exp.content;
		else return exp.children.map(stringifyExpression).join("");
	}
	function isConst(type) {
		return type === "setup-const" || type === "literal-const";
	}
	const transformIf = createStructuralDirectiveTransform(/^(?:if|else|else-if)$/, (node, dir, context) => {
		return processIf(node, dir, context, (ifNode, branch, isRoot) => {
			const siblings = context.parent.children;
			let i = siblings.indexOf(ifNode);
			let key = 0;
			while (i-- >= 0) {
				const sibling = siblings[i];
				if (sibling && sibling.type === 9) key += sibling.branches.length;
			}
			return () => {
				if (isRoot) ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
				else {
					const parentCondition = getParentCondition(ifNode.codegenNode);
					parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
				}
			};
		});
	});
	function processIf(node, dir, context, processCodegen) {
		if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
			const loc = dir.exp ? dir.exp.loc : node.loc;
			context.onError(createCompilerError(28, dir.loc));
			dir.exp = createSimpleExpression(`true`, false, loc);
		}
		if (context.prefixIdentifiers && dir.exp) dir.exp = processExpression(dir.exp, context);
		if (dir.name === "if") {
			const branch = createIfBranch(node, dir);
			const ifNode = {
				type: 9,
				loc: cloneLoc(node.loc),
				branches: [branch]
			};
			context.replaceNode(ifNode);
			if (processCodegen) return processCodegen(ifNode, branch, true);
		} else {
			const siblings = context.parent.children;
			let i = siblings.indexOf(node);
			while (i-- >= -1) {
				const sibling = siblings[i];
				if (sibling && sibling.type === 3) {
					context.removeNode(sibling);
					continue;
				}
				if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
					context.removeNode(sibling);
					continue;
				}
				if (sibling && sibling.type === 9) {
					if ((dir.name === "else-if" || dir.name === "else") && sibling.branches[sibling.branches.length - 1].condition === void 0) context.onError(createCompilerError(30, node.loc));
					context.removeNode();
					const branch = createIfBranch(node, dir);
					{
						const key = branch.userKey;
						if (key) sibling.branches.forEach(({ userKey }) => {
							if (isSameKey(userKey, key)) context.onError(createCompilerError(29, branch.userKey.loc));
						});
					}
					sibling.branches.push(branch);
					const onExit = processCodegen && processCodegen(sibling, branch, false);
					traverseNode(branch, context);
					if (onExit) onExit();
					context.currentNode = null;
				} else context.onError(createCompilerError(30, node.loc));
				break;
			}
		}
	}
	function createIfBranch(node, dir) {
		const isTemplateIf = node.tagType === 3;
		return {
			type: 10,
			loc: node.loc,
			condition: dir.name === "else" ? void 0 : dir.exp,
			children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
			userKey: findProp(node, `key`),
			isTemplateIf
		};
	}
	function createCodegenNodeForBranch(branch, keyIndex, context) {
		if (branch.condition) return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), createCallExpression(context.helper(CREATE_COMMENT), ["\"\"", "true"]));
		else return createChildrenCodegenNode(branch, keyIndex, context);
	}
	function createChildrenCodegenNode(branch, keyIndex, context) {
		const { helper } = context;
		const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
		const { children } = branch;
		const firstChild = children[0];
		const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
		if (needFragmentWrapper) if (children.length === 1 && firstChild.type === 11) {
			const vnodeCall = firstChild.codegenNode;
			injectProp(vnodeCall, keyProperty, context);
			return vnodeCall;
		} else {
			let patchFlag = 64;
			return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag, void 0, void 0, true, false, false, branch.loc);
		}
		else {
			const ret = firstChild.codegenNode;
			const vnodeCall = getMemoedVNodeCall(ret);
			if (vnodeCall.type === 13) convertToBlock(vnodeCall, context);
			injectProp(vnodeCall, keyProperty, context);
			return ret;
		}
	}
	function isSameKey(a, b) {
		if (!a || a.type !== b.type) return false;
		if (a.type === 6) {
			if (a.value.content !== b.value.content) return false;
		} else {
			const exp = a.exp;
			const branchExp = b.exp;
			if (exp.type !== branchExp.type) return false;
			if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) return false;
		}
		return true;
	}
	function getParentCondition(node) {
		while (true) if (node.type === 19) if (node.alternate.type === 19) node = node.alternate;
		else return node;
		else if (node.type === 20) node = node.value;
	}
	const transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
		const { helper, removeHelper } = context;
		return processFor(node, dir, context, (forNode) => {
			const renderExp = createCallExpression(helper(RENDER_LIST), [forNode.source]);
			const isTemplate = isTemplateNode(node);
			const memo = findDir(node, "memo");
			const keyProp = findProp(node, `key`, false, true);
			const isDirKey = keyProp && keyProp.type === 7;
			let keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
			if (memo && keyExp && isDirKey) keyProp.exp = keyExp = processExpression(keyExp, context);
			const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
			if (isTemplate) {
				if (memo) memo.exp = processExpression(memo.exp, context);
				if (keyProperty && keyProp.type !== 6) keyProperty.value = processExpression(keyProperty.value, context);
			}
			const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
			const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
			forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag, void 0, void 0, true, !isStableFragment, false, node.loc);
			return () => {
				let childBlock;
				const { children } = forNode;
				if (isTemplate) node.children.some((c) => {
					if (c.type === 1) {
						const key = findProp(c, "key");
						if (key) {
							context.onError(createCompilerError(33, key.loc));
							return true;
						}
					}
				});
				const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
				const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
				if (slotOutlet) {
					childBlock = slotOutlet.codegenNode;
					if (isTemplate && keyProperty) injectProp(childBlock, keyProperty, context);
				} else if (needFragmentWrapper) childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64, void 0, void 0, true, void 0, false);
				else {
					childBlock = children[0].codegenNode;
					if (isTemplate && keyProperty) injectProp(childBlock, keyProperty, context);
					if (childBlock.isBlock !== !isStableFragment) if (childBlock.isBlock) {
						removeHelper(OPEN_BLOCK);
						removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
					} else removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
					childBlock.isBlock = !isStableFragment;
					if (childBlock.isBlock) {
						helper(OPEN_BLOCK);
						helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
					} else helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
				}
				if (memo) {
					const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [createSimpleExpression(`_cached`)]));
					loop.body = createBlockStatement([
						createCompoundExpression([
							`const _memo = (`,
							memo.exp,
							`)`
						]),
						createCompoundExpression([
							`if (_cached`,
							...keyExp ? [` && _cached.key === `, keyExp] : [],
							` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
						]),
						createCompoundExpression([`const _item = `, childBlock]),
						createSimpleExpression(`_item.memo = _memo`),
						createSimpleExpression(`return _item`)
					]);
					renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached.length)));
					context.cached.push(null);
				} else renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
			};
		});
	});
	function processFor(node, dir, context, processCodegen) {
		if (!dir.exp) {
			context.onError(createCompilerError(31, dir.loc));
			return;
		}
		const parseResult = dir.forParseResult;
		if (!parseResult) {
			context.onError(createCompilerError(32, dir.loc));
			return;
		}
		finalizeForParseResult(parseResult, context);
		const { addIdentifiers, removeIdentifiers, scopes } = context;
		const { source, value, key, index } = parseResult;
		const forNode = {
			type: 11,
			loc: dir.loc,
			source,
			valueAlias: value,
			keyAlias: key,
			objectIndexAlias: index,
			parseResult,
			children: isTemplateNode(node) ? node.children : [node]
		};
		context.replaceNode(forNode);
		scopes.vFor++;
		if (context.prefixIdentifiers) {
			value && addIdentifiers(value);
			key && addIdentifiers(key);
			index && addIdentifiers(index);
		}
		const onExit = processCodegen && processCodegen(forNode);
		return () => {
			scopes.vFor--;
			if (context.prefixIdentifiers) {
				value && removeIdentifiers(value);
				key && removeIdentifiers(key);
				index && removeIdentifiers(index);
			}
			if (onExit) onExit();
		};
	}
	function finalizeForParseResult(result, context) {
		if (result.finalized) return;
		if (context.prefixIdentifiers) {
			result.source = processExpression(result.source, context);
			if (result.key) result.key = processExpression(result.key, context, true);
			if (result.index) result.index = processExpression(result.index, context, true);
			if (result.value) result.value = processExpression(result.value, context, true);
		}
		result.finalized = true;
	}
	function createForLoopParams({ value, key, index }, memoArgs = []) {
		return createParamsList([
			value,
			key,
			index,
			...memoArgs
		]);
	}
	function createParamsList(args) {
		let i = args.length;
		while (i--) if (args[i]) break;
		return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
	}
	const defaultFallback = createSimpleExpression(`undefined`, false);
	const trackSlotScopes = (node, context) => {
		if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
			const vSlot = findDir(node, "slot");
			if (vSlot) {
				const slotProps = vSlot.exp;
				if (context.prefixIdentifiers) slotProps && context.addIdentifiers(slotProps);
				context.scopes.vSlot++;
				return () => {
					if (context.prefixIdentifiers) slotProps && context.removeIdentifiers(slotProps);
					context.scopes.vSlot--;
				};
			}
		}
	};
	const trackVForSlotScopes = (node, context) => {
		let vFor;
		if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
			const result = vFor.forParseResult;
			if (result) {
				finalizeForParseResult(result, context);
				const { value, key, index } = result;
				const { addIdentifiers, removeIdentifiers } = context;
				value && addIdentifiers(value);
				key && addIdentifiers(key);
				index && addIdentifiers(index);
				return () => {
					value && removeIdentifiers(value);
					key && removeIdentifiers(key);
					index && removeIdentifiers(index);
				};
			}
		}
	};
	const buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
	function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
		context.helper(WITH_CTX);
		const { children, loc } = node;
		const slotsProperties = [];
		const dynamicSlots = [];
		let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
		if (!context.ssr && context.prefixIdentifiers) hasDynamicSlots = node.props.some((prop) => isVSlot(prop) && (hasScopeRef(prop.arg, context.identifiers) || hasScopeRef(prop.exp, context.identifiers))) || children.some((child) => hasScopeRef(child, context.identifiers));
		const onComponentSlot = findDir(node, "slot", true);
		if (onComponentSlot) {
			const { arg, exp } = onComponentSlot;
			if (arg && !isStaticExp(arg)) hasDynamicSlots = true;
			slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, void 0, children, loc)));
		}
		let hasTemplateSlots = false;
		let hasNamedDefaultSlot = false;
		const implicitDefaultChildren = [];
		const seenSlotNames = /* @__PURE__ */ new Set();
		let conditionalBranchIndex = 0;
		for (let i = 0; i < children.length; i++) {
			const slotElement = children[i];
			let slotDir;
			if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
				if (slotElement.type !== 3) implicitDefaultChildren.push(slotElement);
				continue;
			}
			if (onComponentSlot) {
				context.onError(createCompilerError(37, slotDir.loc));
				break;
			}
			hasTemplateSlots = true;
			const { children: slotChildren, loc: slotLoc } = slotElement;
			const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
			let staticSlotName;
			if (isStaticExp(slotName)) staticSlotName = slotName ? slotName.content : `default`;
			else hasDynamicSlots = true;
			const vFor = findDir(slotElement, "for");
			const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
			let vIf;
			let vElse;
			if (vIf = findDir(slotElement, "if")) {
				hasDynamicSlots = true;
				dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback));
			} else if (vElse = findDir(slotElement, /^else(?:-if)?$/, true)) {
				let j = i;
				let prev;
				while (j--) {
					prev = children[j];
					if (prev.type !== 3 && isNonWhitespaceContent(prev)) break;
				}
				if (prev && isTemplateNode(prev) && findDir(prev, /^(?:else-)?if$/)) {
					let conditional = dynamicSlots[dynamicSlots.length - 1];
					while (conditional.alternate.type === 19) conditional = conditional.alternate;
					conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
				} else context.onError(createCompilerError(30, vElse.loc));
			} else if (vFor) {
				hasDynamicSlots = true;
				const parseResult = vFor.forParseResult;
				if (parseResult) {
					finalizeForParseResult(parseResult, context);
					dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [parseResult.source, createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)]));
				} else context.onError(createCompilerError(32, vFor.loc));
			} else {
				if (staticSlotName) {
					if (seenSlotNames.has(staticSlotName)) {
						context.onError(createCompilerError(38, dirLoc));
						continue;
					}
					seenSlotNames.add(staticSlotName);
					if (staticSlotName === "default") hasNamedDefaultSlot = true;
				}
				slotsProperties.push(createObjectProperty(slotName, slotFunction));
			}
		}
		if (!onComponentSlot) {
			const buildDefaultSlotProperty = (props, children2) => {
				const fn = buildSlotFn(props, void 0, children2, loc);
				if (context.compatConfig) fn.isNonScopedSlot = true;
				return createObjectProperty(`default`, fn);
			};
			if (!hasTemplateSlots) slotsProperties.push(buildDefaultSlotProperty(void 0, children));
			else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) if (hasNamedDefaultSlot) context.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
			else slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
		}
		const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
		let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + ``, false))), loc);
		if (dynamicSlots.length) slots = createCallExpression(context.helper(CREATE_SLOTS), [slots, createArrayExpression(dynamicSlots)]);
		return {
			slots,
			hasDynamicSlots
		};
	}
	function buildDynamicSlot(name, fn, index) {
		const props = [createObjectProperty(`name`, name), createObjectProperty(`fn`, fn)];
		if (index != null) props.push(createObjectProperty(`key`, createSimpleExpression(String(index), true)));
		return createObjectExpression(props);
	}
	function hasForwardedSlots(children) {
		for (let i = 0; i < children.length; i++) {
			const child = children[i];
			switch (child.type) {
				case 1:
					if (child.tagType === 2 || hasForwardedSlots(child.children)) return true;
					break;
				case 9:
					if (hasForwardedSlots(child.branches)) return true;
					break;
				case 10:
				case 11:
					if (hasForwardedSlots(child.children)) return true;
					break;
			}
		}
		return false;
	}
	function isNonWhitespaceContent(node) {
		if (node.type !== 2 && node.type !== 12) return true;
		return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
	}
	const directiveImportMap = /* @__PURE__ */ new WeakMap();
	const transformElement = (node, context) => {
		return function postTransformElement() {
			node = context.currentNode;
			if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) return;
			const { tag, props } = node;
			const isComponent$1 = node.tagType === 1;
			let vnodeTag = isComponent$1 ? resolveComponentType(node, context) : `"${tag}"`;
			const isDynamicComponent = shared$1.isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
			let vnodeProps;
			let vnodeChildren;
			let patchFlag = 0;
			let vnodeDynamicProps;
			let dynamicPropNames;
			let vnodeDirectives;
			let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent$1 && (tag === "svg" || tag === "foreignObject" || tag === "math");
			if (props.length > 0) {
				const propsBuildResult = buildProps(node, context, void 0, isComponent$1, isDynamicComponent);
				vnodeProps = propsBuildResult.props;
				patchFlag = propsBuildResult.patchFlag;
				dynamicPropNames = propsBuildResult.dynamicPropNames;
				const directives = propsBuildResult.directives;
				vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context))) : void 0;
				if (propsBuildResult.shouldUseBlock) shouldUseBlock = true;
			}
			if (node.children.length > 0) {
				if (vnodeTag === KEEP_ALIVE) {
					shouldUseBlock = true;
					patchFlag |= 1024;
				}
				const shouldBuildAsSlots = isComponent$1 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
				if (shouldBuildAsSlots) {
					const { slots, hasDynamicSlots } = buildSlots(node, context);
					vnodeChildren = slots;
					if (hasDynamicSlots) patchFlag |= 1024;
				} else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
					const child = node.children[0];
					const type = child.type;
					const hasDynamicTextChild = type === 5 || type === 8;
					if (hasDynamicTextChild && getConstantType(child, context) === 0) patchFlag |= 1;
					if (hasDynamicTextChild || type === 2) vnodeChildren = child;
					else vnodeChildren = node.children;
				} else vnodeChildren = node.children;
			}
			if (dynamicPropNames && dynamicPropNames.length) vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
			node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, patchFlag === 0 ? void 0 : patchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent$1, node.loc);
		};
	};
	function resolveComponentType(node, context, ssr = false) {
		let { tag } = node;
		const isExplicitDynamic = isComponentTag(tag);
		const isProp = findProp(node, "is", false, true);
		if (isProp) {
			if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
				let exp;
				if (isProp.type === 6) exp = isProp.value && createSimpleExpression(isProp.value.content, true);
				else {
					exp = isProp.exp;
					if (!exp) {
						exp = createSimpleExpression(`is`, false, isProp.arg.loc);
						exp = isProp.exp = processExpression(exp, context);
					}
				}
				if (exp) return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [exp]);
			} else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) tag = isProp.value.content.slice(4);
		}
		const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
		if (builtIn) {
			if (!ssr) context.helper(builtIn);
			return builtIn;
		}
		{
			const fromSetup = resolveSetupReference(tag, context);
			if (fromSetup) return fromSetup;
			const dotIndex = tag.indexOf(".");
			if (dotIndex > 0) {
				const ns = resolveSetupReference(tag.slice(0, dotIndex), context);
				if (ns) return ns + tag.slice(dotIndex);
			}
		}
		if (context.selfName && shared$1.capitalize(shared$1.camelize(tag)) === context.selfName) {
			context.helper(RESOLVE_COMPONENT);
			context.components.add(tag + `__self`);
			return toValidAssetId(tag, `component`);
		}
		context.helper(RESOLVE_COMPONENT);
		context.components.add(tag);
		return toValidAssetId(tag, `component`);
	}
	function resolveSetupReference(name, context) {
		const bindings = context.bindingMetadata;
		if (!bindings || bindings.__isScriptSetup === false) return;
		const camelName = shared$1.camelize(name);
		const PascalName = shared$1.capitalize(camelName);
		const checkType = (type) => {
			if (bindings[name] === type) return name;
			if (bindings[camelName] === type) return camelName;
			if (bindings[PascalName] === type) return PascalName;
		};
		const fromConst = checkType("setup-const") || checkType("setup-reactive-const") || checkType("literal-const");
		if (fromConst) return context.inline ? fromConst : `$setup[${JSON.stringify(fromConst)}]`;
		const fromMaybeRef = checkType("setup-let") || checkType("setup-ref") || checkType("setup-maybe-ref");
		if (fromMaybeRef) return context.inline ? `${context.helperString(UNREF)}(${fromMaybeRef})` : `$setup[${JSON.stringify(fromMaybeRef)}]`;
		const fromProps = checkType("props");
		if (fromProps) return `${context.helperString(UNREF)}(${context.inline ? "__props" : "$props"}[${JSON.stringify(fromProps)}])`;
	}
	function buildProps(node, context, props = node.props, isComponent$1, isDynamicComponent, ssr = false) {
		const { tag, loc: elementLoc, children } = node;
		let properties = [];
		const mergeArgs = [];
		const runtimeDirectives = [];
		const hasChildren = children.length > 0;
		let shouldUseBlock = false;
		let patchFlag = 0;
		let hasRef = false;
		let hasClassBinding = false;
		let hasStyleBinding = false;
		let hasHydrationEventBinding = false;
		let hasDynamicKeys = false;
		let hasVnodeHook = false;
		const dynamicPropNames = [];
		const pushMergeArg = (arg) => {
			if (properties.length) {
				mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
				properties = [];
			}
			if (arg) mergeArgs.push(arg);
		};
		const pushRefVForMarker = () => {
			if (context.scopes.vFor > 0) properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
		};
		const analyzePatchFlag = ({ key, value }) => {
			if (isStaticExp(key)) {
				const name = key.content;
				const isEventHandler = shared$1.isOn(name);
				if (isEventHandler && (!isComponent$1 || isDynamicComponent) && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !shared$1.isReservedProp(name)) hasHydrationEventBinding = true;
				if (isEventHandler && shared$1.isReservedProp(name)) hasVnodeHook = true;
				if (isEventHandler && value.type === 14) value = value.arguments[0];
				if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) return;
				if (name === "ref") hasRef = true;
				else if (name === "class") hasClassBinding = true;
				else if (name === "style") hasStyleBinding = true;
				else if (name !== "key" && !dynamicPropNames.includes(name)) dynamicPropNames.push(name);
				if (isComponent$1 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) dynamicPropNames.push(name);
			} else hasDynamicKeys = true;
		};
		for (let i = 0; i < props.length; i++) {
			const prop = props[i];
			if (prop.type === 6) {
				const { loc, name, nameLoc, value } = prop;
				let isStatic = true;
				if (name === "ref") {
					hasRef = true;
					pushRefVForMarker();
					if (value && context.inline) {
						const binding = context.bindingMetadata[value.content];
						if (binding === "setup-let" || binding === "setup-ref" || binding === "setup-maybe-ref") {
							isStatic = false;
							properties.push(createObjectProperty(createSimpleExpression("ref_key", true), createSimpleExpression(value.content, true, value.loc)));
						}
					}
				}
				if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) continue;
				properties.push(createObjectProperty(createSimpleExpression(name, true, nameLoc), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
			} else {
				const { name, arg, exp, loc, modifiers } = prop;
				const isVBind = name === "bind";
				const isVOn = name === "on";
				if (name === "slot") {
					if (!isComponent$1) context.onError(createCompilerError(40, loc));
					continue;
				}
				if (name === "once" || name === "memo") continue;
				if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) continue;
				if (isVOn && ssr) continue;
				if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) shouldUseBlock = true;
				if (isVBind && isStaticArgOf(arg, "ref")) pushRefVForMarker();
				if (!arg && (isVBind || isVOn)) {
					hasDynamicKeys = true;
					if (exp) if (isVBind) {
						{
							pushMergeArg();
							if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
								mergeArgs.unshift(exp);
								continue;
							}
						}
						pushRefVForMarker();
						pushMergeArg();
						mergeArgs.push(exp);
					} else pushMergeArg({
						type: 14,
						loc,
						callee: context.helper(TO_HANDLERS),
						arguments: isComponent$1 ? [exp] : [exp, `true`]
					});
					else context.onError(createCompilerError(isVBind ? 34 : 35, loc));
					continue;
				}
				if (isVBind && modifiers.some((mod) => mod.content === "prop")) patchFlag |= 32;
				const directiveTransform = context.directiveTransforms[name];
				if (directiveTransform) {
					const { props: props2, needRuntime } = directiveTransform(prop, node, context);
					!ssr && props2.forEach(analyzePatchFlag);
					if (isVOn && arg && !isStaticExp(arg)) pushMergeArg(createObjectExpression(props2, elementLoc));
					else properties.push(...props2);
					if (needRuntime) {
						runtimeDirectives.push(prop);
						if (shared$1.isSymbol(needRuntime)) directiveImportMap.set(prop, needRuntime);
					}
				} else if (!shared$1.isBuiltInDirective(name)) {
					runtimeDirectives.push(prop);
					if (hasChildren) shouldUseBlock = true;
				}
			}
		}
		let propsExpression = void 0;
		if (mergeArgs.length) {
			pushMergeArg();
			if (mergeArgs.length > 1) propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
			else propsExpression = mergeArgs[0];
		} else if (properties.length) propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
		if (hasDynamicKeys) patchFlag |= 16;
		else {
			if (hasClassBinding && !isComponent$1) patchFlag |= 2;
			if (hasStyleBinding && !isComponent$1) patchFlag |= 4;
			if (dynamicPropNames.length) patchFlag |= 8;
			if (hasHydrationEventBinding) patchFlag |= 32;
		}
		if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) patchFlag |= 512;
		if (!context.inSSR && propsExpression) switch (propsExpression.type) {
			case 15:
				let classKeyIndex = -1;
				let styleKeyIndex = -1;
				let hasDynamicKey = false;
				for (let i = 0; i < propsExpression.properties.length; i++) {
					const key = propsExpression.properties[i].key;
					if (isStaticExp(key)) {
						if (key.content === "class") classKeyIndex = i;
						else if (key.content === "style") styleKeyIndex = i;
					} else if (!key.isHandlerKey) hasDynamicKey = true;
				}
				const classProp = propsExpression.properties[classKeyIndex];
				const styleProp = propsExpression.properties[styleKeyIndex];
				if (!hasDynamicKey) {
					if (classProp && !isStaticExp(classProp.value)) classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
					if (styleProp && (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || styleProp.value.type === 17)) styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
				} else propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
				break;
			case 14: break;
			default:
				propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [propsExpression])]);
				break;
		}
		return {
			props: propsExpression,
			directives: runtimeDirectives,
			patchFlag,
			dynamicPropNames,
			shouldUseBlock
		};
	}
	function dedupeProperties(properties) {
		const knownProps = /* @__PURE__ */ new Map();
		const deduped = [];
		for (let i = 0; i < properties.length; i++) {
			const prop = properties[i];
			if (prop.key.type === 8 || !prop.key.isStatic) {
				deduped.push(prop);
				continue;
			}
			const name = prop.key.content;
			const existing = knownProps.get(name);
			if (existing) {
				if (name === "style" || name === "class" || shared$1.isOn(name)) mergeAsArray(existing, prop);
			} else {
				knownProps.set(name, prop);
				deduped.push(prop);
			}
		}
		return deduped;
	}
	function mergeAsArray(existing, incoming) {
		if (existing.value.type === 17) existing.value.elements.push(incoming.value);
		else existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
	}
	function buildDirectiveArgs(dir, context) {
		const dirArgs = [];
		const runtime = directiveImportMap.get(dir);
		if (runtime) dirArgs.push(context.helperString(runtime));
		else {
			const fromSetup = resolveSetupReference("v-" + dir.name, context);
			if (fromSetup) dirArgs.push(fromSetup);
			else {
				context.helper(RESOLVE_DIRECTIVE);
				context.directives.add(dir.name);
				dirArgs.push(toValidAssetId(dir.name, `directive`));
			}
		}
		const { loc } = dir;
		if (dir.exp) dirArgs.push(dir.exp);
		if (dir.arg) {
			if (!dir.exp) dirArgs.push(`void 0`);
			dirArgs.push(dir.arg);
		}
		if (Object.keys(dir.modifiers).length) {
			if (!dir.arg) {
				if (!dir.exp) dirArgs.push(`void 0`);
				dirArgs.push(`void 0`);
			}
			const trueExpression = createSimpleExpression(`true`, false, loc);
			dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
		}
		return createArrayExpression(dirArgs, dir.loc);
	}
	function stringifyDynamicPropNames(props) {
		let propsNamesString = `[`;
		for (let i = 0, l = props.length; i < l; i++) {
			propsNamesString += JSON.stringify(props[i]);
			if (i < l - 1) propsNamesString += ", ";
		}
		return propsNamesString + `]`;
	}
	function isComponentTag(tag) {
		return tag === "component" || tag === "Component";
	}
	const transformSlotOutlet = (node, context) => {
		if (isSlotOutlet(node)) {
			const { children, loc } = node;
			const { slotName, slotProps } = processSlotOutlet(node, context);
			const slotArgs = [
				context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
				slotName,
				"{}",
				"undefined",
				"true"
			];
			let expectedLen = 2;
			if (slotProps) {
				slotArgs[2] = slotProps;
				expectedLen = 3;
			}
			if (children.length) {
				slotArgs[3] = createFunctionExpression([], children, false, false, loc);
				expectedLen = 4;
			}
			if (context.scopeId && !context.slotted) expectedLen = 5;
			slotArgs.splice(expectedLen);
			node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
		}
	};
	function processSlotOutlet(node, context) {
		let slotName = `"default"`;
		let slotProps = void 0;
		const nonNameProps = [];
		for (let i = 0; i < node.props.length; i++) {
			const p = node.props[i];
			if (p.type === 6) {
				if (p.value) if (p.name === "name") slotName = JSON.stringify(p.value.content);
				else {
					p.name = shared$1.camelize(p.name);
					nonNameProps.push(p);
				}
			} else if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
				if (p.exp) slotName = p.exp;
				else if (p.arg && p.arg.type === 4) {
					const name = shared$1.camelize(p.arg.content);
					slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
					slotName = p.exp = processExpression(p.exp, context);
				}
			} else {
				if (p.name === "bind" && p.arg && isStaticExp(p.arg)) p.arg.content = shared$1.camelize(p.arg.content);
				nonNameProps.push(p);
			}
		}
		if (nonNameProps.length > 0) {
			const { props, directives } = buildProps(node, context, nonNameProps, false, false);
			slotProps = props;
			if (directives.length) context.onError(createCompilerError(36, directives[0].loc));
		}
		return {
			slotName,
			slotProps
		};
	}
	const transformOn$1 = (dir, node, context, augmentor) => {
		const { loc, modifiers, arg } = dir;
		if (!dir.exp && !modifiers.length) context.onError(createCompilerError(35, loc));
		let eventName;
		if (arg.type === 4) if (arg.isStatic) {
			let rawName = arg.content;
			if (rawName.startsWith("vue:")) rawName = `vnode-${rawName.slice(4)}`;
			const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? shared$1.toHandlerKey(shared$1.camelize(rawName)) : `on:${rawName}`;
			eventName = createSimpleExpression(eventString, true, arg.loc);
		} else eventName = createCompoundExpression([
			`${context.helperString(TO_HANDLER_KEY)}(`,
			arg,
			`)`
		]);
		else {
			eventName = arg;
			eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
			eventName.children.push(`)`);
		}
		let exp = dir.exp;
		if (exp && !exp.content.trim()) exp = void 0;
		let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
		if (exp) {
			const isMemberExp = isMemberExpression(exp, context);
			const isInlineStatement = !(isMemberExp || isFnExpression(exp, context));
			const hasMultipleStatements = exp.content.includes(`;`);
			if (context.prefixIdentifiers) {
				isInlineStatement && context.addIdentifiers(`$event`);
				exp = dir.exp = processExpression(exp, context, false, hasMultipleStatements);
				isInlineStatement && context.removeIdentifiers(`$event`);
				shouldCache = context.cacheHandlers && !context.inVOnce && !(exp.type === 4 && exp.constType > 0) && !(isMemberExp && node.tagType === 1) && !hasScopeRef(exp, context.identifiers);
				if (shouldCache && isMemberExp) if (exp.type === 4) exp.content = `${exp.content} && ${exp.content}(...args)`;
				else exp.children = [
					...exp.children,
					` && `,
					...exp.children,
					`(...args)`
				];
			}
			if (isInlineStatement || shouldCache && isMemberExp) exp = createCompoundExpression([
				`${isInlineStatement ? context.isTS ? `($event: any)` : `$event` : `${context.isTS ? `
//@ts-ignore
` : ``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
				exp,
				hasMultipleStatements ? `}` : `)`
			]);
		}
		let ret = { props: [createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))] };
		if (augmentor) ret = augmentor(ret);
		if (shouldCache) ret.props[0].value = context.cache(ret.props[0].value);
		ret.props.forEach((p) => p.key.isHandlerKey = true);
		return ret;
	};
	const transformBind = (dir, _node, context) => {
		const { modifiers, loc } = dir;
		const arg = dir.arg;
		let { exp } = dir;
		if (exp && exp.type === 4 && !exp.content.trim()) {
			context.onError(createCompilerError(34, loc));
			return { props: [createObjectProperty(arg, createSimpleExpression("", true, loc))] };
		}
		if (arg.type !== 4) {
			arg.children.unshift(`(`);
			arg.children.push(`) || ""`);
		} else if (!arg.isStatic) arg.content = arg.content ? `${arg.content} || ""` : `""`;
		if (modifiers.some((mod) => mod.content === "camel")) if (arg.type === 4) if (arg.isStatic) arg.content = shared$1.camelize(arg.content);
		else arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
		else {
			arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
			arg.children.push(`)`);
		}
		if (!context.inSSR) {
			if (modifiers.some((mod) => mod.content === "prop")) injectPrefix(arg, ".");
			if (modifiers.some((mod) => mod.content === "attr")) injectPrefix(arg, "^");
		}
		return { props: [createObjectProperty(arg, exp)] };
	};
	const injectPrefix = (arg, prefix$1) => {
		if (arg.type === 4) if (arg.isStatic) arg.content = prefix$1 + arg.content;
		else arg.content = `\`${prefix$1}\${${arg.content}}\``;
		else {
			arg.children.unshift(`'${prefix$1}' + (`);
			arg.children.push(`)`);
		}
	};
	const transformText = (node, context) => {
		if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) return () => {
			const children = node.children;
			let currentContainer = void 0;
			let hasText = false;
			for (let i = 0; i < children.length; i++) {
				const child = children[i];
				if (isText$1(child)) {
					hasText = true;
					for (let j = i + 1; j < children.length; j++) {
						const next = children[j];
						if (isText$1(next)) {
							if (!currentContainer) currentContainer = children[i] = createCompoundExpression([child], child.loc);
							currentContainer.children.push(` + `, next);
							children.splice(j, 1);
							j--;
						} else {
							currentContainer = void 0;
							break;
						}
					}
				}
			}
			if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p) => p.type === 7 && !context.directiveTransforms[p.name]) && !(node.tag === "template"))) return;
			for (let i = 0; i < children.length; i++) {
				const child = children[i];
				if (isText$1(child) || child.type === 8) {
					const callArgs = [];
					if (child.type !== 2 || child.content !== " ") callArgs.push(child);
					if (!context.ssr && getConstantType(child, context) === 0) callArgs.push("1");
					children[i] = {
						type: 12,
						content: child,
						loc: child.loc,
						codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
					};
				}
			}
		};
	};
	const seen$1 = /* @__PURE__ */ new WeakSet();
	const transformOnce = (node, context) => {
		if (node.type === 1 && findDir(node, "once", true)) {
			if (seen$1.has(node) || context.inVOnce || context.inSSR) return;
			seen$1.add(node);
			context.inVOnce = true;
			context.helper(SET_BLOCK_TRACKING);
			return () => {
				context.inVOnce = false;
				const cur = context.currentNode;
				if (cur.codegenNode) cur.codegenNode = context.cache(cur.codegenNode, true, true);
			};
		}
	};
	const transformModel$1 = (dir, node, context) => {
		const { exp, arg } = dir;
		if (!exp) {
			context.onError(createCompilerError(41, dir.loc));
			return createTransformProps();
		}
		const rawExp = exp.loc.source.trim();
		const expString = exp.type === 4 ? exp.content : rawExp;
		const bindingType = context.bindingMetadata[rawExp];
		if (bindingType === "props" || bindingType === "props-aliased") {
			context.onError(createCompilerError(44, exp.loc));
			return createTransformProps();
		}
		const maybeRef = context.inline && (bindingType === "setup-let" || bindingType === "setup-ref" || bindingType === "setup-maybe-ref");
		if (!expString.trim() || !isMemberExpression(exp, context) && !maybeRef) {
			context.onError(createCompilerError(42, exp.loc));
			return createTransformProps();
		}
		if (context.prefixIdentifiers && isSimpleIdentifier(expString) && context.identifiers[expString]) {
			context.onError(createCompilerError(43, exp.loc));
			return createTransformProps();
		}
		const propName = arg ? arg : createSimpleExpression("modelValue", true);
		const eventName = arg ? isStaticExp(arg) ? `onUpdate:${shared$1.camelize(arg.content)}` : createCompoundExpression(["\"onUpdate:\" + ", arg]) : `onUpdate:modelValue`;
		let assignmentExp;
		const eventArg = context.isTS ? `($event: any)` : `$event`;
		if (maybeRef) if (bindingType === "setup-ref") assignmentExp = createCompoundExpression([
			`${eventArg} => ((`,
			createSimpleExpression(rawExp, false, exp.loc),
			`).value = $event)`
		]);
		else {
			const altAssignment = bindingType === "setup-let" ? `${rawExp} = $event` : `null`;
			assignmentExp = createCompoundExpression([
				`${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,
				createSimpleExpression(rawExp, false, exp.loc),
				`).value = $event : ${altAssignment})`
			]);
		}
		else assignmentExp = createCompoundExpression([
			`${eventArg} => ((`,
			exp,
			`) = $event)`
		]);
		const props = [createObjectProperty(propName, dir.exp), createObjectProperty(eventName, assignmentExp)];
		if (context.prefixIdentifiers && !context.inVOnce && context.cacheHandlers && !hasScopeRef(exp, context.identifiers)) props[1].value = context.cache(props[1].value);
		if (dir.modifiers.length && node.tagType === 1) {
			const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
			const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, " + \"Modifiers\""]) : `modelModifiers`;
			props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
		}
		return createTransformProps(props);
	};
	function createTransformProps(props = []) {
		return { props };
	}
	const validDivisionCharRE = /[\w).+\-_$\]]/;
	const transformFilter = (node, context) => {
		if (!isCompatEnabled("COMPILER_FILTERS", context)) return;
		if (node.type === 5) rewriteFilter(node.content, context);
		else if (node.type === 1) node.props.forEach((prop) => {
			if (prop.type === 7 && prop.name !== "for" && prop.exp) rewriteFilter(prop.exp, context);
		});
	};
	function rewriteFilter(node, context) {
		if (node.type === 4) parseFilter(node, context);
		else for (let i = 0; i < node.children.length; i++) {
			const child = node.children[i];
			if (typeof child !== "object") continue;
			if (child.type === 4) parseFilter(child, context);
			else if (child.type === 8) rewriteFilter(node, context);
			else if (child.type === 5) rewriteFilter(child.content, context);
		}
	}
	function parseFilter(node, context) {
		const exp = node.content;
		let inSingle = false;
		let inDouble = false;
		let inTemplateString = false;
		let inRegex = false;
		let curly = 0;
		let square = 0;
		let paren = 0;
		let lastFilterIndex = 0;
		let c, prev, i, expression, filters = [];
		for (i = 0; i < exp.length; i++) {
			prev = c;
			c = exp.charCodeAt(i);
			if (inSingle) {
				if (c === 39 && prev !== 92) inSingle = false;
			} else if (inDouble) {
				if (c === 34 && prev !== 92) inDouble = false;
			} else if (inTemplateString) {
				if (c === 96 && prev !== 92) inTemplateString = false;
			} else if (inRegex) {
				if (c === 47 && prev !== 92) inRegex = false;
			} else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) if (expression === void 0) {
				lastFilterIndex = i + 1;
				expression = exp.slice(0, i).trim();
			} else pushFilter();
			else {
				switch (c) {
					case 34:
						inDouble = true;
						break;
					case 39:
						inSingle = true;
						break;
					case 96:
						inTemplateString = true;
						break;
					case 40:
						paren++;
						break;
					case 41:
						paren--;
						break;
					case 91:
						square++;
						break;
					case 93:
						square--;
						break;
					case 123:
						curly++;
						break;
					case 125:
						curly--;
						break;
				}
				if (c === 47) {
					let j = i - 1;
					let p;
					for (; j >= 0; j--) {
						p = exp.charAt(j);
						if (p !== " ") break;
					}
					if (!p || !validDivisionCharRE.test(p)) inRegex = true;
				}
			}
		}
		if (expression === void 0) expression = exp.slice(0, i).trim();
		else if (lastFilterIndex !== 0) pushFilter();
		function pushFilter() {
			filters.push(exp.slice(lastFilterIndex, i).trim());
			lastFilterIndex = i + 1;
		}
		if (filters.length) {
			for (i = 0; i < filters.length; i++) expression = wrapFilter(expression, filters[i], context);
			node.content = expression;
			node.ast = void 0;
		}
	}
	function wrapFilter(exp, filter, context) {
		context.helper(RESOLVE_FILTER);
		const i = filter.indexOf("(");
		if (i < 0) {
			context.filters.add(filter);
			return `${toValidAssetId(filter, "filter")}(${exp})`;
		} else {
			const name = filter.slice(0, i);
			const args = filter.slice(i + 1);
			context.filters.add(name);
			return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
		}
	}
	const seen = /* @__PURE__ */ new WeakSet();
	const transformMemo = (node, context) => {
		if (node.type === 1) {
			const dir = findDir(node, "memo");
			if (!dir || seen.has(node) || context.inSSR) return;
			seen.add(node);
			return () => {
				const codegenNode = node.codegenNode || context.currentNode.codegenNode;
				if (codegenNode && codegenNode.type === 13) {
					if (node.tagType !== 1) convertToBlock(codegenNode, context);
					node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
						dir.exp,
						createFunctionExpression(void 0, codegenNode),
						`_cache`,
						String(context.cached.length)
					]);
					context.cached.push(null);
				}
			};
		}
	};
	const transformVBindShorthand = (node, context) => {
		if (node.type === 1) {
			for (const prop of node.props) if (prop.type === 7 && prop.name === "bind" && !prop.exp) {
				const arg = prop.arg;
				if (arg.type !== 4 || !arg.isStatic) {
					context.onError(createCompilerError(52, arg.loc));
					prop.exp = createSimpleExpression("", true, arg.loc);
				} else {
					const propName = shared$1.camelize(arg.content);
					if (validFirstIdentCharRE.test(propName[0]) || propName[0] === "-") prop.exp = createSimpleExpression(propName, false, arg.loc);
				}
			}
		}
	};
	function getBaseTransformPreset(prefixIdentifiers) {
		return [[
			transformVBindShorthand,
			transformOnce,
			transformIf,
			transformMemo,
			transformFor,
			...[transformFilter],
			...prefixIdentifiers ? [trackVForSlotScopes, transformExpression] : [],
			transformSlotOutlet,
			transformElement,
			trackSlotScopes,
			transformText
		], {
			on: transformOn$1,
			bind: transformBind,
			model: transformModel$1
		}];
	}
	function baseCompile(source, options = {}) {
		const onError = options.onError || defaultOnError;
		const isModuleMode = options.mode === "module";
		const prefixIdentifiers = options.prefixIdentifiers === true || isModuleMode;
		if (!prefixIdentifiers && options.cacheHandlers) onError(createCompilerError(49));
		if (options.scopeId && !isModuleMode) onError(createCompilerError(50));
		const resolvedOptions = shared$1.extend({}, options, { prefixIdentifiers });
		const ast = shared$1.isString(source) ? baseParse(source, resolvedOptions) : source;
		const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers);
		if (options.isTS) {
			const { expressionPlugins } = options;
			if (!expressionPlugins || !expressionPlugins.includes("typescript")) options.expressionPlugins = [...expressionPlugins || [], "typescript"];
		}
		transform(ast, shared$1.extend({}, resolvedOptions, {
			nodeTransforms: [...nodeTransforms, ...options.nodeTransforms || []],
			directiveTransforms: shared$1.extend({}, directiveTransforms, options.directiveTransforms || {})
		}));
		return generate$3(ast, resolvedOptions);
	}
	const BindingTypes = {
		"DATA": "data",
		"PROPS": "props",
		"PROPS_ALIASED": "props-aliased",
		"SETUP_LET": "setup-let",
		"SETUP_CONST": "setup-const",
		"SETUP_REACTIVE_CONST": "setup-reactive-const",
		"SETUP_MAYBE_REF": "setup-maybe-ref",
		"SETUP_REF": "setup-ref",
		"OPTIONS": "options",
		"LITERAL_CONST": "literal-const"
	};
	const noopDirectiveTransform = () => ({ props: [] });
	exports.generateCodeFrame = shared$1.generateCodeFrame;
	exports.BASE_TRANSITION = BASE_TRANSITION;
	exports.BindingTypes = BindingTypes;
	exports.CAMELIZE = CAMELIZE;
	exports.CAPITALIZE = CAPITALIZE;
	exports.CREATE_BLOCK = CREATE_BLOCK;
	exports.CREATE_COMMENT = CREATE_COMMENT;
	exports.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK;
	exports.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE;
	exports.CREATE_SLOTS = CREATE_SLOTS;
	exports.CREATE_STATIC = CREATE_STATIC;
	exports.CREATE_TEXT = CREATE_TEXT;
	exports.CREATE_VNODE = CREATE_VNODE;
	exports.CompilerDeprecationTypes = CompilerDeprecationTypes;
	exports.ConstantTypes = ConstantTypes;
	exports.ElementTypes = ElementTypes;
	exports.ErrorCodes = ErrorCodes;
	exports.FRAGMENT = FRAGMENT;
	exports.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS;
	exports.IS_MEMO_SAME = IS_MEMO_SAME;
	exports.IS_REF = IS_REF;
	exports.KEEP_ALIVE = KEEP_ALIVE;
	exports.MERGE_PROPS = MERGE_PROPS;
	exports.NORMALIZE_CLASS = NORMALIZE_CLASS;
	exports.NORMALIZE_PROPS = NORMALIZE_PROPS;
	exports.NORMALIZE_STYLE = NORMALIZE_STYLE;
	exports.Namespaces = Namespaces;
	exports.NodeTypes = NodeTypes;
	exports.OPEN_BLOCK = OPEN_BLOCK;
	exports.POP_SCOPE_ID = POP_SCOPE_ID;
	exports.PUSH_SCOPE_ID = PUSH_SCOPE_ID;
	exports.RENDER_LIST = RENDER_LIST;
	exports.RENDER_SLOT = RENDER_SLOT;
	exports.RESOLVE_COMPONENT = RESOLVE_COMPONENT;
	exports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;
	exports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;
	exports.RESOLVE_FILTER = RESOLVE_FILTER;
	exports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;
	exports.SUSPENSE = SUSPENSE;
	exports.TELEPORT = TELEPORT;
	exports.TO_DISPLAY_STRING = TO_DISPLAY_STRING;
	exports.TO_HANDLERS = TO_HANDLERS;
	exports.TO_HANDLER_KEY = TO_HANDLER_KEY;
	exports.TS_NODE_TYPES = TS_NODE_TYPES;
	exports.UNREF = UNREF;
	exports.WITH_CTX = WITH_CTX;
	exports.WITH_DIRECTIVES = WITH_DIRECTIVES;
	exports.WITH_MEMO = WITH_MEMO;
	exports.advancePositionWithClone = advancePositionWithClone;
	exports.advancePositionWithMutation = advancePositionWithMutation;
	exports.assert = assert;
	exports.baseCompile = baseCompile;
	exports.baseParse = baseParse;
	exports.buildDirectiveArgs = buildDirectiveArgs;
	exports.buildProps = buildProps;
	exports.buildSlots = buildSlots;
	exports.checkCompatEnabled = checkCompatEnabled;
	exports.convertToBlock = convertToBlock;
	exports.createArrayExpression = createArrayExpression;
	exports.createAssignmentExpression = createAssignmentExpression;
	exports.createBlockStatement = createBlockStatement;
	exports.createCacheExpression = createCacheExpression;
	exports.createCallExpression = createCallExpression;
	exports.createCompilerError = createCompilerError;
	exports.createCompoundExpression = createCompoundExpression;
	exports.createConditionalExpression = createConditionalExpression;
	exports.createForLoopParams = createForLoopParams;
	exports.createFunctionExpression = createFunctionExpression;
	exports.createIfStatement = createIfStatement;
	exports.createInterpolation = createInterpolation;
	exports.createObjectExpression = createObjectExpression;
	exports.createObjectProperty = createObjectProperty;
	exports.createReturnStatement = createReturnStatement;
	exports.createRoot = createRoot;
	exports.createSequenceExpression = createSequenceExpression;
	exports.createSimpleExpression = createSimpleExpression;
	exports.createStructuralDirectiveTransform = createStructuralDirectiveTransform;
	exports.createTemplateLiteral = createTemplateLiteral;
	exports.createTransformContext = createTransformContext;
	exports.createVNodeCall = createVNodeCall;
	exports.errorMessages = errorMessages;
	exports.extractIdentifiers = extractIdentifiers;
	exports.findDir = findDir;
	exports.findProp = findProp;
	exports.forAliasRE = forAliasRE;
	exports.generate = generate$3;
	exports.getBaseTransformPreset = getBaseTransformPreset;
	exports.getConstantType = getConstantType;
	exports.getMemoedVNodeCall = getMemoedVNodeCall;
	exports.getVNodeBlockHelper = getVNodeBlockHelper;
	exports.getVNodeHelper = getVNodeHelper;
	exports.hasDynamicKeyVBind = hasDynamicKeyVBind;
	exports.hasScopeRef = hasScopeRef;
	exports.helperNameMap = helperNameMap;
	exports.injectProp = injectProp;
	exports.isCoreComponent = isCoreComponent;
	exports.isFnExpression = isFnExpression;
	exports.isFnExpressionBrowser = isFnExpressionBrowser;
	exports.isFnExpressionNode = isFnExpressionNode;
	exports.isFunctionType = isFunctionType;
	exports.isInDestructureAssignment = isInDestructureAssignment;
	exports.isInNewExpression = isInNewExpression;
	exports.isMemberExpression = isMemberExpression;
	exports.isMemberExpressionBrowser = isMemberExpressionBrowser;
	exports.isMemberExpressionNode = isMemberExpressionNode;
	exports.isReferencedIdentifier = isReferencedIdentifier;
	exports.isSimpleIdentifier = isSimpleIdentifier;
	exports.isSlotOutlet = isSlotOutlet;
	exports.isStaticArgOf = isStaticArgOf;
	exports.isStaticExp = isStaticExp;
	exports.isStaticProperty = isStaticProperty;
	exports.isStaticPropertyKey = isStaticPropertyKey;
	exports.isTemplateNode = isTemplateNode;
	exports.isText = isText$1;
	exports.isVPre = isVPre;
	exports.isVSlot = isVSlot;
	exports.locStub = locStub;
	exports.noopDirectiveTransform = noopDirectiveTransform;
	exports.processExpression = processExpression;
	exports.processFor = processFor;
	exports.processIf = processIf;
	exports.processSlotOutlet = processSlotOutlet;
	exports.registerRuntimeHelpers = registerRuntimeHelpers;
	exports.resolveComponentType = resolveComponentType;
	exports.stringifyExpression = stringifyExpression;
	exports.toValidAssetId = toValidAssetId;
	exports.trackSlotScopes = trackSlotScopes;
	exports.trackVForSlotScopes = trackVForSlotScopes;
	exports.transform = transform;
	exports.transformBind = transformBind;
	exports.transformElement = transformElement;
	exports.transformExpression = transformExpression;
	exports.transformModel = transformModel$1;
	exports.transformOn = transformOn$1;
	exports.transformVBindShorthand = transformVBindShorthand;
	exports.traverseNode = traverseNode;
	exports.unwrapTSNode = unwrapTSNode;
	exports.validFirstIdentCharRE = validFirstIdentCharRE;
	exports.walkBlockDeclarations = walkBlockDeclarations;
	exports.walkFunctionParams = walkFunctionParams;
	exports.walkIdentifiers = walkIdentifiers$1;
	exports.warnDeprecation = warnDeprecation;
} });

//#endregion
//#region node_modules/@vue/compiler-core/index.js
var require_compiler_core = __commonJS({ "node_modules/@vue/compiler-core/index.js"(exports, module) {
	module.exports = require_compiler_core_cjs_prod();
} });

//#endregion
//#region node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.prod.js
var require_compiler_dom_cjs_prod = __commonJS({ "node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.prod.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var compilerCore = require_compiler_core();
	var shared = require_shared$2();
	const V_MODEL_RADIO = Symbol(``);
	const V_MODEL_CHECKBOX = Symbol(``);
	const V_MODEL_TEXT = Symbol(``);
	const V_MODEL_SELECT = Symbol(``);
	const V_MODEL_DYNAMIC = Symbol(``);
	const V_ON_WITH_MODIFIERS = Symbol(``);
	const V_ON_WITH_KEYS = Symbol(``);
	const V_SHOW = Symbol(``);
	const TRANSITION = Symbol(``);
	const TRANSITION_GROUP = Symbol(``);
	compilerCore.registerRuntimeHelpers({
		[V_MODEL_RADIO]: `vModelRadio`,
		[V_MODEL_CHECKBOX]: `vModelCheckbox`,
		[V_MODEL_TEXT]: `vModelText`,
		[V_MODEL_SELECT]: `vModelSelect`,
		[V_MODEL_DYNAMIC]: `vModelDynamic`,
		[V_ON_WITH_MODIFIERS]: `withModifiers`,
		[V_ON_WITH_KEYS]: `withKeys`,
		[V_SHOW]: `vShow`,
		[TRANSITION]: `Transition`,
		[TRANSITION_GROUP]: `TransitionGroup`
	});
	const parserOptions = {
		parseMode: "html",
		isVoidTag: shared.isVoidTag,
		isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag) || shared.isMathMLTag(tag),
		isPreTag: (tag) => tag === "pre",
		isIgnoreNewlineTag: (tag) => tag === "pre" || tag === "textarea",
		decodeEntities: void 0,
		isBuiltInComponent: (tag) => {
			if (tag === "Transition" || tag === "transition") return TRANSITION;
			else if (tag === "TransitionGroup" || tag === "transition-group") return TRANSITION_GROUP;
		},
		getNamespace(tag, parent, rootNamespace) {
			let ns = parent ? parent.ns : rootNamespace;
			if (parent && ns === 2) {
				if (parent.tag === "annotation-xml") {
					if (tag === "svg") return 1;
					if (parent.props.some((a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) ns = 0;
				} else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") ns = 0;
			} else if (parent && ns === 1) {
				if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") ns = 0;
			}
			if (ns === 0) {
				if (tag === "svg") return 1;
				if (tag === "math") return 2;
			}
			return ns;
		}
	};
	const transformStyle = (node) => {
		if (node.type === 1) node.props.forEach((p, i) => {
			if (p.type === 6 && p.name === "style" && p.value) node.props[i] = {
				type: 7,
				name: `bind`,
				arg: compilerCore.createSimpleExpression(`style`, true, p.loc),
				exp: parseInlineCSS(p.value.content, p.loc),
				modifiers: [],
				loc: p.loc
			};
		});
	};
	const parseInlineCSS = (cssText, loc) => {
		const normalized = shared.parseStringStyle(cssText);
		return compilerCore.createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
	};
	function createDOMCompilerError(code$1, loc) {
		return compilerCore.createCompilerError(code$1, loc, DOMErrorMessages);
	}
	const DOMErrorCodes = {
		"X_V_HTML_NO_EXPRESSION": 53,
		"53": "X_V_HTML_NO_EXPRESSION",
		"X_V_HTML_WITH_CHILDREN": 54,
		"54": "X_V_HTML_WITH_CHILDREN",
		"X_V_TEXT_NO_EXPRESSION": 55,
		"55": "X_V_TEXT_NO_EXPRESSION",
		"X_V_TEXT_WITH_CHILDREN": 56,
		"56": "X_V_TEXT_WITH_CHILDREN",
		"X_V_MODEL_ON_INVALID_ELEMENT": 57,
		"57": "X_V_MODEL_ON_INVALID_ELEMENT",
		"X_V_MODEL_ARG_ON_ELEMENT": 58,
		"58": "X_V_MODEL_ARG_ON_ELEMENT",
		"X_V_MODEL_ON_FILE_INPUT_ELEMENT": 59,
		"59": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
		"X_V_MODEL_UNNECESSARY_VALUE": 60,
		"60": "X_V_MODEL_UNNECESSARY_VALUE",
		"X_V_SHOW_NO_EXPRESSION": 61,
		"61": "X_V_SHOW_NO_EXPRESSION",
		"X_TRANSITION_INVALID_CHILDREN": 62,
		"62": "X_TRANSITION_INVALID_CHILDREN",
		"X_IGNORED_SIDE_EFFECT_TAG": 63,
		"63": "X_IGNORED_SIDE_EFFECT_TAG",
		"__EXTEND_POINT__": 64,
		"64": "__EXTEND_POINT__"
	};
	const DOMErrorMessages = {
		[53]: `v-html is missing expression.`,
		[54]: `v-html will override element children.`,
		[55]: `v-text is missing expression.`,
		[56]: `v-text will override element children.`,
		[57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
		[58]: `v-model argument is not supported on plain elements.`,
		[59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
		[60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
		[61]: `v-show is missing expression.`,
		[62]: `<Transition> expects exactly one child element or component.`,
		[63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
	};
	const transformVHtml = (dir, node, context) => {
		const { exp, loc } = dir;
		if (!exp) context.onError(createDOMCompilerError(53, loc));
		if (node.children.length) {
			context.onError(createDOMCompilerError(54, loc));
			node.children.length = 0;
		}
		return { props: [compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`innerHTML`, true, loc), exp || compilerCore.createSimpleExpression("", true))] };
	};
	const transformVText = (dir, node, context) => {
		const { exp, loc } = dir;
		if (!exp) context.onError(createDOMCompilerError(55, loc));
		if (node.children.length) {
			context.onError(createDOMCompilerError(56, loc));
			node.children.length = 0;
		}
		return { props: [compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`textContent`, true), exp ? compilerCore.getConstantType(exp, context) > 0 ? exp : compilerCore.createCallExpression(context.helperString(compilerCore.TO_DISPLAY_STRING), [exp], loc) : compilerCore.createSimpleExpression("", true))] };
	};
	const transformModel = (dir, node, context) => {
		const baseResult = compilerCore.transformModel(dir, node, context);
		if (!baseResult.props.length || node.tagType === 1) return baseResult;
		if (dir.arg) context.onError(createDOMCompilerError(58, dir.arg.loc));
		const { tag } = node;
		const isCustomElement = context.isCustomElement(tag);
		if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
			let directiveToUse = V_MODEL_TEXT;
			let isInvalidType = false;
			if (tag === "input" || isCustomElement) {
				const type = compilerCore.findProp(node, `type`);
				if (type) {
					if (type.type === 7) directiveToUse = V_MODEL_DYNAMIC;
					else if (type.value) switch (type.value.content) {
						case "radio":
							directiveToUse = V_MODEL_RADIO;
							break;
						case "checkbox":
							directiveToUse = V_MODEL_CHECKBOX;
							break;
						case "file":
							isInvalidType = true;
							context.onError(createDOMCompilerError(59, dir.loc));
							break;
					}
				} else if (compilerCore.hasDynamicKeyVBind(node)) directiveToUse = V_MODEL_DYNAMIC;
			} else if (tag === "select") directiveToUse = V_MODEL_SELECT;
			if (!isInvalidType) baseResult.needRuntime = context.helper(directiveToUse);
		} else context.onError(createDOMCompilerError(57, dir.loc));
		baseResult.props = baseResult.props.filter((p) => !(p.key.type === 4 && p.key.content === "modelValue"));
		return baseResult;
	};
	const isEventOptionModifier = /* @__PURE__ */ shared.makeMap(`passive,once,capture`);
	const isNonKeyModifier = /* @__PURE__ */ shared.makeMap(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
	const maybeKeyModifier = /* @__PURE__ */ shared.makeMap("left,right");
	const isKeyboardEvent = /* @__PURE__ */ shared.makeMap(`onkeyup,onkeydown,onkeypress`);
	const resolveModifiers = (key, modifiers, context, loc) => {
		const keyModifiers = [];
		const nonKeyModifiers = [];
		const eventOptionModifiers = [];
		for (let i = 0; i < modifiers.length; i++) {
			const modifier = modifiers[i].content;
			if (modifier === "native" && compilerCore.checkCompatEnabled("COMPILER_V_ON_NATIVE", context, loc)) eventOptionModifiers.push(modifier);
			else if (isEventOptionModifier(modifier)) eventOptionModifiers.push(modifier);
			else if (maybeKeyModifier(modifier)) if (compilerCore.isStaticExp(key)) if (isKeyboardEvent(key.content.toLowerCase())) keyModifiers.push(modifier);
			else nonKeyModifiers.push(modifier);
			else {
				keyModifiers.push(modifier);
				nonKeyModifiers.push(modifier);
			}
			else if (isNonKeyModifier(modifier)) nonKeyModifiers.push(modifier);
			else keyModifiers.push(modifier);
		}
		return {
			keyModifiers,
			nonKeyModifiers,
			eventOptionModifiers
		};
	};
	const transformClick = (key, event) => {
		const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === "onclick";
		return isStaticClick ? compilerCore.createSimpleExpression(event, true) : key.type !== 4 ? compilerCore.createCompoundExpression([
			`(`,
			key,
			`) === "onClick" ? "${event}" : (`,
			key,
			`)`
		]) : key;
	};
	const transformOn = (dir, node, context) => {
		return compilerCore.transformOn(dir, node, context, (baseResult) => {
			const { modifiers } = dir;
			if (!modifiers.length) return baseResult;
			let { key, value: handlerExp } = baseResult.props[0];
			const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
			if (nonKeyModifiers.includes("right")) key = transformClick(key, `onContextmenu`);
			if (nonKeyModifiers.includes("middle")) key = transformClick(key, `onMouseup`);
			if (nonKeyModifiers.length) handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [handlerExp, JSON.stringify(nonKeyModifiers)]);
			if (keyModifiers.length && (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content.toLowerCase()))) handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_KEYS), [handlerExp, JSON.stringify(keyModifiers)]);
			if (eventOptionModifiers.length) {
				const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join("");
				key = compilerCore.isStaticExp(key) ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true) : compilerCore.createCompoundExpression([
					`(`,
					key,
					`) + "${modifierPostfix}"`
				]);
			}
			return { props: [compilerCore.createObjectProperty(key, handlerExp)] };
		});
	};
	const transformShow = (dir, node, context) => {
		const { exp, loc } = dir;
		if (!exp) context.onError(createDOMCompilerError(61, loc));
		return {
			props: [],
			needRuntime: context.helper(V_SHOW)
		};
	};
	const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
	const stringifyStatic = (children, context, parent) => {
		if (context.scopes.vSlot > 0) return;
		const isParentCached = parent.type === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !shared.isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 20;
		let nc = 0;
		let ec = 0;
		const currentChunk = [];
		const stringifyCurrentChunk = (currentIndex) => {
			if (nc >= 20 || ec >= 5) {
				const staticCall = compilerCore.createCallExpression(context.helper(compilerCore.CREATE_STATIC), [JSON.stringify(currentChunk.map((node) => stringifyNode(node, context)).join("")).replace(expReplaceRE, `" + $1 + "`), String(currentChunk.length)]);
				const deleteCount = currentChunk.length - 1;
				if (isParentCached) children.splice(currentIndex - currentChunk.length, currentChunk.length, staticCall);
				else {
					currentChunk[0].codegenNode.value = staticCall;
					if (currentChunk.length > 1) {
						children.splice(currentIndex - currentChunk.length + 1, deleteCount);
						const cacheIndex = context.cached.indexOf(currentChunk[currentChunk.length - 1].codegenNode);
						if (cacheIndex > -1) {
							for (let i2 = cacheIndex; i2 < context.cached.length; i2++) {
								const c = context.cached[i2];
								if (c) c.index -= deleteCount;
							}
							context.cached.splice(cacheIndex - deleteCount + 1, deleteCount);
						}
					}
				}
				return deleteCount;
			}
			return 0;
		};
		let i = 0;
		for (; i < children.length; i++) {
			const child = children[i];
			const isCached = isParentCached || getCachedNode(child);
			if (isCached) {
				const result = analyzeNode(child);
				if (result) {
					nc += result[0];
					ec += result[1];
					currentChunk.push(child);
					continue;
				}
			}
			i -= stringifyCurrentChunk(i);
			nc = 0;
			ec = 0;
			currentChunk.length = 0;
		}
		stringifyCurrentChunk(i);
	};
	const getCachedNode = (node) => {
		if ((node.type === 1 && node.tagType === 0 || node.type === 12) && node.codegenNode && node.codegenNode.type === 20) return node.codegenNode;
	};
	const dataAriaRE = /^(?:data|aria)-/;
	const isStringifiableAttr = (name, ns) => {
		return (ns === 0 ? shared.isKnownHtmlAttr(name) : ns === 1 ? shared.isKnownSvgAttr(name) : ns === 2 ? shared.isKnownMathMLAttr(name) : false) || dataAriaRE.test(name);
	};
	const isNonStringifiable = /* @__PURE__ */ shared.makeMap(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);
	function analyzeNode(node) {
		if (node.type === 1 && isNonStringifiable(node.tag)) return false;
		if (node.type === 1 && compilerCore.findDir(node, "once", true)) return false;
		if (node.type === 12) return [1, 0];
		let nc = 1;
		let ec = node.props.length > 0 ? 1 : 0;
		let bailed = false;
		const bail = () => {
			bailed = true;
			return false;
		};
		function walk$1(node2) {
			const isOptionTag = node2.tag === "option" && node2.ns === 0;
			for (let i = 0; i < node2.props.length; i++) {
				const p = node2.props[i];
				if (p.type === 6 && !isStringifiableAttr(p.name, node2.ns)) return bail();
				if (p.type === 7 && p.name === "bind") {
					if (p.arg && (p.arg.type === 8 || p.arg.isStatic && !isStringifiableAttr(p.arg.content, node2.ns))) return bail();
					if (p.exp && (p.exp.type === 8 || p.exp.constType < 3)) return bail();
					if (isOptionTag && compilerCore.isStaticArgOf(p.arg, "value") && p.exp && !p.exp.isStatic) return bail();
				}
			}
			for (let i = 0; i < node2.children.length; i++) {
				nc++;
				const child = node2.children[i];
				if (child.type === 1) {
					if (child.props.length > 0) ec++;
					walk$1(child);
					if (bailed) return false;
				}
			}
			return true;
		}
		return walk$1(node) ? [nc, ec] : false;
	}
	function stringifyNode(node, context) {
		if (shared.isString(node)) return node;
		if (shared.isSymbol(node)) return ``;
		switch (node.type) {
			case 1: return stringifyElement(node, context);
			case 2: return shared.escapeHtml(node.content);
			case 3: return `<!--${shared.escapeHtml(node.content)}-->`;
			case 5: return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));
			case 8: return shared.escapeHtml(evaluateConstant(node));
			case 12: return stringifyNode(node.content, context);
			default: return "";
		}
	}
	function stringifyElement(node, context) {
		let res = `<${node.tag}`;
		let innerHTML = "";
		for (let i = 0; i < node.props.length; i++) {
			const p = node.props[i];
			if (p.type === 6) {
				res += ` ${p.name}`;
				if (p.value) res += `="${shared.escapeHtml(p.value.content)}"`;
			} else if (p.type === 7) {
				if (p.name === "bind") {
					const exp = p.exp;
					if (exp.content[0] === "_") {
						res += ` ${p.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`;
						continue;
					}
					if (shared.isBooleanAttr(p.arg.content) && exp.content === "false") continue;
					let evaluated = evaluateConstant(exp);
					if (evaluated != null) {
						const arg = p.arg && p.arg.content;
						if (arg === "class") evaluated = shared.normalizeClass(evaluated);
						else if (arg === "style") evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));
						res += ` ${p.arg.content}="${shared.escapeHtml(evaluated)}"`;
					}
				} else if (p.name === "html") innerHTML = evaluateConstant(p.exp);
				else if (p.name === "text") innerHTML = shared.escapeHtml(shared.toDisplayString(evaluateConstant(p.exp)));
			}
		}
		if (context.scopeId) res += ` ${context.scopeId}`;
		res += `>`;
		if (innerHTML) res += innerHTML;
		else for (let i = 0; i < node.children.length; i++) res += stringifyNode(node.children[i], context);
		if (!shared.isVoidTag(node.tag)) res += `</${node.tag}>`;
		return res;
	}
	function evaluateConstant(exp) {
		if (exp.type === 4) return new Function(`return (${exp.content})`)();
		else {
			let res = ``;
			exp.children.forEach((c) => {
				if (shared.isString(c) || shared.isSymbol(c)) return;
				if (c.type === 2) res += c.content;
				else if (c.type === 5) res += shared.toDisplayString(evaluateConstant(c.content));
				else res += evaluateConstant(c);
			});
			return res;
		}
	}
	const ignoreSideEffectTags = (node, context) => {
		if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) context.removeNode();
	};
	const DOMNodeTransforms = [transformStyle, ...[]];
	const DOMDirectiveTransforms = {
		cloak: compilerCore.noopDirectiveTransform,
		html: transformVHtml,
		text: transformVText,
		model: transformModel,
		on: transformOn,
		show: transformShow
	};
	function compile(src, options = {}) {
		return compilerCore.baseCompile(src, shared.extend({}, parserOptions, options, {
			nodeTransforms: [
				ignoreSideEffectTags,
				...DOMNodeTransforms,
				...options.nodeTransforms || []
			],
			directiveTransforms: shared.extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
			transformHoist: stringifyStatic
		}));
	}
	function parse$3(template, options = {}) {
		return compilerCore.baseParse(template, shared.extend({}, parserOptions, options));
	}
	exports.DOMDirectiveTransforms = DOMDirectiveTransforms;
	exports.DOMErrorCodes = DOMErrorCodes;
	exports.DOMErrorMessages = DOMErrorMessages;
	exports.DOMNodeTransforms = DOMNodeTransforms;
	exports.TRANSITION = TRANSITION;
	exports.TRANSITION_GROUP = TRANSITION_GROUP;
	exports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
	exports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
	exports.V_MODEL_RADIO = V_MODEL_RADIO;
	exports.V_MODEL_SELECT = V_MODEL_SELECT;
	exports.V_MODEL_TEXT = V_MODEL_TEXT;
	exports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
	exports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
	exports.V_SHOW = V_SHOW;
	exports.compile = compile;
	exports.createDOMCompilerError = createDOMCompilerError;
	exports.parse = parse$3;
	exports.parserOptions = parserOptions;
	exports.transformStyle = transformStyle;
	Object.keys(compilerCore).forEach(function(k) {
		if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = compilerCore[k];
	});
} });

//#endregion
//#region node_modules/@vue/compiler-dom/index.js
var require_compiler_dom = __commonJS({ "node_modules/@vue/compiler-dom/index.js"(exports, module) {
	module.exports = require_compiler_dom_cjs_prod();
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/codeFeatures.js
var require_codeFeatures = __commonJS({ "node_modules/@vue/language-core/lib/codegen/codeFeatures.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.codeFeatures = void 0;
	const raw = {
		all: {
			verification: true,
			completion: true,
			semantic: true,
			navigation: true
		},
		verification: { verification: true },
		completion: { completion: true },
		additionalCompletion: { completion: { isAdditional: true } },
		withoutCompletion: {
			verification: true,
			semantic: true,
			navigation: true
		},
		navigation: { navigation: true },
		navigationWithoutRename: { navigation: { shouldRename: () => false } },
		navigationAndAdditionalCompletion: {
			navigation: true,
			completion: { isAdditional: true }
		},
		navigationAndVerification: {
			navigation: true,
			verification: true
		},
		withoutNavigation: {
			verification: true,
			completion: true,
			semantic: true
		},
		semanticWithoutHighlight: { semantic: { shouldHighlight: () => false } },
		withoutHighlight: {
			semantic: { shouldHighlight: () => false },
			verification: true,
			navigation: true,
			completion: true
		},
		withoutHighlightAndCompletion: {
			semantic: { shouldHighlight: () => false },
			verification: true,
			navigation: true
		},
		withoutSemantic: {
			verification: true,
			navigation: true,
			completion: true
		},
		doNotReportTs2339AndTs2551: { verification: { shouldReport: (_source, code$1) => String(code$1) !== "2339" && String(code$1) !== "2551" } },
		doNotReportTs2353AndTs2561: { verification: { shouldReport: (_source, code$1) => String(code$1) !== "2353" && String(code$1) !== "2561" } },
		doNotReportTs6133: { verification: { shouldReport: (_source, code$1) => String(code$1) !== "6133" } }
	};
	exports.codeFeatures = raw;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/utils/index.js
var require_utils$3 = __commonJS({ "node_modules/@vue/language-core/lib/codegen/utils/index.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.identifierRegex = exports.combineLastMapping = exports.endOfLine = exports.newLine = void 0;
	exports.normalizeAttributeValue = normalizeAttributeValue;
	exports.createTsAst = createTsAst;
	exports.generateSfcBlockSection = generateSfcBlockSection;
	exports.generatePartiallyEnding = generatePartiallyEnding;
	const codeFeatures_1$20 = require_codeFeatures();
	exports.newLine = `\n`;
	exports.endOfLine = `;${exports.newLine}`;
	exports.combineLastMapping = { __combineOffset: 1 };
	exports.identifierRegex = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
	function normalizeAttributeValue(node) {
		let offset = node.loc.start.offset;
		let content = node.loc.source;
		if (content.startsWith(`'`) && content.endsWith(`'`) || content.startsWith(`"`) && content.endsWith(`"`)) {
			offset++;
			content = content.slice(1, -1);
		}
		return [content, offset];
	}
	function createTsAst(ts, inlineTsAsts, text) {
		let ast = inlineTsAsts?.get(text);
		if (!ast) {
			ast = ts.createSourceFile("/a.ts", text, 99);
			inlineTsAsts?.set(text, ast);
		}
		ast.__volar_used = true;
		return ast;
	}
	function generateSfcBlockSection(block, start, end, features) {
		return [
			block.content.slice(start, end),
			block.name,
			start,
			features
		];
	}
	function* generatePartiallyEnding(source, end, mark, delimiter = "debugger") {
		yield delimiter;
		yield [
			``,
			source,
			end,
			codeFeatures_1$20.codeFeatures.verification
		];
		yield `/* PartiallyEnd: ${mark} */${exports.newLine}`;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/utils/wrapWith.js
var require_wrapWith = __commonJS({ "node_modules/@vue/language-core/lib/codegen/utils/wrapWith.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.wrapWith = wrapWith;
	function* wrapWith(startOffset, endOffset, ...args) {
		let source = "template";
		let features;
		let codes;
		if (typeof args[0] === "string") [source, features, ...codes] = args;
		else [features, ...codes] = args;
		yield [
			"",
			source,
			startOffset,
			features
		];
		let offset = 1;
		for (const code$1 of codes) {
			if (typeof code$1 !== "string") offset++;
			yield code$1;
		}
		yield [
			"",
			source,
			endOffset,
			{ __combineOffset: offset }
		];
	}
} });

//#endregion
//#region node_modules/alien-signals/cjs/system.cjs
var require_system = __commonJS({ "node_modules/alien-signals/cjs/system.cjs"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ReactiveFlags = void 0;
	exports.createReactiveSystem = createReactiveSystem;
	var ReactiveFlags;
	(function(ReactiveFlags$1) {
		ReactiveFlags$1[ReactiveFlags$1["None"] = 0] = "None";
		ReactiveFlags$1[ReactiveFlags$1["Mutable"] = 1] = "Mutable";
		ReactiveFlags$1[ReactiveFlags$1["Watching"] = 2] = "Watching";
		ReactiveFlags$1[ReactiveFlags$1["RecursedCheck"] = 4] = "RecursedCheck";
		ReactiveFlags$1[ReactiveFlags$1["Recursed"] = 8] = "Recursed";
		ReactiveFlags$1[ReactiveFlags$1["Dirty"] = 16] = "Dirty";
		ReactiveFlags$1[ReactiveFlags$1["Pending"] = 32] = "Pending";
	})(ReactiveFlags || (exports.ReactiveFlags = ReactiveFlags = {}));
	function createReactiveSystem({ update, notify, unwatched }) {
		return {
			link: link$1,
			unlink: unlink$1,
			propagate: propagate$1,
			checkDirty: checkDirty$1,
			shallowPropagate: shallowPropagate$1
		};
		function link$1(dep, sub, version) {
			const prevDep = sub.depsTail;
			if (prevDep !== void 0 && prevDep.dep === dep) return;
			const nextDep = prevDep !== void 0 ? prevDep.nextDep : sub.deps;
			if (nextDep !== void 0 && nextDep.dep === dep) {
				nextDep.version = version;
				sub.depsTail = nextDep;
				return;
			}
			const prevSub = dep.subsTail;
			if (prevSub !== void 0 && prevSub.version === version && prevSub.sub === sub) return;
			const newLink = sub.depsTail = dep.subsTail = {
				version,
				dep,
				sub,
				prevDep,
				nextDep,
				prevSub,
				nextSub: void 0
			};
			if (nextDep !== void 0) nextDep.prevDep = newLink;
			if (prevDep !== void 0) prevDep.nextDep = newLink;
			else sub.deps = newLink;
			if (prevSub !== void 0) prevSub.nextSub = newLink;
			else dep.subs = newLink;
		}
		function unlink$1(link$2, sub = link$2.sub) {
			const dep = link$2.dep;
			const prevDep = link$2.prevDep;
			const nextDep = link$2.nextDep;
			const nextSub = link$2.nextSub;
			const prevSub = link$2.prevSub;
			if (nextDep !== void 0) nextDep.prevDep = prevDep;
			else sub.depsTail = prevDep;
			if (prevDep !== void 0) prevDep.nextDep = nextDep;
			else sub.deps = nextDep;
			if (nextSub !== void 0) nextSub.prevSub = prevSub;
			else dep.subsTail = prevSub;
			if (prevSub !== void 0) prevSub.nextSub = nextSub;
			else if ((dep.subs = nextSub) === void 0) unwatched(dep);
			return nextDep;
		}
		function propagate$1(link$2) {
			let next = link$2.nextSub;
			let stack$1;
			top: do {
				const sub = link$2.sub;
				let flags = sub.flags;
				if (!(flags & 60)) sub.flags = flags | 32;
				else if (!(flags & 12)) flags = 0;
				else if (!(flags & 4)) sub.flags = flags & -9 | 32;
				else if (!(flags & 48) && isValidLink(link$2, sub)) {
					sub.flags = flags | 40;
					flags &= 1;
				} else flags = 0;
				if (flags & 2) notify(sub);
				if (flags & 1) {
					const subSubs = sub.subs;
					if (subSubs !== void 0) {
						const nextSub = (link$2 = subSubs).nextSub;
						if (nextSub !== void 0) {
							stack$1 = {
								value: next,
								prev: stack$1
							};
							next = nextSub;
						}
						continue;
					}
				}
				if ((link$2 = next) !== void 0) {
					next = link$2.nextSub;
					continue;
				}
				while (stack$1 !== void 0) {
					link$2 = stack$1.value;
					stack$1 = stack$1.prev;
					if (link$2 !== void 0) {
						next = link$2.nextSub;
						continue top;
					}
				}
				break;
			} while (true);
		}
		function checkDirty$1(link$2, sub) {
			let stack$1;
			let checkDepth = 0;
			let dirty = false;
			top: do {
				const dep = link$2.dep;
				const flags = dep.flags;
				if (sub.flags & 16) dirty = true;
				else if ((flags & 17) === 17) {
					if (update(dep)) {
						const subs = dep.subs;
						if (subs.nextSub !== void 0) shallowPropagate$1(subs);
						dirty = true;
					}
				} else if ((flags & 33) === 33) {
					if (link$2.nextSub !== void 0 || link$2.prevSub !== void 0) stack$1 = {
						value: link$2,
						prev: stack$1
					};
					link$2 = dep.deps;
					sub = dep;
					++checkDepth;
					continue;
				}
				if (!dirty) {
					const nextDep = link$2.nextDep;
					if (nextDep !== void 0) {
						link$2 = nextDep;
						continue;
					}
				}
				while (checkDepth--) {
					const firstSub = sub.subs;
					const hasMultipleSubs = firstSub.nextSub !== void 0;
					if (hasMultipleSubs) {
						link$2 = stack$1.value;
						stack$1 = stack$1.prev;
					} else link$2 = firstSub;
					if (dirty) {
						if (update(sub)) {
							if (hasMultipleSubs) shallowPropagate$1(firstSub);
							sub = link$2.sub;
							continue;
						}
						dirty = false;
					} else sub.flags &= -33;
					sub = link$2.sub;
					const nextDep = link$2.nextDep;
					if (nextDep !== void 0) {
						link$2 = nextDep;
						continue top;
					}
				}
				return dirty;
			} while (true);
		}
		function shallowPropagate$1(link$2) {
			do {
				const sub = link$2.sub;
				const flags = sub.flags;
				if ((flags & 48) === 32) {
					sub.flags = flags | 16;
					if (flags & 2) notify(sub);
				}
			} while ((link$2 = link$2.nextSub) !== void 0);
		}
		function isValidLink(checkLink, sub) {
			let link$2 = sub.depsTail;
			while (link$2 !== void 0) {
				if (link$2 === checkLink) return true;
				link$2 = link$2.prevDep;
			}
			return false;
		}
	}
} });

//#endregion
//#region node_modules/alien-signals/cjs/index.cjs
var require_cjs = __commonJS({ "node_modules/alien-signals/cjs/index.cjs"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getActiveSub = getActiveSub;
	exports.setActiveSub = setActiveSub;
	exports.getBatchDepth = getBatchDepth;
	exports.startBatch = startBatch;
	exports.endBatch = endBatch;
	exports.isSignal = isSignal;
	exports.isComputed = isComputed;
	exports.isEffect = isEffect;
	exports.isEffectScope = isEffectScope;
	exports.signal = signal;
	exports.computed = computed;
	exports.effect = effect;
	exports.effectScope = effectScope;
	const system_js_1 = require_system();
	let cycle = 0;
	let batchDepth = 0;
	let notifyIndex = 0;
	let queuedLength = 0;
	let activeSub;
	const queued = [];
	const { link, unlink, propagate, checkDirty, shallowPropagate } = (0, system_js_1.createReactiveSystem)({
		update(node) {
			if (node.depsTail !== void 0) return updateComputed(node);
			else return updateSignal(node);
		},
		notify(effect$1) {
			let insertIndex = queuedLength;
			let firstInsertedIndex = insertIndex;
			do {
				effect$1.flags &= -3;
				queued[insertIndex++] = effect$1;
				effect$1 = effect$1.subs?.sub;
				if (effect$1 === void 0 || !(effect$1.flags & 2)) break;
			} while (true);
			queuedLength = insertIndex;
			while (firstInsertedIndex < --insertIndex) {
				const left = queued[firstInsertedIndex];
				queued[firstInsertedIndex++] = queued[insertIndex];
				queued[insertIndex] = left;
			}
		},
		unwatched(node) {
			if (!(node.flags & 1)) effectScopeOper.call(node);
			else if (node.depsTail !== void 0) {
				node.depsTail = void 0;
				node.flags = 17;
				purgeDeps(node);
			}
		}
	});
	function getActiveSub() {
		return activeSub;
	}
	function setActiveSub(sub) {
		const prevSub = activeSub;
		activeSub = sub;
		return prevSub;
	}
	function getBatchDepth() {
		return batchDepth;
	}
	function startBatch() {
		++batchDepth;
	}
	function endBatch() {
		if (!--batchDepth) flush();
	}
	function isSignal(fn) {
		return fn.name === "bound " + signalOper.name;
	}
	function isComputed(fn) {
		return fn.name === "bound " + computedOper.name;
	}
	function isEffect(fn) {
		return fn.name === "bound " + effectOper.name;
	}
	function isEffectScope(fn) {
		return fn.name === "bound " + effectScopeOper.name;
	}
	function signal(initialValue) {
		return signalOper.bind({
			currentValue: initialValue,
			pendingValue: initialValue,
			subs: void 0,
			subsTail: void 0,
			flags: 1
		});
	}
	function computed(getter) {
		return computedOper.bind({
			value: void 0,
			subs: void 0,
			subsTail: void 0,
			deps: void 0,
			depsTail: void 0,
			flags: 0,
			getter
		});
	}
	function effect(fn) {
		const e = {
			fn,
			subs: void 0,
			subsTail: void 0,
			deps: void 0,
			depsTail: void 0,
			flags: 2
		};
		const prevSub = setActiveSub(e);
		if (prevSub !== void 0) link(e, prevSub, 0);
		try {
			e.fn();
		} finally {
			activeSub = prevSub;
		}
		return effectOper.bind(e);
	}
	function effectScope(fn) {
		const e = {
			deps: void 0,
			depsTail: void 0,
			subs: void 0,
			subsTail: void 0,
			flags: 0
		};
		const prevSub = setActiveSub(e);
		if (prevSub !== void 0) link(e, prevSub, 0);
		try {
			fn();
		} finally {
			activeSub = prevSub;
		}
		return effectScopeOper.bind(e);
	}
	function updateComputed(c) {
		++cycle;
		c.depsTail = void 0;
		c.flags = 5;
		const prevSub = setActiveSub(c);
		try {
			const oldValue = c.value;
			return oldValue !== (c.value = c.getter(oldValue));
		} finally {
			activeSub = prevSub;
			c.flags &= -5;
			purgeDeps(c);
		}
	}
	function updateSignal(s) {
		s.flags = 1;
		return s.currentValue !== (s.currentValue = s.pendingValue);
	}
	function run(e) {
		const flags = e.flags;
		if (flags & 16 || flags & 32 && checkDirty(e.deps, e)) {
			++cycle;
			e.depsTail = void 0;
			e.flags = 6;
			const prevSub = setActiveSub(e);
			try {
				e.fn();
			} finally {
				activeSub = prevSub;
				e.flags &= -5;
				purgeDeps(e);
			}
		} else e.flags = 2;
	}
	function flush() {
		while (notifyIndex < queuedLength) {
			const effect$1 = queued[notifyIndex];
			queued[notifyIndex++] = void 0;
			run(effect$1);
		}
		notifyIndex = 0;
		queuedLength = 0;
	}
	function computedOper() {
		const flags = this.flags;
		if (flags & 16 || flags & 32 && (checkDirty(this.deps, this) || (this.flags = flags & -33, false))) {
			if (updateComputed(this)) {
				const subs = this.subs;
				if (subs !== void 0) shallowPropagate(subs);
			}
		} else if (!flags) {
			this.flags = 1;
			const prevSub = setActiveSub(this);
			try {
				this.value = this.getter();
			} finally {
				activeSub = prevSub;
			}
		}
		const sub = activeSub;
		if (sub !== void 0) link(this, sub, cycle);
		return this.value;
	}
	function signalOper(...value) {
		if (value.length) {
			if (this.pendingValue !== (this.pendingValue = value[0])) {
				this.flags = 17;
				const subs = this.subs;
				if (subs !== void 0) {
					propagate(subs);
					if (!batchDepth) flush();
				}
			}
		} else {
			if (this.flags & 16) {
				if (updateSignal(this)) {
					const subs = this.subs;
					if (subs !== void 0) shallowPropagate(subs);
				}
			}
			let sub = activeSub;
			while (sub !== void 0) {
				if (sub.flags & 3) {
					link(this, sub, cycle);
					break;
				}
				sub = sub.subs?.sub;
			}
			return this.currentValue;
		}
	}
	function effectOper() {
		effectScopeOper.call(this);
	}
	function effectScopeOper() {
		this.depsTail = void 0;
		this.flags = 0;
		purgeDeps(this);
		const sub = this.subs;
		if (sub !== void 0) unlink(sub);
	}
	function purgeDeps(sub) {
		const depsTail = sub.depsTail;
		let dep = depsTail !== void 0 ? depsTail.nextDep : sub.deps;
		while (dep !== void 0) dep = unlink(dep, sub);
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/utils/signals.js
var require_signals = __commonJS({ "node_modules/@vue/language-core/lib/utils/signals.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.computedArray = computedArray;
	exports.computedSet = computedSet;
	exports.computedItems = computedItems;
	const alien_signals_1$5 = require_cjs();
	function computedArray(arr, getGetter) {
		const length = (0, alien_signals_1$5.computed)(() => arr().length);
		const keys = (0, alien_signals_1$5.computed)(() => {
			const keys$1 = [];
			for (let i = 0; i < length(); i++) keys$1.push(String(i));
			return keys$1;
		});
		const items = (0, alien_signals_1$5.computed)((array) => {
			array ??= [];
			while (array.length < length()) {
				const index = array.length;
				const item = (0, alien_signals_1$5.computed)(() => arr()[index]);
				array.push((0, alien_signals_1$5.computed)(getGetter(item, index)));
			}
			if (array.length > length()) array.length = length();
			return array;
		});
		return new Proxy({}, {
			get(_, p, receiver) {
				if (p === "length") return length();
				if (typeof p === "string" && !isNaN(Number(p))) return items()[Number(p)]?.();
				return Reflect.get(items(), p, receiver);
			},
			has(_, p) {
				return Reflect.has(items(), p);
			},
			ownKeys() {
				return keys();
			}
		});
	}
	function computedSet(source) {
		return (0, alien_signals_1$5.computed)((oldValue) => {
			const newValue = source();
			if (oldValue?.size === newValue.size && [...oldValue].every((c) => newValue.has(c))) return oldValue;
			return newValue;
		});
	}
	function computedItems(source, compareFn) {
		return (0, alien_signals_1$5.computed)((oldArr) => {
			oldArr ??= [];
			const newArr = source();
			if (oldArr.length === newArr.length && oldArr.every((item, index) => compareFn(item, newArr[index]))) return oldArr;
			return newArr;
		});
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/virtualFile/computedSfc.js
var require_computedSfc = __commonJS({ "node_modules/@vue/language-core/lib/virtualFile/computedSfc.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.templateInlineTsAsts = void 0;
	exports.computedSfc = computedSfc;
	const alien_signals_1$4 = require_cjs();
	const signals_1$1 = require_signals();
	exports.templateInlineTsAsts = /* @__PURE__ */ new WeakMap();
	function computedSfc(ts, plugins, fileName, getSnapshot, getParseResult) {
		const getUntrackedSnapshot = () => {
			const pausedSub = (0, alien_signals_1$4.setActiveSub)(void 0);
			const res = getSnapshot();
			(0, alien_signals_1$4.setActiveSub)(pausedSub);
			return res;
		};
		const getContent = (0, alien_signals_1$4.computed)(() => {
			return getSnapshot().getText(0, getSnapshot().getLength());
		});
		const getComments = (0, alien_signals_1$4.computed)((oldValue) => {
			const newValue = getParseResult()?.descriptor.comments ?? [];
			if (oldValue?.length === newValue.length && oldValue.every((v, i) => v === newValue[i])) return oldValue;
			return newValue;
		});
		const getTemplate = computedNullableSfcBlock("template", "html", (0, alien_signals_1$4.computed)(() => getParseResult()?.descriptor.template ?? void 0), (_block, base) => {
			const compiledAst = computedTemplateAst(base);
			return mergeObject(base, {
				get ast() {
					return compiledAst().ast;
				},
				get errors() {
					return compiledAst().errors;
				},
				get warnings() {
					return compiledAst().warnings;
				}
			});
		});
		const getScript = computedNullableSfcBlock("script", "js", (0, alien_signals_1$4.computed)(() => getParseResult()?.descriptor.script ?? void 0), (block, base) => {
			const getSrc = computedAttrValue("__src", base, block);
			const getAst = (0, alien_signals_1$4.computed)(() => {
				for (const plugin$14 of plugins) {
					const ast = plugin$14.compileSFCScript?.(base.lang, base.content);
					if (ast) return ast;
				}
				return ts.createSourceFile(fileName + "." + base.lang, "", 99);
			});
			return mergeObject(base, {
				get src() {
					return getSrc();
				},
				get ast() {
					return getAst();
				}
			});
		});
		const getOriginalScriptSetup = computedNullableSfcBlock("scriptSetup", "js", (0, alien_signals_1$4.computed)(() => getParseResult()?.descriptor.scriptSetup ?? void 0), (block, base) => {
			const getGeneric = computedAttrValue("__generic", base, block);
			const getAst = (0, alien_signals_1$4.computed)(() => {
				for (const plugin$14 of plugins) {
					const ast = plugin$14.compileSFCScript?.(base.lang, base.content);
					if (ast) return ast;
				}
				return ts.createSourceFile(fileName + "." + base.lang, "", 99);
			});
			return mergeObject(base, {
				get generic() {
					return getGeneric();
				},
				get ast() {
					return getAst();
				}
			});
		});
		const hasScript = (0, alien_signals_1$4.computed)(() => !!getParseResult()?.descriptor.script);
		const hasScriptSetup = (0, alien_signals_1$4.computed)(() => !!getParseResult()?.descriptor.scriptSetup);
		const getScriptSetup = (0, alien_signals_1$4.computed)(() => {
			if (!hasScript() && !hasScriptSetup()) return {
				content: "",
				lang: "ts",
				name: "",
				start: 0,
				end: 0,
				startTagEnd: 0,
				endTagStart: 0,
				generic: void 0,
				genericOffset: 0,
				attrs: {},
				ast: ts.createSourceFile("", "", 99, false, ts.ScriptKind.TS)
			};
			return getOriginalScriptSetup();
		});
		const styles = (0, signals_1$1.computedArray)((0, alien_signals_1$4.computed)(() => getParseResult()?.descriptor.styles ?? []), (getBlock, i) => {
			const base = computedSfcBlock("style_" + i, "css", getBlock);
			const getSrc = computedAttrValue("__src", base, getBlock);
			const getModule = computedAttrValue("__module", base, getBlock);
			const getScoped = (0, alien_signals_1$4.computed)(() => !!getBlock().scoped);
			const getIr = (0, alien_signals_1$4.computed)(() => {
				for (const plugin$14 of plugins) {
					const ast = plugin$14.compileSFCStyle?.(base.lang, base.content);
					if (ast) return ast;
				}
			});
			const getImports = (0, signals_1$1.computedItems)(() => getIr()?.imports ?? [], (oldItem, newItem) => oldItem.text === newItem.text && oldItem.offset === newItem.offset);
			const getBindings = (0, signals_1$1.computedItems)(() => getIr()?.bindings ?? [], (oldItem, newItem) => oldItem.text === newItem.text && oldItem.offset === newItem.offset);
			const getClassNames = (0, signals_1$1.computedItems)(() => getIr()?.classNames ?? [], (oldItem, newItem) => oldItem.text === newItem.text && oldItem.offset === newItem.offset);
			return () => mergeObject(base, {
				get src() {
					return getSrc();
				},
				get module() {
					return getModule();
				},
				get scoped() {
					return getScoped();
				},
				get imports() {
					return getImports();
				},
				get bindings() {
					return getBindings();
				},
				get classNames() {
					return getClassNames();
				}
			});
		});
		const customBlocks = (0, signals_1$1.computedArray)((0, alien_signals_1$4.computed)(() => getParseResult()?.descriptor.customBlocks ?? []), (getBlock, i) => {
			const base = computedSfcBlock("custom_block_" + i, "txt", getBlock);
			const getType = (0, alien_signals_1$4.computed)(() => getBlock().type);
			return () => mergeObject(base, { get type() {
				return getType();
			} });
		});
		return {
			get content() {
				return getContent();
			},
			get comments() {
				return getComments();
			},
			get template() {
				return getTemplate();
			},
			get script() {
				return getScript();
			},
			get scriptSetup() {
				return getScriptSetup();
			},
			get styles() {
				return styles;
			},
			get customBlocks() {
				return customBlocks;
			}
		};
		function computedTemplateAst(base) {
			let cache;
			let inlineTsAsts;
			function updateInlineTsAsts(newAst, oldAst) {
				let newTsAsts = exports.templateInlineTsAsts.get(newAst);
				if (!newTsAsts) exports.templateInlineTsAsts.set(newAst, newTsAsts = /* @__PURE__ */ new Map());
				const oldTsAsts = oldAst && exports.templateInlineTsAsts.get(oldAst) || inlineTsAsts;
				if (oldTsAsts) for (const [text, ast] of oldTsAsts) if (!ast.__volar_used) oldTsAsts.delete(text);
				else {
					newTsAsts.set(text, ast);
					ast.__volar_used = false;
				}
				inlineTsAsts = new Map(newTsAsts);
			}
			return (0, alien_signals_1$4.computed)(() => {
				if (cache?.template === base.content) return {
					errors: [],
					warnings: [],
					ast: cache.result.ast
				};
				if (cache?.plugin.updateSFCTemplate) {
					const change = getUntrackedSnapshot().getChangeRange(cache.snapshot);
					if (change) {
						const pausedSub = (0, alien_signals_1$4.setActiveSub)(void 0);
						const templateOffset = base.startTagEnd;
						(0, alien_signals_1$4.setActiveSub)(pausedSub);
						const newText = getUntrackedSnapshot().getText(change.span.start, change.span.start + change.newLength);
						const newResult = cache.plugin.updateSFCTemplate(cache.result, {
							start: change.span.start - templateOffset,
							end: change.span.start + change.span.length - templateOffset,
							newText
						});
						if (newResult) {
							updateInlineTsAsts(newResult.ast, cache.result.ast);
							cache.template = base.content;
							cache.snapshot = getUntrackedSnapshot();
							cache.result = newResult;
							return {
								errors: [],
								warnings: [],
								ast: newResult.ast
							};
						}
					}
				}
				const errors = [];
				const warnings = [];
				let options = {
					onError: (err) => errors.push(err),
					onWarn: (err) => warnings.push(err),
					expressionPlugins: ["typescript"]
				};
				for (const plugin$14 of plugins) if (plugin$14.resolveTemplateCompilerOptions) options = plugin$14.resolveTemplateCompilerOptions(options);
				for (const plugin$14 of plugins) {
					let result;
					try {
						result = plugin$14.compileSFCTemplate?.(base.lang, base.content, options);
						if (result) updateInlineTsAsts(result.ast, cache?.result.ast);
					} catch (e) {
						const err = e;
						errors.push(err);
					}
					if (result || errors.length) {
						if (result && !errors.length && !warnings.length) cache = {
							template: base.content,
							snapshot: getUntrackedSnapshot(),
							result,
							plugin: plugin$14
						};
						else cache = void 0;
						return {
							errors,
							warnings,
							ast: result?.ast
						};
					}
				}
				return {
					errors,
					warnings,
					ast: void 0
				};
			});
		}
		function computedNullableSfcBlock(name, defaultLang, getBlock, resolve) {
			const hasBlock = (0, alien_signals_1$4.computed)(() => !!getBlock());
			return (0, alien_signals_1$4.computed)(() => {
				if (!hasBlock()) return;
				const _block = (0, alien_signals_1$4.computed)(() => getBlock());
				return resolve(_block, computedSfcBlock(name, defaultLang, _block));
			});
		}
		function computedSfcBlock(name, defaultLang, getBlock) {
			const getLang = (0, alien_signals_1$4.computed)(() => getBlock().lang ?? defaultLang);
			const getAttrs = (0, alien_signals_1$4.computed)(() => getBlock().attrs);
			const getContent$1 = (0, alien_signals_1$4.computed)(() => getBlock().content);
			const getStartTagEnd = (0, alien_signals_1$4.computed)(() => getBlock().loc.start.offset);
			const getEndTagStart = (0, alien_signals_1$4.computed)(() => getBlock().loc.end.offset);
			const getStart = (0, alien_signals_1$4.computed)(() => getUntrackedSnapshot().getText(0, getStartTagEnd()).lastIndexOf("<" + getBlock().type));
			const getEnd = (0, alien_signals_1$4.computed)(() => getEndTagStart() + getUntrackedSnapshot().getText(getEndTagStart(), getUntrackedSnapshot().getLength()).indexOf(">") + 1);
			return {
				name,
				get lang() {
					return getLang();
				},
				get attrs() {
					return getAttrs();
				},
				get content() {
					return getContent$1();
				},
				get startTagEnd() {
					return getStartTagEnd();
				},
				get endTagStart() {
					return getEndTagStart();
				},
				get start() {
					return getStart();
				},
				get end() {
					return getEnd();
				}
			};
		}
		function computedAttrValue(key, base, getBlock) {
			return (0, alien_signals_1$4.computed)(() => {
				const val = getBlock()[key];
				if (typeof val === "object") return {
					...val,
					offset: base.start + val.offset
				};
				return val;
			});
		}
	}
	function mergeObject(a, b) {
		return Object.defineProperties(a, Object.getOwnPropertyDescriptors(b));
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/context.js
var require_context$1 = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/context.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createTemplateCodegenContext = createTemplateCodegenContext;
	const CompilerDOM$15 = require_compiler_dom();
	const computedSfc_1$2 = require_computedSfc();
	const codeFeatures_1$19 = require_codeFeatures();
	const utils_1$34 = require_utils$3();
	const wrapWith_1$16 = require_wrapWith();
	const commentDirectiveRegex = /^<!--\s*@vue-(?<name>[-\w]+)\b(?<content>[\s\S]*)-->$/;
	/**
	* Creates and returns a Context object used for generating type-checkable TS code
	* from the template section of a .vue file.
	*
	* ## Implementation Notes for supporting `@vue-ignore`, `@vue-expect-error`, and `@vue-skip` directives.
	*
	* Vue language tooling supports a number of directives for suppressing diagnostics within
	* Vue templates (https://github.com/vuejs/language-tools/pull/3215)
	*
	* Here is an overview for how support for how @vue-expect-error is implemented within this file
	* (@vue-expect-error is the most complicated directive to support due to its behavior of raising
	* a diagnostic when it is annotating a piece of code that doesn't actually have any errors/warning/diagnostics).
	*
	* Given .vue code:
	*
	* ```vue
	*   <script setup lang="ts">
	*   defineProps<{
	*     knownProp1: string;
	*     knownProp2: string;
	*     knownProp3: string;
	*     knownProp4_will_trigger_unused_expect_error: string;
	*   }>();
	*   </script>
	*
	*   <template>
	*     {{ knownProp1 }}
	*     {{ error_unknownProp }} <!-- ERROR: Property 'error_unknownProp' does not exist on type [...] -->
	*     {{ knownProp2 }}
	*     <!-- @vue-expect-error This suppresses an Unknown Property Error -->
	*     {{ suppressed_error_unknownProp }}
	*     {{ knownProp3 }}
	*     <!-- @vue-expect-error This will trigger Unused '@ts-expect-error' directive.ts(2578) -->
	*     {{ knownProp4_will_trigger_unused_expect_error }}
	*   </template>
	* ```
	*
	* The above code should raise two diagnostics:
	*
	* 1. Property 'error_unknownProp' does not exist on type [...]
	* 2. Unused '@ts-expect-error' directive.ts(2578) -- this is the bottom `@vue-expect-error` directive
	*    that covers code that doesn't actually raise an error -- note that all `@vue-...` directives
	*    will ultimately translate into `@ts-...` diagnostics.
	*
	* The above code will produce the following type-checkable TS code (note: omitting asterisks
	* to prevent VSCode syntax double-greying out double-commented code).
	*
	* ```ts
	*   ( __VLS_ctx.knownProp1 );
	*   ( __VLS_ctx.error_unknownProp ); // ERROR: Property 'error_unknownProp' does not exist on type [...]
	*   ( __VLS_ctx.knownProp2 );
	*   // @vue-expect-error start
	*   ( __VLS_ctx.suppressed_error_unknownProp );
	*   // @ts-expect-error __VLS_TS_EXPECT_ERROR
	*   ;
	*   // @vue-expect-error end of INTERPOLATION
	*   ( __VLS_ctx.knownProp3 );
	*   // @vue-expect-error start
	*   ( __VLS_ctx.knownProp4_will_trigger_unused_expect_error );
	*   // @ts-expect-error __VLS_TS_EXPECT_ERROR
	*   ;
	*   // @vue-expect-error end of INTERPOLATION
	* ```
	*
	* In the generated code, there are actually 3 diagnostic errors that'll be raised in the first
	* pass on this generated code (but through cleverness described below, not all of them will be
	* propagated back to the original .vue file):
	*
	* 1. Property 'error_unknownProp' does not exist on type [...]
	* 2. Unused '@ts-expect-error' directive.ts(2578) from the 1st `@ts-expect-error __VLS_TS_EXPECT_ERROR`
	* 3. Unused '@ts-expect-error' directive.ts(2578) from the 2nd `@ts-expect-error __VLS_TS_EXPECT_ERROR`
	*
	* Be sure to pay careful attention to the mixture of `@vue-expect-error` and `@ts-expect-error`;
	* Within the TS file, the only "real" directives recognized by TS are going to be prefixed with `@ts-`;
	* any `@vue-` prefixed directives in the comments are only for debugging purposes.
	*
	* As mentioned above, there are 3 diagnostics errors that'll be generated for the above code, but
	* only 2 should be propagated back to the original .vue file.
	*
	* (The reason we structure things this way is somewhat complicated, but in short it allows us
	* to lean on TS as much as possible to generate actual `unused @ts-expect-error directive` errors
	* while covering a number of edge cases.)
	*
	* So, we need a way to dynamically decide whether each of the `@ts-expect-error __VLS_TS_EXPECT_ERROR`
	* directives should be reported as an unused directive or not.
	*
	* To do this, we'll make use of the `shouldReport` callback that'll optionally be provided to the
	* `verification` property of the `CodeInformation` object attached to the mapping between source .vue
	* and generated .ts code. The `verification` property determines whether "verification" (which includes
	* semantic diagnostics) should be performed on the generated .ts code, and `shouldReport`, if provided,
	* can be used to determine whether a given diagnostic should be reported back "upwards" to the original
	* .vue file or not.
	*
	* See the comments in the code below for how and where we use this hook to keep track of whether
	* an error/diagnostic was encountered for a region of code covered by a `@vue-expect-error` directive,
	* and additionally how we use that to determine whether to propagate diagnostics back upward.
	*/
	function createTemplateCodegenContext(options, templateAst) {
		let variableId = 0;
		function resolveCodeFeatures(features) {
			if (features.verification && stack$1.length) {
				const data = stack$1[stack$1.length - 1];
				if (data.ignoreError) return {
					...features,
					verification: false
				};
				if (data.expectError !== void 0) return {
					...features,
					verification: { shouldReport: () => {
						data.expectError.token++;
						return false;
					} }
				};
			}
			return features;
		}
		const hoistVars = /* @__PURE__ */ new Map();
		const localVars = /* @__PURE__ */ new Map();
		const dollarVars = /* @__PURE__ */ new Set();
		const accessExternalVariables = /* @__PURE__ */ new Map();
		const slots = [];
		const dynamicSlots = [];
		const blockConditions = [];
		const scopedClasses = [];
		const emptyClassOffsets = [];
		const inlayHints = [];
		const bindingAttrLocs = [];
		const inheritedAttrVars = /* @__PURE__ */ new Set();
		const templateRefs = /* @__PURE__ */ new Map();
		const stack$1 = [];
		const commentBuffer = [];
		return {
			get currentInfo() {
				return stack$1[stack$1.length - 1];
			},
			resolveCodeFeatures,
			inlineTsAsts: templateAst && computedSfc_1$2.templateInlineTsAsts.get(templateAst),
			inVFor: false,
			slots,
			dynamicSlots,
			dollarVars,
			accessExternalVariables,
			blockConditions,
			scopedClasses,
			emptyClassOffsets,
			inlayHints,
			bindingAttrLocs,
			inheritedAttrVars,
			templateRefs,
			currentComponent: void 0,
			singleRootElTypes: [],
			singleRootNodes: /* @__PURE__ */ new Set(),
			addTemplateRef(name, typeExp, offset) {
				let refs = templateRefs.get(name);
				if (!refs) templateRefs.set(name, refs = []);
				refs.push({
					typeExp,
					offset
				});
			},
			accessExternalVariable(name, offset) {
				let arr = accessExternalVariables.get(name);
				if (!arr) accessExternalVariables.set(name, arr = /* @__PURE__ */ new Set());
				if (offset !== void 0) arr.add(offset);
			},
			hasLocalVariable(name) {
				return !!localVars.get(name);
			},
			addLocalVariable(name) {
				localVars.set(name, (localVars.get(name) ?? 0) + 1);
			},
			removeLocalVariable(name) {
				localVars.set(name, localVars.get(name) - 1);
			},
			getInternalVariable() {
				return `__VLS_${variableId++}`;
			},
			getHoistVariable(originalVar) {
				let name = hoistVars.get(originalVar);
				if (name === void 0) hoistVars.set(originalVar, name = `__VLS_${variableId++}`);
				return name;
			},
			*generateHoistVariables() {
				if (hoistVars.size) {
					yield `// @ts-ignore${utils_1$34.newLine}`;
					yield `var `;
					for (const [originalVar, hoistVar] of hoistVars) yield `${hoistVar} = ${originalVar}, `;
					yield utils_1$34.endOfLine;
				}
			},
			*generateConditionGuards() {
				for (const condition of blockConditions) yield `if (!${condition}) return${utils_1$34.endOfLine}`;
			},
			*generateAutoImportCompletion() {
				const all = [...accessExternalVariables.entries()];
				if (!all.some(([, offsets]) => offsets.size)) return;
				yield `// @ts-ignore${utils_1$34.newLine}`;
				yield `[`;
				for (const [varName, offsets] of all) {
					for (const offset of offsets) {
						if (options.scriptSetupBindingNames.has(varName)) yield [
							varName,
							"template",
							offset,
							{
								...codeFeatures_1$19.codeFeatures.additionalCompletion,
								...codeFeatures_1$19.codeFeatures.semanticWithoutHighlight
							}
						];
						else yield [
							varName,
							"template",
							offset,
							codeFeatures_1$19.codeFeatures.additionalCompletion
						];
						yield `,`;
					}
					offsets.clear();
				}
				yield `]${utils_1$34.endOfLine}`;
			},
			enter(node) {
				if (node.type === CompilerDOM$15.NodeTypes.COMMENT) {
					commentBuffer.push(node);
					return false;
				}
				const data = {};
				const comments = [...commentBuffer];
				commentBuffer.length = 0;
				for (const comment of comments) {
					const match = comment.loc.source.match(commentDirectiveRegex);
					if (match) {
						const { name, content } = match.groups;
						switch (name) {
							case "skip": return false;
							case "ignore": {
								data.ignoreError = true;
								break;
							}
							case "expect-error": {
								data.expectError = {
									token: 0,
									node: comment
								};
								break;
							}
							case "generic": {
								const text = content.trim();
								if (text.startsWith("{") && text.endsWith("}")) data.generic = {
									content: text.slice(1, -1),
									offset: comment.loc.start.offset + comment.loc.source.indexOf("{") + 1
								};
								break;
							}
						}
					}
				}
				stack$1.push(data);
				return true;
			},
			*exit() {
				const data = stack$1.pop();
				commentBuffer.length = 0;
				if (data.expectError !== void 0) {
					yield* (0, wrapWith_1$16.wrapWith)(data.expectError.node.loc.start.offset, data.expectError.node.loc.end.offset, { verification: { shouldReport: () => data.expectError.token === 0 } }, `// @ts-expect-error`);
					yield `${utils_1$34.newLine}${utils_1$34.endOfLine}`;
				}
			}
		};
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/utils/camelized.js
var require_camelized = __commonJS({ "node_modules/@vue/language-core/lib/codegen/utils/camelized.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateCamelized = generateCamelized;
	const shared_1$25 = require_shared$2();
	function* generateCamelized(code$1, source, offset, features) {
		const parts = code$1.split("-");
		const startCombineOffset = features.__combineOffset ?? 0;
		for (let i = 0; i < parts.length; i++) {
			const part = parts[i];
			if (part !== "") if (i === 0) yield [
				part,
				source,
				offset,
				features
			];
			else yield [
				(0, shared_1$25.capitalize)(part),
				source,
				offset,
				{ __combineOffset: startCombineOffset + i }
			];
			offset += part.length + 1;
		}
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/utils/stringLiteralKey.js
var require_stringLiteralKey = __commonJS({ "node_modules/@vue/language-core/lib/codegen/utils/stringLiteralKey.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateStringLiteralKey = generateStringLiteralKey;
	const index_1$2 = require_utils$3();
	const wrapWith_1$15 = require_wrapWith();
	function* generateStringLiteralKey(code$1, offset, info) {
		if (offset === void 0 || !info) yield `'${code$1}'`;
		else yield* (0, wrapWith_1$15.wrapWith)(offset, offset + code$1.length, info, `'`, [
			code$1,
			"template",
			offset,
			index_1$2.combineLastMapping
		], `'`);
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/utils/shared.js
var require_shared$1 = __commonJS({ "node_modules/@vue/language-core/lib/utils/shared.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.hyphenateTag = void 0;
	exports.hyphenateAttr = hyphenateAttr;
	exports.getElementTagOffsets = getElementTagOffsets;
	exports.getStartEnd = getStartEnd;
	exports.getNodeText = getNodeText;
	const shared_1$24 = require_shared$2();
	var shared_2$4 = require_shared$2();
	Object.defineProperty(exports, "hyphenateTag", {
		enumerable: true,
		get: function() {
			return shared_2$4.hyphenate;
		}
	});
	function hyphenateAttr(str) {
		let hyphencase = (0, shared_1$24.hyphenate)(str);
		if (str.length && str[0] !== str[0].toLowerCase()) hyphencase = "-" + hyphencase;
		return hyphencase;
	}
	function getElementTagOffsets(node, template) {
		const tagOffsets = [template.content.indexOf(node.tag, node.loc.start.offset)];
		if (!node.isSelfClosing && template.lang === "html") {
			const endTagOffset = node.loc.start.offset + node.loc.source.lastIndexOf(node.tag);
			if (endTagOffset > tagOffsets[0]) tagOffsets.push(endTagOffset);
		}
		return tagOffsets;
	}
	function getStartEnd(ts, node, ast) {
		return {
			start: ts.getTokenPosOfNode(node, ast),
			end: node.end
		};
	}
	function getNodeText(ts, node, ast) {
		const { start, end } = getStartEnd(ts, node, ast);
		return ast.text.slice(start, end);
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/utils/collectBindings.js
var require_collectBindings = __commonJS({ "node_modules/@vue/language-core/lib/utils/collectBindings.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.collectBindingNames = collectBindingNames;
	exports.collectBindingRanges = collectBindingRanges;
	exports.collectBindingIdentifiers = collectBindingIdentifiers;
	const shared_1$23 = require_shared$1();
	function collectBindingNames(ts, node, ast) {
		return collectBindingIdentifiers(ts, node).map(({ id }) => (0, shared_1$23.getNodeText)(ts, id, ast));
	}
	function collectBindingRanges(ts, node, ast) {
		return collectBindingIdentifiers(ts, node).map(({ id }) => (0, shared_1$23.getStartEnd)(ts, id, ast));
	}
	function collectBindingIdentifiers(ts, node, results = [], isRest = false, initializer = void 0) {
		if (ts.isIdentifier(node)) results.push({
			id: node,
			isRest,
			initializer
		});
		else if (ts.isArrayBindingPattern(node) || ts.isObjectBindingPattern(node)) {
			for (const el of node.elements) if (ts.isBindingElement(el)) collectBindingIdentifiers(ts, el.name, results, !!el.dotDotDotToken, el.initializer);
		} else ts.forEachChild(node, (node$1) => collectBindingIdentifiers(ts, node$1, results, false));
		return results;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/interpolation.js
var require_interpolation = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/interpolation.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateInterpolation = generateInterpolation;
	const shared_1$22 = require_shared$2();
	const collectBindings_1$4 = require_collectBindings();
	const shared_2$3 = require_shared$1();
	const codeFeatures_1$18 = require_codeFeatures();
	const utils_1$33 = require_utils$3();
	const isLiteralWhitelisted = /* @__PURE__ */ (0, shared_1$22.makeMap)("true,false,null,this");
	function* generateInterpolation(options, ctx, source, data, code$1, start, prefix$1 = "", suffix = "") {
		const { ts, destructuredPropNames, templateRefNames } = options;
		for (let [section, offset, type] of forEachInterpolationSegment(ts, ctx.inlineTsAsts, destructuredPropNames, templateRefNames, ctx, code$1, start, prefix$1, suffix)) if (offset === void 0) yield section;
		else {
			offset -= prefix$1.length;
			let addSuffix = "";
			const overLength = offset + section.length - code$1.length;
			if (overLength > 0) {
				addSuffix = section.slice(section.length - overLength);
				section = section.slice(0, -overLength);
			}
			if (offset < 0) {
				yield section.slice(0, -offset);
				section = section.slice(-offset);
				offset = 0;
			}
			const shouldSkip = section.length === 0 && (type === "startText" || type === "endText");
			if (!shouldSkip) if (start !== void 0 && data) yield [
				section,
				source,
				start + offset,
				type === "errorMappingOnly" ? codeFeatures_1$18.codeFeatures.verification : typeof data === "function" ? data(start + offset) : data
			];
			else yield section;
			yield addSuffix;
		}
	}
	function* forEachInterpolationSegment(ts, inlineTsAsts, destructuredPropNames, templateRefNames, ctx, originalCode, start, prefix$1, suffix) {
		const code$1 = prefix$1 + originalCode + suffix;
		const offset = start !== void 0 ? start - prefix$1.length : void 0;
		let ctxVars = [];
		if (utils_1$33.identifierRegex.test(originalCode) && !shouldIdentifierSkipped(ctx, originalCode, destructuredPropNames)) ctxVars.push({
			text: originalCode,
			offset: prefix$1.length
		});
		else {
			const ast = (0, utils_1$33.createTsAst)(ts, inlineTsAsts, code$1);
			const varCb = (id, isShorthand) => {
				const text = (0, shared_2$3.getNodeText)(ts, id, ast);
				if (!shouldIdentifierSkipped(ctx, text, destructuredPropNames)) ctxVars.push({
					text,
					offset: (0, shared_2$3.getStartEnd)(ts, id, ast).start,
					isShorthand
				});
			};
			ts.forEachChild(ast, (node) => walkIdentifiers(ts, node, ast, varCb, ctx, [], true));
		}
		ctxVars = ctxVars.sort((a, b) => a.offset - b.offset);
		if (ctxVars.length) {
			for (let i = 0; i < ctxVars.length; i++) {
				const lastVar$1 = ctxVars[i - 1];
				const curVar = ctxVars[i];
				const lastVarEnd = lastVar$1 ? lastVar$1.offset + lastVar$1.text.length : 0;
				if (curVar.isShorthand) {
					yield [code$1.slice(lastVarEnd, curVar.offset + curVar.text.length), lastVarEnd];
					yield [": ", void 0];
				} else yield [
					code$1.slice(lastVarEnd, curVar.offset),
					lastVarEnd,
					i ? void 0 : "startText"
				];
				yield* generateVar(templateRefNames, ctx, code$1, offset, curVar);
			}
			const lastVar = ctxVars.at(-1);
			if (lastVar.offset + lastVar.text.length < code$1.length) yield [
				code$1.slice(lastVar.offset + lastVar.text.length),
				lastVar.offset + lastVar.text.length,
				"endText"
			];
		} else yield [code$1, 0];
	}
	function* generateVar(templateRefNames, ctx, code$1, offset, curVar) {
		yield [
			"",
			curVar.offset,
			"errorMappingOnly"
		];
		const isTemplateRef = templateRefNames?.has(curVar.text) ?? false;
		if (isTemplateRef) {
			yield [`__VLS_unref(`, void 0];
			yield [code$1.slice(curVar.offset, curVar.offset + curVar.text.length), curVar.offset];
			yield [`)`, void 0];
		} else {
			if (offset !== void 0) ctx.accessExternalVariable(curVar.text, offset + curVar.offset);
			else ctx.accessExternalVariable(curVar.text);
			if (ctx.dollarVars.has(curVar.text)) yield [`__VLS_dollars.`, void 0];
			else yield [`__VLS_ctx.`, void 0];
			yield [code$1.slice(curVar.offset, curVar.offset + curVar.text.length), curVar.offset];
		}
	}
	function walkIdentifiers(ts, node, ast, cb, ctx, blockVars, isRoot = false) {
		if (ts.isIdentifier(node)) cb(node, false);
		else if (ts.isShorthandPropertyAssignment(node)) cb(node.name, true);
		else if (ts.isPropertyAccessExpression(node)) walkIdentifiers(ts, node.expression, ast, cb, ctx, blockVars);
		else if (ts.isVariableDeclaration(node)) {
			const bindingNames = (0, collectBindings_1$4.collectBindingNames)(ts, node.name, ast);
			for (const name of bindingNames) {
				ctx.addLocalVariable(name);
				blockVars.push(name);
			}
			walkIdentifiersInBinding(ts, node, ast, cb, ctx, blockVars);
		} else if (ts.isArrayBindingPattern(node) || ts.isObjectBindingPattern(node)) {
			for (const element of node.elements) if (ts.isBindingElement(element)) walkIdentifiersInBinding(ts, element, ast, cb, ctx, blockVars);
		} else if (ts.isArrowFunction(node) || ts.isFunctionExpression(node)) walkIdentifiersInFunction(ts, node, ast, cb, ctx);
		else if (ts.isObjectLiteralExpression(node)) {
			for (const prop of node.properties) if (ts.isPropertyAssignment(prop)) {
				if (ts.isComputedPropertyName(prop.name)) walkIdentifiers(ts, prop.name.expression, ast, cb, ctx, blockVars);
				walkIdentifiers(ts, prop.initializer, ast, cb, ctx, blockVars);
			} else if (ts.isShorthandPropertyAssignment(prop)) walkIdentifiers(ts, prop, ast, cb, ctx, blockVars);
			else if (ts.isSpreadAssignment(prop)) walkIdentifiers(ts, prop.expression, ast, cb, ctx, blockVars);
			else if (ts.isFunctionLike(prop) && prop.body) walkIdentifiersInFunction(ts, prop, ast, cb, ctx);
		} else if (ts.isTypeNode(node)) walkIdentifiersInTypeNode(ts, node, cb);
		else {
			const _blockVars = blockVars;
			if (ts.isBlock(node)) blockVars = [];
			ts.forEachChild(node, (node$1) => walkIdentifiers(ts, node$1, ast, cb, ctx, blockVars));
			if (ts.isBlock(node)) for (const varName of blockVars) ctx.removeLocalVariable(varName);
			blockVars = _blockVars;
		}
		if (isRoot) for (const varName of blockVars) ctx.removeLocalVariable(varName);
	}
	function walkIdentifiersInBinding(ts, node, ast, cb, ctx, blockVars) {
		if ("type" in node && node.type) walkIdentifiersInTypeNode(ts, node.type, cb);
		if (!ts.isIdentifier(node.name)) walkIdentifiers(ts, node.name, ast, cb, ctx, blockVars);
		if (node.initializer) walkIdentifiers(ts, node.initializer, ast, cb, ctx, blockVars);
	}
	function walkIdentifiersInFunction(ts, node, ast, cb, ctx) {
		const functionArgs = [];
		for (const param of node.parameters) {
			functionArgs.push(...(0, collectBindings_1$4.collectBindingNames)(ts, param.name, ast));
			walkIdentifiersInBinding(ts, param, ast, cb, ctx, functionArgs);
		}
		for (const varName of functionArgs) ctx.addLocalVariable(varName);
		if (node.body) walkIdentifiers(ts, node.body, ast, cb, ctx, [], true);
		for (const varName of functionArgs) ctx.removeLocalVariable(varName);
	}
	function walkIdentifiersInTypeNode(ts, node, cb) {
		if (ts.isTypeQueryNode(node)) {
			let id = node.exprName;
			while (!ts.isIdentifier(id)) id = id.left;
			cb(id, false);
		} else ts.forEachChild(node, (node$1) => walkIdentifiersInTypeNode(ts, node$1, cb));
	}
	function shouldIdentifierSkipped(ctx, text, destructuredPropNames) {
		return ctx.hasLocalVariable(text) || (0, shared_1$22.isGloballyAllowed)(text) || isLiteralWhitelisted(text) || text === "require" || text.startsWith("__VLS_") || destructuredPropNames?.has(text);
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/objectProperty.js
var require_objectProperty = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/objectProperty.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateObjectProperty = generateObjectProperty;
	const shared_1$21 = require_shared$2();
	const utils_1$32 = require_utils$3();
	const camelized_1$5 = require_camelized();
	const stringLiteralKey_1$2 = require_stringLiteralKey();
	const wrapWith_1$14 = require_wrapWith();
	const interpolation_1$11 = require_interpolation();
	function* generateObjectProperty(options, ctx, code$1, offset, features, shouldCamelize = false, shouldBeConstant = false) {
		if (code$1.startsWith("[") && code$1.endsWith("]")) if (shouldBeConstant) yield* (0, interpolation_1$11.generateInterpolation)(options, ctx, "template", features, code$1.slice(1, -1), offset + 1, `[__VLS_tryAsConstant(`, `)]`);
		else yield* (0, interpolation_1$11.generateInterpolation)(options, ctx, "template", features, code$1, offset);
		else if (shouldCamelize) if (utils_1$32.identifierRegex.test((0, shared_1$21.camelize)(code$1))) yield* (0, camelized_1$5.generateCamelized)(code$1, "template", offset, features);
		else yield* (0, wrapWith_1$14.wrapWith)(offset, offset + code$1.length, features, `'`, ...(0, camelized_1$5.generateCamelized)(code$1, "template", offset, utils_1$32.combineLastMapping), `'`);
		else if (utils_1$32.identifierRegex.test(code$1)) yield [
			code$1,
			"template",
			offset,
			features
		];
		else yield* (0, stringLiteralKey_1$2.generateStringLiteralKey)(code$1, offset, features);
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/utils/escaped.js
var require_escaped = __commonJS({ "node_modules/@vue/language-core/lib/codegen/utils/escaped.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateEscaped = generateEscaped;
	function* generateEscaped(text, source, offset, features, escapeTarget) {
		const parts = text.split(escapeTarget);
		const startCombineOffset = features.__combineOffset ?? 0;
		let isEscapeTarget = false;
		for (let i = 0; i < parts.length; i++) {
			const part = parts[i];
			if (isEscapeTarget) yield `\\`;
			yield [
				part,
				source,
				offset,
				i === 0 ? features : { __combineOffset: startCombineOffset + i }
			];
			offset += part.length;
			isEscapeTarget = !isEscapeTarget;
		}
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/styleScopedClasses.js
var require_styleScopedClasses = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/styleScopedClasses.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateStyleScopedClassReferences = generateStyleScopedClassReferences;
	exports.collectStyleScopedClassReferences = collectStyleScopedClassReferences;
	const CompilerDOM$14 = require_compiler_dom();
	const shared_1$20 = require_shared$1();
	const codeFeatures_1$17 = require_codeFeatures();
	const utils_1$31 = require_utils$3();
	const escaped_1 = require_escaped();
	const wrapWith_1$13 = require_wrapWith();
	const classNameEscapeRegex = /([\\'])/;
	function* generateStyleScopedClassReferences(ctx, withDot = false) {
		for (const offset of ctx.emptyClassOffsets) {
			yield `/** @type {__VLS_StyleScopedClasses['`;
			yield [
				"",
				"template",
				offset,
				codeFeatures_1$17.codeFeatures.additionalCompletion
			];
			yield `']} */${utils_1$31.endOfLine}`;
		}
		for (const { source, className, offset } of ctx.scopedClasses) {
			yield `/** @type {__VLS_StyleScopedClasses[`;
			yield* (0, wrapWith_1$13.wrapWith)(offset - (withDot ? 1 : 0), offset + className.length, source, codeFeatures_1$17.codeFeatures.navigation, `'`, ...(0, escaped_1.generateEscaped)(className, source, offset, codeFeatures_1$17.codeFeatures.navigationAndAdditionalCompletion, classNameEscapeRegex), `'`);
			yield `]} */${utils_1$31.endOfLine}`;
		}
	}
	function collectStyleScopedClassReferences(options, ctx, node) {
		for (const prop of node.props) if (prop.type === CompilerDOM$14.NodeTypes.ATTRIBUTE && prop.name === "class" && prop.value) if (options.template.lang === "pug") {
			const getClassOffset = Reflect.get(prop.value.loc.start, "getClassOffset");
			const content = prop.value.loc.source.slice(1, -1);
			let startOffset = 1;
			for (const className of content.split(" ")) {
				if (className) ctx.scopedClasses.push({
					source: "template",
					className,
					offset: getClassOffset(startOffset)
				});
				startOffset += className.length + 1;
			}
		} else {
			const [content, startOffset] = (0, utils_1$31.normalizeAttributeValue)(prop.value);
			if (content) {
				const classes = collectClasses(content, startOffset);
				ctx.scopedClasses.push(...classes);
			} else ctx.emptyClassOffsets.push(startOffset);
		}
		else if (prop.type === CompilerDOM$14.NodeTypes.DIRECTIVE && prop.arg?.type === CompilerDOM$14.NodeTypes.SIMPLE_EXPRESSION && prop.exp?.type === CompilerDOM$14.NodeTypes.SIMPLE_EXPRESSION && prop.arg.content === "class") {
			const content = "(" + prop.exp.content + ")";
			const startOffset = prop.exp.loc.start.offset - 1;
			const { ts } = options;
			const ast = ts.createSourceFile("", content, 99);
			const literals = [];
			ts.forEachChild(ast, (node$1) => {
				if (!ts.isExpressionStatement(node$1) || !ts.isParenthesizedExpression(node$1.expression)) return;
				const { expression } = node$1.expression;
				if (ts.isStringLiteralLike(expression)) literals.push(expression);
				else if (ts.isArrayLiteralExpression(expression)) walkArrayLiteral(expression);
				else if (ts.isObjectLiteralExpression(expression)) walkObjectLiteral(expression);
			});
			for (const literal of literals) if (literal.text) {
				const classes = collectClasses(literal.text, literal.end - literal.text.length - 1 + startOffset);
				ctx.scopedClasses.push(...classes);
			} else ctx.emptyClassOffsets.push(literal.end - 1 + startOffset);
			function walkArrayLiteral(node$1) {
				const { elements } = node$1;
				for (const element of elements) if (ts.isStringLiteralLike(element)) literals.push(element);
				else if (ts.isObjectLiteralExpression(element)) walkObjectLiteral(element);
			}
			function walkObjectLiteral(node$1) {
				const { properties } = node$1;
				for (const property of properties) if (ts.isPropertyAssignment(property)) {
					const { name } = property;
					if (ts.isIdentifier(name)) walkIdentifier(name);
					else if (ts.isStringLiteral(name)) literals.push(name);
					else if (ts.isComputedPropertyName(name)) {
						const { expression } = name;
						if (ts.isStringLiteralLike(expression)) literals.push(expression);
					}
				} else if (ts.isShorthandPropertyAssignment(property)) walkIdentifier(property.name);
			}
			function walkIdentifier(node$1) {
				const text = (0, shared_1$20.getNodeText)(ts, node$1, ast);
				ctx.scopedClasses.push({
					source: "template",
					className: text,
					offset: node$1.end - text.length + startOffset
				});
			}
		}
	}
	function collectClasses(content, startOffset = 0) {
		const classes = [];
		let currentClassName = "";
		let offset = 0;
		for (const char of content + " ") if (char.trim() === "") {
			if (currentClassName !== "") {
				classes.push({
					source: "template",
					className: currentClassName,
					offset: offset + startOffset
				});
				offset += currentClassName.length;
				currentClassName = "";
			}
			offset += char.length;
		} else currentClassName += char;
		return classes;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/inlayHints.js
var require_inlayHints = __commonJS({ "node_modules/@vue/language-core/lib/codegen/inlayHints.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createVBindShorthandInlayHintInfo = createVBindShorthandInlayHintInfo;
	function createVBindShorthandInlayHintInfo(loc, variableName) {
		return {
			blockName: "template",
			offset: loc.end.offset,
			setting: "vue.inlayHints.vBindShorthand",
			label: `="${variableName}"`,
			tooltip: [
				`This is a shorthand for \`${loc.source}="${variableName}"\`.`,
				"To hide this hint, set `vue.inlayHints.vBindShorthand` to `false` in IDE settings.",
				"[More info](https://github.com/vuejs/core/pull/9451)"
			].join("\n\n")
		};
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/elementChildren.js
var require_elementChildren = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/elementChildren.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateElementChildren = generateElementChildren;
	const templateChild_1$2 = require_templateChild();
	function* generateElementChildren(options, ctx, children, enterNode = true) {
		yield* ctx.generateAutoImportCompletion();
		for (const childNode of children) yield* (0, templateChild_1$2.generateTemplateChild)(options, ctx, childNode, enterNode);
		yield* ctx.generateAutoImportCompletion();
	}
} });

//#endregion
//#region node_modules/muggle-string/out/binarySearch.js
var require_binarySearch = __commonJS({ "node_modules/muggle-string/out/binarySearch.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.binarySearch = void 0;
	function binarySearch(offsets, start) {
		let low = 0;
		let high = offsets.length - 1;
		while (low <= high) {
			const mid = Math.floor((low + high) / 2);
			const midValue = offsets[mid];
			if (midValue < start) low = mid + 1;
			else if (midValue > start) high = mid - 1;
			else {
				low = mid;
				high = mid;
				break;
			}
		}
		return Math.max(Math.min(low, high, offsets.length - 1), 0);
	}
	exports.binarySearch = binarySearch;
} });

//#endregion
//#region node_modules/muggle-string/out/track.js
var require_track = __commonJS({ "node_modules/muggle-string/out/track.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getStack = exports.track = exports.resetOffsetStack = exports.offsetStack = exports.setTracking = void 0;
	let tracking = true;
	let stackOffset = 0;
	function setTracking(value) {
		tracking = value;
	}
	exports.setTracking = setTracking;
	function offsetStack() {
		stackOffset++;
	}
	exports.offsetStack = offsetStack;
	function resetOffsetStack() {
		stackOffset--;
	}
	exports.resetOffsetStack = resetOffsetStack;
	function track(segments, stacks = []) {
		return [new Proxy(segments, { get(target, prop, receiver) {
			if (tracking) {
				if (prop === "push") return push;
				if (prop === "pop") return pop;
				if (prop === "shift") return shift;
				if (prop === "unshift") return unshift;
				if (prop === "splice") return splice;
				if (prop === "sort") return sort;
				if (prop === "reverse") return reverse;
			}
			return Reflect.get(target, prop, receiver);
		} }), stacks];
		function push(...items) {
			stacks.push({
				stack: getStack(),
				length: items.length
			});
			return segments.push(...items);
		}
		function pop() {
			if (stacks.length) {
				const last = stacks[stacks.length - 1];
				if (last.length > 1) last.length--;
				else stacks.pop();
			}
			return segments.pop();
		}
		function shift() {
			if (stacks.length) {
				const first = stacks[0];
				if (first.length > 1) first.length--;
				else stacks.shift();
			}
			return segments.shift();
		}
		function unshift(...items) {
			stacks.unshift({
				stack: getStack(),
				length: items.length
			});
			return segments.unshift(...items);
		}
		function splice(start, deleteCount, ...items) {
			if (deleteCount === void 0) deleteCount = segments.length - start;
			let _stackStart = 0;
			let operateIndex;
			for (let i = 0; i < stacks.length; i++) {
				const stack$1 = stacks[i];
				const stackStart = _stackStart;
				const stackEnd = stackStart + stack$1.length;
				_stackStart = stackEnd;
				if (start >= stackStart) {
					operateIndex = i + 1;
					const originalLength = stack$1.length;
					stack$1.length = start - stackStart;
					stacks.splice(operateIndex, 0, {
						stack: stack$1.stack,
						length: originalLength - stack$1.length
					});
					break;
				}
			}
			if (operateIndex === void 0) throw new Error("Invalid splice operation");
			let _deleteCount = deleteCount;
			for (let i = operateIndex; i < stacks.length; i++) {
				const stack$1 = stacks[i];
				while (_deleteCount > 0 && stack$1.length > 0) {
					stack$1.length--;
					_deleteCount--;
				}
				if (_deleteCount === 0) break;
			}
			stacks.splice(operateIndex, 0, {
				stack: getStack(),
				length: items.length
			});
			return segments.splice(start, deleteCount, ...items);
		}
		function sort(compareFn) {
			stacks.splice(0, stacks.length, {
				stack: getStack(),
				length: segments.length
			});
			return segments.sort(compareFn);
		}
		function reverse() {
			stacks.splice(0, stacks.length, {
				stack: getStack(),
				length: segments.length
			});
			return segments.reverse();
		}
	}
	exports.track = track;
	function getStack() {
		const stack$1 = new Error().stack;
		let source = stack$1.split("\n")[3 + stackOffset].trim();
		if (source.endsWith(")")) source = source.slice(source.lastIndexOf("(") + 1, -1);
		else source = source.slice(source.lastIndexOf(" ") + 1);
		return source;
	}
	exports.getStack = getStack;
} });

//#endregion
//#region node_modules/muggle-string/out/types.js
var require_types$1 = __commonJS({ "node_modules/muggle-string/out/types.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
} });

//#endregion
//#region node_modules/muggle-string/out/index.js
var require_out = __commonJS({ "node_modules/muggle-string/out/index.js"(exports) {
	var __createBinding$2 = void 0 && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	});
	var __exportStar$2 = void 0 && (void 0).__exportStar || function(m, exports$1) {
		for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$2(exports$1, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.replaceRange = exports.replaceSourceRange = exports.replaceAll = exports.replace = exports.create = exports.toString = exports.getLength = void 0;
	const binarySearch_1 = require_binarySearch();
	const track_1 = require_track();
	__exportStar$2(require_types$1(), exports);
	__exportStar$2(require_track(), exports);
	function getLength(segments) {
		let length = 0;
		for (const segment of segments) length += typeof segment == "string" ? segment.length : segment[0].length;
		return length;
	}
	exports.getLength = getLength;
	function toString(segments) {
		return segments.map((s) => typeof s === "string" ? s : s[0]).join("");
	}
	exports.toString = toString;
	function create(source) {
		return [[
			source,
			void 0,
			0
		]];
	}
	exports.create = create;
	function replace(segments, pattern, ...replacers) {
		const str = toString(segments);
		const match = str.match(pattern);
		if (match && match.index !== void 0) {
			const startOffset = match.index;
			const endOffset = startOffset + match[0].length;
			(0, track_1.offsetStack)();
			replaceRange(segments, startOffset, endOffset, ...replacers.map((replacer$1) => typeof replacer$1 === "function" ? replacer$1(match[0]) : replacer$1));
			(0, track_1.resetOffsetStack)();
		}
	}
	exports.replace = replace;
	function replaceAll(segments, pattern, ...replacers) {
		const str = toString(segments);
		const allMatch = str.matchAll(pattern);
		let length = str.length;
		let lengthDiff = 0;
		for (const match of allMatch) if (match.index !== void 0) {
			const startOffset = match.index + lengthDiff;
			const endOffset = startOffset + match[0].length;
			(0, track_1.offsetStack)();
			replaceRange(segments, startOffset, endOffset, ...replacers.map((replacer$1) => typeof replacer$1 === "function" ? replacer$1(match[0]) : replacer$1));
			(0, track_1.resetOffsetStack)();
			const newLength = getLength(segments);
			lengthDiff += newLength - length;
			length = newLength;
		}
	}
	exports.replaceAll = replaceAll;
	function replaceSourceRange(segments, source, startOffset, endOffset, ...newSegments) {
		for (const segment of segments) {
			if (typeof segment === "string") continue;
			if (segment[1] === source) {
				const segmentStart = segment[2];
				const segmentEnd = segment[2] + segment[0].length;
				if (segmentStart <= startOffset && segmentEnd >= endOffset) {
					const inserts = [];
					if (startOffset > segmentStart) inserts.push(trimSegmentEnd(segment, startOffset - segmentStart));
					for (const newSegment of newSegments) inserts.push(newSegment);
					if (endOffset < segmentEnd) inserts.push(trimSegmentStart(segment, endOffset - segmentEnd));
					combineStrings(inserts);
					(0, track_1.offsetStack)();
					segments.splice(segments.indexOf(segment), 1, ...inserts);
					(0, track_1.resetOffsetStack)();
					return true;
				}
			}
		}
		return false;
	}
	exports.replaceSourceRange = replaceSourceRange;
	function replaceRange(segments, startOffset, endOffset, ...newSegments) {
		const offsets = toOffsets(segments);
		const startIndex = (0, binarySearch_1.binarySearch)(offsets, startOffset);
		const endIndex = (0, binarySearch_1.binarySearch)(offsets, endOffset);
		const startSegment = segments[startIndex];
		const endSegment = segments[endIndex];
		const startSegmentStart = offsets[startIndex];
		const endSegmentStart = offsets[endIndex];
		const endSegmentEnd = offsets[endIndex] + (typeof endSegment === "string" ? endSegment.length : endSegment[0].length);
		const inserts = [];
		if (startOffset > startSegmentStart) inserts.push(trimSegmentEnd(startSegment, startOffset - startSegmentStart));
		for (const newSegment of newSegments) inserts.push(newSegment);
		if (endOffset < endSegmentEnd) inserts.push(trimSegmentStart(endSegment, endOffset - endSegmentStart));
		combineStrings(inserts);
		(0, track_1.offsetStack)();
		segments.splice(startIndex, endIndex - startIndex + 1, ...inserts);
		(0, track_1.resetOffsetStack)();
	}
	exports.replaceRange = replaceRange;
	function combineStrings(segments) {
		for (let i = segments.length - 1; i >= 1; i--) if (typeof segments[i] === "string" && typeof segments[i - 1] === "string") {
			segments[i - 1] = segments[i - 1] + segments[i];
			(0, track_1.offsetStack)();
			segments.splice(i, 1);
			(0, track_1.resetOffsetStack)();
		}
	}
	function trimSegmentEnd(segment, trimEnd) {
		if (typeof segment === "string") return segment.slice(0, trimEnd);
		return [segment[0].slice(0, trimEnd), ...segment.slice(1)];
	}
	function trimSegmentStart(segment, trimStart) {
		if (typeof segment === "string") return segment.slice(trimStart);
		if (trimStart < 0) trimStart += segment[0].length;
		return [
			segment[0].slice(trimStart),
			segment[1],
			segment[2] + trimStart,
			...segment.slice(3)
		];
	}
	function toOffsets(segments) {
		const offsets = [];
		let offset = 0;
		for (const segment of segments) {
			offsets.push(offset);
			offset += typeof segment == "string" ? segment.length : segment[0].length;
		}
		return offsets;
	}
} });

//#endregion
//#region node_modules/picomatch/lib/constants.js
var require_constants = __commonJS({ "node_modules/picomatch/lib/constants.js"(exports, module) {
	const WIN_SLASH = "\\\\/";
	const WIN_NO_SLASH = `[^${WIN_SLASH}]`;
	/**
	* Posix glob regex
	*/
	const DOT_LITERAL = "\\.";
	const PLUS_LITERAL = "\\+";
	const QMARK_LITERAL = "\\?";
	const SLASH_LITERAL = "\\/";
	const ONE_CHAR = "(?=.)";
	const QMARK = "[^/]";
	const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
	const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
	const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
	const NO_DOT = `(?!${DOT_LITERAL})`;
	const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
	const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
	const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
	const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
	const STAR = `${QMARK}*?`;
	const SEP = "/";
	const POSIX_CHARS = {
		DOT_LITERAL,
		PLUS_LITERAL,
		QMARK_LITERAL,
		SLASH_LITERAL,
		ONE_CHAR,
		QMARK,
		END_ANCHOR,
		DOTS_SLASH,
		NO_DOT,
		NO_DOTS,
		NO_DOT_SLASH,
		NO_DOTS_SLASH,
		QMARK_NO_DOT,
		STAR,
		START_ANCHOR,
		SEP
	};
	/**
	* Windows glob regex
	*/
	const WINDOWS_CHARS = {
		...POSIX_CHARS,
		SLASH_LITERAL: `[${WIN_SLASH}]`,
		QMARK: WIN_NO_SLASH,
		STAR: `${WIN_NO_SLASH}*?`,
		DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
		NO_DOT: `(?!${DOT_LITERAL})`,
		NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
		NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
		NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
		QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
		START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
		END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
		SEP: "\\"
	};
	/**
	* POSIX Bracket Regex
	*/
	const POSIX_REGEX_SOURCE$1 = {
		alnum: "a-zA-Z0-9",
		alpha: "a-zA-Z",
		ascii: "\\x00-\\x7F",
		blank: " \\t",
		cntrl: "\\x00-\\x1F\\x7F",
		digit: "0-9",
		graph: "\\x21-\\x7E",
		lower: "a-z",
		print: "\\x20-\\x7E ",
		punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
		space: " \\t\\r\\n\\v\\f",
		upper: "A-Z",
		word: "A-Za-z0-9_",
		xdigit: "A-Fa-f0-9"
	};
	module.exports = {
		MAX_LENGTH: 1024 * 64,
		POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
		REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
		REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
		REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
		REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
		REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
		REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
		REPLACEMENTS: {
			__proto__: null,
			"***": "*",
			"**/**": "**",
			"**/**/**": "**"
		},
		CHAR_0: 48,
		CHAR_9: 57,
		CHAR_UPPERCASE_A: 65,
		CHAR_LOWERCASE_A: 97,
		CHAR_UPPERCASE_Z: 90,
		CHAR_LOWERCASE_Z: 122,
		CHAR_LEFT_PARENTHESES: 40,
		CHAR_RIGHT_PARENTHESES: 41,
		CHAR_ASTERISK: 42,
		CHAR_AMPERSAND: 38,
		CHAR_AT: 64,
		CHAR_BACKWARD_SLASH: 92,
		CHAR_CARRIAGE_RETURN: 13,
		CHAR_CIRCUMFLEX_ACCENT: 94,
		CHAR_COLON: 58,
		CHAR_COMMA: 44,
		CHAR_DOT: 46,
		CHAR_DOUBLE_QUOTE: 34,
		CHAR_EQUAL: 61,
		CHAR_EXCLAMATION_MARK: 33,
		CHAR_FORM_FEED: 12,
		CHAR_FORWARD_SLASH: 47,
		CHAR_GRAVE_ACCENT: 96,
		CHAR_HASH: 35,
		CHAR_HYPHEN_MINUS: 45,
		CHAR_LEFT_ANGLE_BRACKET: 60,
		CHAR_LEFT_CURLY_BRACE: 123,
		CHAR_LEFT_SQUARE_BRACKET: 91,
		CHAR_LINE_FEED: 10,
		CHAR_NO_BREAK_SPACE: 160,
		CHAR_PERCENT: 37,
		CHAR_PLUS: 43,
		CHAR_QUESTION_MARK: 63,
		CHAR_RIGHT_ANGLE_BRACKET: 62,
		CHAR_RIGHT_CURLY_BRACE: 125,
		CHAR_RIGHT_SQUARE_BRACKET: 93,
		CHAR_SEMICOLON: 59,
		CHAR_SINGLE_QUOTE: 39,
		CHAR_SPACE: 32,
		CHAR_TAB: 9,
		CHAR_UNDERSCORE: 95,
		CHAR_VERTICAL_LINE: 124,
		CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
		extglobChars(chars) {
			return {
				"!": {
					type: "negate",
					open: "(?:(?!(?:",
					close: `))${chars.STAR})`
				},
				"?": {
					type: "qmark",
					open: "(?:",
					close: ")?"
				},
				"+": {
					type: "plus",
					open: "(?:",
					close: ")+"
				},
				"*": {
					type: "star",
					open: "(?:",
					close: ")*"
				},
				"@": {
					type: "at",
					open: "(?:",
					close: ")"
				}
			};
		},
		globChars(win32) {
			return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
		}
	};
} });

//#endregion
//#region node_modules/picomatch/lib/utils.js
var require_utils$2 = __commonJS({ "node_modules/picomatch/lib/utils.js"(exports) {
	const { REGEX_BACKSLASH, REGEX_REMOVE_BACKSLASH, REGEX_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_GLOBAL } = require_constants();
	exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
	exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
	exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
	exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
	exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
	exports.isWindows = () => {
		if (typeof navigator !== "undefined" && navigator.platform) {
			const platform = navigator.platform.toLowerCase();
			return platform === "win32" || platform === "windows";
		}
		if (typeof process !== "undefined" && process.platform) return process.platform === "win32";
		return false;
	};
	exports.removeBackslashes = (str) => {
		return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
			return match === "\\" ? "" : match;
		});
	};
	exports.escapeLast = (input, char, lastIdx) => {
		const idx = input.lastIndexOf(char, lastIdx);
		if (idx === -1) return input;
		if (input[idx - 1] === "\\") return exports.escapeLast(input, char, idx - 1);
		return `${input.slice(0, idx)}\\${input.slice(idx)}`;
	};
	exports.removePrefix = (input, state = {}) => {
		let output = input;
		if (output.startsWith("./")) {
			output = output.slice(2);
			state.prefix = "./";
		}
		return output;
	};
	exports.wrapOutput = (input, state = {}, options = {}) => {
		const prepend = options.contains ? "" : "^";
		const append = options.contains ? "" : "$";
		let output = `${prepend}(?:${input})${append}`;
		if (state.negated === true) output = `(?:^(?!${output}).*$)`;
		return output;
	};
	exports.basename = (path$4, { windows } = {}) => {
		const segs = path$4.split(windows ? /[\\/]/ : "/");
		const last = segs[segs.length - 1];
		if (last === "") return segs[segs.length - 2];
		return last;
	};
} });

//#endregion
//#region node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({ "node_modules/picomatch/lib/scan.js"(exports, module) {
	const utils$3 = require_utils$2();
	const { CHAR_ASTERISK, CHAR_AT, CHAR_BACKWARD_SLASH, CHAR_COMMA, CHAR_DOT, CHAR_EXCLAMATION_MARK, CHAR_FORWARD_SLASH, CHAR_LEFT_CURLY_BRACE, CHAR_LEFT_PARENTHESES, CHAR_LEFT_SQUARE_BRACKET, CHAR_PLUS, CHAR_QUESTION_MARK, CHAR_RIGHT_CURLY_BRACE, CHAR_RIGHT_PARENTHESES, CHAR_RIGHT_SQUARE_BRACKET } = require_constants();
	const isPathSeparator = (code$1) => {
		return code$1 === CHAR_FORWARD_SLASH || code$1 === CHAR_BACKWARD_SLASH;
	};
	const depth = (token) => {
		if (token.isPrefix !== true) token.depth = token.isGlobstar ? Infinity : 1;
	};
	/**
	* Quickly scans a glob pattern and returns an object with a handful of
	* useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
	* `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
	* with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
	*
	* ```js
	* const pm = require('picomatch');
	* console.log(pm.scan('foo/bar/*.js'));
	* { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
	* ```
	* @param {String} `str`
	* @param {Object} `options`
	* @return {Object} Returns an object with tokens and regex source string.
	* @api public
	*/
	const scan$1 = (input, options) => {
		const opts = options || {};
		const length = input.length - 1;
		const scanToEnd = opts.parts === true || opts.scanToEnd === true;
		const slashes = [];
		const tokens = [];
		const parts = [];
		let str = input;
		let index = -1;
		let start = 0;
		let lastIndex = 0;
		let isBrace = false;
		let isBracket = false;
		let isGlob = false;
		let isExtglob = false;
		let isGlobstar = false;
		let braceEscaped = false;
		let backslashes = false;
		let negated = false;
		let negatedExtglob = false;
		let finished = false;
		let braces = 0;
		let prev;
		let code$1;
		let token = {
			value: "",
			depth: 0,
			isGlob: false
		};
		const eos = () => index >= length;
		const peek = () => str.charCodeAt(index + 1);
		const advance = () => {
			prev = code$1;
			return str.charCodeAt(++index);
		};
		while (index < length) {
			code$1 = advance();
			let next;
			if (code$1 === CHAR_BACKWARD_SLASH) {
				backslashes = token.backslashes = true;
				code$1 = advance();
				if (code$1 === CHAR_LEFT_CURLY_BRACE) braceEscaped = true;
				continue;
			}
			if (braceEscaped === true || code$1 === CHAR_LEFT_CURLY_BRACE) {
				braces++;
				while (eos() !== true && (code$1 = advance())) {
					if (code$1 === CHAR_BACKWARD_SLASH) {
						backslashes = token.backslashes = true;
						advance();
						continue;
					}
					if (code$1 === CHAR_LEFT_CURLY_BRACE) {
						braces++;
						continue;
					}
					if (braceEscaped !== true && code$1 === CHAR_DOT && (code$1 = advance()) === CHAR_DOT) {
						isBrace = token.isBrace = true;
						isGlob = token.isGlob = true;
						finished = true;
						if (scanToEnd === true) continue;
						break;
					}
					if (braceEscaped !== true && code$1 === CHAR_COMMA) {
						isBrace = token.isBrace = true;
						isGlob = token.isGlob = true;
						finished = true;
						if (scanToEnd === true) continue;
						break;
					}
					if (code$1 === CHAR_RIGHT_CURLY_BRACE) {
						braces--;
						if (braces === 0) {
							braceEscaped = false;
							isBrace = token.isBrace = true;
							finished = true;
							break;
						}
					}
				}
				if (scanToEnd === true) continue;
				break;
			}
			if (code$1 === CHAR_FORWARD_SLASH) {
				slashes.push(index);
				tokens.push(token);
				token = {
					value: "",
					depth: 0,
					isGlob: false
				};
				if (finished === true) continue;
				if (prev === CHAR_DOT && index === start + 1) {
					start += 2;
					continue;
				}
				lastIndex = index + 1;
				continue;
			}
			if (opts.noext !== true) {
				const isExtglobChar = code$1 === CHAR_PLUS || code$1 === CHAR_AT || code$1 === CHAR_ASTERISK || code$1 === CHAR_QUESTION_MARK || code$1 === CHAR_EXCLAMATION_MARK;
				if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
					isGlob = token.isGlob = true;
					isExtglob = token.isExtglob = true;
					finished = true;
					if (code$1 === CHAR_EXCLAMATION_MARK && index === start) negatedExtglob = true;
					if (scanToEnd === true) {
						while (eos() !== true && (code$1 = advance())) {
							if (code$1 === CHAR_BACKWARD_SLASH) {
								backslashes = token.backslashes = true;
								code$1 = advance();
								continue;
							}
							if (code$1 === CHAR_RIGHT_PARENTHESES) {
								isGlob = token.isGlob = true;
								finished = true;
								break;
							}
						}
						continue;
					}
					break;
				}
			}
			if (code$1 === CHAR_ASTERISK) {
				if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
				isGlob = token.isGlob = true;
				finished = true;
				if (scanToEnd === true) continue;
				break;
			}
			if (code$1 === CHAR_QUESTION_MARK) {
				isGlob = token.isGlob = true;
				finished = true;
				if (scanToEnd === true) continue;
				break;
			}
			if (code$1 === CHAR_LEFT_SQUARE_BRACKET) {
				while (eos() !== true && (next = advance())) {
					if (next === CHAR_BACKWARD_SLASH) {
						backslashes = token.backslashes = true;
						advance();
						continue;
					}
					if (next === CHAR_RIGHT_SQUARE_BRACKET) {
						isBracket = token.isBracket = true;
						isGlob = token.isGlob = true;
						finished = true;
						break;
					}
				}
				if (scanToEnd === true) continue;
				break;
			}
			if (opts.nonegate !== true && code$1 === CHAR_EXCLAMATION_MARK && index === start) {
				negated = token.negated = true;
				start++;
				continue;
			}
			if (opts.noparen !== true && code$1 === CHAR_LEFT_PARENTHESES) {
				isGlob = token.isGlob = true;
				if (scanToEnd === true) {
					while (eos() !== true && (code$1 = advance())) {
						if (code$1 === CHAR_LEFT_PARENTHESES) {
							backslashes = token.backslashes = true;
							code$1 = advance();
							continue;
						}
						if (code$1 === CHAR_RIGHT_PARENTHESES) {
							finished = true;
							break;
						}
					}
					continue;
				}
				break;
			}
			if (isGlob === true) {
				finished = true;
				if (scanToEnd === true) continue;
				break;
			}
		}
		if (opts.noext === true) {
			isExtglob = false;
			isGlob = false;
		}
		let base = str;
		let prefix$1 = "";
		let glob = "";
		if (start > 0) {
			prefix$1 = str.slice(0, start);
			str = str.slice(start);
			lastIndex -= start;
		}
		if (base && isGlob === true && lastIndex > 0) {
			base = str.slice(0, lastIndex);
			glob = str.slice(lastIndex);
		} else if (isGlob === true) {
			base = "";
			glob = str;
		} else base = str;
		if (base && base !== "" && base !== "/" && base !== str) {
			if (isPathSeparator(base.charCodeAt(base.length - 1))) base = base.slice(0, -1);
		}
		if (opts.unescape === true) {
			if (glob) glob = utils$3.removeBackslashes(glob);
			if (base && backslashes === true) base = utils$3.removeBackslashes(base);
		}
		const state = {
			prefix: prefix$1,
			input,
			start,
			base,
			glob,
			isBrace,
			isBracket,
			isGlob,
			isExtglob,
			isGlobstar,
			negated,
			negatedExtglob
		};
		if (opts.tokens === true) {
			state.maxDepth = 0;
			if (!isPathSeparator(code$1)) tokens.push(token);
			state.tokens = tokens;
		}
		if (opts.parts === true || opts.tokens === true) {
			let prevIndex;
			for (let idx = 0; idx < slashes.length; idx++) {
				const n = prevIndex ? prevIndex + 1 : start;
				const i = slashes[idx];
				const value = input.slice(n, i);
				if (opts.tokens) {
					if (idx === 0 && start !== 0) {
						tokens[idx].isPrefix = true;
						tokens[idx].value = prefix$1;
					} else tokens[idx].value = value;
					depth(tokens[idx]);
					state.maxDepth += tokens[idx].depth;
				}
				if (idx !== 0 || value !== "") parts.push(value);
				prevIndex = i;
			}
			if (prevIndex && prevIndex + 1 < input.length) {
				const value = input.slice(prevIndex + 1);
				parts.push(value);
				if (opts.tokens) {
					tokens[tokens.length - 1].value = value;
					depth(tokens[tokens.length - 1]);
					state.maxDepth += tokens[tokens.length - 1].depth;
				}
			}
			state.slashes = slashes;
			state.parts = parts;
		}
		return state;
	};
	module.exports = scan$1;
} });

//#endregion
//#region node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({ "node_modules/picomatch/lib/parse.js"(exports, module) {
	const constants$1 = require_constants();
	const utils$2 = require_utils$2();
	/**
	* Constants
	*/
	const { MAX_LENGTH, POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS } = constants$1;
	/**
	* Helpers
	*/
	const expandRange = (args, options) => {
		if (typeof options.expandRange === "function") return options.expandRange(...args, options);
		args.sort();
		const value = `[${args.join("-")}]`;
		try {
			new RegExp(value);
		} catch (ex) {
			return args.map((v) => utils$2.escapeRegex(v)).join("..");
		}
		return value;
	};
	/**
	* Create the message for a syntax error
	*/
	const syntaxError = (type, char) => {
		return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
	};
	/**
	* Parse the given input string.
	* @param {String} input
	* @param {Object} options
	* @return {Object}
	*/
	const parse$2 = (input, options) => {
		if (typeof input !== "string") throw new TypeError("Expected a string");
		input = REPLACEMENTS[input] || input;
		const opts = { ...options };
		const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
		let len = input.length;
		if (len > max) throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
		const bos = {
			type: "bos",
			value: "",
			output: opts.prepend || ""
		};
		const tokens = [bos];
		const capture = opts.capture ? "" : "?:";
		const PLATFORM_CHARS = constants$1.globChars(opts.windows);
		const EXTGLOB_CHARS = constants$1.extglobChars(PLATFORM_CHARS);
		const { DOT_LITERAL: DOT_LITERAL$1, PLUS_LITERAL: PLUS_LITERAL$1, SLASH_LITERAL: SLASH_LITERAL$1, ONE_CHAR: ONE_CHAR$1, DOTS_SLASH: DOTS_SLASH$1, NO_DOT: NO_DOT$1, NO_DOT_SLASH: NO_DOT_SLASH$1, NO_DOTS_SLASH: NO_DOTS_SLASH$1, QMARK: QMARK$1, QMARK_NO_DOT: QMARK_NO_DOT$1, STAR: STAR$1, START_ANCHOR: START_ANCHOR$1 } = PLATFORM_CHARS;
		const globstar = (opts$1) => {
			return `(${capture}(?:(?!${START_ANCHOR$1}${opts$1.dot ? DOTS_SLASH$1 : DOT_LITERAL$1}).)*?)`;
		};
		const nodot = opts.dot ? "" : NO_DOT$1;
		const qmarkNoDot = opts.dot ? QMARK$1 : QMARK_NO_DOT$1;
		let star = opts.bash === true ? globstar(opts) : STAR$1;
		if (opts.capture) star = `(${star})`;
		if (typeof opts.noext === "boolean") opts.noextglob = opts.noext;
		const state = {
			input,
			index: -1,
			start: 0,
			dot: opts.dot === true,
			consumed: "",
			output: "",
			prefix: "",
			backtrack: false,
			negated: false,
			brackets: 0,
			braces: 0,
			parens: 0,
			quotes: 0,
			globstar: false,
			tokens
		};
		input = utils$2.removePrefix(input, state);
		len = input.length;
		const extglobs = [];
		const braces = [];
		const stack$1 = [];
		let prev = bos;
		let value;
		/**
		* Tokenizing helpers
		*/
		const eos = () => state.index === len - 1;
		const peek = state.peek = (n = 1) => input[state.index + n];
		const advance = state.advance = () => input[++state.index] || "";
		const remaining = () => input.slice(state.index + 1);
		const consume = (value$1 = "", num = 0) => {
			state.consumed += value$1;
			state.index += num;
		};
		const append = (token) => {
			state.output += token.output != null ? token.output : token.value;
			consume(token.value);
		};
		const negate = () => {
			let count = 1;
			while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
				advance();
				state.start++;
				count++;
			}
			if (count % 2 === 0) return false;
			state.negated = true;
			state.start++;
			return true;
		};
		const increment = (type) => {
			state[type]++;
			stack$1.push(type);
		};
		const decrement = (type) => {
			state[type]--;
			stack$1.pop();
		};
		/**
		* Push tokens onto the tokens array. This helper speeds up
		* tokenizing by 1) helping us avoid backtracking as much as possible,
		* and 2) helping us avoid creating extra tokens when consecutive
		* characters are plain text. This improves performance and simplifies
		* lookbehinds.
		*/
		const push = (tok) => {
			if (prev.type === "globstar") {
				const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
				const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
				if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
					state.output = state.output.slice(0, -prev.output.length);
					prev.type = "star";
					prev.value = "*";
					prev.output = star;
					state.output += prev.output;
				}
			}
			if (extglobs.length && tok.type !== "paren") extglobs[extglobs.length - 1].inner += tok.value;
			if (tok.value || tok.output) append(tok);
			if (prev && prev.type === "text" && tok.type === "text") {
				prev.output = (prev.output || prev.value) + tok.value;
				prev.value += tok.value;
				return;
			}
			tok.prev = prev;
			tokens.push(tok);
			prev = tok;
		};
		const extglobOpen = (type, value$1) => {
			const token = {
				...EXTGLOB_CHARS[value$1],
				conditions: 1,
				inner: ""
			};
			token.prev = prev;
			token.parens = state.parens;
			token.output = state.output;
			const output = (opts.capture ? "(" : "") + token.open;
			increment("parens");
			push({
				type,
				value: value$1,
				output: state.output ? "" : ONE_CHAR$1
			});
			push({
				type: "paren",
				extglob: true,
				value: advance(),
				output
			});
			extglobs.push(token);
		};
		const extglobClose = (token) => {
			let output = token.close + (opts.capture ? ")" : "");
			let rest;
			if (token.type === "negate") {
				let extglobStar = star;
				if (token.inner && token.inner.length > 1 && token.inner.includes("/")) extglobStar = globstar(opts);
				if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) output = token.close = `)$))${extglobStar}`;
				if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
					const expression = parse$2(rest, {
						...options,
						fastpaths: false
					}).output;
					output = token.close = `)${expression})${extglobStar})`;
				}
				if (token.prev.type === "bos") state.negatedExtglob = true;
			}
			push({
				type: "paren",
				extglob: true,
				value,
				output
			});
			decrement("parens");
		};
		/**
		* Fast paths
		*/
		if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
			let backslashes = false;
			let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
				if (first === "\\") {
					backslashes = true;
					return m;
				}
				if (first === "?") {
					if (esc) return esc + first + (rest ? QMARK$1.repeat(rest.length) : "");
					if (index === 0) return qmarkNoDot + (rest ? QMARK$1.repeat(rest.length) : "");
					return QMARK$1.repeat(chars.length);
				}
				if (first === ".") return DOT_LITERAL$1.repeat(chars.length);
				if (first === "*") {
					if (esc) return esc + first + (rest ? star : "");
					return star;
				}
				return esc ? m : `\\${m}`;
			});
			if (backslashes === true) if (opts.unescape === true) output = output.replace(/\\/g, "");
			else output = output.replace(/\\+/g, (m) => {
				return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
			});
			if (output === input && opts.contains === true) {
				state.output = input;
				return state;
			}
			state.output = utils$2.wrapOutput(output, state, options);
			return state;
		}
		/**
		* Tokenize input until we reach end-of-string
		*/
		while (!eos()) {
			value = advance();
			if (value === "\0") continue;
			/**
			* Escaped characters
			*/
			if (value === "\\") {
				const next = peek();
				if (next === "/" && opts.bash !== true) continue;
				if (next === "." || next === ";") continue;
				if (!next) {
					value += "\\";
					push({
						type: "text",
						value
					});
					continue;
				}
				const match = /^\\+/.exec(remaining());
				let slashes = 0;
				if (match && match[0].length > 2) {
					slashes = match[0].length;
					state.index += slashes;
					if (slashes % 2 !== 0) value += "\\";
				}
				if (opts.unescape === true) value = advance();
				else value += advance();
				if (state.brackets === 0) {
					push({
						type: "text",
						value
					});
					continue;
				}
			}
			/**
			* If we're inside a regex character class, continue
			* until we reach the closing bracket.
			*/
			if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
				if (opts.posix !== false && value === ":") {
					const inner = prev.value.slice(1);
					if (inner.includes("[")) {
						prev.posix = true;
						if (inner.includes(":")) {
							const idx = prev.value.lastIndexOf("[");
							const pre = prev.value.slice(0, idx);
							const rest$1 = prev.value.slice(idx + 2);
							const posix$1 = POSIX_REGEX_SOURCE[rest$1];
							if (posix$1) {
								prev.value = pre + posix$1;
								state.backtrack = true;
								advance();
								if (!bos.output && tokens.indexOf(prev) === 1) bos.output = ONE_CHAR$1;
								continue;
							}
						}
					}
				}
				if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") value = `\\${value}`;
				if (value === "]" && (prev.value === "[" || prev.value === "[^")) value = `\\${value}`;
				if (opts.posix === true && value === "!" && prev.value === "[") value = "^";
				prev.value += value;
				append({ value });
				continue;
			}
			/**
			* If we're inside a quoted string, continue
			* until we reach the closing double quote.
			*/
			if (state.quotes === 1 && value !== "\"") {
				value = utils$2.escapeRegex(value);
				prev.value += value;
				append({ value });
				continue;
			}
			/**
			* Double quotes
			*/
			if (value === "\"") {
				state.quotes = state.quotes === 1 ? 0 : 1;
				if (opts.keepQuotes === true) push({
					type: "text",
					value
				});
				continue;
			}
			/**
			* Parentheses
			*/
			if (value === "(") {
				increment("parens");
				push({
					type: "paren",
					value
				});
				continue;
			}
			if (value === ")") {
				if (state.parens === 0 && opts.strictBrackets === true) throw new SyntaxError(syntaxError("opening", "("));
				const extglob = extglobs[extglobs.length - 1];
				if (extglob && state.parens === extglob.parens + 1) {
					extglobClose(extglobs.pop());
					continue;
				}
				push({
					type: "paren",
					value,
					output: state.parens ? ")" : "\\)"
				});
				decrement("parens");
				continue;
			}
			/**
			* Square brackets
			*/
			if (value === "[") {
				if (opts.nobracket === true || !remaining().includes("]")) {
					if (opts.nobracket !== true && opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
					value = `\\${value}`;
				} else increment("brackets");
				push({
					type: "bracket",
					value
				});
				continue;
			}
			if (value === "]") {
				if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
					push({
						type: "text",
						value,
						output: `\\${value}`
					});
					continue;
				}
				if (state.brackets === 0) {
					if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("opening", "["));
					push({
						type: "text",
						value,
						output: `\\${value}`
					});
					continue;
				}
				decrement("brackets");
				const prevValue = prev.value.slice(1);
				if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) value = `/${value}`;
				prev.value += value;
				append({ value });
				if (opts.literalBrackets === false || utils$2.hasRegexChars(prevValue)) continue;
				const escaped = utils$2.escapeRegex(prev.value);
				state.output = state.output.slice(0, -prev.value.length);
				if (opts.literalBrackets === true) {
					state.output += escaped;
					prev.value = escaped;
					continue;
				}
				prev.value = `(${capture}${escaped}|${prev.value})`;
				state.output += prev.value;
				continue;
			}
			/**
			* Braces
			*/
			if (value === "{" && opts.nobrace !== true) {
				increment("braces");
				const open = {
					type: "brace",
					value,
					output: "(",
					outputIndex: state.output.length,
					tokensIndex: state.tokens.length
				};
				braces.push(open);
				push(open);
				continue;
			}
			if (value === "}") {
				const brace = braces[braces.length - 1];
				if (opts.nobrace === true || !brace) {
					push({
						type: "text",
						value,
						output: value
					});
					continue;
				}
				let output = ")";
				if (brace.dots === true) {
					const arr = tokens.slice();
					const range$1 = [];
					for (let i = arr.length - 1; i >= 0; i--) {
						tokens.pop();
						if (arr[i].type === "brace") break;
						if (arr[i].type !== "dots") range$1.unshift(arr[i].value);
					}
					output = expandRange(range$1, opts);
					state.backtrack = true;
				}
				if (brace.comma !== true && brace.dots !== true) {
					const out = state.output.slice(0, brace.outputIndex);
					const toks = state.tokens.slice(brace.tokensIndex);
					brace.value = brace.output = "\\{";
					value = output = "\\}";
					state.output = out;
					for (const t of toks) state.output += t.output || t.value;
				}
				push({
					type: "brace",
					value,
					output
				});
				decrement("braces");
				braces.pop();
				continue;
			}
			/**
			* Pipes
			*/
			if (value === "|") {
				if (extglobs.length > 0) extglobs[extglobs.length - 1].conditions++;
				push({
					type: "text",
					value
				});
				continue;
			}
			/**
			* Commas
			*/
			if (value === ",") {
				let output = value;
				const brace = braces[braces.length - 1];
				if (brace && stack$1[stack$1.length - 1] === "braces") {
					brace.comma = true;
					output = "|";
				}
				push({
					type: "comma",
					value,
					output
				});
				continue;
			}
			/**
			* Slashes
			*/
			if (value === "/") {
				if (prev.type === "dot" && state.index === state.start + 1) {
					state.start = state.index + 1;
					state.consumed = "";
					state.output = "";
					tokens.pop();
					prev = bos;
					continue;
				}
				push({
					type: "slash",
					value,
					output: SLASH_LITERAL$1
				});
				continue;
			}
			/**
			* Dots
			*/
			if (value === ".") {
				if (state.braces > 0 && prev.type === "dot") {
					if (prev.value === ".") prev.output = DOT_LITERAL$1;
					const brace = braces[braces.length - 1];
					prev.type = "dots";
					prev.output += value;
					prev.value += value;
					brace.dots = true;
					continue;
				}
				if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
					push({
						type: "text",
						value,
						output: DOT_LITERAL$1
					});
					continue;
				}
				push({
					type: "dot",
					value,
					output: DOT_LITERAL$1
				});
				continue;
			}
			/**
			* Question marks
			*/
			if (value === "?") {
				const isGroup = prev && prev.value === "(";
				if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
					extglobOpen("qmark", value);
					continue;
				}
				if (prev && prev.type === "paren") {
					const next = peek();
					let output = value;
					if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) output = `\\${value}`;
					push({
						type: "text",
						value,
						output
					});
					continue;
				}
				if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
					push({
						type: "qmark",
						value,
						output: QMARK_NO_DOT$1
					});
					continue;
				}
				push({
					type: "qmark",
					value,
					output: QMARK$1
				});
				continue;
			}
			/**
			* Exclamation
			*/
			if (value === "!") {
				if (opts.noextglob !== true && peek() === "(") {
					if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
						extglobOpen("negate", value);
						continue;
					}
				}
				if (opts.nonegate !== true && state.index === 0) {
					negate();
					continue;
				}
			}
			/**
			* Plus
			*/
			if (value === "+") {
				if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
					extglobOpen("plus", value);
					continue;
				}
				if (prev && prev.value === "(" || opts.regex === false) {
					push({
						type: "plus",
						value,
						output: PLUS_LITERAL$1
					});
					continue;
				}
				if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
					push({
						type: "plus",
						value
					});
					continue;
				}
				push({
					type: "plus",
					value: PLUS_LITERAL$1
				});
				continue;
			}
			/**
			* Plain text
			*/
			if (value === "@") {
				if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
					push({
						type: "at",
						extglob: true,
						value,
						output: ""
					});
					continue;
				}
				push({
					type: "text",
					value
				});
				continue;
			}
			/**
			* Plain text
			*/
			if (value !== "*") {
				if (value === "$" || value === "^") value = `\\${value}`;
				const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
				if (match) {
					value += match[0];
					state.index += match[0].length;
				}
				push({
					type: "text",
					value
				});
				continue;
			}
			/**
			* Stars
			*/
			if (prev && (prev.type === "globstar" || prev.star === true)) {
				prev.type = "star";
				prev.star = true;
				prev.value += value;
				prev.output = star;
				state.backtrack = true;
				state.globstar = true;
				consume(value);
				continue;
			}
			let rest = remaining();
			if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
				extglobOpen("star", value);
				continue;
			}
			if (prev.type === "star") {
				if (opts.noglobstar === true) {
					consume(value);
					continue;
				}
				const prior = prev.prev;
				const before = prior.prev;
				const isStart = prior.type === "slash" || prior.type === "bos";
				const afterStar = before && (before.type === "star" || before.type === "globstar");
				if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
					push({
						type: "star",
						value,
						output: ""
					});
					continue;
				}
				const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
				const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
				if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
					push({
						type: "star",
						value,
						output: ""
					});
					continue;
				}
				while (rest.slice(0, 3) === "/**") {
					const after = input[state.index + 4];
					if (after && after !== "/") break;
					rest = rest.slice(3);
					consume("/**", 3);
				}
				if (prior.type === "bos" && eos()) {
					prev.type = "globstar";
					prev.value += value;
					prev.output = globstar(opts);
					state.output = prev.output;
					state.globstar = true;
					consume(value);
					continue;
				}
				if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
					state.output = state.output.slice(0, -(prior.output + prev.output).length);
					prior.output = `(?:${prior.output}`;
					prev.type = "globstar";
					prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
					prev.value += value;
					state.globstar = true;
					state.output += prior.output + prev.output;
					consume(value);
					continue;
				}
				if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
					const end = rest[1] !== void 0 ? "|$" : "";
					state.output = state.output.slice(0, -(prior.output + prev.output).length);
					prior.output = `(?:${prior.output}`;
					prev.type = "globstar";
					prev.output = `${globstar(opts)}${SLASH_LITERAL$1}|${SLASH_LITERAL$1}${end})`;
					prev.value += value;
					state.output += prior.output + prev.output;
					state.globstar = true;
					consume(value + advance());
					push({
						type: "slash",
						value: "/",
						output: ""
					});
					continue;
				}
				if (prior.type === "bos" && rest[0] === "/") {
					prev.type = "globstar";
					prev.value += value;
					prev.output = `(?:^|${SLASH_LITERAL$1}|${globstar(opts)}${SLASH_LITERAL$1})`;
					state.output = prev.output;
					state.globstar = true;
					consume(value + advance());
					push({
						type: "slash",
						value: "/",
						output: ""
					});
					continue;
				}
				state.output = state.output.slice(0, -prev.output.length);
				prev.type = "globstar";
				prev.output = globstar(opts);
				prev.value += value;
				state.output += prev.output;
				state.globstar = true;
				consume(value);
				continue;
			}
			const token = {
				type: "star",
				value,
				output: star
			};
			if (opts.bash === true) {
				token.output = ".*?";
				if (prev.type === "bos" || prev.type === "slash") token.output = nodot + token.output;
				push(token);
				continue;
			}
			if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
				token.output = value;
				push(token);
				continue;
			}
			if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
				if (prev.type === "dot") {
					state.output += NO_DOT_SLASH$1;
					prev.output += NO_DOT_SLASH$1;
				} else if (opts.dot === true) {
					state.output += NO_DOTS_SLASH$1;
					prev.output += NO_DOTS_SLASH$1;
				} else {
					state.output += nodot;
					prev.output += nodot;
				}
				if (peek() !== "*") {
					state.output += ONE_CHAR$1;
					prev.output += ONE_CHAR$1;
				}
			}
			push(token);
		}
		while (state.brackets > 0) {
			if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
			state.output = utils$2.escapeLast(state.output, "[");
			decrement("brackets");
		}
		while (state.parens > 0) {
			if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
			state.output = utils$2.escapeLast(state.output, "(");
			decrement("parens");
		}
		while (state.braces > 0) {
			if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
			state.output = utils$2.escapeLast(state.output, "{");
			decrement("braces");
		}
		if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) push({
			type: "maybe_slash",
			value: "",
			output: `${SLASH_LITERAL$1}?`
		});
		if (state.backtrack === true) {
			state.output = "";
			for (const token of state.tokens) {
				state.output += token.output != null ? token.output : token.value;
				if (token.suffix) state.output += token.suffix;
			}
		}
		return state;
	};
	/**
	* Fast paths for creating regular expressions for common glob patterns.
	* This can significantly speed up processing and has very little downside
	* impact when none of the fast paths match.
	*/
	parse$2.fastpaths = (input, options) => {
		const opts = { ...options };
		const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
		const len = input.length;
		if (len > max) throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
		input = REPLACEMENTS[input] || input;
		const { DOT_LITERAL: DOT_LITERAL$1, SLASH_LITERAL: SLASH_LITERAL$1, ONE_CHAR: ONE_CHAR$1, DOTS_SLASH: DOTS_SLASH$1, NO_DOT: NO_DOT$1, NO_DOTS: NO_DOTS$1, NO_DOTS_SLASH: NO_DOTS_SLASH$1, STAR: STAR$1, START_ANCHOR: START_ANCHOR$1 } = constants$1.globChars(opts.windows);
		const nodot = opts.dot ? NO_DOTS$1 : NO_DOT$1;
		const slashDot = opts.dot ? NO_DOTS_SLASH$1 : NO_DOT$1;
		const capture = opts.capture ? "" : "?:";
		const state = {
			negated: false,
			prefix: ""
		};
		let star = opts.bash === true ? ".*?" : STAR$1;
		if (opts.capture) star = `(${star})`;
		const globstar = (opts$1) => {
			if (opts$1.noglobstar === true) return star;
			return `(${capture}(?:(?!${START_ANCHOR$1}${opts$1.dot ? DOTS_SLASH$1 : DOT_LITERAL$1}).)*?)`;
		};
		const create$1 = (str) => {
			switch (str) {
				case "*": return `${nodot}${ONE_CHAR$1}${star}`;
				case ".*": return `${DOT_LITERAL$1}${ONE_CHAR$1}${star}`;
				case "*.*": return `${nodot}${star}${DOT_LITERAL$1}${ONE_CHAR$1}${star}`;
				case "*/*": return `${nodot}${star}${SLASH_LITERAL$1}${ONE_CHAR$1}${slashDot}${star}`;
				case "**": return nodot + globstar(opts);
				case "**/*": return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL$1})?${slashDot}${ONE_CHAR$1}${star}`;
				case "**/*.*": return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL$1})?${slashDot}${star}${DOT_LITERAL$1}${ONE_CHAR$1}${star}`;
				case "**/.*": return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL$1})?${DOT_LITERAL$1}${ONE_CHAR$1}${star}`;
				default: {
					const match = /^(.*?)\.(\w+)$/.exec(str);
					if (!match) return;
					const source$1 = create$1(match[1]);
					if (!source$1) return;
					return source$1 + DOT_LITERAL$1 + match[2];
				}
			}
		};
		const output = utils$2.removePrefix(input, state);
		let source = create$1(output);
		if (source && opts.strictSlashes !== true) source += `${SLASH_LITERAL$1}?`;
		return source;
	};
	module.exports = parse$2;
} });

//#endregion
//#region node_modules/picomatch/lib/picomatch.js
var require_picomatch$1 = __commonJS({ "node_modules/picomatch/lib/picomatch.js"(exports, module) {
	const scan = require_scan();
	const parse$1 = require_parse();
	const utils$1 = require_utils$2();
	const constants = require_constants();
	const isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
	/**
	* Creates a matcher function from one or more glob patterns. The
	* returned function takes a string to match as its first argument,
	* and returns true if the string is a match. The returned matcher
	* function also takes a boolean as the second argument that, when true,
	* returns an object with additional information.
	*
	* ```js
	* const picomatch = require('picomatch');
	* // picomatch(glob[, options]);
	*
	* const isMatch = picomatch('*.!(*a)');
	* console.log(isMatch('a.a')); //=> false
	* console.log(isMatch('a.b')); //=> true
	* ```
	* @name picomatch
	* @param {String|Array} `globs` One or more glob patterns.
	* @param {Object=} `options`
	* @return {Function=} Returns a matcher function.
	* @api public
	*/
	const picomatch$1 = (glob, options, returnState = false) => {
		if (Array.isArray(glob)) {
			const fns = glob.map((input) => picomatch$1(input, options, returnState));
			const arrayMatcher = (str) => {
				for (const isMatch of fns) {
					const state$1 = isMatch(str);
					if (state$1) return state$1;
				}
				return false;
			};
			return arrayMatcher;
		}
		const isState = isObject(glob) && glob.tokens && glob.input;
		if (glob === "" || typeof glob !== "string" && !isState) throw new TypeError("Expected pattern to be a non-empty string");
		const opts = options || {};
		const posix$1 = opts.windows;
		const regex = isState ? picomatch$1.compileRe(glob, options) : picomatch$1.makeRe(glob, options, false, true);
		const state = regex.state;
		delete regex.state;
		let isIgnored = () => false;
		if (opts.ignore) {
			const ignoreOpts = {
				...options,
				ignore: null,
				onMatch: null,
				onResult: null
			};
			isIgnored = picomatch$1(opts.ignore, ignoreOpts, returnState);
		}
		const matcher = (input, returnObject = false) => {
			const { isMatch, match, output } = picomatch$1.test(input, regex, options, {
				glob,
				posix: posix$1
			});
			const result = {
				glob,
				state,
				regex,
				posix: posix$1,
				input,
				output,
				match,
				isMatch
			};
			if (typeof opts.onResult === "function") opts.onResult(result);
			if (isMatch === false) {
				result.isMatch = false;
				return returnObject ? result : false;
			}
			if (isIgnored(input)) {
				if (typeof opts.onIgnore === "function") opts.onIgnore(result);
				result.isMatch = false;
				return returnObject ? result : false;
			}
			if (typeof opts.onMatch === "function") opts.onMatch(result);
			return returnObject ? result : true;
		};
		if (returnState) matcher.state = state;
		return matcher;
	};
	/**
	* Test `input` with the given `regex`. This is used by the main
	* `picomatch()` function to test the input string.
	*
	* ```js
	* const picomatch = require('picomatch');
	* // picomatch.test(input, regex[, options]);
	*
	* console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
	* // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
	* ```
	* @param {String} `input` String to test.
	* @param {RegExp} `regex`
	* @return {Object} Returns an object with matching info.
	* @api public
	*/
	picomatch$1.test = (input, regex, options, { glob, posix: posix$1 } = {}) => {
		if (typeof input !== "string") throw new TypeError("Expected input to be a string");
		if (input === "") return {
			isMatch: false,
			output: ""
		};
		const opts = options || {};
		const format = opts.format || (posix$1 ? utils$1.toPosixSlashes : null);
		let match = input === glob;
		let output = match && format ? format(input) : input;
		if (match === false) {
			output = format ? format(input) : input;
			match = output === glob;
		}
		if (match === false || opts.capture === true) if (opts.matchBase === true || opts.basename === true) match = picomatch$1.matchBase(input, regex, options, posix$1);
		else match = regex.exec(output);
		return {
			isMatch: Boolean(match),
			match,
			output
		};
	};
	/**
	* Match the basename of a filepath.
	*
	* ```js
	* const picomatch = require('picomatch');
	* // picomatch.matchBase(input, glob[, options]);
	* console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
	* ```
	* @param {String} `input` String to test.
	* @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
	* @return {Boolean}
	* @api public
	*/
	picomatch$1.matchBase = (input, glob, options) => {
		const regex = glob instanceof RegExp ? glob : picomatch$1.makeRe(glob, options);
		return regex.test(utils$1.basename(input));
	};
	/**
	* Returns true if **any** of the given glob `patterns` match the specified `string`.
	*
	* ```js
	* const picomatch = require('picomatch');
	* // picomatch.isMatch(string, patterns[, options]);
	*
	* console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
	* console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
	* ```
	* @param {String|Array} str The string to test.
	* @param {String|Array} patterns One or more glob patterns to use for matching.
	* @param {Object} [options] See available [options](#options).
	* @return {Boolean} Returns true if any patterns match `str`
	* @api public
	*/
	picomatch$1.isMatch = (str, patterns, options) => picomatch$1(patterns, options)(str);
	/**
	* Parse a glob pattern to create the source string for a regular
	* expression.
	*
	* ```js
	* const picomatch = require('picomatch');
	* const result = picomatch.parse(pattern[, options]);
	* ```
	* @param {String} `pattern`
	* @param {Object} `options`
	* @return {Object} Returns an object with useful properties and output to be used as a regex source string.
	* @api public
	*/
	picomatch$1.parse = (pattern, options) => {
		if (Array.isArray(pattern)) return pattern.map((p) => picomatch$1.parse(p, options));
		return parse$1(pattern, {
			...options,
			fastpaths: false
		});
	};
	/**
	* Scan a glob pattern to separate the pattern into segments.
	*
	* ```js
	* const picomatch = require('picomatch');
	* // picomatch.scan(input[, options]);
	*
	* const result = picomatch.scan('!./foo/*.js');
	* console.log(result);
	* { prefix: '!./',
	*   input: '!./foo/*.js',
	*   start: 3,
	*   base: 'foo',
	*   glob: '*.js',
	*   isBrace: false,
	*   isBracket: false,
	*   isGlob: true,
	*   isExtglob: false,
	*   isGlobstar: false,
	*   negated: true }
	* ```
	* @param {String} `input` Glob pattern to scan.
	* @param {Object} `options`
	* @return {Object} Returns an object with
	* @api public
	*/
	picomatch$1.scan = (input, options) => scan(input, options);
	/**
	* Compile a regular expression from the `state` object returned by the
	* [parse()](#parse) method.
	*
	* @param {Object} `state`
	* @param {Object} `options`
	* @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
	* @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
	* @return {RegExp}
	* @api public
	*/
	picomatch$1.compileRe = (state, options, returnOutput = false, returnState = false) => {
		if (returnOutput === true) return state.output;
		const opts = options || {};
		const prepend = opts.contains ? "" : "^";
		const append = opts.contains ? "" : "$";
		let source = `${prepend}(?:${state.output})${append}`;
		if (state && state.negated === true) source = `^(?!${source}).*$`;
		const regex = picomatch$1.toRegex(source, options);
		if (returnState === true) regex.state = state;
		return regex;
	};
	/**
	* Create a regular expression from a parsed glob pattern.
	*
	* ```js
	* const picomatch = require('picomatch');
	* const state = picomatch.parse('*.js');
	* // picomatch.compileRe(state[, options]);
	*
	* console.log(picomatch.compileRe(state));
	* //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
	* ```
	* @param {String} `state` The object returned from the `.parse` method.
	* @param {Object} `options`
	* @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
	* @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
	* @return {RegExp} Returns a regex created from the given pattern.
	* @api public
	*/
	picomatch$1.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
		if (!input || typeof input !== "string") throw new TypeError("Expected a non-empty string");
		let parsed = {
			negated: false,
			fastpaths: true
		};
		if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) parsed.output = parse$1.fastpaths(input, options);
		if (!parsed.output) parsed = parse$1(input, options);
		return picomatch$1.compileRe(parsed, options, returnOutput, returnState);
	};
	/**
	* Create a regular expression from the given regex source string.
	*
	* ```js
	* const picomatch = require('picomatch');
	* // picomatch.toRegex(source[, options]);
	*
	* const { output } = picomatch.parse('*.js');
	* console.log(picomatch.toRegex(output));
	* //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
	* ```
	* @param {String} `source` Regular expression source string.
	* @param {Object} `options`
	* @return {RegExp}
	* @api public
	*/
	picomatch$1.toRegex = (source, options) => {
		try {
			const opts = options || {};
			return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
		} catch (err) {
			if (options && options.debug === true) throw err;
			return /$^/;
		}
	};
	/**
	* Picomatch constants.
	* @return {Object}
	*/
	picomatch$1.constants = constants;
	/**
	* Expose "picomatch"
	*/
	module.exports = picomatch$1;
} });

//#endregion
//#region node_modules/picomatch/index.js
var require_picomatch = __commonJS({ "node_modules/picomatch/index.js"(exports, module) {
	const pico = require_picomatch$1();
	const utils = require_utils$2();
	function picomatch(glob, options, returnState = false) {
		if (options && (options.windows === null || options.windows === void 0)) options = {
			...options,
			windows: utils.isWindows()
		};
		return pico(glob, options, returnState);
	}
	Object.assign(picomatch, pico);
	module.exports = picomatch;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/utils/unicode.js
var require_unicode = __commonJS({ "node_modules/@vue/language-core/lib/codegen/utils/unicode.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateUnicode = generateUnicode;
	const wrapWith_1$12 = require_wrapWith();
	function* generateUnicode(code$1, offset, info) {
		if (needToUnicode(code$1)) yield* (0, wrapWith_1$12.wrapWith)(offset, offset + code$1.length, info, toUnicode(code$1));
		else yield [
			code$1,
			"template",
			offset,
			info
		];
	}
	function needToUnicode(str) {
		return str.includes("\\") || str.includes("\n");
	}
	function toUnicode(str) {
		return str.split("").map((value) => {
			const temp = value.charCodeAt(0).toString(16).padStart(4, "0");
			if (temp.length > 2) return "\\u" + temp;
			return value;
		}).join("");
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/elementEvents.js
var require_elementEvents = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/elementEvents.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateElementEvents = generateElementEvents;
	exports.generateEventArg = generateEventArg;
	exports.generateEventExpression = generateEventExpression;
	exports.generateModelEventExpression = generateModelEventExpression;
	exports.isCompoundExpression = isCompoundExpression;
	const CompilerDOM$13 = require_compiler_dom();
	const shared_1$19 = require_shared$2();
	const codeFeatures_1$16 = require_codeFeatures();
	const utils_1$30 = require_utils$3();
	const camelized_1$4 = require_camelized();
	const wrapWith_1$11 = require_wrapWith();
	const interpolation_1$10 = require_interpolation();
	function* generateElementEvents(options, ctx, node, componentOriginalVar, componentFunctionalVar, componentVNodeVar, componentCtxVar) {
		let emitsVar;
		let propsVar;
		for (const prop of node.props) if (prop.type === CompilerDOM$13.NodeTypes.DIRECTIVE && (prop.name === "on" && prop.arg?.type === CompilerDOM$13.NodeTypes.SIMPLE_EXPRESSION && prop.arg.isStatic || options.vueCompilerOptions.strictVModel && prop.name === "model" && (!prop.arg || prop.arg.type === CompilerDOM$13.NodeTypes.SIMPLE_EXPRESSION && prop.arg.isStatic))) {
			ctx.currentComponent.used = true;
			if (!emitsVar) {
				emitsVar = ctx.getInternalVariable();
				propsVar = ctx.getInternalVariable();
				yield `let ${emitsVar}!: __VLS_ResolveEmits<typeof ${componentOriginalVar}, typeof ${componentCtxVar}.emit>${utils_1$30.endOfLine}`;
				yield `let ${propsVar}!: __VLS_FunctionalComponentProps<typeof ${componentFunctionalVar}, typeof ${componentVNodeVar}>${utils_1$30.endOfLine}`;
			}
			let source = prop.arg?.loc.source ?? "model-value";
			let start = prop.arg?.loc.start.offset;
			let propPrefix = "on-";
			let emitPrefix = "";
			if (prop.name === "model") {
				propPrefix = "onUpdate:";
				emitPrefix = "update:";
			} else if (source.startsWith("vue:")) {
				source = source.slice(4);
				start = start + 4;
				propPrefix = "onVnode-";
				emitPrefix = "vnode-";
			}
			const propName = (0, shared_1$19.camelize)(propPrefix + source);
			const emitName = emitPrefix + source;
			const camelizedEmitName = (0, shared_1$19.camelize)(emitName);
			yield `const ${ctx.getInternalVariable()}: __VLS_NormalizeComponentEvent<typeof ${propsVar}, typeof ${emitsVar}, '${propName}', '${emitName}', '${camelizedEmitName}'> = (${utils_1$30.newLine}`;
			if (prop.name === "on") {
				yield `{ `;
				yield* generateEventArg(options, source, start, emitPrefix.slice(0, -1), codeFeatures_1$16.codeFeatures.navigation);
				yield `: {} as any } as typeof ${emitsVar},${utils_1$30.newLine}`;
			}
			yield `{ `;
			if (prop.name === "on") {
				yield* generateEventArg(options, source, start, propPrefix.slice(0, -1));
				yield `: `;
				yield* generateEventExpression(options, ctx, prop);
			} else {
				yield `'${propName}': `;
				yield* generateModelEventExpression(options, ctx, prop);
			}
			yield `})${utils_1$30.endOfLine}`;
		}
	}
	function* generateEventArg(options, name, start, directive = "on", features) {
		features ??= {
			...codeFeatures_1$16.codeFeatures.semanticWithoutHighlight,
			...codeFeatures_1$16.codeFeatures.navigationWithoutRename,
			...options.vueCompilerOptions.checkUnknownEvents ? codeFeatures_1$16.codeFeatures.verification : codeFeatures_1$16.codeFeatures.doNotReportTs2353AndTs2561
		};
		if (directive.length) name = (0, shared_1$19.capitalize)(name);
		if (utils_1$30.identifierRegex.test((0, shared_1$19.camelize)(name))) {
			yield [
				"",
				"template",
				start,
				features
			];
			yield directive;
			yield* (0, camelized_1$4.generateCamelized)(name, "template", start, utils_1$30.combineLastMapping);
		} else yield* (0, wrapWith_1$11.wrapWith)(start, start + name.length, features, `'`, directive, ...(0, camelized_1$4.generateCamelized)(name, "template", start, utils_1$30.combineLastMapping), `'`);
	}
	function* generateEventExpression(options, ctx, prop) {
		if (prop.exp?.type === CompilerDOM$13.NodeTypes.SIMPLE_EXPRESSION) {
			let isFirstMapping = true;
			const ast = (0, utils_1$30.createTsAst)(options.ts, ctx.inlineTsAsts, prop.exp.content);
			const isCompound = isCompoundExpression(options.ts, ast);
			const interpolation = (0, interpolation_1$10.generateInterpolation)(options, ctx, "template", (offset) => {
				if (isCompound && isFirstMapping) {
					isFirstMapping = false;
					ctx.inlayHints.push({
						blockName: "template",
						offset,
						setting: "vue.inlayHints.inlineHandlerLeading",
						label: "$event =>",
						paddingRight: true,
						tooltip: [
							"`$event` is a hidden parameter, you can use it in this callback.",
							"To hide this hint, set `vue.inlayHints.inlineHandlerLeading` to `false` in IDE settings.",
							"[More info](https://github.com/vuejs/language-tools/issues/2445#issuecomment-1444771420)"
						].join("\n\n")
					});
				}
				return codeFeatures_1$16.codeFeatures.all;
			}, prop.exp.content, prop.exp.loc.start.offset, isCompound ? `` : `(`, isCompound ? `` : `)`);
			if (isCompound) {
				yield `(...[$event]) => {${utils_1$30.newLine}`;
				ctx.addLocalVariable("$event");
				yield* ctx.generateConditionGuards();
				yield* interpolation;
				yield utils_1$30.endOfLine;
				ctx.removeLocalVariable("$event");
				yield* ctx.generateAutoImportCompletion();
				yield `}`;
			} else yield* interpolation;
		} else yield `() => {}`;
	}
	function* generateModelEventExpression(options, ctx, prop) {
		if (prop.exp?.type === CompilerDOM$13.NodeTypes.SIMPLE_EXPRESSION) {
			yield `(...[$event]) => {${utils_1$30.newLine}`;
			yield* ctx.generateConditionGuards();
			yield* (0, interpolation_1$10.generateInterpolation)(options, ctx, "template", codeFeatures_1$16.codeFeatures.verification, prop.exp.content, prop.exp.loc.start.offset);
			yield ` = $event${utils_1$30.endOfLine}`;
			yield `}`;
		} else yield `() => {}`;
	}
	function isCompoundExpression(ts, ast) {
		let result = true;
		if (ast.statements.length === 0) result = false;
		else if (ast.statements.length === 1) ts.forEachChild(ast, (child_1) => {
			if (ts.isExpressionStatement(child_1)) ts.forEachChild(child_1, (child_2) => {
				if (ts.isArrowFunction(child_2)) result = false;
				else if (isPropertyAccessOrId(ts, child_2)) result = false;
			});
			else if (ts.isFunctionDeclaration(child_1)) result = false;
		});
		return result;
	}
	function isPropertyAccessOrId(ts, node) {
		if (ts.isIdentifier(node)) return true;
		if (ts.isPropertyAccessExpression(node)) return isPropertyAccessOrId(ts, node.expression);
		return false;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/elementProps.js
var require_elementProps = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/elementProps.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateElementProps = generateElementProps;
	exports.generatePropExp = generatePropExp;
	const CompilerDOM$12 = require_compiler_dom();
	const shared_1$18 = require_shared$2();
	const muggle_string_1$5 = require_out();
	const picomatch_1 = require_picomatch();
	const shared_2$2 = require_shared$1();
	const codeFeatures_1$15 = require_codeFeatures();
	const inlayHints_1$2 = require_inlayHints();
	const utils_1$29 = require_utils$3();
	const camelized_1$3 = require_camelized();
	const unicode_1 = require_unicode();
	const wrapWith_1$10 = require_wrapWith();
	const elementDirectives_1$1 = require_elementDirectives();
	const elementEvents_1$2 = require_elementEvents();
	const interpolation_1$9 = require_interpolation();
	const objectProperty_1$3 = require_objectProperty();
	function* generateElementProps(options, ctx, node, props, strictPropsCheck, enableCodeFeatures, failedPropExps) {
		const isComponent$1 = node.tagType === CompilerDOM$12.ElementTypes.COMPONENT;
		for (const prop of props) if (prop.type === CompilerDOM$12.NodeTypes.DIRECTIVE && prop.name === "on") {
			if (prop.arg?.type === CompilerDOM$12.NodeTypes.SIMPLE_EXPRESSION && !prop.arg.loc.source.startsWith("[") && !prop.arg.loc.source.endsWith("]")) {
				if (!isComponent$1) {
					yield `...{ `;
					yield* (0, elementEvents_1$2.generateEventArg)(options, prop.arg.loc.source, prop.arg.loc.start.offset);
					yield `: `;
					yield* (0, elementEvents_1$2.generateEventExpression)(options, ctx, prop);
					yield `},`;
				} else yield `...{ '${(0, shared_1$18.camelize)("on-" + prop.arg.loc.source)}': {} as any },`;
				yield utils_1$29.newLine;
			} else if (prop.arg?.type === CompilerDOM$12.NodeTypes.SIMPLE_EXPRESSION && prop.exp?.type === CompilerDOM$12.NodeTypes.SIMPLE_EXPRESSION && prop.arg.loc.source.startsWith("[") && prop.arg.loc.source.endsWith("]")) {
				failedPropExps?.push({
					node: prop.arg,
					prefix: `(`,
					suffix: `)`
				});
				failedPropExps?.push({
					node: prop.exp,
					prefix: `() => {`,
					suffix: `}`
				});
			} else if (!prop.arg && prop.exp?.type === CompilerDOM$12.NodeTypes.SIMPLE_EXPRESSION) failedPropExps?.push({
				node: prop.exp,
				prefix: `(`,
				suffix: `)`
			});
		}
		for (const prop of props) if (prop.type === CompilerDOM$12.NodeTypes.DIRECTIVE && (prop.name === "bind" && prop.arg?.type === CompilerDOM$12.NodeTypes.SIMPLE_EXPRESSION || prop.name === "model") && (!prop.exp || prop.exp.type === CompilerDOM$12.NodeTypes.SIMPLE_EXPRESSION)) {
			let propName;
			if (prop.arg?.type === CompilerDOM$12.NodeTypes.SIMPLE_EXPRESSION) propName = prop.arg.constType === CompilerDOM$12.ConstantTypes.CAN_STRINGIFY ? prop.arg.content : prop.arg.loc.source;
			else propName = getModelPropName(node, options.vueCompilerOptions);
			if (propName === void 0 || options.vueCompilerOptions.dataAttributes.some((pattern) => (0, picomatch_1.isMatch)(propName, pattern))) {
				if (prop.exp && prop.exp.constType !== CompilerDOM$12.ConstantTypes.CAN_STRINGIFY) failedPropExps?.push({
					node: prop.exp,
					prefix: `(`,
					suffix: `)`
				});
				continue;
			}
			if (prop.name === "bind" && prop.modifiers.some((m) => m.content === "prop" || m.content === "attr")) propName = propName.slice(1);
			const shouldSpread = propName === "style" || propName === "class";
			const shouldCamelize = isComponent$1 && getShouldCamelize(options, prop, propName);
			const features = getPropsCodeFeatures(strictPropsCheck);
			if (shouldSpread) yield `...{ `;
			const codes = [...(0, wrapWith_1$10.wrapWith)(prop.loc.start.offset, prop.loc.end.offset, codeFeatures_1$15.codeFeatures.verification, ...prop.arg ? (0, objectProperty_1$3.generateObjectProperty)(options, ctx, propName, prop.arg.loc.start.offset, features, shouldCamelize) : (0, wrapWith_1$10.wrapWith)(prop.loc.start.offset, prop.loc.start.offset + 7, codeFeatures_1$15.codeFeatures.withoutHighlightAndCompletion, propName), `: `, ...(0, wrapWith_1$10.wrapWith)(prop.arg?.loc.start.offset ?? prop.loc.start.offset, prop.arg?.loc.end.offset ?? prop.loc.end.offset, codeFeatures_1$15.codeFeatures.verification, ...generatePropExp(options, ctx, prop, prop.exp, enableCodeFeatures)))];
			if (enableCodeFeatures) yield* codes;
			else yield (0, muggle_string_1$5.toString)(codes);
			if (shouldSpread) yield ` }`;
			yield `,${utils_1$29.newLine}`;
			if (isComponent$1 && prop.name === "model" && prop.modifiers.length) {
				const propertyName = prop.arg?.type === CompilerDOM$12.NodeTypes.SIMPLE_EXPRESSION ? !prop.arg.isStatic ? `[__VLS_tryAsConstant(\`\${${prop.arg.content}}Modifiers\`)]` : (0, shared_1$18.camelize)(propName) + `Modifiers` : `modelModifiers`;
				const codes$1 = [...(0, elementDirectives_1$1.generateModifiers)(options, ctx, prop, propertyName)];
				if (enableCodeFeatures) yield* codes$1;
				else yield (0, muggle_string_1$5.toString)(codes$1);
				yield utils_1$29.newLine;
			}
		} else if (prop.type === CompilerDOM$12.NodeTypes.ATTRIBUTE) {
			if (options.vueCompilerOptions.dataAttributes.some((pattern) => (0, picomatch_1.isMatch)(prop.name, pattern))) continue;
			const shouldSpread = prop.name === "style" || prop.name === "class";
			const shouldCamelize = isComponent$1 && getShouldCamelize(options, prop, prop.name);
			const features = getPropsCodeFeatures(strictPropsCheck);
			if (shouldSpread) yield `...{ `;
			const codes = [...(0, wrapWith_1$10.wrapWith)(prop.loc.start.offset, prop.loc.end.offset, codeFeatures_1$15.codeFeatures.verification, ...(0, objectProperty_1$3.generateObjectProperty)(options, ctx, prop.name, prop.loc.start.offset, features, shouldCamelize), `: `, ...prop.value ? generateAttrValue(prop.value, codeFeatures_1$15.codeFeatures.withoutNavigation) : [`true`])];
			if (enableCodeFeatures) yield* codes;
			else yield (0, muggle_string_1$5.toString)(codes);
			if (shouldSpread) yield ` }`;
			yield `,${utils_1$29.newLine}`;
		} else if (prop.name === "bind" && !prop.arg && prop.exp?.type === CompilerDOM$12.NodeTypes.SIMPLE_EXPRESSION) if (prop.exp.loc.source === "$attrs") {
			if (enableCodeFeatures) ctx.bindingAttrLocs.push(prop.exp.loc);
		} else {
			const codes = [...(0, wrapWith_1$10.wrapWith)(prop.exp.loc.start.offset, prop.exp.loc.end.offset, codeFeatures_1$15.codeFeatures.verification, `...`, ...generatePropExp(options, ctx, prop, prop.exp, enableCodeFeatures))];
			if (enableCodeFeatures) yield* codes;
			else yield (0, muggle_string_1$5.toString)(codes);
			yield `,${utils_1$29.newLine}`;
		}
	}
	function* generatePropExp(options, ctx, prop, exp, enableCodeFeatures = true) {
		const isShorthand = prop.arg?.loc.start.offset === prop.exp?.loc.start.offset;
		const features = isShorthand ? codeFeatures_1$15.codeFeatures.withoutHighlightAndCompletion : codeFeatures_1$15.codeFeatures.all;
		if (exp && exp.constType !== CompilerDOM$12.ConstantTypes.CAN_STRINGIFY) if (!isShorthand) yield* (0, interpolation_1$9.generateInterpolation)(options, ctx, "template", features, exp.loc.source, exp.loc.start.offset, `(`, `)`);
		else {
			const propVariableName = (0, shared_1$18.camelize)(exp.loc.source);
			if (utils_1$29.identifierRegex.test(propVariableName)) {
				const isDestructuredProp = options.destructuredPropNames.has(propVariableName);
				const isTemplateRef = options.templateRefNames.has(propVariableName);
				const codes = (0, camelized_1$3.generateCamelized)(exp.loc.source, "template", exp.loc.start.offset, features);
				if (ctx.hasLocalVariable(propVariableName) || isDestructuredProp) yield* codes;
				else {
					ctx.accessExternalVariable(propVariableName, exp.loc.start.offset);
					if (isTemplateRef) {
						yield `__VLS_unref(`;
						yield* codes;
						yield `)`;
					} else {
						yield `__VLS_ctx.`;
						yield* codes;
					}
				}
				if (enableCodeFeatures) ctx.inlayHints.push((0, inlayHints_1$2.createVBindShorthandInlayHintInfo)(prop.loc, propVariableName));
			}
		}
		else yield `{}`;
	}
	function* generateAttrValue(attrNode, features) {
		const quote = attrNode.loc.source.startsWith("'") ? "'" : "\"";
		yield quote;
		let start = attrNode.loc.start.offset;
		let content = attrNode.loc.source;
		if (content.startsWith("\"") && content.endsWith("\"") || content.startsWith("'") && content.endsWith("'")) {
			start++;
			content = content.slice(1, -1);
		}
		yield* (0, unicode_1.generateUnicode)(content, start, features);
		yield quote;
	}
	function getShouldCamelize(options, prop, propName) {
		return (prop.type !== CompilerDOM$12.NodeTypes.DIRECTIVE || !prop.arg || prop.arg.type === CompilerDOM$12.NodeTypes.SIMPLE_EXPRESSION && prop.arg.isStatic) && (0, shared_2$2.hyphenateAttr)(propName) === propName && !options.vueCompilerOptions.htmlAttributes.some((pattern) => (0, picomatch_1.isMatch)(propName, pattern));
	}
	function getPropsCodeFeatures(strictPropsCheck) {
		return {
			...codeFeatures_1$15.codeFeatures.withoutHighlightAndCompletion,
			...strictPropsCheck ? codeFeatures_1$15.codeFeatures.verification : codeFeatures_1$15.codeFeatures.doNotReportTs2353AndTs2561
		};
	}
	function getModelPropName(node, vueCompilerOptions) {
		for (const modelName in vueCompilerOptions.experimentalModelPropName) {
			const tags = vueCompilerOptions.experimentalModelPropName[modelName];
			for (const tag in tags) if (node.tag === tag || node.tag === (0, shared_2$2.hyphenateTag)(tag)) {
				const val = tags[tag];
				if (typeof val === "object") {
					const arr = Array.isArray(val) ? val : [val];
					for (const attrs of arr) {
						let failed = false;
						for (const attr in attrs) {
							const attrNode = node.props.find((prop) => prop.type === CompilerDOM$12.NodeTypes.ATTRIBUTE && prop.name === attr);
							if (!attrNode || attrNode.value?.content !== attrs[attr]) {
								failed = true;
								break;
							}
						}
						if (!failed) return modelName || void 0;
					}
				}
			}
		}
		for (const modelName in vueCompilerOptions.experimentalModelPropName) {
			const tags = vueCompilerOptions.experimentalModelPropName[modelName];
			for (const tag in tags) if (node.tag === tag || node.tag === (0, shared_2$2.hyphenateTag)(tag)) {
				const attrs = tags[tag];
				if (attrs === true) return modelName || void 0;
			}
		}
		return "modelValue";
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/elementDirectives.js
var require_elementDirectives = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/elementDirectives.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateElementDirectives = generateElementDirectives;
	exports.generateModifiers = generateModifiers;
	const CompilerDOM$11 = require_compiler_dom();
	const shared_1$17 = require_shared$2();
	const codeFeatures_1$14 = require_codeFeatures();
	const utils_1$28 = require_utils$3();
	const camelized_1$2 = require_camelized();
	const stringLiteralKey_1$1 = require_stringLiteralKey();
	const wrapWith_1$9 = require_wrapWith();
	const elementProps_1$2 = require_elementProps();
	const interpolation_1$8 = require_interpolation();
	const objectProperty_1$2 = require_objectProperty();
	const builtInDirectives$1 = new Set([
		"cloak",
		"html",
		"memo",
		"once",
		"show",
		"text"
	]);
	function* generateElementDirectives(options, ctx, node) {
		for (const prop of node.props) {
			if (prop.type !== CompilerDOM$11.NodeTypes.DIRECTIVE || prop.name === "slot" || prop.name === "on" || prop.name === "model" || prop.name === "bind") continue;
			if (!builtInDirectives$1.has(prop.name)) ctx.accessExternalVariable((0, shared_1$17.camelize)("v-" + prop.name), prop.loc.start.offset);
			yield* (0, wrapWith_1$9.wrapWith)(prop.loc.start.offset, prop.loc.end.offset, codeFeatures_1$14.codeFeatures.verification, `__VLS_asFunctionalDirective(`, ...generateIdentifier(options, prop), `)(null!, { ...__VLS_directiveBindingRestFields, `, ...generateArg(options, ctx, prop), ...generateModifiers(options, ctx, prop), ...generateValue(options, ctx, prop), ` }, null!, null!)`);
			yield utils_1$28.endOfLine;
		}
	}
	function* generateIdentifier(options, prop) {
		const rawName = "v-" + prop.name;
		yield* (0, wrapWith_1$9.wrapWith)(prop.loc.start.offset, prop.loc.start.offset + rawName.length, codeFeatures_1$14.codeFeatures.verification, `__VLS_directives.`, ...(0, camelized_1$2.generateCamelized)(rawName, "template", prop.loc.start.offset, {
			...codeFeatures_1$14.codeFeatures.withoutHighlightAndCompletion,
			verification: options.vueCompilerOptions.checkUnknownDirectives && !builtInDirectives$1.has(prop.name)
		}));
	}
	function* generateArg(options, ctx, prop) {
		const { arg } = prop;
		if (arg?.type !== CompilerDOM$11.NodeTypes.SIMPLE_EXPRESSION) return;
		const startOffset = arg.loc.start.offset + arg.loc.source.indexOf(arg.content);
		yield* (0, wrapWith_1$9.wrapWith)(startOffset, startOffset + arg.content.length, codeFeatures_1$14.codeFeatures.verification, `arg`);
		yield `: `;
		if (arg.isStatic) yield* (0, stringLiteralKey_1$1.generateStringLiteralKey)(arg.content, startOffset, codeFeatures_1$14.codeFeatures.all);
		else yield* (0, interpolation_1$8.generateInterpolation)(options, ctx, "template", codeFeatures_1$14.codeFeatures.all, arg.content, startOffset, `(`, `)`);
		yield `, `;
	}
	function* generateModifiers(options, ctx, prop, propertyName = "modifiers") {
		const { modifiers } = prop;
		if (!modifiers.length) return;
		const startOffset = modifiers[0].loc.start.offset - 1;
		const endOffset = modifiers.at(-1).loc.end.offset;
		yield* (0, wrapWith_1$9.wrapWith)(startOffset, endOffset, codeFeatures_1$14.codeFeatures.verification, propertyName);
		yield `: { `;
		for (const mod of modifiers) {
			yield* (0, objectProperty_1$2.generateObjectProperty)(options, ctx, mod.content, mod.loc.start.offset, codeFeatures_1$14.codeFeatures.withoutHighlight);
			yield `: true, `;
		}
		yield `}, `;
	}
	function* generateValue(options, ctx, prop) {
		const { exp } = prop;
		if (exp?.type !== CompilerDOM$11.NodeTypes.SIMPLE_EXPRESSION) return;
		yield* (0, wrapWith_1$9.wrapWith)(exp.loc.start.offset, exp.loc.end.offset, codeFeatures_1$14.codeFeatures.verification, `value`);
		yield `: `;
		yield* (0, elementProps_1$2.generatePropExp)(options, ctx, prop, exp);
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/propertyAccess.js
var require_propertyAccess = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/propertyAccess.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generatePropertyAccess = generatePropertyAccess;
	const utils_1$27 = require_utils$3();
	const stringLiteralKey_1 = require_stringLiteralKey();
	const interpolation_1$7 = require_interpolation();
	function* generatePropertyAccess(options, ctx, code$1, offset, features) {
		if (!options.compilerOptions.noPropertyAccessFromIndexSignature && utils_1$27.identifierRegex.test(code$1)) {
			yield `.`;
			yield offset !== void 0 && features ? [
				code$1,
				"template",
				offset,
				features
			] : code$1;
		} else if (code$1.startsWith("[") && code$1.endsWith("]")) yield* (0, interpolation_1$7.generateInterpolation)(options, ctx, "template", features, code$1, offset);
		else {
			yield `[`;
			yield* (0, stringLiteralKey_1.generateStringLiteralKey)(code$1, offset, features);
			yield `]`;
		}
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/vSlot.js
var require_vSlot = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/vSlot.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateVSlot = generateVSlot;
	const CompilerDOM$10 = require_compiler_dom();
	const muggle_string_1$4 = require_out();
	const collectBindings_1$3 = require_collectBindings();
	const codeFeatures_1$13 = require_codeFeatures();
	const utils_1$26 = require_utils$3();
	const wrapWith_1$8 = require_wrapWith();
	const elementChildren_1$5 = require_elementChildren();
	const interpolation_1$6 = require_interpolation();
	const objectProperty_1$1 = require_objectProperty();
	function* generateVSlot(options, ctx, node, slotDir) {
		if (!ctx.currentComponent) return;
		const slotBlockVars = [];
		const slotVar = ctx.getInternalVariable();
		if (slotDir) yield `{${utils_1$26.newLine}`;
		if (slotDir || node.children.length) {
			ctx.currentComponent.used = true;
			yield `const { `;
			if (slotDir) if (slotDir.arg?.type === CompilerDOM$10.NodeTypes.SIMPLE_EXPRESSION && slotDir.arg.content) yield* (0, objectProperty_1$1.generateObjectProperty)(options, ctx, slotDir.arg.loc.source, slotDir.arg.loc.start.offset, slotDir.arg.isStatic ? codeFeatures_1$13.codeFeatures.withoutHighlight : codeFeatures_1$13.codeFeatures.all, false, true);
			else yield* (0, wrapWith_1$8.wrapWith)(slotDir.loc.start.offset, slotDir.loc.start.offset + (slotDir.rawName?.length ?? 0), codeFeatures_1$13.codeFeatures.withoutHighlightAndCompletion, `default`);
			else yield* (0, wrapWith_1$8.wrapWith)(node.loc.start.offset, node.loc.end.offset, codeFeatures_1$13.codeFeatures.navigation, `default`);
			yield `: ${slotVar} } = ${ctx.currentComponent.ctxVar}.slots!${utils_1$26.endOfLine}`;
		}
		if (slotDir?.exp?.type === CompilerDOM$10.NodeTypes.SIMPLE_EXPRESSION) {
			const slotAst = (0, utils_1$26.createTsAst)(options.ts, ctx.inlineTsAsts, `(${slotDir.exp.content}) => {}`);
			slotBlockVars.push(...(0, collectBindings_1$3.collectBindingNames)(options.ts, slotAst, slotAst));
			yield* generateSlotParameters(options, ctx, slotAst, slotDir.exp, slotVar);
		}
		for (const varName of slotBlockVars) ctx.addLocalVariable(varName);
		yield* (0, elementChildren_1$5.generateElementChildren)(options, ctx, node.children);
		for (const varName of slotBlockVars) ctx.removeLocalVariable(varName);
		if (slotDir) {
			let isStatic = true;
			if (slotDir.arg?.type === CompilerDOM$10.NodeTypes.SIMPLE_EXPRESSION) isStatic = slotDir.arg.isStatic;
			if (isStatic && !slotDir.arg) {
				yield `${ctx.currentComponent.ctxVar}.slots!['`;
				yield [
					"",
					"template",
					slotDir.loc.start.offset + (slotDir.loc.source.startsWith("#") ? 1 : slotDir.loc.source.startsWith("v-slot:") ? 7 : 0),
					codeFeatures_1$13.codeFeatures.completion
				];
				yield `'/* empty slot name completion */]${utils_1$26.endOfLine}`;
			}
			yield `}${utils_1$26.newLine}`;
		}
	}
	function* generateSlotParameters(options, ctx, ast, exp, slotVar) {
		const { ts } = options;
		const statement = ast.statements[0];
		if (!statement || !ts.isExpressionStatement(statement) || !ts.isArrowFunction(statement.expression)) return;
		const { expression } = statement;
		const startOffset = exp.loc.start.offset - 1;
		const types$1 = [];
		const interpolation = [...(0, interpolation_1$6.generateInterpolation)(options, ctx, "template", codeFeatures_1$13.codeFeatures.all, ast.text, startOffset)];
		(0, muggle_string_1$4.replaceSourceRange)(interpolation, "template", startOffset, startOffset + `(`.length);
		(0, muggle_string_1$4.replaceSourceRange)(interpolation, "template", startOffset + ast.text.length - `) => {}`.length, startOffset + ast.text.length);
		for (const { name, type } of expression.parameters) if (type) {
			types$1.push([
				ast.text.slice(name.end, type.end),
				"template",
				startOffset + name.end,
				codeFeatures_1$13.codeFeatures.all
			]);
			(0, muggle_string_1$4.replaceSourceRange)(interpolation, "template", startOffset + name.end, startOffset + type.end);
		} else types$1.push(null);
		yield `const [`;
		yield* interpolation;
		yield `] = __VLS_getSlotParameters(${slotVar}!`;
		if (types$1.some((t) => t)) {
			yield `, `;
			yield* (0, wrapWith_1$8.wrapWith)(exp.loc.start.offset, exp.loc.end.offset, codeFeatures_1$13.codeFeatures.verification, `(`, ...types$1.flatMap((type) => type ? [
				`_`,
				type,
				`, `
			] : `_, `), `) => [] as any`);
		}
		yield `)${utils_1$26.endOfLine}`;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/element.js
var require_element = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/element.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateComponent = generateComponent$1;
	exports.generateElement = generateElement;
	const CompilerDOM$9 = require_compiler_dom();
	const shared_1$16 = require_shared$2();
	const shared_2$1 = require_shared$1();
	const codeFeatures_1$12 = require_codeFeatures();
	const inlayHints_1$1 = require_inlayHints();
	const utils_1$25 = require_utils$3();
	const camelized_1$1 = require_camelized();
	const wrapWith_1$7 = require_wrapWith();
	const elementChildren_1$4 = require_elementChildren();
	const elementDirectives_1 = require_elementDirectives();
	const elementEvents_1$1 = require_elementEvents();
	const elementProps_1$1 = require_elementProps();
	const interpolation_1$5 = require_interpolation();
	const propertyAccess_1$1 = require_propertyAccess();
	const styleScopedClasses_1$2 = require_styleScopedClasses();
	const vSlot_1$1 = require_vSlot();
	const colonReg = /:/g;
	function* generateComponent$1(options, ctx, node) {
		const tagOffsets = (0, shared_2$1.getElementTagOffsets)(node, options.template);
		const failedPropExps = [];
		const possibleOriginalNames = getPossibleOriginalComponentNames(node.tag, true);
		const matchImportName = possibleOriginalNames.find((name) => options.scriptSetupImportComponentNames.has(name));
		const componentOriginalVar = matchImportName ?? ctx.getInternalVariable();
		const componentFunctionalVar = ctx.getInternalVariable();
		const componentVNodeVar = ctx.getInternalVariable();
		const componentCtxVar = ctx.getInternalVariable();
		const isComponentTag$1 = node.tag.toLowerCase() === "component";
		ctx.currentComponent = {
			ctxVar: componentCtxVar,
			used: false
		};
		let props = node.props;
		let dynamicTagInfo;
		if (isComponentTag$1) {
			for (const prop of node.props) if (prop.type === CompilerDOM$9.NodeTypes.DIRECTIVE && prop.name === "bind" && prop.arg?.loc.source === "is" && prop.exp?.type === CompilerDOM$9.NodeTypes.SIMPLE_EXPRESSION) {
				if (prop.arg.loc.end.offset === prop.exp.loc.end.offset) ctx.inlayHints.push((0, inlayHints_1$1.createVBindShorthandInlayHintInfo)(prop.exp.loc, "is"));
				dynamicTagInfo = {
					tag: prop.exp.content,
					offsets: [prop.exp.loc.start.offset]
				};
				props = props.filter((p) => p !== prop);
				break;
			}
		} else if (node.tag.includes(".")) dynamicTagInfo = {
			tag: node.tag,
			offsets: tagOffsets
		};
		if (matchImportName) {
			yield `/** @type {[`;
			for (const tagOffset of tagOffsets) {
				yield `typeof `;
				if (componentOriginalVar === node.tag) yield [
					componentOriginalVar,
					"template",
					tagOffset,
					codeFeatures_1$12.codeFeatures.withoutHighlightAndCompletion
				];
				else {
					const shouldCapitalize = matchImportName[0].toUpperCase() === matchImportName[0];
					yield* (0, camelized_1$1.generateCamelized)(shouldCapitalize ? (0, shared_1$16.capitalize)(node.tag) : node.tag, "template", tagOffset, codeFeatures_1$12.codeFeatures.withoutHighlightAndCompletion);
				}
				yield `, `;
			}
			yield `]} */${utils_1$25.endOfLine}`;
		} else if (dynamicTagInfo) {
			yield `const ${componentOriginalVar} = (`;
			yield* (0, interpolation_1$5.generateInterpolation)(options, ctx, "template", codeFeatures_1$12.codeFeatures.all, dynamicTagInfo.tag, dynamicTagInfo.offsets[0], `(`, `)`);
			if (dynamicTagInfo.offsets[1] !== void 0) {
				yield `,`;
				yield* (0, interpolation_1$5.generateInterpolation)(options, ctx, "template", codeFeatures_1$12.codeFeatures.withoutCompletion, dynamicTagInfo.tag, dynamicTagInfo.offsets[1], `(`, `)`);
			}
			yield `)${utils_1$25.endOfLine}`;
		} else {
			yield `const ${componentOriginalVar} = ({} as __VLS_WithComponent<'${getCanonicalComponentName(node.tag)}', __VLS_LocalComponents, `;
			if (options.selfComponentName && possibleOriginalNames.includes(options.selfComponentName)) yield `typeof __VLS_export, `;
			else yield `void, `;
			yield getPossibleOriginalComponentNames(node.tag, false).map((name) => `'${name}'`).join(`, `);
			yield `>).`;
			yield* generateCanonicalComponentName(node.tag, tagOffsets[0], {
				...codeFeatures_1$12.codeFeatures.semanticWithoutHighlight,
				...options.vueCompilerOptions.checkUnknownComponents ? codeFeatures_1$12.codeFeatures.verification : codeFeatures_1$12.codeFeatures.doNotReportTs2339AndTs2551
			});
			yield utils_1$25.endOfLine;
			const camelizedTag = (0, shared_1$16.camelize)(node.tag);
			if (utils_1$25.identifierRegex.test(camelizedTag)) {
				yield `/** @type {[`;
				for (const tagOffset of tagOffsets) for (const shouldCapitalize of node.tag[0] === node.tag[0].toUpperCase() ? [false] : [true, false]) {
					yield `typeof __VLS_components.`;
					yield* (0, camelized_1$1.generateCamelized)(shouldCapitalize ? (0, shared_1$16.capitalize)(node.tag) : node.tag, "template", tagOffset, codeFeatures_1$12.codeFeatures.navigation);
					yield `, `;
				}
				yield `]} */${utils_1$25.endOfLine}`;
				yield `// @ts-ignore${utils_1$25.newLine}`;
				yield* (0, camelized_1$1.generateCamelized)((0, shared_1$16.capitalize)(node.tag), "template", tagOffsets[0], { completion: {
					isAdditional: true,
					onlyImport: true
				} });
				yield utils_1$25.endOfLine;
			}
		}
		yield `// @ts-ignore${utils_1$25.newLine}`;
		yield `const ${componentFunctionalVar} = __VLS_asFunctionalComponent(${componentOriginalVar}, new ${componentOriginalVar}({${utils_1$25.newLine}`;
		yield* (0, elementProps_1$1.generateElementProps)(options, ctx, node, props, options.vueCompilerOptions.checkUnknownProps, false);
		yield `}))${utils_1$25.endOfLine}`;
		yield `const `;
		yield* (0, wrapWith_1$7.wrapWith)(node.loc.start.offset, node.loc.end.offset, codeFeatures_1$12.codeFeatures.doNotReportTs6133, componentVNodeVar);
		yield ` = ${componentFunctionalVar}`;
		yield* generateComponentGeneric(ctx);
		yield `(`;
		yield* (0, wrapWith_1$7.wrapWith)(tagOffsets[0], tagOffsets[0] + node.tag.length, codeFeatures_1$12.codeFeatures.verification, `{${utils_1$25.newLine}`, ...(0, elementProps_1$1.generateElementProps)(options, ctx, node, props, options.vueCompilerOptions.checkUnknownProps, true, failedPropExps), `}`);
		yield `, ...__VLS_functionalComponentArgsRest(${componentFunctionalVar}))${utils_1$25.endOfLine}`;
		yield* generateFailedPropExps(options, ctx, failedPropExps);
		yield* (0, elementEvents_1$1.generateElementEvents)(options, ctx, node, componentOriginalVar, componentFunctionalVar, componentVNodeVar, componentCtxVar);
		yield* (0, elementDirectives_1.generateElementDirectives)(options, ctx, node);
		const reference = yield* generateElementReference(options, ctx, node);
		const tag = (0, shared_2$1.hyphenateTag)(node.tag);
		const isRootNode = ctx.singleRootNodes.has(node) && !options.vueCompilerOptions.fallthroughComponentNames.includes(tag);
		if (reference || isRootNode) {
			const componentInstanceVar = ctx.getInternalVariable();
			ctx.currentComponent.used = true;
			yield `var ${componentInstanceVar} = {} as (Parameters<NonNullable<typeof ${componentCtxVar}['expose']>>[0] | null)`;
			if (ctx.inVFor) yield `[]`;
			yield utils_1$25.endOfLine;
			if (reference) {
				const typeExp = `typeof ${ctx.getHoistVariable(componentInstanceVar)}`;
				ctx.addTemplateRef(reference.name, typeExp, reference.offset);
			}
			if (isRootNode) ctx.singleRootElTypes.push(`NonNullable<typeof ${componentInstanceVar}>['$el']`);
		}
		if (hasVBindAttrs(options, ctx, node)) {
			const attrsVar = ctx.getInternalVariable();
			ctx.currentComponent.used = true;
			yield `var ${attrsVar}!: NonNullable<typeof ${componentCtxVar}['props']>${utils_1$25.endOfLine}`;
			ctx.inheritedAttrVars.add(attrsVar);
		}
		(0, styleScopedClasses_1$2.collectStyleScopedClassReferences)(options, ctx, node);
		const slotDir = node.props.find((p) => p.type === CompilerDOM$9.NodeTypes.DIRECTIVE && p.name === "slot");
		yield* (0, vSlot_1$1.generateVSlot)(options, ctx, node, slotDir);
		if (ctx.currentComponent.used) yield `var ${componentCtxVar}!: __VLS_FunctionalComponentCtx<typeof ${componentOriginalVar}, typeof ${componentVNodeVar}>${utils_1$25.endOfLine}`;
	}
	function* generateElement(options, ctx, node) {
		const [startTagOffset, endTagOffset] = (0, shared_2$1.getElementTagOffsets)(node, options.template);
		const failedPropExps = [];
		yield `__VLS_asFunctionalElement(__VLS_elements`;
		yield* (0, propertyAccess_1$1.generatePropertyAccess)(options, ctx, node.tag, startTagOffset, codeFeatures_1$12.codeFeatures.withoutHighlightAndCompletion);
		if (endTagOffset !== void 0) {
			yield `, __VLS_elements`;
			yield* (0, propertyAccess_1$1.generatePropertyAccess)(options, ctx, node.tag, endTagOffset, codeFeatures_1$12.codeFeatures.withoutHighlightAndCompletion);
		}
		yield `)(`;
		yield* (0, wrapWith_1$7.wrapWith)(startTagOffset, startTagOffset + node.tag.length, codeFeatures_1$12.codeFeatures.verification, `{${utils_1$25.newLine}`, ...(0, elementProps_1$1.generateElementProps)(options, ctx, node, node.props, options.vueCompilerOptions.checkUnknownProps, true, failedPropExps), `}`);
		yield `)${utils_1$25.endOfLine}`;
		yield* generateFailedPropExps(options, ctx, failedPropExps);
		yield* (0, elementDirectives_1.generateElementDirectives)(options, ctx, node);
		const reference = yield* generateElementReference(options, ctx, node);
		if (reference) {
			let typeExp = `__VLS_NativeElements['${node.tag}']`;
			if (ctx.inVFor) typeExp += `[]`;
			ctx.addTemplateRef(reference.name, typeExp, reference.offset);
		}
		if (ctx.singleRootNodes.has(node)) ctx.singleRootElTypes.push(`__VLS_NativeElements['${node.tag}']`);
		if (hasVBindAttrs(options, ctx, node)) ctx.inheritedAttrVars.add(`__VLS_elements.${node.tag}`);
		(0, styleScopedClasses_1$2.collectStyleScopedClassReferences)(options, ctx, node);
		const { currentComponent } = ctx;
		ctx.currentComponent = void 0;
		yield* (0, elementChildren_1$4.generateElementChildren)(options, ctx, node.children);
		ctx.currentComponent = currentComponent;
	}
	function* generateFailedPropExps(options, ctx, failedPropExps) {
		for (const failedExp of failedPropExps) {
			yield* (0, interpolation_1$5.generateInterpolation)(options, ctx, "template", codeFeatures_1$12.codeFeatures.all, failedExp.node.loc.source, failedExp.node.loc.start.offset, failedExp.prefix, failedExp.suffix);
			yield utils_1$25.endOfLine;
		}
	}
	function getCanonicalComponentName(tagText) {
		return utils_1$25.identifierRegex.test(tagText) ? tagText : (0, shared_1$16.capitalize)((0, shared_1$16.camelize)(tagText.replace(colonReg, "-")));
	}
	function getPossibleOriginalComponentNames(tagText, deduplicate) {
		const name1 = (0, shared_1$16.capitalize)((0, shared_1$16.camelize)(tagText));
		const name2 = (0, shared_1$16.camelize)(tagText);
		const name3 = tagText;
		const names = [name1];
		if (!deduplicate || name2 !== name1) names.push(name2);
		if (!deduplicate || name3 !== name2) names.push(name3);
		return names;
	}
	function* generateCanonicalComponentName(tagText, offset, features) {
		if (utils_1$25.identifierRegex.test(tagText)) yield [
			tagText,
			"template",
			offset,
			features
		];
		else yield* (0, camelized_1$1.generateCamelized)((0, shared_1$16.capitalize)(tagText.replace(colonReg, "-")), "template", offset, features);
	}
	function* generateComponentGeneric(ctx) {
		if (ctx.currentInfo.generic) {
			const { content, offset } = ctx.currentInfo.generic;
			yield* (0, wrapWith_1$7.wrapWith)(offset, offset + content.length, codeFeatures_1$12.codeFeatures.verification, `<`, [
				content,
				"template",
				offset,
				codeFeatures_1$12.codeFeatures.all
			], `>`);
		}
	}
	function* generateElementReference(options, ctx, node) {
		for (const prop of node.props) if (prop.type === CompilerDOM$9.NodeTypes.ATTRIBUTE && prop.name === "ref" && prop.value) {
			const [name, offset] = (0, utils_1$25.normalizeAttributeValue)(prop.value);
			yield `/** @type {typeof __VLS_ctx`;
			yield* (0, propertyAccess_1$1.generatePropertyAccess)(options, ctx, name, offset, codeFeatures_1$12.codeFeatures.navigation);
			yield `} */${utils_1$25.endOfLine}`;
			if (utils_1$25.identifierRegex.test(name) && !options.templateRefNames.has(name)) ctx.accessExternalVariable(name, offset);
			return {
				name,
				offset
			};
		}
	}
	function hasVBindAttrs(options, ctx, node) {
		return options.vueCompilerOptions.fallthroughAttributes && (options.inheritAttrs && ctx.singleRootNodes.has(node) || node.props.some((prop) => prop.type === CompilerDOM$9.NodeTypes.DIRECTIVE && prop.name === "bind" && prop.exp?.loc.source === "$attrs"));
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/slotOutlet.js
var require_slotOutlet = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/slotOutlet.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateSlotOutlet = generateSlotOutlet;
	const CompilerDOM$8 = require_compiler_dom();
	const shared_1$15 = require_shared$1();
	const codeFeatures_1$11 = require_codeFeatures();
	const inlayHints_1 = require_inlayHints();
	const utils_1$24 = require_utils$3();
	const wrapWith_1$6 = require_wrapWith();
	const elementChildren_1$3 = require_elementChildren();
	const elementProps_1 = require_elementProps();
	const interpolation_1$4 = require_interpolation();
	const propertyAccess_1 = require_propertyAccess();
	function* generateSlotOutlet(options, ctx, node) {
		const [startTagOffset] = (0, shared_1$15.getElementTagOffsets)(node, options.template);
		const startTagEndOffset = startTagOffset + node.tag.length;
		const propsVar = ctx.getInternalVariable();
		const nameProp = node.props.find((prop) => {
			if (prop.type === CompilerDOM$8.NodeTypes.ATTRIBUTE) return prop.name === "name";
			if (prop.name === "bind" && prop.arg?.type === CompilerDOM$8.NodeTypes.SIMPLE_EXPRESSION) return prop.arg.content === "name";
		});
		if (options.hasDefineSlots) {
			yield `__VLS_asFunctionalSlot(`;
			if (nameProp) {
				let codes;
				if (nameProp.type === CompilerDOM$8.NodeTypes.ATTRIBUTE && nameProp.value) {
					let { source, start: { offset } } = nameProp.value.loc;
					if (source.startsWith("\"") || source.startsWith("'")) {
						source = source.slice(1, -1);
						offset++;
					}
					codes = (0, propertyAccess_1.generatePropertyAccess)(options, ctx, source, offset, codeFeatures_1$11.codeFeatures.navigationAndVerification);
				} else if (nameProp.type === CompilerDOM$8.NodeTypes.DIRECTIVE && nameProp.exp?.type === CompilerDOM$8.NodeTypes.SIMPLE_EXPRESSION) codes = [
					`[`,
					...(0, elementProps_1.generatePropExp)(options, ctx, nameProp, nameProp.exp),
					`]`
				];
				else codes = [`['default']`];
				yield* (0, wrapWith_1$6.wrapWith)(nameProp.loc.start.offset, nameProp.loc.end.offset, codeFeatures_1$11.codeFeatures.verification, options.slotsAssignName ?? "__VLS_slots", ...codes);
			} else yield* (0, wrapWith_1$6.wrapWith)(startTagOffset, startTagEndOffset, codeFeatures_1$11.codeFeatures.verification, `${options.slotsAssignName ?? "__VLS_slots"}[`, ...(0, wrapWith_1$6.wrapWith)(startTagOffset, startTagEndOffset, codeFeatures_1$11.codeFeatures.verification, `'default'`), `]`);
			yield `)(`;
			yield* (0, wrapWith_1$6.wrapWith)(startTagOffset, startTagEndOffset, codeFeatures_1$11.codeFeatures.verification, `{${utils_1$24.newLine}`, ...(0, elementProps_1.generateElementProps)(options, ctx, node, node.props.filter((prop) => prop !== nameProp), true, true), `}`);
			yield `)${utils_1$24.endOfLine}`;
		} else {
			yield `var ${propsVar} = {${utils_1$24.newLine}`;
			yield* (0, elementProps_1.generateElementProps)(options, ctx, node, node.props.filter((prop) => prop !== nameProp), options.vueCompilerOptions.checkUnknownProps, true);
			yield `}${utils_1$24.endOfLine}`;
			if (nameProp?.type === CompilerDOM$8.NodeTypes.ATTRIBUTE && nameProp.value) ctx.slots.push({
				name: nameProp.value.content,
				offset: nameProp.loc.start.offset + nameProp.loc.source.indexOf(nameProp.value.content, nameProp.name.length),
				tagRange: [startTagOffset, startTagOffset + node.tag.length],
				nodeLoc: node.loc,
				propsVar: ctx.getHoistVariable(propsVar)
			});
			else if (nameProp?.type === CompilerDOM$8.NodeTypes.DIRECTIVE && nameProp.exp?.type === CompilerDOM$8.NodeTypes.SIMPLE_EXPRESSION) {
				const isShortHand = nameProp.arg?.loc.start.offset === nameProp.exp.loc.start.offset;
				if (isShortHand) ctx.inlayHints.push((0, inlayHints_1.createVBindShorthandInlayHintInfo)(nameProp.exp.loc, "name"));
				const expVar = ctx.getInternalVariable();
				yield `var ${expVar} = __VLS_tryAsConstant(`;
				yield* (0, interpolation_1$4.generateInterpolation)(options, ctx, "template", codeFeatures_1$11.codeFeatures.all, nameProp.exp.content, nameProp.exp.loc.start.offset);
				yield `)${utils_1$24.endOfLine}`;
				ctx.dynamicSlots.push({
					expVar: ctx.getHoistVariable(expVar),
					propsVar: ctx.getHoistVariable(propsVar)
				});
			} else ctx.slots.push({
				name: "default",
				tagRange: [startTagOffset, startTagEndOffset],
				nodeLoc: node.loc,
				propsVar: ctx.getHoistVariable(propsVar)
			});
		}
		yield* (0, elementChildren_1$3.generateElementChildren)(options, ctx, node.children);
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/vFor.js
var require_vFor = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/vFor.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateVFor = generateVFor;
	exports.parseVForNode = parseVForNode;
	const CompilerDOM$7 = require_compiler_dom();
	const collectBindings_1$2 = require_collectBindings();
	const codeFeatures_1$10 = require_codeFeatures();
	const utils_1$23 = require_utils$3();
	const elementChildren_1$2 = require_elementChildren();
	const interpolation_1$3 = require_interpolation();
	function* generateVFor(options, ctx, node) {
		const { source } = node.parseResult;
		const { leftExpressionRange, leftExpressionText } = parseVForNode(node);
		const forBlockVars = [];
		yield `for (const [`;
		if (leftExpressionRange && leftExpressionText) {
			const collectAst = (0, utils_1$23.createTsAst)(options.ts, ctx.inlineTsAsts, `const [${leftExpressionText}]`);
			forBlockVars.push(...(0, collectBindings_1$2.collectBindingNames)(options.ts, collectAst, collectAst));
			yield [
				leftExpressionText,
				"template",
				leftExpressionRange.start,
				codeFeatures_1$10.codeFeatures.all
			];
		}
		yield `] of `;
		if (source.type === CompilerDOM$7.NodeTypes.SIMPLE_EXPRESSION) {
			yield `__VLS_getVForSourceType(`;
			yield* (0, interpolation_1$3.generateInterpolation)(options, ctx, "template", codeFeatures_1$10.codeFeatures.all, source.content, source.loc.start.offset, `(`, `)`);
			yield `!)`;
		} else yield `{} as any`;
		yield `) {${utils_1$23.newLine}`;
		for (const varName of forBlockVars) ctx.addLocalVariable(varName);
		let isFragment$2 = true;
		for (const argument of node.codegenNode?.children.arguments ?? []) if (argument.type === CompilerDOM$7.NodeTypes.JS_FUNCTION_EXPRESSION && argument.returns?.type === CompilerDOM$7.NodeTypes.VNODE_CALL && argument.returns.props?.type === CompilerDOM$7.NodeTypes.JS_OBJECT_EXPRESSION) {
			if (argument.returns.tag !== CompilerDOM$7.FRAGMENT) {
				isFragment$2 = false;
				continue;
			}
			for (const prop of argument.returns.props.properties) if (prop.value.type === CompilerDOM$7.NodeTypes.SIMPLE_EXPRESSION && !prop.value.isStatic) {
				yield* (0, interpolation_1$3.generateInterpolation)(options, ctx, "template", codeFeatures_1$10.codeFeatures.all, prop.value.content, prop.value.loc.start.offset, `(`, `)`);
				yield utils_1$23.endOfLine;
			}
		}
		const { inVFor } = ctx;
		ctx.inVFor = true;
		yield* (0, elementChildren_1$2.generateElementChildren)(options, ctx, node.children, isFragment$2);
		ctx.inVFor = inVFor;
		for (const varName of forBlockVars) ctx.removeLocalVariable(varName);
		yield `}${utils_1$23.newLine}`;
	}
	function parseVForNode(node) {
		const { value, key, index } = node.parseResult;
		const leftExpressionRange = value || key || index ? {
			start: (value ?? key ?? index).loc.start.offset,
			end: (index ?? key ?? value).loc.end.offset
		} : void 0;
		const leftExpressionText = leftExpressionRange ? node.loc.source.slice(leftExpressionRange.start - node.loc.start.offset, leftExpressionRange.end - node.loc.start.offset) : void 0;
		return {
			leftExpressionRange,
			leftExpressionText
		};
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/vIf.js
var require_vIf = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/vIf.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateVIf = generateVIf;
	const CompilerDOM$6 = require_compiler_dom();
	const muggle_string_1$3 = require_out();
	const codeFeatures_1$9 = require_codeFeatures();
	const utils_1$22 = require_utils$3();
	const elementChildren_1$1 = require_elementChildren();
	const interpolation_1$2 = require_interpolation();
	function* generateVIf(options, ctx, node) {
		const originalBlockConditionsLength = ctx.blockConditions.length;
		for (let i = 0; i < node.branches.length; i++) {
			const branch = node.branches[i];
			if (i === 0) yield `if `;
			else if (branch.condition) yield `else if `;
			else yield `else `;
			let addedBlockCondition = false;
			if (branch.condition?.type === CompilerDOM$6.NodeTypes.SIMPLE_EXPRESSION) {
				const codes = [...(0, interpolation_1$2.generateInterpolation)(options, ctx, "template", codeFeatures_1$9.codeFeatures.all, branch.condition.content, branch.condition.loc.start.offset, `(`, `)`)];
				yield* codes;
				ctx.blockConditions.push((0, muggle_string_1$3.toString)(codes));
				addedBlockCondition = true;
				yield ` `;
			}
			yield `{${utils_1$22.newLine}`;
			yield* (0, elementChildren_1$1.generateElementChildren)(options, ctx, branch.children, isFragment(node));
			yield `}${utils_1$22.newLine}`;
			if (addedBlockCondition) ctx.blockConditions[ctx.blockConditions.length - 1] = `!${ctx.blockConditions[ctx.blockConditions.length - 1]}`;
		}
		ctx.blockConditions.length = originalBlockConditionsLength;
	}
	function isFragment(node) {
		return node.codegenNode && "consequent" in node.codegenNode && "tag" in node.codegenNode.consequent && node.codegenNode.consequent.tag === CompilerDOM$6.FRAGMENT;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/templateChild.js
var require_templateChild = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/templateChild.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateTemplateChild = generateTemplateChild;
	exports.getVForNode = getVForNode;
	exports.parseInterpolationNode = parseInterpolationNode;
	const CompilerDOM$5 = require_compiler_dom();
	const shared_1$14 = require_shared$1();
	const codeFeatures_1$8 = require_codeFeatures();
	const utils_1$21 = require_utils$3();
	const element_1 = require_element();
	const elementChildren_1 = require_elementChildren();
	const interpolation_1$1 = require_interpolation();
	const slotOutlet_1 = require_slotOutlet();
	const vFor_1$1 = require_vFor();
	const vIf_1 = require_vIf();
	const vSlot_1 = require_vSlot();
	const transformContext = {
		onError: () => {},
		helperString: (str) => str.toString(),
		replaceNode: () => {},
		cacheHandlers: false,
		prefixIdentifiers: false,
		scopes: {
			vFor: 0,
			vOnce: 0,
			vPre: 0,
			vSlot: 0
		},
		expressionPlugins: ["typescript"]
	};
	function* generateTemplateChild(options, ctx, node, enterNode = true) {
		if (enterNode && !ctx.enter(node)) return;
		const cur = node;
		if (cur.codegenNode?.type === CompilerDOM$5.NodeTypes.JS_CACHE_EXPRESSION) cur.codegenNode = cur.codegenNode.value;
		if (node.type === CompilerDOM$5.NodeTypes.ROOT) {
			for (const item of collectSingleRootNodes(options, node.children)) ctx.singleRootNodes.add(item);
			yield* (0, elementChildren_1.generateElementChildren)(options, ctx, node.children);
		} else if (node.type === CompilerDOM$5.NodeTypes.ELEMENT) {
			const vForNode = getVForNode(node);
			const vIfNode = getVIfNode(node);
			if (vForNode) yield* (0, vFor_1$1.generateVFor)(options, ctx, vForNode);
			else if (vIfNode) yield* (0, vIf_1.generateVIf)(options, ctx, vIfNode);
			else if (node.tagType === CompilerDOM$5.ElementTypes.SLOT) yield* (0, slotOutlet_1.generateSlotOutlet)(options, ctx, node);
			else {
				const slotDir = node.props.find((p) => p.type === CompilerDOM$5.NodeTypes.DIRECTIVE && p.name === "slot");
				if (node.tagType === CompilerDOM$5.ElementTypes.TEMPLATE && ctx.currentComponent && slotDir) yield* (0, vSlot_1.generateVSlot)(options, ctx, node, slotDir);
				else if (node.tagType === CompilerDOM$5.ElementTypes.ELEMENT || node.tagType === CompilerDOM$5.ElementTypes.TEMPLATE) yield* (0, element_1.generateElement)(options, ctx, node);
				else {
					const { currentComponent } = ctx;
					yield* (0, element_1.generateComponent)(options, ctx, node);
					ctx.currentComponent = currentComponent;
				}
			}
		} else if (node.type === CompilerDOM$5.NodeTypes.TEXT_CALL) yield* generateTemplateChild(options, ctx, node.content, false);
		else if (node.type === CompilerDOM$5.NodeTypes.COMPOUND_EXPRESSION) yield* (0, elementChildren_1.generateElementChildren)(options, ctx, node.children.filter((child) => typeof child === "object"), false);
		else if (node.type === CompilerDOM$5.NodeTypes.INTERPOLATION) {
			const [content, start] = parseInterpolationNode(node, options.template.content);
			yield* (0, interpolation_1$1.generateInterpolation)(options, ctx, "template", codeFeatures_1$8.codeFeatures.all, content, start, `(`, `)${utils_1$21.endOfLine}`);
		} else if (node.type === CompilerDOM$5.NodeTypes.IF) yield* (0, vIf_1.generateVIf)(options, ctx, node);
		else if (node.type === CompilerDOM$5.NodeTypes.FOR) yield* (0, vFor_1$1.generateVFor)(options, ctx, node);
		else if (node.type === CompilerDOM$5.NodeTypes.TEXT) {}
		if (enterNode) yield* ctx.exit();
	}
	function* collectSingleRootNodes(options, children) {
		children = children.filter((node) => node.type !== CompilerDOM$5.NodeTypes.COMMENT);
		if (children.length !== 1) {
			if (children.length > 1) yield null;
			return;
		}
		const child = children[0];
		if (child.type === CompilerDOM$5.NodeTypes.IF) {
			for (const branch of child.branches) yield* collectSingleRootNodes(options, branch.children);
			return;
		} else if (child.type !== CompilerDOM$5.NodeTypes.ELEMENT) return;
		yield child;
		const tag = (0, shared_1$14.hyphenateTag)(child.tag);
		if (options.vueCompilerOptions.fallthroughComponentNames.includes(tag)) yield* collectSingleRootNodes(options, child.children);
	}
	function getVForNode(node) {
		const forDirective = node.props.find((prop) => prop.type === CompilerDOM$5.NodeTypes.DIRECTIVE && prop.name === "for");
		if (forDirective) {
			let forNode;
			CompilerDOM$5.processFor(node, forDirective, transformContext, (_forNode) => {
				forNode = { ..._forNode };
				return void 0;
			});
			if (forNode) {
				forNode.children = [{
					...node,
					props: node.props.filter((prop) => prop !== forDirective)
				}];
				return forNode;
			}
		}
	}
	function getVIfNode(node) {
		const ifDirective = node.props.find((prop) => prop.type === CompilerDOM$5.NodeTypes.DIRECTIVE && prop.name === "if");
		if (ifDirective) {
			let ifNode;
			CompilerDOM$5.processIf(node, ifDirective, transformContext, (_ifNode) => {
				ifNode = { ..._ifNode };
				return void 0;
			});
			if (ifNode) {
				for (const branch of ifNode.branches) branch.children = [{
					...node,
					props: node.props.filter((prop) => prop !== ifDirective)
				}];
				return ifNode;
			}
		}
	}
	function parseInterpolationNode(node, template) {
		let content = node.content.loc.source;
		let start = node.content.loc.start.offset;
		let leftCharacter;
		let rightCharacter;
		while ((leftCharacter = template.slice(start - 1, start)).trim() === "" && leftCharacter.length) {
			start--;
			content = leftCharacter + content;
		}
		while ((rightCharacter = template.slice(start + content.length, start + content.length + 1)).trim() === "" && rightCharacter.length) content = content + rightCharacter;
		return [content, start];
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/template/index.js
var require_template$1 = __commonJS({ "node_modules/@vue/language-core/lib/codegen/template/index.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateTemplate = generate$2;
	exports.forEachElementNode = forEachElementNode;
	const CompilerDOM$4 = require_compiler_dom();
	const codeFeatures_1$7 = require_codeFeatures();
	const utils_1$20 = require_utils$3();
	const wrapWith_1$5 = require_wrapWith();
	const context_1$2 = require_context$1();
	const objectProperty_1 = require_objectProperty();
	const styleScopedClasses_1$1 = require_styleScopedClasses();
	const templateChild_1$1 = require_templateChild();
	function generate$2(options) {
		const context = (0, context_1$2.createTemplateCodegenContext)(options, options.template.ast);
		const codegen = generateTemplate$1(options, context);
		const codes = [];
		for (const code$1 of codegen) {
			if (typeof code$1 === "object") code$1[3] = context.resolveCodeFeatures(code$1[3]);
			codes.push(code$1);
		}
		return {
			...context,
			codes
		};
	}
	function* generateTemplate$1(options, ctx) {
		if (options.slotsAssignName) ctx.addLocalVariable(options.slotsAssignName);
		if (options.propsAssignName) ctx.addLocalVariable(options.propsAssignName);
		if (options.vueCompilerOptions.inferTemplateDollarSlots) ctx.dollarVars.add("$slots");
		if (options.vueCompilerOptions.inferTemplateDollarAttrs) ctx.dollarVars.add("$attrs");
		if (options.vueCompilerOptions.inferTemplateDollarRefs) ctx.dollarVars.add("$refs");
		if (options.vueCompilerOptions.inferTemplateDollarEl) ctx.dollarVars.add("$el");
		if (options.template.ast) yield* (0, templateChild_1$1.generateTemplateChild)(options, ctx, options.template.ast);
		yield* (0, styleScopedClasses_1$1.generateStyleScopedClassReferences)(ctx);
		yield* ctx.generateHoistVariables();
		const dollarTypes = [
			["$slots", yield* generateSlots(options, ctx)],
			["$attrs", yield* generateInheritedAttrs(options, ctx)],
			["$refs", yield* generateTemplateRefs(options, ctx)],
			["$el", yield* generateRootEl(ctx)]
		].filter(([name]) => ctx.dollarVars.has(name));
		if (dollarTypes.length) {
			yield `var __VLS_dollars!: {${utils_1$20.newLine}`;
			for (const [name, type] of dollarTypes) yield `${name}: ${type}${utils_1$20.endOfLine}`;
			yield `} & { [K in keyof import('${options.vueCompilerOptions.lib}').ComponentPublicInstance]: unknown }${utils_1$20.endOfLine}`;
		}
	}
	function* generateSlots(options, ctx) {
		if (!options.hasDefineSlots) {
			yield `type __VLS_Slots = {}`;
			for (const { expVar, propsVar } of ctx.dynamicSlots) yield `${utils_1$20.newLine}& { [K in NonNullable<typeof ${expVar}>]?: (props: typeof ${propsVar}) => any }`;
			for (const slot of ctx.slots) {
				yield `${utils_1$20.newLine}& { `;
				if (slot.name && slot.offset !== void 0) yield* (0, objectProperty_1.generateObjectProperty)(options, ctx, slot.name, slot.offset, codeFeatures_1$7.codeFeatures.navigation);
				else yield* (0, wrapWith_1$5.wrapWith)(slot.tagRange[0], slot.tagRange[1], codeFeatures_1$7.codeFeatures.navigation, `default`);
				yield `?: (props: typeof ${slot.propsVar}) => any }`;
			}
			yield utils_1$20.endOfLine;
		}
		return `__VLS_Slots`;
	}
	function* generateInheritedAttrs(options, ctx) {
		yield `type __VLS_InheritedAttrs = ${ctx.inheritedAttrVars.size ? `Partial<${[...ctx.inheritedAttrVars].map((name) => `typeof ${name}`).join(` & `)}>` : `{}`}`;
		yield utils_1$20.endOfLine;
		if (ctx.bindingAttrLocs.length) {
			yield `[`;
			for (const loc of ctx.bindingAttrLocs) {
				yield `__VLS_dollars.`;
				yield [
					loc.source,
					"template",
					loc.start.offset,
					codeFeatures_1$7.codeFeatures.all
				];
				yield `,`;
			}
			yield `]${utils_1$20.endOfLine}`;
		}
		return `import('${options.vueCompilerOptions.lib}').ComponentPublicInstance['$attrs'] & __VLS_InheritedAttrs`;
	}
	function* generateTemplateRefs(options, ctx) {
		yield `type __VLS_TemplateRefs = {}`;
		for (const [name, refs] of ctx.templateRefs) {
			yield `${utils_1$20.newLine}& `;
			if (refs.length >= 2) yield `(`;
			for (let i = 0; i < refs.length; i++) {
				const { typeExp, offset } = refs[i];
				if (i) yield ` | `;
				yield `{ `;
				yield* (0, objectProperty_1.generateObjectProperty)(options, ctx, name, offset, codeFeatures_1$7.codeFeatures.navigation);
				yield `: ${typeExp} }`;
			}
			if (refs.length >= 2) yield `)`;
		}
		yield utils_1$20.endOfLine;
		return `__VLS_TemplateRefs`;
	}
	function* generateRootEl(ctx) {
		yield `type __VLS_RootEl = `;
		if (ctx.singleRootElTypes.length && !ctx.singleRootNodes.has(null)) for (const type of ctx.singleRootElTypes) yield `${utils_1$20.newLine}| ${type}`;
		else yield `any`;
		yield utils_1$20.endOfLine;
		return `__VLS_RootEl`;
	}
	function* forEachElementNode(node) {
		if (node.type === CompilerDOM$4.NodeTypes.ROOT) for (const child of node.children) yield* forEachElementNode(child);
		else if (node.type === CompilerDOM$4.NodeTypes.ELEMENT) {
			const patchForNode = (0, templateChild_1$1.getVForNode)(node);
			if (patchForNode) yield* forEachElementNode(patchForNode);
			else {
				yield node;
				for (const child of node.children) yield* forEachElementNode(child);
			}
		} else if (node.type === CompilerDOM$4.NodeTypes.IF) for (const branch of node.branches) for (const childNode of branch.children) yield* forEachElementNode(childNode);
		else if (node.type === CompilerDOM$4.NodeTypes.FOR) for (const child of node.children) yield* forEachElementNode(child);
	}
} });

//#endregion
//#region node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({ "node_modules/path-browserify/index.js"(exports, module) {
	function assertPath(path$4) {
		if (typeof path$4 !== "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(path$4));
	}
	function normalizeStringPosix(path$4, allowAboveRoot) {
		var res = "";
		var lastSegmentLength = 0;
		var lastSlash = -1;
		var dots = 0;
		var code$1;
		for (var i = 0; i <= path$4.length; ++i) {
			if (i < path$4.length) code$1 = path$4.charCodeAt(i);
			else if (code$1 === 47) break;
			else code$1 = 47;
			if (code$1 === 47) {
				if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
					if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
						if (res.length > 2) {
							var lastSlashIndex = res.lastIndexOf("/");
							if (lastSlashIndex !== res.length - 1) {
								if (lastSlashIndex === -1) {
									res = "";
									lastSegmentLength = 0;
								} else {
									res = res.slice(0, lastSlashIndex);
									lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
								}
								lastSlash = i;
								dots = 0;
								continue;
							}
						} else if (res.length === 2 || res.length === 1) {
							res = "";
							lastSegmentLength = 0;
							lastSlash = i;
							dots = 0;
							continue;
						}
					}
					if (allowAboveRoot) {
						if (res.length > 0) res += "/..";
						else res = "..";
						lastSegmentLength = 2;
					}
				} else {
					if (res.length > 0) res += "/" + path$4.slice(lastSlash + 1, i);
					else res = path$4.slice(lastSlash + 1, i);
					lastSegmentLength = i - lastSlash - 1;
				}
				lastSlash = i;
				dots = 0;
			} else if (code$1 === 46 && dots !== -1) ++dots;
			else dots = -1;
		}
		return res;
	}
	function _format(sep, pathObject) {
		var dir = pathObject.dir || pathObject.root;
		var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
		if (!dir) return base;
		if (dir === pathObject.root) return dir + base;
		return dir + sep + base;
	}
	var posix = {
		resolve: function resolve() {
			var resolvedPath = "";
			var resolvedAbsolute = false;
			var cwd;
			for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
				var path$4;
				if (i >= 0) path$4 = arguments[i];
				else {
					if (cwd === void 0) cwd = process.cwd();
					path$4 = cwd;
				}
				assertPath(path$4);
				if (path$4.length === 0) continue;
				resolvedPath = path$4 + "/" + resolvedPath;
				resolvedAbsolute = path$4.charCodeAt(0) === 47;
			}
			resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
			if (resolvedAbsolute) if (resolvedPath.length > 0) return "/" + resolvedPath;
			else return "/";
			else if (resolvedPath.length > 0) return resolvedPath;
			else return ".";
		},
		normalize: function normalize$1(path$4) {
			assertPath(path$4);
			if (path$4.length === 0) return ".";
			var isAbsolute = path$4.charCodeAt(0) === 47;
			var trailingSeparator = path$4.charCodeAt(path$4.length - 1) === 47;
			path$4 = normalizeStringPosix(path$4, !isAbsolute);
			if (path$4.length === 0 && !isAbsolute) path$4 = ".";
			if (path$4.length > 0 && trailingSeparator) path$4 += "/";
			if (isAbsolute) return "/" + path$4;
			return path$4;
		},
		isAbsolute: function isAbsolute(path$4) {
			assertPath(path$4);
			return path$4.length > 0 && path$4.charCodeAt(0) === 47;
		},
		join: function join$1() {
			if (arguments.length === 0) return ".";
			var joined;
			for (var i = 0; i < arguments.length; ++i) {
				var arg = arguments[i];
				assertPath(arg);
				if (arg.length > 0) if (joined === void 0) joined = arg;
				else joined += "/" + arg;
			}
			if (joined === void 0) return ".";
			return posix.normalize(joined);
		},
		relative: function relative$1(from, to) {
			assertPath(from);
			assertPath(to);
			if (from === to) return "";
			from = posix.resolve(from);
			to = posix.resolve(to);
			if (from === to) return "";
			var fromStart = 1;
			for (; fromStart < from.length; ++fromStart) if (from.charCodeAt(fromStart) !== 47) break;
			var fromEnd = from.length;
			var fromLen = fromEnd - fromStart;
			var toStart = 1;
			for (; toStart < to.length; ++toStart) if (to.charCodeAt(toStart) !== 47) break;
			var toEnd = to.length;
			var toLen = toEnd - toStart;
			var length = fromLen < toLen ? fromLen : toLen;
			var lastCommonSep = -1;
			var i = 0;
			for (; i <= length; ++i) {
				if (i === length) {
					if (toLen > length) {
						if (to.charCodeAt(toStart + i) === 47) return to.slice(toStart + i + 1);
						else if (i === 0) return to.slice(toStart + i);
					} else if (fromLen > length) {
						if (from.charCodeAt(fromStart + i) === 47) lastCommonSep = i;
						else if (i === 0) lastCommonSep = 0;
					}
					break;
				}
				var fromCode = from.charCodeAt(fromStart + i);
				var toCode = to.charCodeAt(toStart + i);
				if (fromCode !== toCode) break;
				else if (fromCode === 47) lastCommonSep = i;
			}
			var out = "";
			for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) if (i === fromEnd || from.charCodeAt(i) === 47) if (out.length === 0) out += "..";
			else out += "/..";
			if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
			else {
				toStart += lastCommonSep;
				if (to.charCodeAt(toStart) === 47) ++toStart;
				return to.slice(toStart);
			}
		},
		_makeLong: function _makeLong(path$4) {
			return path$4;
		},
		dirname: function dirname(path$4) {
			assertPath(path$4);
			if (path$4.length === 0) return ".";
			var code$1 = path$4.charCodeAt(0);
			var hasRoot = code$1 === 47;
			var end = -1;
			var matchedSlash = true;
			for (var i = path$4.length - 1; i >= 1; --i) {
				code$1 = path$4.charCodeAt(i);
				if (code$1 === 47) {
					if (!matchedSlash) {
						end = i;
						break;
					}
				} else matchedSlash = false;
			}
			if (end === -1) return hasRoot ? "/" : ".";
			if (hasRoot && end === 1) return "//";
			return path$4.slice(0, end);
		},
		basename: function basename(path$4, ext) {
			if (ext !== void 0 && typeof ext !== "string") throw new TypeError("\"ext\" argument must be a string");
			assertPath(path$4);
			var start = 0;
			var end = -1;
			var matchedSlash = true;
			var i;
			if (ext !== void 0 && ext.length > 0 && ext.length <= path$4.length) {
				if (ext.length === path$4.length && ext === path$4) return "";
				var extIdx = ext.length - 1;
				var firstNonSlashEnd = -1;
				for (i = path$4.length - 1; i >= 0; --i) {
					var code$1 = path$4.charCodeAt(i);
					if (code$1 === 47) {
						if (!matchedSlash) {
							start = i + 1;
							break;
						}
					} else {
						if (firstNonSlashEnd === -1) {
							matchedSlash = false;
							firstNonSlashEnd = i + 1;
						}
						if (extIdx >= 0) if (code$1 === ext.charCodeAt(extIdx)) {
							if (--extIdx === -1) end = i;
						} else {
							extIdx = -1;
							end = firstNonSlashEnd;
						}
					}
				}
				if (start === end) end = firstNonSlashEnd;
				else if (end === -1) end = path$4.length;
				return path$4.slice(start, end);
			} else {
				for (i = path$4.length - 1; i >= 0; --i) if (path$4.charCodeAt(i) === 47) {
					if (!matchedSlash) {
						start = i + 1;
						break;
					}
				} else if (end === -1) {
					matchedSlash = false;
					end = i + 1;
				}
				if (end === -1) return "";
				return path$4.slice(start, end);
			}
		},
		extname: function extname(path$4) {
			assertPath(path$4);
			var startDot = -1;
			var startPart = 0;
			var end = -1;
			var matchedSlash = true;
			var preDotState = 0;
			for (var i = path$4.length - 1; i >= 0; --i) {
				var code$1 = path$4.charCodeAt(i);
				if (code$1 === 47) {
					if (!matchedSlash) {
						startPart = i + 1;
						break;
					}
					continue;
				}
				if (end === -1) {
					matchedSlash = false;
					end = i + 1;
				}
				if (code$1 === 46) {
					if (startDot === -1) startDot = i;
					else if (preDotState !== 1) preDotState = 1;
				} else if (startDot !== -1) preDotState = -1;
			}
			if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) return "";
			return path$4.slice(startDot, end);
		},
		format: function format(pathObject) {
			if (pathObject === null || typeof pathObject !== "object") throw new TypeError("The \"pathObject\" argument must be of type Object. Received type " + typeof pathObject);
			return _format("/", pathObject);
		},
		parse: function parse$5(path$4) {
			assertPath(path$4);
			var ret = {
				root: "",
				dir: "",
				base: "",
				ext: "",
				name: ""
			};
			if (path$4.length === 0) return ret;
			var code$1 = path$4.charCodeAt(0);
			var isAbsolute = code$1 === 47;
			var start;
			if (isAbsolute) {
				ret.root = "/";
				start = 1;
			} else start = 0;
			var startDot = -1;
			var startPart = 0;
			var end = -1;
			var matchedSlash = true;
			var i = path$4.length - 1;
			var preDotState = 0;
			for (; i >= start; --i) {
				code$1 = path$4.charCodeAt(i);
				if (code$1 === 47) {
					if (!matchedSlash) {
						startPart = i + 1;
						break;
					}
					continue;
				}
				if (end === -1) {
					matchedSlash = false;
					end = i + 1;
				}
				if (code$1 === 46) {
					if (startDot === -1) startDot = i;
					else if (preDotState !== 1) preDotState = 1;
				} else if (startDot !== -1) preDotState = -1;
			}
			if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
				if (end !== -1) if (startPart === 0 && isAbsolute) ret.base = ret.name = path$4.slice(1, end);
				else ret.base = ret.name = path$4.slice(startPart, end);
			} else {
				if (startPart === 0 && isAbsolute) {
					ret.name = path$4.slice(1, startDot);
					ret.base = path$4.slice(1, end);
				} else {
					ret.name = path$4.slice(startPart, startDot);
					ret.base = path$4.slice(startPart, end);
				}
				ret.ext = path$4.slice(startDot, end);
			}
			if (startPart > 0) ret.dir = path$4.slice(0, startPart - 1);
			else if (isAbsolute) ret.dir = "/";
			return ret;
		},
		sep: "/",
		delimiter: ":",
		win32: null,
		posix: null
	};
	posix.posix = posix;
	module.exports = posix;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/compilerOptions.js
var require_compilerOptions = __commonJS({ "node_modules/@vue/language-core/lib/compilerOptions.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CompilerOptionsResolver = void 0;
	exports.createParsedCommandLineByJson = createParsedCommandLineByJson;
	exports.createParsedCommandLine = createParsedCommandLine;
	exports.getDefaultCompilerOptions = getDefaultCompilerOptions;
	exports.createGlobalTypesWriter = createGlobalTypesWriter;
	exports.writeGlobalTypes = writeGlobalTypes;
	const shared_1$13 = require_shared$2();
	const path_browserify_1 = require_path_browserify();
	const globalTypes_1 = require_globalTypes();
	const shared_2 = require_shared$1();
	function createParsedCommandLineByJson(ts, host, rootDir, json, configFileName) {
		const extendedPaths = /* @__PURE__ */ new Set();
		const proxyHost = {
			...host,
			readFile(fileName) {
				if (!fileName.endsWith("/package.json")) extendedPaths.add(fileName);
				return host.readFile(fileName);
			},
			readDirectory() {
				return [];
			}
		};
		const parsed = ts.parseJsonConfigFileContent(json, proxyHost, rootDir, {}, configFileName);
		const resolver = new CompilerOptionsResolver(host.fileExists);
		for (const extendPath of [...extendedPaths].reverse()) try {
			const configFile = ts.readJsonConfigFile(extendPath, host.readFile);
			const obj = ts.convertToObject(configFile, []);
			const rawOptions = obj?.vueCompilerOptions ?? {};
			resolver.addConfig(rawOptions, path_browserify_1.posix.dirname(configFile.fileName));
		} catch {}
		resolver.addConfig({}, rootDir);
		return {
			...parsed,
			vueOptions: resolver.build()
		};
	}
	function createParsedCommandLine(ts, host, configFileName) {
		try {
			const extendedPaths = /* @__PURE__ */ new Set();
			const proxyHost = {
				...host,
				readFile(fileName) {
					if (!fileName.endsWith("/package.json")) extendedPaths.add(fileName);
					return host.readFile(fileName);
				},
				readDirectory() {
					return [];
				}
			};
			const config = ts.readJsonConfigFile(configFileName, proxyHost.readFile);
			const parsed = ts.parseJsonSourceFileConfigFileContent(config, proxyHost, path_browserify_1.posix.dirname(configFileName), {}, configFileName);
			const resolver = new CompilerOptionsResolver(host.fileExists);
			for (const extendPath of [...extendedPaths].reverse()) try {
				const configFile = ts.readJsonConfigFile(extendPath, host.readFile);
				const obj = ts.convertToObject(configFile, []);
				const rawOptions = obj?.vueCompilerOptions ?? {};
				resolver.addConfig(rawOptions, path_browserify_1.posix.dirname(configFile.fileName));
			} catch {}
			return {
				...parsed,
				vueOptions: resolver.build()
			};
		} catch {}
		return {
			options: {},
			errors: [],
			vueOptions: getDefaultCompilerOptions()
		};
	}
	var CompilerOptionsResolver = class {
		constructor(fileExists) {
			this.fileExists = fileExists;
			this.options = {};
			this.plugins = [];
		}
		addConfig(options, rootDir) {
			for (const key in options) switch (key) {
				case "target":
					if (options[key] === "auto") this.target = findVueVersion(rootDir);
					else this.target = options[key];
					break;
				case "globalTypesPath":
					if (options[key] !== void 0) this.globalTypesPath = path_browserify_1.posix.join(rootDir, options[key]);
					break;
				case "plugins":
					this.plugins = (options.plugins ?? []).flatMap((pluginPath) => {
						try {
							const resolvedPath = resolvePath(pluginPath, rootDir);
							if (resolvedPath) {
								const plugin$14 = require(resolvedPath);
								plugin$14.__moduleName = pluginPath;
								return plugin$14;
							} else console.warn("[Vue] Load plugin failed:", pluginPath);
						} catch (error) {
							console.warn("[Vue] Resolve plugin path failed:", pluginPath, error);
						}
						return [];
					});
					break;
				default:
					this.options[key] = options[key];
					break;
			}
			if (options.target === void 0) this.target ??= findVueVersion(rootDir);
		}
		build(defaults) {
			defaults ??= getDefaultCompilerOptions(this.target, this.options.lib, this.options.strictTemplates);
			const resolvedOptions = {
				...defaults,
				...this.options,
				plugins: this.plugins,
				macros: {
					...defaults.macros,
					...this.options.macros
				},
				composables: {
					...defaults.composables,
					...this.options.composables
				},
				fallthroughComponentNames: [...defaults.fallthroughComponentNames, ...this.options.fallthroughComponentNames ?? []].map(shared_2.hyphenateTag),
				experimentalModelPropName: Object.fromEntries(Object.entries(this.options.experimentalModelPropName ?? defaults.experimentalModelPropName).map(([k, v]) => [(0, shared_1$13.camelize)(k), v]))
			};
			if (resolvedOptions.globalTypesPath === shared_1$13.NOOP) if (this.fileExists && this.globalTypesPath === void 0) {
				const fileDirToGlobalTypesPath = /* @__PURE__ */ new Map();
				resolvedOptions.globalTypesPath = (fileName) => {
					const fileDir = path_browserify_1.posix.dirname(fileName);
					if (fileDirToGlobalTypesPath.has(fileDir)) return fileDirToGlobalTypesPath.get(fileDir);
					const root = this.findNodeModulesRoot(fileDir, resolvedOptions.lib);
					const result = root ? path_browserify_1.posix.join(root, "node_modules", ".vue-global-types", (0, globalTypes_1.getGlobalTypesFileName)(resolvedOptions)) : void 0;
					fileDirToGlobalTypesPath.set(fileDir, result);
					return result;
				};
			} else resolvedOptions.globalTypesPath = () => this.globalTypesPath;
			return resolvedOptions;
		}
		findNodeModulesRoot(dir, lib) {
			while (!this.fileExists(path_browserify_1.posix.join(dir, "node_modules", lib, "package.json"))) {
				const parentDir = path_browserify_1.posix.dirname(dir);
				if (dir === parentDir) return;
				dir = parentDir;
			}
			return dir;
		}
	};
	exports.CompilerOptionsResolver = CompilerOptionsResolver;
	function findVueVersion(rootDir) {
		const resolvedPath = resolvePath("vue/package.json", rootDir);
		if (resolvedPath) {
			const vuePackageJson = require(resolvedPath);
			const versionNumbers = vuePackageJson.version.split(".");
			return Number(versionNumbers[0] + "." + versionNumbers[1]);
		}
	}
	function resolvePath(scriptPath, root) {
		try {
			if (require?.resolve) return require.resolve(scriptPath, { paths: [root] });
		} catch {}
	}
	function getDefaultCompilerOptions(target = 99, lib = "vue", strictTemplates = false) {
		return {
			target,
			lib,
			globalTypesPath: shared_1$13.NOOP,
			extensions: [".vue"],
			vitePressExtensions: [],
			petiteVueExtensions: [],
			jsxSlots: false,
			strictVModel: strictTemplates,
			strictCssModules: false,
			checkUnknownProps: strictTemplates,
			checkUnknownEvents: strictTemplates,
			checkUnknownDirectives: strictTemplates,
			checkUnknownComponents: strictTemplates,
			inferComponentDollarEl: false,
			inferComponentDollarRefs: false,
			inferTemplateDollarAttrs: false,
			inferTemplateDollarEl: false,
			inferTemplateDollarRefs: false,
			inferTemplateDollarSlots: false,
			skipTemplateCodegen: false,
			fallthroughAttributes: false,
			resolveStyleImports: false,
			resolveStyleClassNames: "scoped",
			fallthroughComponentNames: [
				"Transition",
				"KeepAlive",
				"Teleport",
				"Suspense"
			],
			dataAttributes: [],
			htmlAttributes: ["aria-*"],
			optionsWrapper: [`(await import('${lib}')).defineComponent(`, `)`],
			macros: {
				defineProps: ["defineProps"],
				defineSlots: ["defineSlots"],
				defineEmits: ["defineEmits"],
				defineExpose: ["defineExpose"],
				defineModel: ["defineModel"],
				defineOptions: ["defineOptions"],
				withDefaults: ["withDefaults"]
			},
			composables: {
				useAttrs: ["useAttrs"],
				useCssModule: ["useCssModule"],
				useSlots: ["useSlots"],
				useTemplateRef: ["useTemplateRef", "templateRef"]
			},
			plugins: [],
			experimentalModelPropName: {
				"": { input: true },
				value: {
					input: { type: "text" },
					textarea: true,
					select: true
				}
			}
		};
	}
	function createGlobalTypesWriter(vueOptions, writeFile) {
		const writed = /* @__PURE__ */ new Set();
		const { globalTypesPath } = vueOptions;
		return (fileName) => {
			const result = globalTypesPath(fileName);
			if (result && !writed.has(result)) {
				writed.add(result);
				writeFile(result, (0, globalTypes_1.generateGlobalTypes)(vueOptions));
			}
			return result;
		};
	}
	/**
	* @deprecated use `createGlobalTypesWriter` instead
	*/
	function writeGlobalTypes(vueOptions, writeFile) {
		vueOptions.globalTypesPath = createGlobalTypesWriter(vueOptions, writeFile);
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/file-html.js
var require_file_html = __commonJS({ "node_modules/@vue/language-core/lib/plugins/file-html.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const sfcBlockReg$1 = /<(script|style)\b([\s\S]*?)>([\s\S]*?)<\/\1>/g;
	const langReg = /\blang\s*=\s*(['"]?)(\S*)\b\1/;
	const plugin$13 = ({ vueCompilerOptions }) => {
		return {
			version: 2.2,
			getLanguageId(fileName) {
				if (vueCompilerOptions.petiteVueExtensions.some((ext) => fileName.endsWith(ext))) return "html";
			},
			isValidFile(_fileName, languageId) {
				return languageId === "html";
			},
			parseSFC2(fileName, languageId, content) {
				if (languageId !== "html") return;
				let sfc = {
					descriptor: {
						filename: fileName,
						source: content,
						comments: [],
						template: null,
						script: null,
						scriptSetup: null,
						styles: [],
						customBlocks: [],
						cssVars: [],
						shouldForceReload: () => false,
						slotted: false
					},
					errors: []
				};
				let templateContent = content;
				for (const match of content.matchAll(sfcBlockReg$1)) {
					const matchText = match[0];
					const tag = match[1];
					const attrs = match[2];
					const lang = attrs.match(langReg)?.[2];
					const content$1 = match[3];
					const contentStart = match.index + matchText.indexOf(content$1);
					if (tag === "style") sfc.descriptor.styles.push({
						attrs: {},
						content: content$1,
						loc: {
							start: {
								column: -1,
								line: -1,
								offset: contentStart
							},
							end: {
								column: -1,
								line: -1,
								offset: contentStart + content$1.length
							},
							source: content$1
						},
						type: "style",
						lang
					});
					else if (tag === "script" && !attrs.includes("src=")) {
						let type = attrs.includes("type=") ? "scriptSetup" : "script";
						sfc.descriptor[type] = {
							attrs: {},
							content: content$1,
							loc: {
								start: {
									column: -1,
									line: -1,
									offset: contentStart
								},
								end: {
									column: -1,
									line: -1,
									offset: contentStart + content$1.length
								},
								source: content$1
							},
							type: "script",
							lang
						};
					}
					templateContent = templateContent.slice(0, match.index) + " ".repeat(matchText.length) + templateContent.slice(match.index + matchText.length);
				}
				sfc.descriptor.template = {
					attrs: {},
					content: templateContent,
					loc: {
						start: {
							column: -1,
							line: -1,
							offset: 0
						},
						end: {
							column: -1,
							line: -1,
							offset: templateContent.length
						},
						source: templateContent
					},
					type: "template",
					ast: {}
				};
				return sfc;
			}
		};
	};
	exports.default = plugin$13;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/utils/buildMappings.js
var require_buildMappings = __commonJS({ "node_modules/@vue/language-core/lib/utils/buildMappings.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.buildMappings = buildMappings;
	function buildMappings(chunks) {
		let length = 0;
		const mappings = [];
		for (const segment of chunks) if (typeof segment === "string") length += segment.length;
		else {
			mappings.push({
				sourceOffsets: [segment[2]],
				generatedOffsets: [length],
				lengths: [segment[0].length],
				data: segment[3]
			});
			length += segment[0].length;
		}
		return mappings;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/utils/parseSfc.js
var require_parseSfc = __commonJS({ "node_modules/@vue/language-core/lib/utils/parseSfc.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parse = parse;
	const CompilerDOM$3 = require_compiler_dom();
	function parse(source) {
		const errors = [];
		const ast = CompilerDOM$3.parse(source, {
			isNativeTag: () => true,
			isPreTag: () => true,
			parseMode: "sfc",
			onError: (e) => {
				errors.push(e);
			},
			comments: true
		});
		const descriptor = {
			filename: "anonymous.vue",
			source,
			comments: [],
			template: null,
			script: null,
			scriptSetup: null,
			styles: [],
			customBlocks: [],
			cssVars: [],
			slotted: false,
			shouldForceReload: () => false
		};
		ast.children.forEach((node) => {
			if (node.type === CompilerDOM$3.NodeTypes.COMMENT) {
				descriptor.comments.push(node.content);
				return;
			} else if (node.type !== CompilerDOM$3.NodeTypes.ELEMENT) return;
			switch (node.tag) {
				case "template":
					descriptor.template = createBlock(node, source);
					break;
				case "script":
					const scriptBlock = createBlock(node, source);
					const isSetup = !!scriptBlock.setup;
					if (isSetup && !descriptor.scriptSetup) {
						descriptor.scriptSetup = scriptBlock;
						break;
					}
					if (!isSetup && !descriptor.script) {
						descriptor.script = scriptBlock;
						break;
					}
					break;
				case "style":
					const styleBlock = createBlock(node, source);
					descriptor.styles.push(styleBlock);
					break;
				default:
					descriptor.customBlocks.push(createBlock(node, source));
					break;
			}
		});
		return {
			descriptor,
			errors
		};
	}
	function createBlock(node, source) {
		const type = node.tag;
		let { start, end } = node.loc;
		let content = "";
		if (node.children.length) {
			start = node.children[0].loc.start;
			end = node.children[node.children.length - 1].loc.end;
			content = source.slice(start.offset, end.offset);
		} else {
			const offset = node.loc.source.indexOf(`</`);
			if (offset > -1) start = {
				line: start.line,
				column: start.column + offset,
				offset: start.offset + offset
			};
			end = Object.assign({}, start);
		}
		const loc = {
			source: content,
			start,
			end
		};
		const attrs = {};
		const block = {
			type,
			content,
			loc,
			attrs
		};
		node.props.forEach((p) => {
			if (p.type === CompilerDOM$3.NodeTypes.ATTRIBUTE) {
				attrs[p.name] = p.value ? p.value.content || true : true;
				if (p.name === "lang") block.lang = p.value?.content;
				else if (p.name === "src") block.__src = parseAttr(p, node);
				else if (isScriptBlock(block)) {
					if (p.name === "setup" || p.name === "vapor") block.setup = attrs[p.name];
					else if (p.name === "generic") block.__generic = parseAttr(p, node);
				} else if (isStyleBlock(block)) {
					if (p.name === "scoped") block.scoped = true;
					else if (p.name === "module") block.__module = parseAttr(p, node);
				}
			}
		});
		return block;
	}
	function isScriptBlock(block) {
		return block.type === "script";
	}
	function isStyleBlock(block) {
		return block.type === "style";
	}
	function parseAttr(p, node) {
		if (!p.value) return true;
		const text = p.value.content;
		const source = p.value.loc.source;
		let offset = p.value.loc.start.offset - node.loc.start.offset;
		const quotes = source.startsWith("\"") || source.startsWith("'");
		if (quotes) offset++;
		return {
			text,
			offset,
			quotes
		};
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/file-md.js
var require_file_md = __commonJS({ "node_modules/@vue/language-core/lib/plugins/file-md.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const language_core_1$5 = require_language_core$1();
	const muggle_string_1$2 = require_out();
	const buildMappings_1$1 = require_buildMappings();
	const parseSfc_1$1 = require_parseSfc();
	const frontmatterReg = /^---[\s\S]*?\n---(?:\r?\n|$)/;
	const codeblockReg = /(`{3,})[\s\S]+?\1/g;
	const inlineCodeblockReg = /`[^\n`]+?`/g;
	const latexBlockReg = /(\${2,})[\s\S]+?\1/g;
	const scriptSetupReg = /\\<[\s\S]+?>\n?/g;
	const codeSnippetImportReg = /^\s*<<<\s*.+/gm;
	const sfcBlockReg = /<(script|style)\b[\s\S]*?>([\s\S]*?)<\/\1>/g;
	const angleBracketReg = /<\S*:\S*>/g;
	const linkReg = /\[[\s\S]*?\]\([\s\S]*?\)/g;
	const plugin$12 = ({ vueCompilerOptions }) => {
		return {
			version: 2.2,
			getLanguageId(fileName) {
				if (vueCompilerOptions.vitePressExtensions.some((ext) => fileName.endsWith(ext))) return "markdown";
			},
			isValidFile(_fileName, languageId) {
				return languageId === "markdown";
			},
			parseSFC2(_fileName, languageId, content) {
				if (languageId !== "markdown") return;
				content = content.replace(frontmatterReg, (match) => " ".repeat(match.length)).replace(codeblockReg, (match, quotes) => quotes + " ".repeat(match.length - quotes.length * 2) + quotes).replace(inlineCodeblockReg, (match) => `\`${" ".repeat(match.length - 2)}\``).replace(latexBlockReg, (match, quotes) => quotes + " ".repeat(match.length - quotes.length * 2) + quotes).replace(scriptSetupReg, (match) => " ".repeat(match.length)).replace(codeSnippetImportReg, (match) => " ".repeat(match.length));
				const codes = [];
				for (const match of content.matchAll(sfcBlockReg)) {
					const matchText = match[0];
					codes.push([
						matchText,
						void 0,
						match.index
					]);
					codes.push("\n\n");
					content = content.slice(0, match.index) + " ".repeat(matchText.length) + content.slice(match.index + matchText.length);
				}
				content = content.replace(angleBracketReg, (match) => " ".repeat(match.length)).replace(linkReg, (match) => " ".repeat(match.length));
				codes.push("<template>\n");
				codes.push([
					content,
					void 0,
					0
				]);
				codes.push("\n</template>");
				const mappings = (0, buildMappings_1$1.buildMappings)(codes);
				const mapper = new language_core_1$5.SourceMap(mappings);
				const sfc = (0, parseSfc_1$1.parse)((0, muggle_string_1$2.toString)(codes));
				for (const block of [
					sfc.descriptor.template,
					sfc.descriptor.script,
					sfc.descriptor.scriptSetup,
					...sfc.descriptor.styles,
					...sfc.descriptor.customBlocks
				]) if (block) transformRange(block);
				return sfc;
				function transformRange(block) {
					const { start, end } = block.loc;
					const startOffset = start.offset;
					const endOffset = end.offset;
					start.offset = -1;
					end.offset = -1;
					for (const [offset] of mapper.toSourceLocation(startOffset)) {
						start.offset = offset;
						break;
					}
					for (const [offset] of mapper.toSourceLocation(endOffset)) {
						end.offset = offset;
						break;
					}
				}
			}
		};
	};
	exports.default = plugin$12;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/file-vue.js
var require_file_vue = __commonJS({ "node_modules/@vue/language-core/lib/plugins/file-vue.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const parseSfc_1 = require_parseSfc();
	const plugin$11 = ({ vueCompilerOptions }) => {
		return {
			version: 2.2,
			getLanguageId(fileName) {
				if (vueCompilerOptions.extensions.some((ext) => fileName.endsWith(ext))) return "vue";
			},
			isValidFile(_fileName, languageId) {
				return languageId === "vue";
			},
			parseSFC2(_fileName, languageId, content) {
				if (languageId !== "vue") return;
				const sfc = (0, parseSfc_1.parse)(content);
				for (const error of sfc.errors) if ("code" in error && error.code === 24 && sfc.descriptor.template && error.loc?.start.line === sfc.descriptor.template.loc.start.line) {
					const template = sfc.descriptor.template;
					const templateText = template.content;
					const endTagOffset = templateText.lastIndexOf("<");
					const endTagText = templateText.slice(endTagOffset).trimEnd();
					if ("</template>".startsWith(endTagText)) {
						sfc.descriptor.template.loc.end.offset = template.loc.start.offset + endTagOffset;
						template.content = templateText.slice(0, endTagOffset);
					}
				}
				return sfc;
			},
			updateSFC(sfc, change) {
				const blocks = [
					sfc.descriptor.template,
					sfc.descriptor.script,
					sfc.descriptor.scriptSetup,
					...sfc.descriptor.styles,
					...sfc.descriptor.customBlocks
				].filter((block) => !!block);
				const hitBlock = blocks.find((block) => change.start >= block.loc.start.offset && change.end <= block.loc.end.offset);
				if (!hitBlock) return;
				const oldContent = hitBlock.content;
				const newContent = hitBlock.content = hitBlock.content.slice(0, change.start - hitBlock.loc.start.offset) + change.newText + hitBlock.content.slice(change.end - hitBlock.loc.start.offset);
				const endTagRegex = new RegExp(`</\\s*${hitBlock.type}\\s*>`);
				const insertedEndTag = endTagRegex.test(oldContent) !== endTagRegex.test(newContent);
				if (insertedEndTag) return;
				const lengthDiff = change.newText.length - (change.end - change.start);
				for (const block of blocks) {
					if (block.loc.start.offset > change.end) block.loc.start.offset += lengthDiff;
					if (block.loc.end.offset >= change.end) block.loc.end.offset += lengthDiff;
				}
				return sfc;
			}
		};
	};
	exports.default = plugin$11;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/shared.js
var require_shared = __commonJS({ "node_modules/@vue/language-core/lib/plugins/shared.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.allCodeFeatures = void 0;
	exports.allCodeFeatures = {
		verification: true,
		completion: true,
		semantic: true,
		navigation: true,
		structure: true,
		format: true
	};
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/vue-root-tags.js
var require_vue_root_tags = __commonJS({ "node_modules/@vue/language-core/lib/plugins/vue-root-tags.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const muggle_string_1$1 = require_out();
	const shared_1$12 = require_shared();
	const plugin$10 = () => {
		return {
			version: 2.2,
			getEmbeddedCodes() {
				return [{
					id: "root_tags",
					lang: "vue-root-tags"
				}];
			},
			resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
				if (embeddedFile.id === "root_tags") {
					embeddedFile.content.push([
						sfc.content,
						void 0,
						0,
						shared_1$12.allCodeFeatures
					]);
					for (const block of [
						sfc.template,
						sfc.script,
						sfc.scriptSetup,
						...sfc.styles,
						...sfc.customBlocks
					]) {
						if (!block) continue;
						const offset = block.content.lastIndexOf("\n", block.content.lastIndexOf("\n") - 1) + 1;
						(0, muggle_string_1$1.replaceSourceRange)(embeddedFile.content, void 0, block.startTagEnd, block.endTagStart, sfc.content.slice(block.startTagEnd, block.startTagEnd + offset), [
							"",
							void 0,
							block.startTagEnd + offset,
							{ structure: true }
						], sfc.content.slice(block.startTagEnd + offset, block.endTagStart));
					}
				} else embeddedFile.parentCodeId ??= "root_tags";
			}
		};
	};
	exports.default = plugin$10;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/vue-script-js.js
var require_vue_script_js = __commonJS({ "node_modules/@vue/language-core/lib/plugins/vue-script-js.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const plugin$9 = ({ modules }) => {
		return {
			version: 2.2,
			compileSFCScript(lang, script) {
				if (lang === "js" || lang === "ts" || lang === "jsx" || lang === "tsx") {
					const ts = modules.typescript;
					return ts.createSourceFile("test." + lang, script, 99);
				}
			}
		};
	};
	exports.default = plugin$9;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/vue-sfc-customblocks.js
var require_vue_sfc_customblocks = __commonJS({ "node_modules/@vue/language-core/lib/plugins/vue-sfc-customblocks.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const shared_1$11 = require_shared();
	const plugin$8 = () => {
		return {
			version: 2.2,
			getEmbeddedCodes(_fileName, sfc) {
				return sfc.customBlocks.map((customBlock, i) => ({
					id: "custom_block_" + i,
					lang: customBlock.lang
				}));
			},
			resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
				if (embeddedFile.id.startsWith("custom_block_")) {
					const index = parseInt(embeddedFile.id.slice(13));
					const customBlock = sfc.customBlocks[index];
					embeddedFile.content.push([
						customBlock.content,
						customBlock.name,
						0,
						shared_1$11.allCodeFeatures
					]);
				}
			}
		};
	};
	exports.default = plugin$8;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/vue-sfc-scripts.js
var require_vue_sfc_scripts = __commonJS({ "node_modules/@vue/language-core/lib/plugins/vue-sfc-scripts.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const plugin$7 = () => {
		return {
			version: 2.2,
			getEmbeddedCodes(_fileName, sfc) {
				const names = [];
				if (sfc.script) names.push({
					id: "script_raw",
					lang: sfc.script.lang
				});
				if (sfc.scriptSetup) names.push({
					id: "scriptsetup_raw",
					lang: sfc.scriptSetup.lang
				});
				return names;
			},
			resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
				const script = embeddedFile.id === "script_raw" ? sfc.script : embeddedFile.id === "scriptsetup_raw" ? sfc.scriptSetup : void 0;
				if (script) embeddedFile.content.push([
					script.content,
					script.name,
					0,
					{
						structure: true,
						format: true
					}
				]);
			}
		};
	};
	exports.default = plugin$7;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/vue-sfc-styles.js
var require_vue_sfc_styles = __commonJS({ "node_modules/@vue/language-core/lib/plugins/vue-sfc-styles.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const shared_1$10 = require_shared();
	const plugin$6 = () => {
		return {
			version: 2.2,
			getEmbeddedCodes(_fileName, sfc) {
				const result = [];
				for (let i = 0; i < sfc.styles.length; i++) {
					const style = sfc.styles[i];
					if (style) {
						result.push({
							id: "style_" + i,
							lang: style.lang
						});
						if (style.bindings.length) result.push({
							id: "style_" + i + "_inline_ts",
							lang: "ts"
						});
					}
				}
				return result;
			},
			resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
				if (embeddedFile.id.startsWith("style_")) {
					const index = parseInt(embeddedFile.id.split("_")[1]);
					const style = sfc.styles[index];
					if (embeddedFile.id.endsWith("_inline_ts")) {
						embeddedFile.parentCodeId = "style_" + index;
						for (const binding of style.bindings) embeddedFile.content.push("(", [
							binding.text,
							style.name,
							binding.offset,
							shared_1$10.allCodeFeatures
						], ");\n");
					} else embeddedFile.content.push([
						style.content,
						style.name,
						0,
						shared_1$10.allCodeFeatures
					]);
				}
			}
		};
	};
	exports.default = plugin$6;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/vue-sfc-template.js
var require_vue_sfc_template = __commonJS({ "node_modules/@vue/language-core/lib/plugins/vue-sfc-template.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const shared_1$9 = require_shared();
	const plugin$5 = () => {
		return {
			version: 2.2,
			getEmbeddedCodes(_fileName, sfc) {
				if (sfc.template?.lang === "html") return [{
					id: "template",
					lang: sfc.template.lang
				}];
				return [];
			},
			resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
				if (embeddedFile.id === "template" && sfc.template?.lang === "html") embeddedFile.content.push([
					sfc.template.content,
					sfc.template.name,
					0,
					shared_1$9.allCodeFeatures
				]);
			}
		};
	};
	exports.default = plugin$5;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/vue-style-css.js
var require_vue_style_css = __commonJS({ "node_modules/@vue/language-core/lib/plugins/vue-style-css.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const plugin$4 = () => {
		return {
			version: 2.2,
			compileSFCStyle(_lang, style) {
				return {
					imports: [...parseCssImports(style)],
					bindings: [...parseCssBindings(style)],
					classNames: [...parseCssClassNames(style)]
				};
			}
		};
	};
	exports.default = plugin$4;
	const cssImportReg = /(?<=@import\s+url\()(["']?).*?\1(?=\))|(?<=@import\b\s*)(["']).*?\2/g;
	const cssBindingReg = /\bv-bind\(\s*(?:'([^']+)'|"([^"]+)"|([a-z_]\w*))\s*\)/gi;
	const cssClassNameReg = /(?=(\.[a-z_][-\w]*)[\s.,+~>:#)[{])/gi;
	const commentReg = /(?<=\/\*)[\s\S]*?(?=\*\/)|(?<=\/\/)[\s\S]*?(?=\n)/g;
	const fragmentReg = /(?<={)[^{]*(?=(?<!\\);)/g;
	function* parseCssImports(css) {
		const matches = css.matchAll(cssImportReg);
		for (const match of matches) {
			let text = match[0];
			let offset = match.index;
			if (text.startsWith("'") || text.startsWith("\"")) {
				text = text.slice(1, -1);
				offset += 1;
			}
			if (text) yield {
				text,
				offset
			};
		}
	}
	function* parseCssBindings(css) {
		css = fillBlank(css, commentReg);
		const matchs = css.matchAll(cssBindingReg);
		for (const match of matchs) {
			const matchText = match.slice(1).find((t) => t);
			if (matchText) {
				const offset = match.index + css.slice(match.index).indexOf(matchText);
				yield {
					offset,
					text: matchText
				};
			}
		}
	}
	function* parseCssClassNames(css) {
		css = fillBlank(css, commentReg, fragmentReg);
		const matches = css.matchAll(cssClassNameReg);
		for (const match of matches) {
			const matchText = match[1];
			if (matchText) yield {
				offset: match.index,
				text: matchText
			};
		}
	}
	function fillBlank(css, ...regs) {
		for (const reg of regs) css = css.replace(reg, (match) => " ".repeat(match.length));
		return css;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/vue-template-html.js
var require_vue_template_html = __commonJS({ "node_modules/@vue/language-core/lib/plugins/vue-template-html.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const shouldAddSuffix = /(?<=<[^>/]+)$/;
	const plugin$3 = ({ modules }) => {
		return {
			version: 2.2,
			compileSFCTemplate(lang, template, options) {
				if (lang === "html" || lang === "md") {
					const compiler = modules["@vue/compiler-dom"];
					let addedSuffix = false;
					if (shouldAddSuffix.test(template)) {
						template += ">";
						addedSuffix = true;
					}
					const result = compiler.compile(template, {
						...options,
						comments: true
					});
					result.__addedSuffix = addedSuffix;
					return result;
				}
			},
			updateSFCTemplate(oldResult, change) {
				oldResult.code = oldResult.code.slice(0, change.start) + change.newText + oldResult.code.slice(change.end);
				if (oldResult.__addedSuffix) {
					const originalTemplate = oldResult.code.slice(0, -1);
					if (!shouldAddSuffix.test(originalTemplate)) return void 0;
				}
				const CompilerDOM$16 = modules["@vue/compiler-dom"];
				const lengthDiff = change.newText.length - (change.end - change.start);
				let hitNodes = [];
				if (tryUpdateNode(oldResult.ast) && hitNodes.length) {
					hitNodes = hitNodes.sort((a, b) => a.loc.source.length - b.loc.source.length);
					const hitNode = hitNodes[0];
					if (hitNode.type === CompilerDOM$16.NodeTypes.SIMPLE_EXPRESSION) return oldResult;
				}
				function tryUpdateNode(node) {
					if (withinChangeRange(node.loc)) hitNodes.push(node);
					if (tryUpdateNodeLoc(node.loc)) {
						if (node.type === CompilerDOM$16.NodeTypes.ROOT) {
							for (const child of node.children) if (!tryUpdateNode(child)) return false;
						} else if (node.type === CompilerDOM$16.NodeTypes.ELEMENT) {
							if (withinChangeRange(node.loc)) {
								const start = node.loc.start.offset + 2;
								const end = node.loc.start.offset + node.loc.source.lastIndexOf("</");
								if (!withinChangeRange({
									start: { offset: start },
									end: { offset: end },
									source: ""
								})) return false;
							}
							for (const prop of node.props) if (!tryUpdateNode(prop)) return false;
							for (const child of node.children) if (!tryUpdateNode(child)) return false;
						} else if (node.type === CompilerDOM$16.NodeTypes.ATTRIBUTE) {
							if (node.value && !tryUpdateNode(node.value)) return false;
						} else if (node.type === CompilerDOM$16.NodeTypes.DIRECTIVE) {
							if (node.arg && withinChangeRange(node.arg.loc) && node.name === "slot") return false;
							if (node.exp && withinChangeRange(node.exp.loc) && node.name === "for") return false;
							if (node.arg && !tryUpdateNode(node.arg)) return false;
							if (node.exp && !tryUpdateNode(node.exp)) return false;
						} else if (node.type === CompilerDOM$16.NodeTypes.TEXT_CALL) {
							if (!tryUpdateNode(node.content)) return false;
						} else if (node.type === CompilerDOM$16.NodeTypes.COMPOUND_EXPRESSION) {
							for (const childNode of node.children) if (typeof childNode === "object") {
								if (!tryUpdateNode(childNode)) return false;
							}
						} else if (node.type === CompilerDOM$16.NodeTypes.IF) for (const branch of node.branches) {
							if (branch.condition && !tryUpdateNode(branch.condition)) return false;
							for (const child of branch.children) if (!tryUpdateNode(child)) return false;
						}
						else if (node.type === CompilerDOM$16.NodeTypes.FOR) {
							for (const child of [
								node.parseResult.source,
								node.parseResult.value,
								node.parseResult.key,
								node.parseResult.index
							]) if (child) {
								if (!tryUpdateNode(child)) return false;
								if (child.type === CompilerDOM$16.NodeTypes.SIMPLE_EXPRESSION) {
									const content = child.content.trim();
									if (content.startsWith("(") || content.endsWith(")")) return false;
								}
							}
							for (const child of node.children) if (!tryUpdateNode(child)) return false;
						} else if (node.type === CompilerDOM$16.NodeTypes.INTERPOLATION) {
							if (!tryUpdateNode(node.content)) return false;
						} else if (node.type === CompilerDOM$16.NodeTypes.SIMPLE_EXPRESSION) {
							if (withinChangeRange(node.loc)) if (node.isStatic) return false;
							else if (!node.loc.source) return false;
							else node.content = node.loc.source;
						}
						return true;
					}
					return false;
				}
				function tryUpdateNodeLoc(loc) {
					delete loc.__endOffset;
					if (withinChangeRange(loc)) {
						loc.source = loc.source.slice(0, change.start - loc.start.offset) + change.newText + loc.source.slice(change.end - loc.start.offset);
						loc.__endOffset = loc.end.offset;
						loc.end.offset += lengthDiff;
						return true;
					} else if (change.end <= loc.start.offset) {
						loc.__endOffset = loc.end.offset;
						loc.start.offset += lengthDiff;
						loc.end.offset += lengthDiff;
						return true;
					} else if (change.start >= loc.end.offset) return true;
					return false;
				}
				function withinChangeRange(loc) {
					const originalLocEnd = loc.__endOffset ?? loc.end.offset;
					return change.start >= loc.start.offset && change.end <= originalLocEnd;
				}
			}
		};
	};
	exports.default = plugin$3;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/vue-template-inline-css.js
var require_vue_template_inline_css = __commonJS({ "node_modules/@vue/language-core/lib/plugins/vue-template-inline-css.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const CompilerDOM$2 = require_compiler_dom();
	const template_1$3 = require_template$1();
	const shared_1$8 = require_shared();
	const codeFeatures$1 = {
		...shared_1$8.allCodeFeatures,
		format: false,
		structure: false
	};
	const plugin$2 = () => {
		return {
			version: 2.2,
			getEmbeddedCodes(_fileName, sfc) {
				if (!sfc.template?.ast) return [];
				return [{
					id: "template_inline_css",
					lang: "css"
				}];
			},
			resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
				if (embeddedFile.id !== "template_inline_css" || !sfc.template?.ast) return;
				embeddedFile.parentCodeId = sfc.template.lang === "md" ? "root_tags" : "template";
				embeddedFile.content.push(...generate$1(sfc.template.ast));
			}
		};
	};
	exports.default = plugin$2;
	function* generate$1(templateAst) {
		for (const node of (0, template_1$3.forEachElementNode)(templateAst)) for (const prop of node.props) if (prop.type === CompilerDOM$2.NodeTypes.DIRECTIVE && prop.name === "bind" && prop.arg?.type === CompilerDOM$2.NodeTypes.SIMPLE_EXPRESSION && prop.exp?.type === CompilerDOM$2.NodeTypes.SIMPLE_EXPRESSION && prop.arg.content === "style" && prop.exp.constType === CompilerDOM$2.ConstantTypes.CAN_STRINGIFY) {
			const endCrt = prop.arg.loc.source[prop.arg.loc.source.length - 1];
			const start = prop.arg.loc.source.indexOf(endCrt) + 1;
			const end = prop.arg.loc.source.lastIndexOf(endCrt);
			const content = prop.arg.loc.source.slice(start, end);
			yield `x { `;
			yield [
				content,
				"template",
				prop.arg.loc.start.offset + start,
				codeFeatures$1
			];
			yield ` }\n`;
		}
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/vue-template-inline-ts.js
var require_vue_template_inline_ts = __commonJS({ "node_modules/@vue/language-core/lib/plugins/vue-template-inline-ts.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const CompilerDOM$1 = require_compiler_dom();
	const elementEvents_1 = require_elementEvents();
	const templateChild_1 = require_templateChild();
	const vFor_1 = require_vFor();
	const utils_1$19 = require_utils$3();
	const computedSfc_1$1 = require_computedSfc();
	const codeFeatures = { format: true };
	const formatBrackets = {
		normal: ["`${", "}`;"],
		if: ["if (", ") { }"],
		for: ["for (", ") { }"],
		params: ["(", ") => {};"],
		curly: ["0 +", "+ 0;"],
		event: ["() => ", ";"],
		generic: ["<", ">() => {};"]
	};
	const plugin$1 = (ctx) => {
		const parseds = /* @__PURE__ */ new WeakMap();
		return {
			version: 2.2,
			getEmbeddedCodes(_fileName, sfc) {
				if (!sfc.template?.ast) return [];
				const parsed = parse$5(sfc);
				parseds.set(sfc, parsed);
				const result = [];
				for (const [id] of parsed) result.push({
					id,
					lang: "ts"
				});
				return result;
			},
			resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
				if (!embeddedFile.id.startsWith("template_inline_ts_")) return;
				sfc.template?.content;
				const parsed = parseds.get(sfc);
				if (parsed) {
					const codes = parsed.get(embeddedFile.id);
					if (codes) {
						embeddedFile.content.push(...codes);
						embeddedFile.parentCodeId = sfc.template?.lang === "md" ? "root_tags" : "template";
					}
				}
			}
		};
		function parse$5(sfc) {
			const data = /* @__PURE__ */ new Map();
			if (!sfc.template?.ast) return data;
			const templateContent = sfc.template.content;
			const inlineTsAsts = computedSfc_1$1.templateInlineTsAsts.get(sfc.template.ast);
			let i = 0;
			sfc.template.ast.children.forEach(visit);
			return data;
			function visit(node) {
				if (node.type === CompilerDOM$1.NodeTypes.COMMENT) {
					const match = node.loc.source.match(/^<!--\s*@vue-generic\s*\{(?<content>[\s\S]*)\}\s*-->$/);
					if (match) {
						const { content } = match.groups;
						addFormatCodes(content, node.loc.start.offset + node.loc.source.indexOf("{") + 1, formatBrackets.generic);
					}
				} else if (node.type === CompilerDOM$1.NodeTypes.ELEMENT) {
					for (const prop of node.props) {
						if (prop.type !== CompilerDOM$1.NodeTypes.DIRECTIVE) continue;
						const isShorthand = prop.arg?.loc.start.offset === prop.exp?.loc.start.offset;
						if (isShorthand) continue;
						if (prop.arg?.type === CompilerDOM$1.NodeTypes.SIMPLE_EXPRESSION && !prop.arg.isStatic) addFormatCodes(prop.arg.loc.source, prop.arg.loc.start.offset, formatBrackets.normal);
						if (prop.exp?.type === CompilerDOM$1.NodeTypes.SIMPLE_EXPRESSION && prop.exp.constType !== CompilerDOM$1.ConstantTypes.CAN_STRINGIFY) if (prop.name === "on" && prop.arg?.type === CompilerDOM$1.NodeTypes.SIMPLE_EXPRESSION) {
							const ast = (0, utils_1$19.createTsAst)(ctx.modules.typescript, inlineTsAsts, prop.exp.content);
							if ((0, elementEvents_1.isCompoundExpression)(ctx.modules.typescript, ast)) addFormatCodes(prop.exp.loc.source, prop.exp.loc.start.offset, formatBrackets.event);
							else {
								const lines = prop.exp.content.split("\n");
								const firstLineEmpty = lines[0].trim() === "";
								const lastLineEmpty = lines[lines.length - 1].trim() === "";
								if (lines.length <= 1 || !firstLineEmpty && !lastLineEmpty) addFormatCodes(prop.exp.loc.source, prop.exp.loc.start.offset, formatBrackets.normal);
								else addFormatCodes(prop.exp.loc.source, prop.exp.loc.start.offset, ["(", ");"]);
							}
						} else if (prop.name === "slot") addFormatCodes(prop.exp.loc.source, prop.exp.loc.start.offset, formatBrackets.params);
						else if (prop.rawName === "v-for") addFormatCodes(prop.exp.loc.source, prop.exp.loc.start.offset, formatBrackets.for);
						else addFormatCodes(prop.exp.loc.source, prop.exp.loc.start.offset, formatBrackets.normal);
					}
					for (const child of node.children) visit(child);
				} else if (node.type === CompilerDOM$1.NodeTypes.IF) for (const branch of node.branches) {
					if (branch.condition?.type === CompilerDOM$1.NodeTypes.SIMPLE_EXPRESSION) addFormatCodes(branch.condition.loc.source, branch.condition.loc.start.offset, formatBrackets.if);
					for (const childNode of branch.children) visit(childNode);
				}
				else if (node.type === CompilerDOM$1.NodeTypes.FOR) {
					const { leftExpressionRange, leftExpressionText } = (0, vFor_1.parseVForNode)(node);
					const { source } = node.parseResult;
					if (leftExpressionRange && leftExpressionText && source.type === CompilerDOM$1.NodeTypes.SIMPLE_EXPRESSION) {
						let start = leftExpressionRange.start;
						let end = source.loc.start.offset + source.content.length;
						while (templateContent[start - 1] === " " || templateContent[start - 1] === "(") start--;
						while (templateContent[end] === " " || templateContent[end] === ")") end++;
						addFormatCodes(templateContent.slice(start, end), start, formatBrackets.for);
					}
					for (const child of node.children) visit(child);
				} else if (node.type === CompilerDOM$1.NodeTypes.TEXT_CALL) visit(node.content);
				else if (node.type === CompilerDOM$1.NodeTypes.COMPOUND_EXPRESSION) {
					for (const childNode of node.children) if (typeof childNode === "object") visit(childNode);
				} else if (node.type === CompilerDOM$1.NodeTypes.INTERPOLATION) {
					const [content, start] = (0, templateChild_1.parseInterpolationNode)(node, templateContent);
					const lines = content.split("\n");
					const firstLineEmpty = lines[0].trim() === "";
					const lastLineEmpty = lines[lines.length - 1].trim() === "";
					if (content.includes("=>")) if (lines.length <= 1 || !firstLineEmpty && !lastLineEmpty) addFormatCodes(content, start, formatBrackets.normal);
					else addFormatCodes(content, start, ["(", ");"]);
					else if (lines.length <= 1 || !firstLineEmpty && !lastLineEmpty) addFormatCodes(content, start, formatBrackets.curly);
					else addFormatCodes(content, start, [firstLineEmpty ? "(" : "(0 +", lastLineEmpty ? ");" : "+ 0);"]);
				}
			}
			function addFormatCodes(code$1, offset, wrapper) {
				const id = "template_inline_ts_" + i++;
				data.set(id, [
					wrapper[0],
					[
						code$1,
						"template",
						offset,
						codeFeatures
					],
					wrapper[1]
				]);
			}
		}
	};
	exports.default = plugin$1;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/localTypes.js
var require_localTypes = __commonJS({ "node_modules/@vue/language-core/lib/codegen/localTypes.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getLocalTypesGenerator = getLocalTypesGenerator;
	const utils_1$18 = require_utils$3();
	function getLocalTypesGenerator(vueCompilerOptions) {
		const used = /* @__PURE__ */ new Set();
		const WithDefaultsLocal = defineHelper(`__VLS_WithDefaultsLocal`, () => `
type __VLS_WithDefaultsLocal<P, D> = {
	[K in keyof Pick<P, keyof P>]: K extends keyof D
		? ${PrettifyLocal.name}<P[K] & { default: D[K] }>
		: P[K]
};
`.trimStart());
		const PrettifyLocal = defineHelper(`__VLS_PrettifyLocal`, () => `type __VLS_PrettifyLocal<T> = { [K in keyof T as K]: T[K]; } & {}${utils_1$18.endOfLine}`);
		const WithSlots = defineHelper(`__VLS_WithSlots`, () => `
type __VLS_WithSlots<T, S> = T & {
	new(): {
		$slots: S;
	}
};
`.trimStart());
		const PropsChildren = defineHelper(`__VLS_PropsChildren`, () => `
type __VLS_PropsChildren<S> = {
	[K in keyof (
		boolean extends (
			// @ts-ignore
			JSX.ElementChildrenAttribute extends never
				? true
				: false
		)
			? never
			// @ts-ignore
			: JSX.ElementChildrenAttribute
	)]?: S;
};
`.trimStart());
		const TypePropsToOption = defineHelper(`__VLS_TypePropsToOption`, () => `
type __VLS_TypePropsToOption<T> = {
	[K in keyof T]-?: {} extends Pick<T, K>
		? { type: import('${vueCompilerOptions.lib}').PropType<Required<T>[K]> }
		: { type: import('${vueCompilerOptions.lib}').PropType<T[K]>, required: true }
};
`.trimStart());
		const OmitIndexSignature = defineHelper(`__VLS_OmitIndexSignature`, () => `type __VLS_OmitIndexSignature<T> = { [K in keyof T as {} extends Record<K, unknown> ? never : K]: T[K]; }${utils_1$18.endOfLine}`);
		const helpers = {
			[PrettifyLocal.name]: PrettifyLocal,
			[WithDefaultsLocal.name]: WithDefaultsLocal,
			[WithSlots.name]: WithSlots,
			[PropsChildren.name]: PropsChildren,
			[TypePropsToOption.name]: TypePropsToOption,
			[OmitIndexSignature.name]: OmitIndexSignature
		};
		used.clear();
		return {
			generate: generate$4,
			get PrettifyLocal() {
				return PrettifyLocal.name;
			},
			get WithDefaultsLocal() {
				return WithDefaultsLocal.name;
			},
			get WithSlots() {
				return WithSlots.name;
			},
			get PropsChildren() {
				return PropsChildren.name;
			},
			get TypePropsToOption() {
				return TypePropsToOption.name;
			},
			get OmitIndexSignature() {
				return OmitIndexSignature.name;
			}
		};
		function* generate$4() {
			for (const name of used) yield helpers[name].generate();
			used.clear();
		}
		function defineHelper(name, generate$5) {
			return {
				get name() {
					used.add(name);
					return name;
				},
				generate: generate$5
			};
		}
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/script/context.js
var require_context = __commonJS({ "node_modules/@vue/language-core/lib/codegen/script/context.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createScriptCodegenContext = createScriptCodegenContext;
	const localTypes_1 = require_localTypes();
	function createScriptCodegenContext(options) {
		const localTypes = (0, localTypes_1.getLocalTypesGenerator)(options.vueCompilerOptions);
		const inlayHints = [];
		return {
			generatedTemplate: false,
			generatedPropsType: false,
			bypassDefineComponent: options.lang === "js" || options.lang === "jsx",
			bindingNames: new Set([...options.scriptRanges?.bindings.map(({ range: range$1 }) => options.sfc.script.content.slice(range$1.start, range$1.end)) ?? [], ...options.scriptSetupRanges?.bindings.map(({ range: range$1 }) => options.sfc.scriptSetup.content.slice(range$1.start, range$1.end)) ?? []]),
			localTypes,
			inlayHints
		};
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/utils/merge.js
var require_merge = __commonJS({ "node_modules/@vue/language-core/lib/codegen/utils/merge.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateIntersectMerge = generateIntersectMerge;
	exports.generateSpreadMerge = generateSpreadMerge;
	const index_1$1 = require_utils$3();
	function* generateIntersectMerge(codes) {
		yield codes[0];
		for (let i = 1; i < codes.length; i++) {
			yield ` & `;
			yield codes[i];
		}
	}
	function* generateSpreadMerge(codes) {
		if (codes.length === 1) yield codes[0];
		else {
			yield `{${index_1$1.newLine}`;
			for (const code$1 of codes) {
				yield `...`;
				yield code$1;
				yield `,${index_1$1.newLine}`;
			}
			yield `}`;
		}
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/script/component.js
var require_component = __commonJS({ "node_modules/@vue/language-core/lib/codegen/script/component.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateComponent = generateComponent;
	const codeFeatures_1$6 = require_codeFeatures();
	const utils_1$17 = require_utils$3();
	const merge_1$1 = require_merge();
	function* generateComponent(options, ctx, scriptSetup, scriptSetupRanges) {
		if (options.sfc.script && options.scriptRanges?.componentOptions && options.scriptRanges.componentOptions.expression.start !== options.scriptRanges.componentOptions.args.start) {
			yield (0, utils_1$17.generateSfcBlockSection)(options.sfc.script, options.scriptRanges.componentOptions.expression.start, options.scriptRanges.componentOptions.args.start, codeFeatures_1$6.codeFeatures.all);
			yield `{${utils_1$17.newLine}`;
		} else yield `(await import('${options.vueCompilerOptions.lib}')).defineComponent({${utils_1$17.newLine}`;
		const returns = [];
		if (ctx.bypassDefineComponent) {
			if (scriptSetupRanges.defineProps) {
				const name = scriptSetupRanges.defineProps.name ?? `__VLS_props`;
				returns.push(name, `{} as { $props: Partial<typeof ${name}> }`);
			}
			if (scriptSetupRanges.defineEmits) returns.push(`{} as { $emit: typeof ${scriptSetupRanges.defineEmits.name ?? `__VLS_emit`} }`);
		}
		if (scriptSetupRanges.defineExpose) returns.push(`__VLS_exposed`);
		if (returns.length) {
			yield `setup: () => (`;
			yield* (0, merge_1$1.generateSpreadMerge)(returns);
			yield `),${utils_1$17.newLine}`;
		}
		if (!ctx.bypassDefineComponent) {
			const emitOptionCodes = [...generateEmitsOption(options, scriptSetupRanges)];
			yield* emitOptionCodes;
			yield* generatePropsOption(options, ctx, scriptSetup, scriptSetupRanges, !!emitOptionCodes.length);
		}
		if (options.vueCompilerOptions.target >= 3.5 && options.vueCompilerOptions.inferComponentDollarRefs && options.templateCodegen?.templateRefs.size) yield `__typeRefs: {} as __VLS_TemplateRefs,${utils_1$17.newLine}`;
		if (options.vueCompilerOptions.target >= 3.5 && options.vueCompilerOptions.inferComponentDollarEl && options.templateCodegen?.singleRootElTypes.length) yield `__typeEl: {} as __VLS_RootEl,${utils_1$17.newLine}`;
		if (options.sfc.script && options.scriptRanges?.componentOptions?.args) {
			const { args } = options.scriptRanges.componentOptions;
			yield (0, utils_1$17.generateSfcBlockSection)(options.sfc.script, args.start + 1, args.end - 1, codeFeatures_1$6.codeFeatures.all);
		}
		yield `})`;
	}
	function* generateEmitsOption(options, scriptSetupRanges) {
		const optionCodes = [];
		const typeOptionCodes = [];
		if (scriptSetupRanges.defineModel.length) {
			optionCodes.push(`{} as __VLS_NormalizeEmits<typeof __VLS_modelEmit>`);
			typeOptionCodes.push(`__VLS_ModelEmit`);
		}
		if (scriptSetupRanges.defineEmits) {
			const { name, typeArg, hasUnionTypeArg } = scriptSetupRanges.defineEmits;
			optionCodes.push(`{} as __VLS_NormalizeEmits<typeof ${name ?? "__VLS_emit"}>`);
			if (typeArg && !hasUnionTypeArg) typeOptionCodes.push(`__VLS_Emit`);
			else typeOptionCodes.length = 0;
		}
		if (options.vueCompilerOptions.target >= 3.5 && typeOptionCodes.length) {
			yield `__typeEmits: {} as `;
			yield* (0, merge_1$1.generateIntersectMerge)(typeOptionCodes);
			yield `,${utils_1$17.newLine}`;
		} else if (optionCodes.length) {
			yield `emits: `;
			yield* (0, merge_1$1.generateSpreadMerge)(optionCodes);
			yield `,${utils_1$17.newLine}`;
		}
	}
	function* generatePropsOption(options, ctx, scriptSetup, scriptSetupRanges, hasEmitsOption) {
		const getOptionCodes = [];
		const typeOptionCodes = [];
		if (options.templateCodegen?.inheritedAttrVars.size) {
			let attrsType = `__VLS_InheritedAttrs`;
			if (hasEmitsOption) attrsType = `Omit<${attrsType}, keyof __VLS_EmitProps>`;
			getOptionCodes.push(() => {
				const propsType = `__VLS_PickNotAny<${ctx.localTypes.OmitIndexSignature}<${attrsType}>, {}>`;
				const optionType = `${ctx.localTypes.TypePropsToOption}<${propsType}>`;
				return `{} as ${optionType}`;
			});
			typeOptionCodes.push(`{} as ${attrsType}`);
		}
		if (ctx.generatedPropsType) {
			if (options.vueCompilerOptions.target < 3.6) getOptionCodes.push(() => {
				const propsType = `${ctx.localTypes.TypePropsToOption}<__VLS_PublicProps>`;
				return `{} as ` + (scriptSetupRanges.withDefaults?.arg ? `${ctx.localTypes.WithDefaultsLocal}<${propsType}, typeof __VLS_defaults>` : propsType);
			});
			typeOptionCodes.push(`{} as __VLS_PublicProps`);
		}
		if (scriptSetupRanges.defineProps?.arg) {
			const { arg } = scriptSetupRanges.defineProps;
			getOptionCodes.push(() => (0, utils_1$17.generateSfcBlockSection)(scriptSetup, arg.start, arg.end, codeFeatures_1$6.codeFeatures.navigation));
			typeOptionCodes.length = 0;
		}
		const useTypeOption = options.vueCompilerOptions.target >= 3.5 && typeOptionCodes.length;
		const useOption = (!useTypeOption || scriptSetupRanges.withDefaults) && getOptionCodes.length;
		if (useTypeOption) {
			if (options.vueCompilerOptions.target >= 3.6 && scriptSetupRanges.withDefaults?.arg) yield `__defaults: __VLS_defaults,${utils_1$17.newLine}`;
			yield `__typeProps: `;
			yield* (0, merge_1$1.generateSpreadMerge)(typeOptionCodes);
			yield `,${utils_1$17.newLine}`;
		}
		if (useOption) {
			yield `props: `;
			yield* (0, merge_1$1.generateSpreadMerge)(getOptionCodes.map((fn) => fn()));
			yield `,${utils_1$17.newLine}`;
		}
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/style/classProperty.js
var require_classProperty = __commonJS({ "node_modules/@vue/language-core/lib/codegen/style/classProperty.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateClassProperty = generateClassProperty;
	const codeFeatures_1$5 = require_codeFeatures();
	const utils_1$16 = require_utils$3();
	const wrapWith_1$4 = require_wrapWith();
	function* generateClassProperty(styleIndex, classNameWithDot, offset, propertyType) {
		yield `${utils_1$16.newLine} & { `;
		yield* (0, wrapWith_1$4.wrapWith)(offset, offset + classNameWithDot.length, "style_" + styleIndex, codeFeatures_1$5.codeFeatures.navigation, `'`, [
			classNameWithDot.slice(1),
			"style_" + styleIndex,
			offset + 1,
			utils_1$16.combineLastMapping
		], `'`);
		yield `: ${propertyType}`;
		yield ` }`;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/style/imports.js
var require_imports = __commonJS({ "node_modules/@vue/language-core/lib/codegen/style/imports.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateStyleImports = generateStyleImports;
	const utils_1$15 = require_utils$3();
	const wrapWith_1$3 = require_wrapWith();
	function* generateStyleImports(style) {
		const features = {
			navigation: true,
			verification: true
		};
		if (typeof style.src === "object") {
			yield `${utils_1$15.newLine} & typeof import(`;
			yield* (0, wrapWith_1$3.wrapWith)(style.src.offset, style.src.offset + style.src.text.length, "main", features, `'`, [
				style.src.text,
				"main",
				style.src.offset,
				utils_1$15.combineLastMapping
			], `'`);
			yield `).default`;
		}
		for (const { text, offset } of style.imports) {
			yield `${utils_1$15.newLine} & typeof import('`;
			yield [
				text,
				style.name,
				offset,
				features
			];
			yield `').default`;
		}
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/style/modules.js
var require_modules = __commonJS({ "node_modules/@vue/language-core/lib/codegen/style/modules.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateStyleModules = generateStyleModules;
	const codeFeatures_1$4 = require_codeFeatures();
	const utils_1$14 = require_utils$3();
	const classProperty_1$1 = require_classProperty();
	const imports_1$1 = require_imports();
	function* generateStyleModules(options) {
		const styles = options.sfc.styles.map((style, i) => [style, i]).filter(([style]) => style.module);
		if (!styles.length && !options.scriptSetupRanges?.useCssModule.length) return;
		yield `type __VLS_StyleModules = {${utils_1$14.newLine}`;
		for (const [style, i] of styles) {
			if (style.module === true) yield `$style`;
			else {
				const { text, offset } = style.module;
				yield [
					text,
					"main",
					offset,
					codeFeatures_1$4.codeFeatures.navigation
				];
			}
			yield `: `;
			if (!options.vueCompilerOptions.strictCssModules) yield `Record<string, string> & `;
			yield `__VLS_PrettifyGlobal<{}`;
			if (options.vueCompilerOptions.resolveStyleImports) yield* (0, imports_1$1.generateStyleImports)(style);
			for (const className of style.classNames) yield* (0, classProperty_1$1.generateClassProperty)(i, className.text, className.offset, "string");
			yield `>${utils_1$14.endOfLine}`;
		}
		yield `}${utils_1$14.endOfLine}`;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/style/scopedClasses.js
var require_scopedClasses = __commonJS({ "node_modules/@vue/language-core/lib/codegen/style/scopedClasses.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateStyleScopedClasses = generateStyleScopedClasses;
	const utils_1$13 = require_utils$3();
	const classProperty_1 = require_classProperty();
	const imports_1 = require_imports();
	function* generateStyleScopedClasses(options, ctx) {
		const option = options.vueCompilerOptions.resolveStyleClassNames;
		const styles = options.sfc.styles.map((style, i) => [style, i]).filter(([style]) => option === true || option === "scoped" && style.scoped);
		if (!styles.length) return;
		const firstClasses = /* @__PURE__ */ new Set();
		yield `type __VLS_StyleScopedClasses = {}`;
		for (const [style, i] of styles) {
			if (options.vueCompilerOptions.resolveStyleImports) yield* (0, imports_1.generateStyleImports)(style);
			for (const className of style.classNames) {
				if (firstClasses.has(className.text)) {
					ctx.scopedClasses.push({
						source: "style_" + i,
						className: className.text.slice(1),
						offset: className.offset + 1
					});
					continue;
				}
				firstClasses.add(className.text);
				yield* (0, classProperty_1.generateClassProperty)(i, className.text, className.offset, "boolean");
			}
		}
		yield utils_1$13.endOfLine;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/script/template.js
var require_template = __commonJS({ "node_modules/@vue/language-core/lib/codegen/script/template.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateTemplate = generateTemplate;
	const shared_1$7 = require_shared$2();
	const path$3 = require_path_browserify();
	const codeFeatures_1$3 = require_codeFeatures();
	const modules_1 = require_modules();
	const scopedClasses_1 = require_scopedClasses();
	const context_1$1 = require_context$1();
	const interpolation_1 = require_interpolation();
	const styleScopedClasses_1 = require_styleScopedClasses();
	const utils_1$12 = require_utils$3();
	const merge_1 = require_merge();
	function* generateTemplate(options, ctx) {
		ctx.generatedTemplate = true;
		yield* generateSelf(options);
		yield* generateTemplateCtx(options, ctx);
		yield* generateTemplateElements();
		yield* generateTemplateComponents(options);
		yield* generateTemplateDirectives(options);
		yield* generateTemplateBody(options, ctx);
	}
	function* generateSelf(options) {
		if (options.sfc.script && options.scriptRanges?.componentOptions) {
			yield `const __VLS_self = (await import('${options.vueCompilerOptions.lib}')).defineComponent(`;
			const { args } = options.scriptRanges.componentOptions;
			yield (0, utils_1$12.generateSfcBlockSection)(options.sfc.script, args.start, args.end, codeFeatures_1$3.codeFeatures.all);
			yield `)${utils_1$12.endOfLine}`;
		} else if (options.sfc.script && options.scriptRanges?.exportDefault) {
			yield `const __VLS_self = `;
			const { expression } = options.scriptRanges.exportDefault;
			yield (0, utils_1$12.generateSfcBlockSection)(options.sfc.script, expression.start, expression.end, codeFeatures_1$3.codeFeatures.all);
			yield utils_1$12.endOfLine;
		} else if (options.sfc.script?.src) yield `let __VLS_self!: typeof import('./${path$3.basename(options.fileName)}').default${utils_1$12.endOfLine}`;
	}
	function* generateTemplateCtx(options, ctx) {
		const exps = [];
		if (options.vueCompilerOptions.petiteVueExtensions.some((ext) => options.fileName.endsWith(ext))) exps.push(`globalThis`);
		if (options.sfc.script?.src || options.scriptRanges?.exportDefault) exps.push(`{} as InstanceType<__VLS_PickNotAny<typeof __VLS_self, new () => {}>>`);
		else exps.push(`{} as import('${options.vueCompilerOptions.lib}').ComponentPublicInstance`);
		if (options.sfc.styles.some((style) => style.module)) exps.push(`{} as __VLS_StyleModules`);
		const emitTypes = [];
		if (options.scriptSetupRanges?.defineEmits) {
			const { defineEmits } = options.scriptSetupRanges;
			emitTypes.push(`typeof ${defineEmits.name ?? `__VLS_emit`}`);
		}
		if (options.scriptSetupRanges?.defineModel.length) emitTypes.push(`typeof __VLS_modelEmit`);
		if (emitTypes.length) {
			yield `type __VLS_EmitProps = __VLS_EmitsToProps<__VLS_NormalizeEmits<${emitTypes.join(` & `)}>>${utils_1$12.endOfLine}`;
			exps.push(`{} as { $emit: ${emitTypes.join(` & `)} }`);
		}
		const propTypes = [];
		const { defineProps, withDefaults } = options.scriptSetupRanges ?? {};
		const props = defineProps?.arg ? `typeof ${defineProps.name ?? `__VLS_props`}` : defineProps?.typeArg ? withDefaults?.arg ? `__VLS_WithDefaultsGlobal<__VLS_Props, typeof __VLS_defaults>` : `__VLS_Props` : void 0;
		if (props) propTypes.push(props);
		if (options.scriptSetupRanges?.defineModel.length) propTypes.push(`__VLS_ModelProps`);
		if (emitTypes.length) propTypes.push(`__VLS_EmitProps`);
		if (propTypes.length) {
			yield `type __VLS_InternalProps = ${propTypes.join(` & `)}${utils_1$12.endOfLine}`;
			exps.push(`{} as { $props: __VLS_InternalProps }`);
			exps.push(`{} as __VLS_InternalProps`);
		}
		if (options.scriptSetupRanges && ctx.bindingNames.size) exps.push(`{} as __VLS_Bindings`);
		yield `const __VLS_ctx = `;
		yield* (0, merge_1.generateSpreadMerge)(exps);
		yield utils_1$12.endOfLine;
	}
	function* generateTemplateElements() {
		yield `let __VLS_elements!: __VLS_IntrinsicElements${utils_1$12.endOfLine}`;
	}
	function* generateTemplateComponents(options) {
		const types$1 = [`typeof __VLS_ctx`];
		if (options.sfc.script && options.scriptRanges?.componentOptions?.components) {
			const { components } = options.scriptRanges.componentOptions;
			yield `const __VLS_componentsOption = `;
			yield (0, utils_1$12.generateSfcBlockSection)(options.sfc.script, components.start, components.end, codeFeatures_1$3.codeFeatures.navigation);
			yield utils_1$12.endOfLine;
			types$1.push(`typeof __VLS_componentsOption`);
		}
		yield `type __VLS_LocalComponents = ${types$1.join(` & `)}${utils_1$12.endOfLine}`;
		yield `let __VLS_components!: __VLS_LocalComponents & __VLS_GlobalComponents${utils_1$12.endOfLine}`;
	}
	function* generateTemplateDirectives(options) {
		const types$1 = [`typeof __VLS_ctx`];
		if (options.sfc.script && options.scriptRanges?.componentOptions?.directives) {
			const { directives } = options.scriptRanges.componentOptions;
			yield `const __VLS_directivesOption = `;
			yield (0, utils_1$12.generateSfcBlockSection)(options.sfc.script, directives.start, directives.end, codeFeatures_1$3.codeFeatures.navigation);
			yield utils_1$12.endOfLine;
			types$1.push(`__VLS_ResolveDirectives<typeof __VLS_directivesOption>`);
		}
		yield `type __VLS_LocalDirectives = ${types$1.join(` & `)}${utils_1$12.endOfLine}`;
		yield `let __VLS_directives!: __VLS_LocalDirectives & __VLS_GlobalDirectives${utils_1$12.endOfLine}`;
	}
	function* generateTemplateBody(options, ctx) {
		const templateCodegenCtx = (0, context_1$1.createTemplateCodegenContext)({ scriptSetupBindingNames: /* @__PURE__ */ new Set() });
		yield* (0, scopedClasses_1.generateStyleScopedClasses)(options, templateCodegenCtx);
		yield* (0, styleScopedClasses_1.generateStyleScopedClassReferences)(templateCodegenCtx, true);
		yield* (0, modules_1.generateStyleModules)(options);
		yield* generateCssVars(options, templateCodegenCtx);
		yield* generateBindings(options, ctx, templateCodegenCtx);
		if (options.templateCodegen) yield* options.templateCodegen.codes;
		else {
			if (!options.scriptSetupRanges?.defineSlots) yield `type __VLS_Slots = {}${utils_1$12.endOfLine}`;
			yield `type __VLS_InheritedAttrs = {}${utils_1$12.endOfLine}`;
			yield `type __VLS_TemplateRefs = {}${utils_1$12.endOfLine}`;
			yield `type __VLS_RootEl = any${utils_1$12.endOfLine}`;
		}
	}
	function* generateCssVars(options, ctx) {
		for (const style of options.sfc.styles) for (const binding of style.bindings) {
			yield* (0, interpolation_1.generateInterpolation)(options, ctx, style.name, codeFeatures_1$3.codeFeatures.all, binding.text, binding.offset, `(`, `)`);
			yield utils_1$12.endOfLine;
		}
	}
	function* generateBindings(options, ctx, templateCodegenCtx) {
		if (!options.sfc.scriptSetup || !ctx.bindingNames.size) return;
		const usageVars = new Set([
			...options.sfc.template?.ast?.components.flatMap((c) => [(0, shared_1$7.camelize)(c), (0, shared_1$7.capitalize)((0, shared_1$7.camelize)(c))]) ?? [],
			...options.templateCodegen?.accessExternalVariables.keys() ?? [],
			...templateCodegenCtx.accessExternalVariables.keys()
		]);
		yield `type __VLS_Bindings = __VLS_ProxyRefs<{${utils_1$12.newLine}`;
		for (const varName of ctx.bindingNames) {
			if (!usageVars.has(varName)) continue;
			const token = Symbol(varName.length);
			yield [
				"",
				void 0,
				0,
				{ __linkedToken: token }
			];
			yield `${varName}: typeof `;
			yield [
				"",
				void 0,
				0,
				{ __linkedToken: token }
			];
			yield varName;
			yield utils_1$12.endOfLine;
		}
		yield `}>${utils_1$12.endOfLine}`;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/script/scriptSetup.js
var require_scriptSetup = __commonJS({ "node_modules/@vue/language-core/lib/codegen/script/scriptSetup.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateScriptSetupImports = generateScriptSetupImports;
	exports.generateScriptSetup = generateScriptSetup;
	const shared_1$6 = require_shared$2();
	const codeFeatures_1$2 = require_codeFeatures();
	const utils_1$11 = require_utils$3();
	const camelized_1 = require_camelized();
	const wrapWith_1$2 = require_wrapWith();
	const component_1 = require_component();
	const index_1 = require_script();
	const template_1$2 = require_template();
	function* generateScriptSetupImports(scriptSetup, scriptSetupRanges) {
		yield [
			scriptSetup.content.slice(0, Math.max(scriptSetupRanges.importSectionEndOffset, scriptSetupRanges.leadingCommentEndOffset)),
			"scriptSetup",
			0,
			codeFeatures_1$2.codeFeatures.all
		];
	}
	function* generateScriptSetup(options, ctx, scriptSetup, scriptSetupRanges) {
		if (scriptSetup.generic) {
			yield* (0, index_1.generateConstExport)(options, scriptSetup);
			yield `(`;
			if (typeof scriptSetup.generic === "object") {
				yield `<`;
				yield [
					scriptSetup.generic.text,
					"main",
					scriptSetup.generic.offset,
					codeFeatures_1$2.codeFeatures.all
				];
				if (!scriptSetup.generic.text.endsWith(`,`)) yield `,`;
				yield `>`;
			}
			yield `(${utils_1$11.newLine}	__VLS_props: NonNullable<Awaited<typeof __VLS_setup>>['props'],${utils_1$11.newLine}	__VLS_ctx?: ${ctx.localTypes.PrettifyLocal}<Pick<NonNullable<Awaited<typeof __VLS_setup>>, 'attrs' | 'emit' | 'slots'>>,${utils_1$11.newLine}	__VLS_expose?: NonNullable<Awaited<typeof __VLS_setup>>['expose'],${utils_1$11.newLine}	__VLS_setup = (async () => {${utils_1$11.newLine}`;
			yield* generateSetupFunction(options, ctx, scriptSetup, scriptSetupRanges, void 0);
			const propTypes = [];
			if (ctx.generatedPropsType) propTypes.push(`__VLS_PublicProps`);
			if (scriptSetupRanges.defineProps?.arg) {
				yield `const __VLS_propsOption = `;
				yield (0, utils_1$11.generateSfcBlockSection)(scriptSetup, scriptSetupRanges.defineProps.arg.start, scriptSetupRanges.defineProps.arg.end, codeFeatures_1$2.codeFeatures.navigation);
				yield utils_1$11.endOfLine;
				propTypes.push(`import('${options.vueCompilerOptions.lib}').${options.vueCompilerOptions.target >= 3.3 ? `ExtractPublicPropTypes` : `ExtractPropTypes`}<typeof __VLS_propsOption>`);
			}
			if (scriptSetupRanges.defineEmits || scriptSetupRanges.defineModel.length) propTypes.push(`__VLS_EmitProps`);
			if (options.templateCodegen?.inheritedAttrVars.size) propTypes.push(`__VLS_InheritedAttrs`);
			const emitTypes = [];
			if (scriptSetupRanges.defineEmits) emitTypes.push(`typeof ${scriptSetupRanges.defineEmits.name ?? "__VLS_emit"}`);
			if (scriptSetupRanges.defineModel.length) emitTypes.push(`typeof __VLS_modelEmit`);
			yield `return {} as {${utils_1$11.newLine}	props: ${propTypes.length ? `${ctx.localTypes.PrettifyLocal}<${propTypes.join(` & `)}> & ` : ``}${options.vueCompilerOptions.target >= 3.4 ? `import('${options.vueCompilerOptions.lib}').PublicProps` : options.vueCompilerOptions.target >= 3 ? `import('${options.vueCompilerOptions.lib}').VNodeProps & import('${options.vueCompilerOptions.lib}').AllowedComponentProps & import('${options.vueCompilerOptions.lib}').ComponentCustomProps` : `globalThis.JSX.IntrinsicAttributes`}${utils_1$11.endOfLine}	expose: (exposed: ${scriptSetupRanges.defineExpose ? `import('${options.vueCompilerOptions.lib}').ShallowUnwrapRef<typeof __VLS_exposed>` : `{}`}) => void${utils_1$11.endOfLine}	attrs: any${utils_1$11.endOfLine}	slots: __VLS_Slots${utils_1$11.endOfLine}	emit: ${emitTypes.length ? emitTypes.join(` & `) : `{}`}${utils_1$11.endOfLine}}${utils_1$11.endOfLine}`;
			yield `})(),${utils_1$11.newLine}`;
			yield `) => ({} as import('${options.vueCompilerOptions.lib}').VNode & { __ctx?: Awaited<typeof __VLS_setup> }))${utils_1$11.endOfLine}`;
		} else if (!options.sfc.script) yield* generateSetupFunction(options, ctx, scriptSetup, scriptSetupRanges, "export default");
		else {
			yield* (0, index_1.generateConstExport)(options, scriptSetup);
			yield `await (async () => {${utils_1$11.newLine}`;
			yield* generateSetupFunction(options, ctx, scriptSetup, scriptSetupRanges, "return");
			yield `})()${utils_1$11.endOfLine}`;
		}
	}
	function* generateSetupFunction(options, ctx, scriptSetup, scriptSetupRanges, syntax) {
		let setupCodeModifies = [];
		if (scriptSetupRanges.defineProps) {
			const { name, statement, callExp, typeArg } = scriptSetupRanges.defineProps;
			setupCodeModifies.push(...generateDefineWithType(scriptSetup, statement, scriptSetupRanges.withDefaults?.callExp ?? callExp, typeArg, name, `__VLS_props`, `__VLS_Props`));
		}
		if (scriptSetupRanges.defineEmits) {
			const { name, statement, callExp, typeArg } = scriptSetupRanges.defineEmits;
			setupCodeModifies.push(...generateDefineWithType(scriptSetup, statement, callExp, typeArg, name, `__VLS_emit`, `__VLS_Emit`));
		}
		if (scriptSetupRanges.defineSlots) {
			const { name, statement, callExp, typeArg } = scriptSetupRanges.defineSlots;
			setupCodeModifies.push(...generateDefineWithType(scriptSetup, statement, callExp, typeArg, name, `__VLS_slots`, `__VLS_Slots`));
		}
		if (scriptSetupRanges.defineExpose) {
			const { callExp, arg, typeArg } = scriptSetupRanges.defineExpose;
			if (typeArg) setupCodeModifies.push([
				[
					`let __VLS_exposed!: `,
					(0, utils_1$11.generateSfcBlockSection)(scriptSetup, typeArg.start, typeArg.end, codeFeatures_1$2.codeFeatures.all),
					utils_1$11.endOfLine
				],
				callExp.start,
				callExp.start
			], [
				[`typeof __VLS_exposed`],
				typeArg.start,
				typeArg.end
			]);
			else if (arg) setupCodeModifies.push([
				[
					`const __VLS_exposed = `,
					(0, utils_1$11.generateSfcBlockSection)(scriptSetup, arg.start, arg.end, codeFeatures_1$2.codeFeatures.all),
					utils_1$11.endOfLine
				],
				callExp.start,
				callExp.start
			], [
				[`__VLS_exposed`],
				arg.start,
				arg.end
			]);
			else setupCodeModifies.push([
				[`const __VLS_exposed = {}${utils_1$11.endOfLine}`],
				callExp.start,
				callExp.start
			]);
		}
		if (options.vueCompilerOptions.inferTemplateDollarAttrs) for (const { callExp } of scriptSetupRanges.useAttrs) setupCodeModifies.push([
			[`(`],
			callExp.start,
			callExp.start
		], [
			[` as typeof __VLS_dollars.$attrs)`],
			callExp.end,
			callExp.end
		]);
		for (const { callExp, exp, arg } of scriptSetupRanges.useCssModule) {
			setupCodeModifies.push([
				[`(`],
				callExp.start,
				callExp.start
			], [
				arg ? [
					` as Omit<__VLS_StyleModules, '$style'>[`,
					(0, utils_1$11.generateSfcBlockSection)(scriptSetup, arg.start, arg.end, codeFeatures_1$2.codeFeatures.withoutSemantic),
					`])`
				] : [
					` as __VLS_StyleModules[`,
					...(0, wrapWith_1$2.wrapWith)(exp.start, exp.end, scriptSetup.name, codeFeatures_1$2.codeFeatures.verification, `'$style'`),
					`])`
				],
				callExp.end,
				callExp.end
			]);
			if (arg) setupCodeModifies.push([
				[`__VLS_placeholder`],
				arg.start,
				arg.end
			]);
		}
		if (options.vueCompilerOptions.inferTemplateDollarSlots) for (const { callExp } of scriptSetupRanges.useSlots) setupCodeModifies.push([
			[`(`],
			callExp.start,
			callExp.start
		], [
			[` as typeof __VLS_dollars.$slots)`],
			callExp.end,
			callExp.end
		]);
		const isTs = options.lang !== "js" && options.lang !== "jsx";
		for (const { callExp, exp, arg } of scriptSetupRanges.useTemplateRef) {
			const templateRefType = arg ? [
				`__VLS_TemplateRefs[`,
				(0, utils_1$11.generateSfcBlockSection)(scriptSetup, arg.start, arg.end, codeFeatures_1$2.codeFeatures.withoutSemantic),
				`]`
			] : [`unknown`];
			if (isTs) setupCodeModifies.push([
				[
					`<`,
					...templateRefType,
					`>`
				],
				exp.end,
				exp.end
			]);
			else setupCodeModifies.push([
				[`(`],
				callExp.start,
				callExp.start
			], [
				[
					` as __VLS_UseTemplateRef<`,
					...templateRefType,
					`>)`
				],
				callExp.end,
				callExp.end
			]);
			if (arg) setupCodeModifies.push([
				[`__VLS_placeholder`],
				arg.start,
				arg.end
			]);
		}
		setupCodeModifies = setupCodeModifies.sort((a, b) => a[1] - b[1]);
		let nextStart = Math.max(scriptSetupRanges.importSectionEndOffset, scriptSetupRanges.leadingCommentEndOffset);
		for (const [codes, start, end] of setupCodeModifies) {
			yield (0, utils_1$11.generateSfcBlockSection)(scriptSetup, nextStart, start, codeFeatures_1$2.codeFeatures.all);
			yield* codes;
			nextStart = end;
		}
		yield (0, utils_1$11.generateSfcBlockSection)(scriptSetup, nextStart, scriptSetup.content.length, codeFeatures_1$2.codeFeatures.all);
		yield* (0, utils_1$11.generatePartiallyEnding)(scriptSetup.name, scriptSetup.content.length, "#3632/scriptSetup.vue");
		yield* generateMacros(options, ctx);
		const hasSlots = !!(scriptSetupRanges.defineSlots || options.templateCodegen?.slots.length || options.templateCodegen?.dynamicSlots.length);
		yield* generateModels(scriptSetup, scriptSetupRanges);
		yield* generatePublicProps(options, ctx, scriptSetup, scriptSetupRanges, hasSlots);
		yield* (0, template_1$2.generateTemplate)(options, ctx);
		if (syntax) {
			const prefix$1 = syntax === "return" ? [`return `] : (0, index_1.generateConstExport)(options, scriptSetup);
			if (hasSlots) {
				yield `const __VLS_base = `;
				yield* (0, component_1.generateComponent)(options, ctx, scriptSetup, scriptSetupRanges);
				yield utils_1$11.endOfLine;
				yield* prefix$1;
				yield `{} as ${ctx.localTypes.WithSlots}<typeof __VLS_base, __VLS_Slots>${utils_1$11.endOfLine}`;
			} else {
				yield* prefix$1;
				yield* (0, component_1.generateComponent)(options, ctx, scriptSetup, scriptSetupRanges);
				yield utils_1$11.endOfLine;
			}
		}
	}
	function* generateMacros(options, ctx) {
		if (options.vueCompilerOptions.target >= 3.3) {
			yield `// @ts-ignore${utils_1$11.newLine}`;
			yield `declare const { `;
			for (const macro of Object.keys(options.vueCompilerOptions.macros)) if (!ctx.bindingNames.has(macro)) yield `${macro}, `;
			yield `}: typeof import('${options.vueCompilerOptions.lib}')${utils_1$11.endOfLine}`;
		}
	}
	function* generateDefineWithType(scriptSetup, statement, callExp, typeArg, name, defaultName, typeName) {
		if (typeArg) {
			yield [
				[
					`type ${typeName} = `,
					(0, utils_1$11.generateSfcBlockSection)(scriptSetup, typeArg.start, typeArg.end, codeFeatures_1$2.codeFeatures.all),
					utils_1$11.endOfLine
				],
				statement.start,
				statement.start
			];
			yield [
				[typeName],
				typeArg.start,
				typeArg.end
			];
		}
		if (!name) if (statement.start === callExp.start && statement.end === callExp.end) yield [
			[`const ${defaultName} = `],
			callExp.start,
			callExp.start
		];
		else if (typeArg) {
			yield [
				[`const ${defaultName} = `, (0, utils_1$11.generateSfcBlockSection)(scriptSetup, callExp.start, typeArg.start, codeFeatures_1$2.codeFeatures.all)],
				statement.start,
				typeArg.start
			];
			yield [
				[
					(0, utils_1$11.generateSfcBlockSection)(scriptSetup, typeArg.end, callExp.end, codeFeatures_1$2.codeFeatures.all),
					utils_1$11.endOfLine,
					(0, utils_1$11.generateSfcBlockSection)(scriptSetup, statement.start, callExp.start, codeFeatures_1$2.codeFeatures.all),
					defaultName
				],
				typeArg.end,
				callExp.end
			];
		} else yield [
			[
				`const ${defaultName} = `,
				(0, utils_1$11.generateSfcBlockSection)(scriptSetup, callExp.start, callExp.end, codeFeatures_1$2.codeFeatures.all),
				utils_1$11.endOfLine,
				(0, utils_1$11.generateSfcBlockSection)(scriptSetup, statement.start, callExp.start, codeFeatures_1$2.codeFeatures.all),
				defaultName
			],
			statement.start,
			callExp.end
		];
		else if (!utils_1$11.identifierRegex.test(name)) {
			yield [
				[`const ${defaultName} = `],
				statement.start,
				callExp.start
			];
			yield [
				[
					utils_1$11.endOfLine,
					(0, utils_1$11.generateSfcBlockSection)(scriptSetup, statement.start, callExp.start, codeFeatures_1$2.codeFeatures.all),
					defaultName
				],
				statement.end,
				statement.end
			];
		}
	}
	function* generatePublicProps(options, ctx, scriptSetup, scriptSetupRanges, hasSlots) {
		if (scriptSetupRanges.defineProps?.typeArg && scriptSetupRanges.withDefaults?.arg) {
			yield `const __VLS_defaults = `;
			yield (0, utils_1$11.generateSfcBlockSection)(scriptSetup, scriptSetupRanges.withDefaults.arg.start, scriptSetupRanges.withDefaults.arg.end, codeFeatures_1$2.codeFeatures.navigation);
			yield utils_1$11.endOfLine;
		}
		const propTypes = [];
		if (options.vueCompilerOptions.jsxSlots && hasSlots) propTypes.push(`${ctx.localTypes.PropsChildren}<__VLS_Slots>`);
		if (scriptSetupRanges.defineProps?.typeArg) propTypes.push(`__VLS_Props`);
		if (scriptSetupRanges.defineModel.length) propTypes.push(`__VLS_ModelProps`);
		if (propTypes.length) {
			ctx.generatedPropsType = true;
			yield `type __VLS_PublicProps = ${propTypes.join(` & `)}${utils_1$11.endOfLine}`;
		}
	}
	function* generateModels(scriptSetup, scriptSetupRanges) {
		if (!scriptSetupRanges.defineModel.length) return;
		const defaultCodes = [];
		const propCodes = [];
		const emitCodes = [];
		for (const defineModel of scriptSetupRanges.defineModel) {
			const propName = defineModel.name ? (0, shared_1$6.camelize)(getRangeText(scriptSetup, defineModel.name).slice(1, -1)) : "modelValue";
			let modelType;
			if (defineModel.type) modelType = getRangeText(scriptSetup, defineModel.type);
			else if (defineModel.runtimeType && defineModel.localName) modelType = `typeof ${getRangeText(scriptSetup, defineModel.localName)}['value']`;
			else if (defineModel.defaultValue && propName) modelType = `typeof __VLS_defaultModels['${propName}']`;
			else modelType = `any`;
			if (defineModel.defaultValue) defaultCodes.push(`'${propName}': ${getRangeText(scriptSetup, defineModel.defaultValue)},${utils_1$11.newLine}`);
			propCodes.push(generateModelProp(scriptSetup, defineModel, propName, modelType));
			emitCodes.push(generateModelEmit(defineModel, propName, modelType));
		}
		if (defaultCodes.length) {
			yield `const __VLS_defaultModels = {${utils_1$11.newLine}`;
			yield* defaultCodes;
			yield `}${utils_1$11.endOfLine}`;
		}
		yield `type __VLS_ModelProps = {${utils_1$11.newLine}`;
		for (const codes of propCodes) yield* codes;
		yield `}${utils_1$11.endOfLine}`;
		yield `type __VLS_ModelEmit = {${utils_1$11.newLine}`;
		for (const codes of emitCodes) yield* codes;
		yield `}${utils_1$11.endOfLine}`;
		yield `const __VLS_modelEmit = defineEmits<__VLS_ModelEmit>()${utils_1$11.endOfLine}`;
	}
	function* generateModelProp(scriptSetup, defineModel, propName, modelType) {
		if (defineModel.comments) {
			yield scriptSetup.content.slice(defineModel.comments.start, defineModel.comments.end);
			yield utils_1$11.newLine;
		}
		if (defineModel.name) yield* (0, camelized_1.generateCamelized)(getRangeText(scriptSetup, defineModel.name), scriptSetup.name, defineModel.name.start, codeFeatures_1$2.codeFeatures.navigation);
		else yield propName;
		yield defineModel.required ? `: ` : `?: `;
		yield modelType;
		yield utils_1$11.endOfLine;
		if (defineModel.modifierType) {
			const modifierName = `${propName === "modelValue" ? "model" : propName}Modifiers`;
			const modifierType = getRangeText(scriptSetup, defineModel.modifierType);
			yield `'${modifierName}'?: Partial<Record<${modifierType}, true>>${utils_1$11.endOfLine}`;
		}
	}
	function* generateModelEmit(defineModel, propName, modelType) {
		yield `'update:${propName}': [value: `;
		yield modelType;
		if (!defineModel.required && !defineModel.defaultValue) yield ` | undefined`;
		yield `]${utils_1$11.endOfLine}`;
	}
	function getRangeText(scriptSetup, range$1) {
		return scriptSetup.content.slice(range$1.start, range$1.end);
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/script/src.js
var require_src = __commonJS({ "node_modules/@vue/language-core/lib/codegen/script/src.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateSrc = generateSrc;
	const codeFeatures_1$1 = require_codeFeatures();
	const utils_1$10 = require_utils$3();
	const wrapWith_1$1 = require_wrapWith();
	function* generateSrc(src) {
		if (src === true) return;
		let { text } = src;
		if (text.endsWith(".d.ts")) text = text.slice(0, -5);
		else if (text.endsWith(".ts")) text = text.slice(0, -3);
		else if (text.endsWith(".tsx")) text = text.slice(0, -4) + ".jsx";
		if (!text.endsWith(".js") && !text.endsWith(".jsx")) text = text + ".js";
		yield `export * from `;
		yield* (0, wrapWith_1$1.wrapWith)(src.offset, src.offset + src.text.length, "main", {
			...codeFeatures_1$1.codeFeatures.all,
			...text !== src.text ? codeFeatures_1$1.codeFeatures.navigationWithoutRename : {}
		}, `'`, [
			text.slice(0, src.text.length),
			"main",
			src.offset,
			utils_1$10.combineLastMapping
		], text.slice(src.text.length), `'`);
		yield utils_1$10.endOfLine;
		yield `export { default } from '${text}'${utils_1$10.endOfLine}`;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/codegen/script/index.js
var require_script = __commonJS({ "node_modules/@vue/language-core/lib/codegen/script/index.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateScript = generate;
	exports.generateConstExport = generateConstExport;
	const path$2 = require_path_browserify();
	const codeFeatures_1 = require_codeFeatures();
	const utils_1$9 = require_utils$3();
	const wrapWith_1 = require_wrapWith();
	const context_1 = require_context();
	const scriptSetup_1 = require_scriptSetup();
	const src_1 = require_src();
	const template_1$1 = require_template();
	function generate(options) {
		const context = (0, context_1.createScriptCodegenContext)(options);
		const codegen = generateScript(options, context);
		return {
			...context,
			codes: [...codegen]
		};
	}
	function* generateScript(options, ctx) {
		yield* generateGlobalTypesReference(options);
		if (options.sfc.scriptSetup && options.scriptSetupRanges) yield* (0, scriptSetup_1.generateScriptSetupImports)(options.sfc.scriptSetup, options.scriptSetupRanges);
		if (options.sfc.script && options.scriptRanges) {
			const { exportDefault, componentOptions } = options.scriptRanges;
			if (options.sfc.scriptSetup && options.scriptSetupRanges) if (exportDefault) {
				yield (0, utils_1$9.generateSfcBlockSection)(options.sfc.script, 0, exportDefault.start, codeFeatures_1.codeFeatures.all);
				yield* (0, scriptSetup_1.generateScriptSetup)(options, ctx, options.sfc.scriptSetup, options.scriptSetupRanges);
			} else {
				yield (0, utils_1$9.generateSfcBlockSection)(options.sfc.script, 0, options.sfc.script.content.length, codeFeatures_1.codeFeatures.all);
				yield* (0, scriptSetup_1.generateScriptSetup)(options, ctx, options.sfc.scriptSetup, options.scriptSetupRanges);
			}
			else if (exportDefault) {
				const { expression } = componentOptions ?? exportDefault;
				let wrapLeft;
				let wrapRight;
				if (options.sfc.script.content[expression.start] === "{" && options.vueCompilerOptions.optionsWrapper.length) {
					[wrapLeft, wrapRight] = options.vueCompilerOptions.optionsWrapper;
					ctx.inlayHints.push({
						blockName: options.sfc.script.name,
						offset: expression.start,
						setting: "vue.inlayHints.optionsWrapper",
						label: wrapLeft || "[Missing optionsWrapper[0]]",
						tooltip: ["This is virtual code that is automatically wrapped for type support, it does not affect your runtime behavior, you can customize it via `vueCompilerOptions.optionsWrapper` option in tsconfig / jsconfig.", "To hide it, you can set `\"vue.inlayHints.optionsWrapper\": false` in IDE settings."].join("\n\n")
					}, {
						blockName: options.sfc.script.name,
						offset: expression.end,
						setting: "vue.inlayHints.optionsWrapper",
						label: wrapRight || "[Missing optionsWrapper[1]]"
					});
				}
				yield (0, utils_1$9.generateSfcBlockSection)(options.sfc.script, 0, exportDefault.start, codeFeatures_1.codeFeatures.all);
				yield* generateConstExport(options, options.sfc.script);
				if (wrapLeft) yield wrapLeft;
				yield (0, utils_1$9.generateSfcBlockSection)(options.sfc.script, expression.start, expression.end, codeFeatures_1.codeFeatures.all);
				if (wrapRight) yield wrapRight;
				yield utils_1$9.endOfLine;
			} else {
				yield (0, utils_1$9.generateSfcBlockSection)(options.sfc.script, 0, options.sfc.script.content.length, codeFeatures_1.codeFeatures.all);
				yield* generateConstExport(options, options.sfc.script);
				yield `(await import('${options.vueCompilerOptions.lib}')).defineComponent({})${utils_1$9.endOfLine}`;
			}
		} else if (options.sfc.scriptSetup && options.scriptSetupRanges) yield* (0, scriptSetup_1.generateScriptSetup)(options, ctx, options.sfc.scriptSetup, options.scriptSetupRanges);
		if (!ctx.generatedTemplate) yield* (0, template_1$1.generateTemplate)(options, ctx);
		yield* generateExportDefault(options);
		yield* ctx.localTypes.generate();
	}
	function* generateGlobalTypesReference(options) {
		const globalTypesPath = options.vueCompilerOptions.globalTypesPath(options.fileName);
		if (!globalTypesPath) yield `/* placeholder */${utils_1$9.newLine}`;
		else if (path$2.isAbsolute(globalTypesPath)) {
			let relativePath = path$2.relative(path$2.dirname(options.fileName), globalTypesPath);
			if (relativePath !== globalTypesPath && !relativePath.startsWith("./") && !relativePath.startsWith("../")) relativePath = "./" + relativePath;
			yield `/// <reference types="${relativePath}" />${utils_1$9.newLine}`;
		} else yield `/// <reference types="${globalTypesPath}" />${utils_1$9.newLine}`;
	}
	function* generateConstExport(options, block) {
		if (options.sfc.script) yield* (0, utils_1$9.generatePartiallyEnding)(options.sfc.script.name, options.scriptRanges?.exportDefault?.start ?? options.sfc.script.content.length, "#3632/script.vue");
		yield `const `;
		yield* (0, wrapWith_1.wrapWith)(0, block.content.length, block.name, codeFeatures_1.codeFeatures.doNotReportTs6133, `__VLS_export`);
		yield ` = `;
	}
	function* generateExportDefault(options) {
		if (options.sfc.script?.src) {
			yield* (0, src_1.generateSrc)(options.sfc.script.src);
			return;
		}
		let prefix$1;
		let suffix;
		if (options.sfc.script && options.scriptRanges?.exportDefault) {
			const { exportDefault, componentOptions } = options.scriptRanges;
			prefix$1 = (0, utils_1$9.generateSfcBlockSection)(options.sfc.script, exportDefault.start, (componentOptions ?? exportDefault).expression.start, codeFeatures_1.codeFeatures.all);
			suffix = (0, utils_1$9.generateSfcBlockSection)(options.sfc.script, (componentOptions ?? exportDefault).expression.end, options.sfc.script.content.length, codeFeatures_1.codeFeatures.all);
		} else {
			prefix$1 = `export default `;
			suffix = utils_1$9.endOfLine;
		}
		yield prefix$1;
		yield `{} as typeof __VLS_export`;
		yield suffix;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/parsers/utils.js
var require_utils$1 = __commonJS({ "node_modules/@vue/language-core/lib/parsers/utils.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseBindingRanges = parseBindingRanges;
	exports.getClosestMultiLineCommentRange = getClosestMultiLineCommentRange;
	const collectBindings_1$1 = require_collectBindings();
	const shared_1$5 = require_shared$1();
	function parseBindingRanges(ts, ast) {
		const bindings = [];
		ts.forEachChild(ast, (node) => {
			if (ts.isVariableStatement(node)) for (const decl of node.declarationList.declarations) {
				const ranges = (0, collectBindings_1$1.collectBindingRanges)(ts, decl.name, ast);
				bindings.push(...ranges.map((range$1) => ({ range: range$1 })));
			}
			else if (ts.isFunctionDeclaration(node)) {
				if (node.name && ts.isIdentifier(node.name)) bindings.push({ range: _getStartEnd(node.name) });
			} else if (ts.isClassDeclaration(node)) {
				if (node.name) bindings.push({ range: _getStartEnd(node.name) });
			} else if (ts.isEnumDeclaration(node)) bindings.push({ range: _getStartEnd(node.name) });
			if (ts.isImportDeclaration(node)) {
				const moduleName = _getNodeText(node.moduleSpecifier).slice(1, -1);
				if (node.importClause && !node.importClause.isTypeOnly) {
					const { name, namedBindings } = node.importClause;
					if (name) bindings.push({
						range: _getStartEnd(name),
						moduleName,
						isDefaultImport: true
					});
					if (namedBindings) if (ts.isNamedImports(namedBindings)) for (const element of namedBindings.elements) {
						if (element.isTypeOnly) continue;
						bindings.push({
							range: _getStartEnd(element.name),
							moduleName,
							isDefaultImport: element.propertyName?.text === "default"
						});
					}
					else bindings.push({
						range: _getStartEnd(namedBindings.name),
						moduleName,
						isNamespace: true
					});
				}
			}
		});
		return bindings;
		function _getStartEnd(node) {
			return (0, shared_1$5.getStartEnd)(ts, node, ast);
		}
		function _getNodeText(node) {
			return (0, shared_1$5.getNodeText)(ts, node, ast);
		}
	}
	function getClosestMultiLineCommentRange(ts, node, parents, ast) {
		for (let i = parents.length - 1; i >= 0; i--) {
			if (ts.isStatement(node)) break;
			node = parents[i];
		}
		const comment = ts.getLeadingCommentRanges(ast.text, node.pos)?.reverse().find((range$1) => range$1.kind === 3);
		if (comment) return {
			start: comment.pos,
			end: comment.end
		};
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/parsers/scriptRanges.js
var require_scriptRanges = __commonJS({ "node_modules/@vue/language-core/lib/parsers/scriptRanges.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseScriptRanges = parseScriptRanges;
	const shared_1$4 = require_shared$1();
	const utils_1$8 = require_utils$1();
	function parseScriptRanges(ts, ast, hasScriptSetup) {
		let exportDefault;
		let componentOptions;
		const bindings = hasScriptSetup ? (0, utils_1$8.parseBindingRanges)(ts, ast) : [];
		ts.forEachChild(ast, (raw$1) => {
			if (ts.isExportAssignment(raw$1)) {
				exportDefault = {
					..._getStartEnd(raw$1),
					expression: _getStartEnd(raw$1.expression)
				};
				const comment = (0, utils_1$8.getClosestMultiLineCommentRange)(ts, raw$1, [], ast);
				if (comment) exportDefault.start = comment.start;
				let node = raw$1;
				while (isAsExpression(node.expression) || ts.isParenthesizedExpression(node.expression)) node = node.expression;
				let obj;
				if (ts.isObjectLiteralExpression(node.expression)) obj = node.expression;
				else if (ts.isCallExpression(node.expression) && node.expression.arguments.length) {
					const arg0 = node.expression.arguments[0];
					if (ts.isObjectLiteralExpression(arg0)) obj = arg0;
				}
				if (obj) {
					let componentsOptionNode;
					let directivesOptionNode;
					let nameOptionNode;
					let inheritAttrsOption;
					ts.forEachChild(obj, (node$1) => {
						if (ts.isPropertyAssignment(node$1) && ts.isIdentifier(node$1.name)) {
							const name = _getNodeText(node$1.name);
							if (name === "components" && ts.isObjectLiteralExpression(node$1.initializer)) componentsOptionNode = node$1.initializer;
							else if (name === "directives" && ts.isObjectLiteralExpression(node$1.initializer)) directivesOptionNode = node$1.initializer;
							else if (name === "name") nameOptionNode = node$1.initializer;
							else if (name === "inheritAttrs") inheritAttrsOption = _getNodeText(node$1.initializer);
						}
					});
					componentOptions = {
						expression: _getStartEnd(node.expression),
						args: _getStartEnd(obj),
						argsNode: obj,
						components: componentsOptionNode ? _getStartEnd(componentsOptionNode) : void 0,
						componentsNode: componentsOptionNode,
						directives: directivesOptionNode ? _getStartEnd(directivesOptionNode) : void 0,
						name: nameOptionNode ? _getStartEnd(nameOptionNode) : void 0,
						inheritAttrs: inheritAttrsOption
					};
				}
			}
		});
		return {
			exportDefault,
			componentOptions,
			bindings
		};
		function _getStartEnd(node) {
			return (0, shared_1$4.getStartEnd)(ts, node, ast);
		}
		function _getNodeText(node) {
			return (0, shared_1$4.getNodeText)(ts, node, ast);
		}
		function isAsExpression(node) {
			return node.kind === ts.SyntaxKind.AsExpression;
		}
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/parsers/scriptSetupRanges.js
var require_scriptSetupRanges = __commonJS({ "node_modules/@vue/language-core/lib/parsers/scriptSetupRanges.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseScriptSetupRanges = parseScriptSetupRanges;
	const collectBindings_1 = require_collectBindings();
	const shared_1$3 = require_shared$1();
	const utils_1$7 = require_utils$1();
	const tsCheckReg = /^\/\/\s*@ts-(?:no)?check(?:$|\s)/;
	function parseScriptSetupRanges(ts, ast, vueCompilerOptions) {
		const defineModel = [];
		let defineProps;
		let withDefaults;
		let defineEmits;
		let defineSlots;
		let defineExpose;
		let defineOptions;
		const useAttrs = [];
		const useCssModule = [];
		const useSlots = [];
		const useTemplateRef = [];
		const text = ast.text;
		const leadingCommentRanges = ts.getLeadingCommentRanges(text, 0)?.reverse() ?? [];
		const leadingCommentEndOffset = leadingCommentRanges.find((range$1) => tsCheckReg.test(text.slice(range$1.pos, range$1.end)))?.end ?? 0;
		let bindings = (0, utils_1$7.parseBindingRanges)(ts, ast);
		let foundNonImportExportNode = false;
		let importSectionEndOffset = 0;
		ts.forEachChild(ast, (node) => {
			if (foundNonImportExportNode || ts.isImportDeclaration(node) || ts.isExportDeclaration(node) || ts.isEmptyStatement(node) || ts.isImportEqualsDeclaration(node)) return;
			if ((ts.isTypeAliasDeclaration(node) || ts.isInterfaceDeclaration(node)) && node.modifiers?.some((mod) => mod.kind === ts.SyntaxKind.ExportKeyword)) return;
			const commentRanges = ts.getLeadingCommentRanges(text, node.pos);
			if (commentRanges?.length) {
				const commentRange = commentRanges.sort((a, b) => a.pos - b.pos)[0];
				importSectionEndOffset = commentRange.pos;
			} else importSectionEndOffset = (0, shared_1$3.getStartEnd)(ts, node, ast).start;
			foundNonImportExportNode = true;
		});
		ts.forEachChild(ast, (node) => visitNode(node, [ast]));
		const templateRefNames = new Set(useTemplateRef.map((ref) => ref.name));
		bindings = bindings.filter(({ range: range$1 }) => {
			const name = text.slice(range$1.start, range$1.end);
			return !templateRefNames.has(name);
		});
		return {
			leadingCommentEndOffset,
			importSectionEndOffset,
			bindings,
			defineModel,
			defineProps,
			withDefaults,
			defineEmits,
			defineSlots,
			defineExpose,
			defineOptions,
			useAttrs,
			useCssModule,
			useSlots,
			useTemplateRef
		};
		function visitNode(node, parents) {
			const parent = parents[parents.length - 1];
			if (ts.isCallExpression(node) && ts.isIdentifier(node.expression)) {
				const callText = _getNodeText(node.expression);
				if (vueCompilerOptions.macros.defineModel.includes(callText)) {
					let localName;
					let propName;
					let options;
					let type;
					let modifierType;
					let runtimeType;
					let defaultValue;
					let required = false;
					if (ts.isVariableDeclaration(parent) && ts.isIdentifier(parent.name)) localName = _getStartEnd(parent.name);
					if (node.typeArguments) {
						if (node.typeArguments.length >= 1) type = _getStartEnd(node.typeArguments[0]);
						if (node.typeArguments.length >= 2) modifierType = _getStartEnd(node.typeArguments[1]);
					}
					if (node.arguments.length >= 2) {
						propName = node.arguments[0];
						options = node.arguments[1];
					} else if (node.arguments.length >= 1) if (ts.isStringLiteralLike(node.arguments[0])) propName = node.arguments[0];
					else options = node.arguments[0];
					if (options && ts.isObjectLiteralExpression(options)) for (const property of options.properties) {
						if (!ts.isPropertyAssignment(property) || !ts.isIdentifier(property.name)) continue;
						const text$1 = _getNodeText(property.name);
						if (text$1 === "type") runtimeType = _getStartEnd(property.initializer);
						else if (text$1 === "default") defaultValue = _getStartEnd(property.initializer);
						else if (text$1 === "required" && property.initializer.kind === ts.SyntaxKind.TrueKeyword) required = true;
					}
					let name;
					if (propName && ts.isStringLiteralLike(propName)) name = _getStartEnd(propName);
					defineModel.push({
						localName,
						name,
						type,
						modifierType,
						runtimeType,
						defaultValue,
						required,
						comments: (0, utils_1$7.getClosestMultiLineCommentRange)(ts, node, parents, ast),
						argNode: options
					});
				} else if (vueCompilerOptions.macros.defineProps.includes(callText)) {
					defineProps = {
						...parseCallExpressionAssignment(node, parent),
						statement: getStatementRange(ts, parents, node, ast),
						argNode: node.arguments[0]
					};
					if (ts.isVariableDeclaration(parent) && ts.isObjectBindingPattern(parent.name)) {
						defineProps.destructured = /* @__PURE__ */ new Map();
						const identifiers = (0, collectBindings_1.collectBindingIdentifiers)(ts, parent.name);
						for (const { id, isRest, initializer } of identifiers) {
							const name = _getNodeText(id);
							if (isRest) defineProps.destructuredRest = name;
							else defineProps.destructured.set(name, initializer);
						}
					} else if (ts.isCallExpression(parent) && vueCompilerOptions.macros.withDefaults.includes(_getNodeText(parent.expression))) {
						const grand = parents.at(-2);
						if (grand && ts.isVariableDeclaration(grand)) defineProps.name = _getNodeText(grand.name);
					}
				} else if (vueCompilerOptions.macros.withDefaults.includes(callText)) {
					const [, arg] = node.arguments;
					withDefaults = {
						callExp: _getStartEnd(node),
						exp: _getStartEnd(node.expression),
						arg: arg ? _getStartEnd(arg) : void 0,
						argNode: arg
					};
				} else if (vueCompilerOptions.macros.defineEmits.includes(callText)) {
					defineEmits = {
						...parseCallExpressionAssignment(node, parent),
						statement: getStatementRange(ts, parents, node, ast)
					};
					if (node.typeArguments?.length && ts.isTypeLiteralNode(node.typeArguments[0])) {
						for (const member of node.typeArguments[0].members) if (ts.isCallSignatureDeclaration(member)) {
							const type = member.parameters[0]?.type;
							if (type && ts.isUnionTypeNode(type)) {
								defineEmits.hasUnionTypeArg = true;
								break;
							}
						}
					}
				} else if (vueCompilerOptions.macros.defineSlots.includes(callText)) defineSlots = {
					...parseCallExpressionAssignment(node, parent),
					statement: getStatementRange(ts, parents, node, ast)
				};
				else if (vueCompilerOptions.macros.defineExpose.includes(callText)) defineExpose = parseCallExpression(node);
				else if (vueCompilerOptions.macros.defineOptions.includes(callText) && node.arguments.length && ts.isObjectLiteralExpression(node.arguments[0])) {
					defineOptions = {};
					const obj = node.arguments[0];
					for (const prop of obj.properties) if (ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name)) {
						const name = _getNodeText(prop.name);
						if (name === "inheritAttrs") defineOptions.inheritAttrs = _getNodeText(prop.initializer);
						else if (name === "name" && ts.isStringLiteral(prop.initializer)) defineOptions.name = prop.initializer.text;
					}
				} else if (vueCompilerOptions.composables.useAttrs.includes(callText)) useAttrs.push(parseCallExpression(node));
				else if (vueCompilerOptions.composables.useCssModule.includes(callText)) useCssModule.push(parseCallExpression(node));
				else if (vueCompilerOptions.composables.useSlots.includes(callText)) useSlots.push(parseCallExpression(node));
				else if (vueCompilerOptions.composables.useTemplateRef.includes(callText) && !node.typeArguments?.length) useTemplateRef.push(parseCallExpressionAssignment(node, parent));
			}
			ts.forEachChild(node, (child) => {
				if (ts.isFunctionLike(node)) return;
				parents.push(node);
				visitNode(child, parents);
				parents.pop();
			});
		}
		function parseCallExpression(node) {
			return {
				callExp: _getStartEnd(node),
				exp: _getStartEnd(node.expression),
				arg: node.arguments.length ? _getStartEnd(node.arguments[0]) : void 0,
				typeArg: node.typeArguments?.length ? _getStartEnd(node.typeArguments[0]) : void 0
			};
		}
		function parseCallExpressionAssignment(node, parent) {
			return {
				name: ts.isVariableDeclaration(parent) && ts.isIdentifier(parent.name) ? _getNodeText(parent.name) : void 0,
				...parseCallExpression(node)
			};
		}
		function _getStartEnd(node) {
			return (0, shared_1$3.getStartEnd)(ts, node, ast);
		}
		function _getNodeText(node) {
			return (0, shared_1$3.getNodeText)(ts, node, ast);
		}
	}
	function getStatementRange(ts, parents, node, ast) {
		let statementRange;
		for (let i = parents.length - 1; i >= 0; i--) {
			const statement = parents[i];
			if (ts.isStatement(statement)) {
				ts.forEachChild(statement, (child) => {
					const range$1 = (0, shared_1$3.getStartEnd)(ts, child, ast);
					statementRange ??= range$1;
					statementRange.end = range$1.end;
				});
				break;
			}
		}
		if (!statementRange) statementRange = (0, shared_1$3.getStartEnd)(ts, node, ast);
		return statementRange;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/parsers/vueCompilerOptions.js
var require_vueCompilerOptions = __commonJS({ "node_modules/@vue/language-core/lib/parsers/vueCompilerOptions.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseVueCompilerOptions = parseVueCompilerOptions;
	const syntaxReg = /^\s*@(?<key>.+?)\s+(?<value>.+?)\s*$/m;
	function parseVueCompilerOptions(comments) {
		const entries = comments.map((text) => {
			try {
				const match = text.match(syntaxReg);
				if (match) {
					const { key, value } = match.groups ?? {};
					return [key, JSON.parse(value)];
				}
			} catch {}
		}).filter((item) => !!item);
		if (entries.length) return Object.fromEntries(entries);
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins/vue-tsx.js
var require_vue_tsx = __commonJS({ "node_modules/@vue/language-core/lib/plugins/vue-tsx.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.tsCodegen = void 0;
	const shared_1$2 = require_shared$2();
	const alien_signals_1$3 = require_cjs();
	const path$1 = require_path_browserify();
	const script_1 = require_script();
	const template_1 = require_template$1();
	const compilerOptions_1 = require_compilerOptions();
	const scriptRanges_1 = require_scriptRanges();
	const scriptSetupRanges_1 = require_scriptSetupRanges();
	const vueCompilerOptions_1 = require_vueCompilerOptions();
	const signals_1 = require_signals();
	exports.tsCodegen = /* @__PURE__ */ new WeakMap();
	const validLangs = new Set([
		"js",
		"jsx",
		"ts",
		"tsx"
	]);
	const plugin = (ctx) => {
		return {
			version: 2.2,
			requiredCompilerOptions: ["noPropertyAccessFromIndexSignature", "exactOptionalPropertyTypes"],
			getEmbeddedCodes(fileName, sfc) {
				const codegen = useCodegen(fileName, sfc);
				return [{
					id: "script_" + codegen.getLang(),
					lang: codegen.getLang()
				}];
			},
			resolveEmbeddedCode(fileName, sfc, embeddedFile) {
				if (/script_(js|jsx|ts|tsx)/.test(embeddedFile.id)) {
					const codegen = useCodegen(fileName, sfc);
					const tsx = codegen.getGeneratedScript();
					embeddedFile.content = [...tsx.codes];
				}
			}
		};
		function useCodegen(fileName, sfc) {
			if (!exports.tsCodegen.has(sfc)) exports.tsCodegen.set(sfc, createTsx(fileName, sfc, ctx));
			return exports.tsCodegen.get(sfc);
		}
	};
	exports.default = plugin;
	function createTsx(fileName, sfc, ctx) {
		const ts = ctx.modules.typescript;
		const getRawLang = (0, alien_signals_1$3.computed)(() => {
			if (sfc.script && sfc.scriptSetup) if (sfc.scriptSetup.lang !== "js") return sfc.scriptSetup.lang;
			else return sfc.script.lang;
			return sfc.scriptSetup?.lang ?? sfc.script?.lang;
		});
		const getLang = (0, alien_signals_1$3.computed)(() => {
			const rawLang = getRawLang();
			if (rawLang && validLangs.has(rawLang)) return rawLang;
			return "ts";
		});
		const getResolvedOptions = (0, alien_signals_1$3.computed)(() => {
			const options = (0, vueCompilerOptions_1.parseVueCompilerOptions)(sfc.comments);
			if (options) {
				const resolver = new compilerOptions_1.CompilerOptionsResolver();
				resolver.addConfig(options, path$1.dirname(fileName));
				return resolver.build(ctx.vueCompilerOptions);
			}
			return ctx.vueCompilerOptions;
		});
		const getScriptRanges = (0, alien_signals_1$3.computed)(() => sfc.script && validLangs.has(sfc.script.lang) ? (0, scriptRanges_1.parseScriptRanges)(ts, sfc.script.ast, !!sfc.scriptSetup) : void 0);
		const getScriptSetupRanges = (0, alien_signals_1$3.computed)(() => sfc.scriptSetup && validLangs.has(sfc.scriptSetup.lang) ? (0, scriptSetupRanges_1.parseScriptSetupRanges)(ts, sfc.scriptSetup.ast, getResolvedOptions()) : void 0);
		const getSetupBindingNames = (0, signals_1.computedSet)(() => {
			const newNames = /* @__PURE__ */ new Set();
			const bindings = getScriptSetupRanges()?.bindings;
			if (sfc.scriptSetup && bindings) for (const { range: range$1 } of bindings) newNames.add(sfc.scriptSetup.content.slice(range$1.start, range$1.end));
			return newNames;
		});
		const getSetupImportComponentNames = (0, signals_1.computedSet)(() => {
			const newNames = /* @__PURE__ */ new Set();
			const bindings = getScriptSetupRanges()?.bindings;
			if (sfc.scriptSetup && bindings) {
				for (const { range: range$1, moduleName, isDefaultImport, isNamespace } of bindings) if (moduleName && isDefaultImport && !isNamespace && ctx.vueCompilerOptions.extensions.some((ext) => moduleName.endsWith(ext))) newNames.add(sfc.scriptSetup.content.slice(range$1.start, range$1.end));
			}
			return newNames;
		});
		const getSetupDestructuredPropNames = (0, signals_1.computedSet)(() => {
			const newNames = new Set(getScriptSetupRanges()?.defineProps?.destructured?.keys());
			const rest = getScriptSetupRanges()?.defineProps?.destructuredRest;
			if (rest) newNames.add(rest);
			return newNames;
		});
		const getSetupTemplateRefNames = (0, signals_1.computedSet)(() => {
			const newNames = new Set(getScriptSetupRanges()?.useTemplateRef.map(({ name }) => name).filter((name) => name !== void 0));
			return newNames;
		});
		const setupHasDefineSlots = (0, alien_signals_1$3.computed)(() => !!getScriptSetupRanges()?.defineSlots);
		const getSetupPropsAssignName = (0, alien_signals_1$3.computed)(() => getScriptSetupRanges()?.defineProps?.name);
		const getSetupSlotsAssignName = (0, alien_signals_1$3.computed)(() => getScriptSetupRanges()?.defineSlots?.name);
		const getSetupInheritAttrs = (0, alien_signals_1$3.computed)(() => {
			const value = getScriptSetupRanges()?.defineOptions?.inheritAttrs ?? getScriptRanges()?.componentOptions?.inheritAttrs;
			return value !== "false";
		});
		const getComponentSelfName = (0, alien_signals_1$3.computed)(() => {
			let name;
			const { componentOptions } = getScriptRanges() ?? {};
			if (sfc.script && componentOptions?.name) name = sfc.script.content.slice(componentOptions.name.start + 1, componentOptions.name.end - 1);
			else {
				const { defineOptions } = getScriptSetupRanges() ?? {};
				if (sfc.scriptSetup && defineOptions?.name) name = defineOptions.name;
				else {
					const baseName = path$1.basename(fileName);
					name = baseName.slice(0, baseName.lastIndexOf("."));
				}
			}
			return (0, shared_1$2.capitalize)((0, shared_1$2.camelize)(name));
		});
		const getGeneratedTemplate = (0, alien_signals_1$3.computed)(() => {
			if (getResolvedOptions().skipTemplateCodegen || !sfc.template) return;
			return (0, template_1.generateTemplate)({
				ts,
				compilerOptions: ctx.compilerOptions,
				vueCompilerOptions: getResolvedOptions(),
				template: sfc.template,
				scriptSetupBindingNames: getSetupBindingNames(),
				scriptSetupImportComponentNames: getSetupImportComponentNames(),
				destructuredPropNames: getSetupDestructuredPropNames(),
				templateRefNames: getSetupTemplateRefNames(),
				hasDefineSlots: setupHasDefineSlots(),
				propsAssignName: getSetupPropsAssignName(),
				slotsAssignName: getSetupSlotsAssignName(),
				inheritAttrs: getSetupInheritAttrs(),
				selfComponentName: getComponentSelfName()
			});
		});
		const getGeneratedScript = (0, alien_signals_1$3.computed)(() => {
			return (0, script_1.generateScript)({
				ts,
				compilerOptions: ctx.compilerOptions,
				vueCompilerOptions: getResolvedOptions(),
				sfc,
				fileName,
				lang: getLang(),
				scriptRanges: getScriptRanges(),
				scriptSetupRanges: getScriptSetupRanges(),
				templateCodegen: getGeneratedTemplate(),
				destructuredPropNames: getSetupDestructuredPropNames(),
				templateRefNames: getSetupTemplateRefNames()
			});
		});
		return {
			getLang,
			getScriptRanges,
			getScriptSetupRanges,
			getSetupSlotsAssignName,
			getGeneratedScript,
			getGeneratedTemplate
		};
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/types.js
var require_types = __commonJS({ "node_modules/@vue/language-core/lib/types.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validVersions = void 0;
	exports.validVersions = [
		2,
		2.1,
		2.2
	];
} });

//#endregion
//#region node_modules/@vue/language-core/lib/plugins.js
var require_plugins = __commonJS({ "node_modules/@vue/language-core/lib/plugins.js"(exports) {
	var __createBinding$1 = void 0 && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	});
	var __exportStar$1 = void 0 && (void 0).__exportStar || function(m, exports$1) {
		for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$1(exports$1, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createPlugins = createPlugins;
	const file_html_1 = require_file_html();
	const file_md_1 = require_file_md();
	const file_vue_1 = require_file_vue();
	const vue_root_tags_1 = require_vue_root_tags();
	const vue_script_js_1 = require_vue_script_js();
	const vue_sfc_customblocks_1 = require_vue_sfc_customblocks();
	const vue_sfc_scripts_1 = require_vue_sfc_scripts();
	const vue_sfc_styles_1 = require_vue_sfc_styles();
	const vue_sfc_template_1 = require_vue_sfc_template();
	const vue_style_css_1 = require_vue_style_css();
	const vue_template_html_1 = require_vue_template_html();
	const vue_template_inline_css_1 = require_vue_template_inline_css();
	const vue_template_inline_ts_1 = require_vue_template_inline_ts();
	const vue_tsx_1$1 = require_vue_tsx();
	const types_1 = require_types();
	__exportStar$1(require_shared(), exports);
	function createPlugins(pluginContext) {
		const plugins = [
			file_vue_1.default,
			file_md_1.default,
			file_html_1.default,
			vue_root_tags_1.default,
			vue_script_js_1.default,
			vue_style_css_1.default,
			vue_template_html_1.default,
			vue_template_inline_css_1.default,
			vue_template_inline_ts_1.default,
			vue_sfc_styles_1.default,
			vue_sfc_customblocks_1.default,
			vue_sfc_scripts_1.default,
			vue_sfc_template_1.default,
			vue_tsx_1$1.default,
			...pluginContext.vueCompilerOptions.plugins
		];
		const pluginInstances = plugins.flatMap((plugin$14) => {
			try {
				const instance = plugin$14(pluginContext);
				const moduleName = plugin$14.__moduleName;
				if (Array.isArray(instance)) for (let i = 0; i < instance.length; i++) instance[i].name ??= `${moduleName} (${i})`;
				else instance.name ??= moduleName;
				return instance;
			} catch (err) {
				console.warn("[Vue] Failed to create plugin", err);
			}
		}).filter((plugin$14) => !!plugin$14).sort((a, b) => {
			const aOrder = a.order ?? 0;
			const bOrder = b.order ?? 0;
			return aOrder - bOrder;
		});
		return pluginInstances.filter((plugin$14) => {
			if (!types_1.validVersions.includes(plugin$14.version)) {
				console.warn(`[Vue] Plugin ${plugin$14.name} is not compatible with the current Vue language tools version. (version: ${plugin$14.version}, supported versions: ${JSON.stringify(types_1.validVersions)})`);
				return false;
			}
			return true;
		});
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/virtualFile/embeddedFile.js
var require_embeddedFile = __commonJS({ "node_modules/@vue/language-core/lib/virtualFile/embeddedFile.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.VueEmbeddedCode = void 0;
	var VueEmbeddedCode = class {
		constructor(id, lang, content) {
			this.id = id;
			this.lang = lang;
			this.content = content;
			this.linkedCodeMappings = [];
			this.embeddedCodes = [];
		}
	};
	exports.VueEmbeddedCode = VueEmbeddedCode;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/virtualFile/computedEmbeddedCodes.js
var require_computedEmbeddedCodes = __commonJS({ "node_modules/@vue/language-core/lib/virtualFile/computedEmbeddedCodes.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.computedEmbeddedCodes = computedEmbeddedCodes;
	exports.resolveCommonLanguageId = resolveCommonLanguageId;
	const alien_signals_1$2 = require_cjs();
	const muggle_string_1 = require_out();
	const buildMappings_1 = require_buildMappings();
	const embeddedFile_1 = require_embeddedFile();
	function computedEmbeddedCodes(plugins, fileName, sfc) {
		const getNameToBlockMap = (0, alien_signals_1$2.computed)(() => {
			const blocks = {};
			if (sfc.template) blocks[sfc.template.name] = sfc.template;
			if (sfc.script) blocks[sfc.script.name] = sfc.script;
			if (sfc.scriptSetup) blocks[sfc.scriptSetup.name] = sfc.scriptSetup;
			for (const block of sfc.styles) blocks[block.name] = block;
			for (const block of sfc.customBlocks) blocks[block.name] = block;
			return blocks;
		});
		const getPluginsResult = plugins.map((plugin$14) => computedPluginEmbeddedCodes(plugins, plugin$14, fileName, sfc, (name) => getNameToBlockMap()[name]));
		const getFlatResult = (0, alien_signals_1$2.computed)(() => getPluginsResult.map((r) => r()).flat());
		const getStructuredResult = (0, alien_signals_1$2.computed)(() => {
			const embeddedCodes = [];
			let remain = [...getFlatResult()];
			while (remain.length) {
				const beforeLength = remain.length;
				consumeRemain();
				if (beforeLength === remain.length) break;
			}
			for (const { code: code$1 } of remain) console.error("Unable to resolve embedded: " + code$1.parentCodeId + " -> " + code$1.id);
			return embeddedCodes;
			function consumeRemain() {
				for (let i = remain.length - 1; i >= 0; i--) {
					const { code: code$1, snapshot, mappings } = remain[i];
					if (!code$1.parentCodeId) {
						embeddedCodes.push({
							id: code$1.id,
							languageId: resolveCommonLanguageId(code$1.lang),
							linkedCodeMappings: code$1.linkedCodeMappings,
							snapshot,
							mappings,
							embeddedCodes: []
						});
						remain.splice(i, 1);
					} else {
						const parent = findParentStructure(code$1.parentCodeId, embeddedCodes);
						if (parent) {
							parent.embeddedCodes ??= [];
							parent.embeddedCodes.push({
								id: code$1.id,
								languageId: resolveCommonLanguageId(code$1.lang),
								linkedCodeMappings: code$1.linkedCodeMappings,
								snapshot,
								mappings,
								embeddedCodes: []
							});
							remain.splice(i, 1);
						}
					}
				}
			}
			function findParentStructure(id, current) {
				for (const child of current) {
					if (child.id === id) return child;
					let parent = findParentStructure(id, child.embeddedCodes ?? []);
					if (parent) return parent;
				}
			}
		});
		return getStructuredResult;
	}
	function computedPluginEmbeddedCodes(plugins, plugin$14, fileName, sfc, getBlockByName) {
		const computeds = /* @__PURE__ */ new Map();
		const getComputedKey = (code$1) => code$1.id + "__" + code$1.lang;
		const getCodes = (0, alien_signals_1$2.computed)(() => {
			try {
				if (!plugin$14.getEmbeddedCodes) return [...computeds.values()];
				const embeddedCodeInfos = plugin$14.getEmbeddedCodes(fileName, sfc);
				for (const oldId of computeds.keys()) if (!embeddedCodeInfos.some((code$1) => getComputedKey(code$1) === oldId)) computeds.delete(oldId);
				for (const codeInfo of embeddedCodeInfos) if (!computeds.has(getComputedKey(codeInfo))) computeds.set(getComputedKey(codeInfo), (0, alien_signals_1$2.computed)(() => {
					const content = [];
					const code$1 = new embeddedFile_1.VueEmbeddedCode(codeInfo.id, codeInfo.lang, content);
					for (const plugin$15 of plugins) {
						if (!plugin$15.resolveEmbeddedCode) continue;
						try {
							plugin$15.resolveEmbeddedCode(fileName, sfc, code$1);
						} catch (e) {
							console.error(e);
						}
					}
					const newText = (0, muggle_string_1.toString)(code$1.content);
					const changeRanges = /* @__PURE__ */ new Map();
					const snapshot = {
						getText: (start, end) => newText.slice(start, end),
						getLength: () => newText.length,
						getChangeRange(oldSnapshot) {
							if (!changeRanges.has(oldSnapshot)) {
								changeRanges.set(oldSnapshot, void 0);
								const oldText = oldSnapshot.getText(0, oldSnapshot.getLength());
								const changeRange = fullDiffTextChangeRange(oldText, newText);
								if (changeRange) changeRanges.set(oldSnapshot, changeRange);
							}
							return changeRanges.get(oldSnapshot);
						}
					};
					return {
						code: code$1,
						snapshot
					};
				}));
			} catch (e) {
				console.error(e);
			}
			return [...computeds.values()];
		});
		return (0, alien_signals_1$2.computed)(() => {
			return getCodes().map((_file) => {
				const { code: code$1, snapshot } = _file();
				const mappings = (0, buildMappings_1.buildMappings)(code$1.content.map((segment) => {
					if (typeof segment === "string") return segment;
					const source = segment[1];
					if (source === void 0) return segment;
					const block = getBlockByName(source);
					if (!block) return segment;
					return [
						segment[0],
						void 0,
						segment[2] + block.startTagEnd,
						segment[3]
					];
				}));
				const newMappings = [];
				const tokenMappings = /* @__PURE__ */ new Map();
				for (let i = 0; i < mappings.length; i++) {
					const mapping = mappings[i];
					if (mapping.data.__combineOffset !== void 0) {
						const offsetMapping = mappings[i - mapping.data.__combineOffset];
						if (typeof offsetMapping === "string" || !offsetMapping) throw new Error("Invalid offset mapping, mappings: " + mappings.length + ", i: " + i + ", offset: " + mapping.data.__combineOffset);
						offsetMapping.sourceOffsets.push(...mapping.sourceOffsets);
						offsetMapping.generatedOffsets.push(...mapping.generatedOffsets);
						offsetMapping.lengths.push(...mapping.lengths);
						continue;
					}
					if (mapping.data.__linkedToken !== void 0) {
						const token = mapping.data.__linkedToken;
						if (tokenMappings.has(token)) {
							const prevMapping = tokenMappings.get(token);
							code$1.linkedCodeMappings.push({
								sourceOffsets: [prevMapping.generatedOffsets[0]],
								generatedOffsets: [mapping.generatedOffsets[0]],
								lengths: [Number(token.description)],
								data: void 0
							});
						} else tokenMappings.set(token, mapping);
						continue;
					}
					newMappings.push(mapping);
				}
				return {
					code: code$1,
					snapshot,
					mappings: newMappings
				};
			});
		});
	}
	function fullDiffTextChangeRange(oldText, newText) {
		for (let start = 0; start < oldText.length && start < newText.length; start++) if (oldText[start] !== newText[start]) {
			let end = oldText.length;
			for (let i = 0; i < oldText.length - start && i < newText.length - start; i++) {
				if (oldText[oldText.length - i - 1] !== newText[newText.length - i - 1]) break;
				end--;
			}
			let length = end - start;
			let newLength = length + (newText.length - oldText.length);
			if (newLength < 0) {
				length -= newLength;
				newLength = 0;
			}
			return {
				span: {
					start,
					length
				},
				newLength
			};
		}
	}
	function resolveCommonLanguageId(lang) {
		switch (lang) {
			case "js": return "javascript";
			case "cjs": return "javascript";
			case "mjs": return "javascript";
			case "ts": return "typescript";
			case "cts": return "typescript";
			case "mts": return "typescript";
			case "jsx": return "javascriptreact";
			case "tsx": return "typescriptreact";
			case "pug": return "jade";
			case "md": return "markdown";
		}
		return lang;
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/virtualFile/computedVueSfc.js
var require_computedVueSfc = __commonJS({ "node_modules/@vue/language-core/lib/virtualFile/computedVueSfc.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.computedVueSfc = computedVueSfc;
	const alien_signals_1$1 = require_cjs();
	function computedVueSfc(plugins, fileName, languageId, getSnapshot) {
		let cache;
		return (0, alien_signals_1$1.computed)(() => {
			if (cache?.plugin.updateSFC) {
				const change = getSnapshot().getChangeRange(cache.snapshot);
				if (change) {
					const newSfc = cache.plugin.updateSFC(cache.sfc, {
						start: change.span.start,
						end: change.span.start + change.span.length,
						newText: getSnapshot().getText(change.span.start, change.span.start + change.newLength)
					});
					if (newSfc) {
						cache.snapshot = getSnapshot();
						cache.sfc = JSON.parse(JSON.stringify(newSfc));
						return cache.sfc;
					}
				}
			}
			for (const plugin$14 of plugins) {
				const sfc = plugin$14.parseSFC?.(fileName, getSnapshot().getText(0, getSnapshot().getLength())) ?? plugin$14.parseSFC2?.(fileName, languageId, getSnapshot().getText(0, getSnapshot().getLength()));
				if (sfc) {
					if (!sfc.errors.length) cache = {
						snapshot: getSnapshot(),
						sfc,
						plugin: plugin$14
					};
					return sfc;
				}
			}
		});
	}
} });

//#endregion
//#region node_modules/@vue/language-core/lib/virtualFile/vueFile.js
var require_vueFile = __commonJS({ "node_modules/@vue/language-core/lib/virtualFile/vueFile.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.VueVirtualCode = void 0;
	const alien_signals_1 = require_cjs();
	const plugins_1$1 = require_plugins();
	const computedEmbeddedCodes_1 = require_computedEmbeddedCodes();
	const computedSfc_1 = require_computedSfc();
	const computedVueSfc_1 = require_computedVueSfc();
	var VueVirtualCode = class {
		get snapshot() {
			return this._snapshot();
		}
		get vueSfc() {
			return this._vueSfc();
		}
		get embeddedCodes() {
			return this._embeddedCodes();
		}
		get mappings() {
			return this._mappings();
		}
		constructor(fileName, languageId, initSnapshot, vueCompilerOptions, plugins, ts) {
			this.fileName = fileName;
			this.languageId = languageId;
			this.initSnapshot = initSnapshot;
			this.vueCompilerOptions = vueCompilerOptions;
			this.plugins = plugins;
			this.ts = ts;
			this.id = "main";
			this._snapshot = (0, alien_signals_1.signal)(initSnapshot);
			this._vueSfc = (0, computedVueSfc_1.computedVueSfc)(this.plugins, this.fileName, this.languageId, this._snapshot);
			this.sfc = (0, computedSfc_1.computedSfc)(this.ts, this.plugins, this.fileName, this._snapshot, this._vueSfc);
			this._embeddedCodes = (0, computedEmbeddedCodes_1.computedEmbeddedCodes)(this.plugins, this.fileName, this.sfc);
			this._mappings = (0, alien_signals_1.computed)(() => {
				const snapshot = this._snapshot();
				return [{
					sourceOffsets: [0],
					generatedOffsets: [0],
					lengths: [snapshot.getLength()],
					data: plugins_1$1.allCodeFeatures
				}];
			});
		}
		update(newSnapshot) {
			this._snapshot(newSnapshot);
		}
	};
	exports.VueVirtualCode = VueVirtualCode;
} });

//#endregion
//#region node_modules/@vue/language-core/lib/languagePlugin.js
var require_languagePlugin = __commonJS({ "node_modules/@vue/language-core/lib/languagePlugin.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createVueLanguagePlugin = createVueLanguagePlugin;
	exports.getAllExtensions = getAllExtensions;
	const language_core_1$4 = require_language_core$1();
	const CompilerDOM = require_compiler_dom();
	const plugins_1 = require_plugins();
	const vueFile_1 = require_vueFile();
	const fileRegistries = [];
	function getVueFileRegistry(key, plugins) {
		let fileRegistry = fileRegistries.find((r) => r.key === key && r.plugins.length === plugins.length && r.plugins.every((plugin$14) => plugins.includes(plugin$14)))?.files;
		if (!fileRegistry) {
			fileRegistry = /* @__PURE__ */ new Map();
			fileRegistries.push({
				key,
				plugins,
				files: fileRegistry
			});
		}
		return fileRegistry;
	}
	function getFileRegistryKey(compilerOptions, vueCompilerOptions, plugins) {
		const values = [...Object.keys(vueCompilerOptions).sort().filter((key) => key !== "plugins").map((key) => [key, vueCompilerOptions[key]]), [...new Set(plugins.map((plugin$14) => plugin$14.requiredCompilerOptions ?? []).flat())].sort().map((key) => [key, compilerOptions[key]])];
		return JSON.stringify(values);
	}
	function createVueLanguagePlugin(ts, compilerOptions, vueCompilerOptions, asFileName) {
		const pluginContext = {
			modules: {
				"@vue/compiler-dom": CompilerDOM,
				typescript: ts
			},
			compilerOptions,
			vueCompilerOptions
		};
		const plugins = (0, plugins_1.createPlugins)(pluginContext);
		const fileRegistry = getVueFileRegistry(getFileRegistryKey(compilerOptions, vueCompilerOptions, plugins), vueCompilerOptions.plugins);
		return {
			getLanguageId(scriptId) {
				const fileName = asFileName(scriptId);
				for (const plugin$14 of plugins) {
					const languageId = plugin$14.getLanguageId?.(fileName);
					if (languageId) return languageId;
				}
			},
			createVirtualCode(scriptId, languageId, snapshot) {
				const fileName = asFileName(scriptId);
				if (plugins.some((plugin$14) => plugin$14.isValidFile?.(fileName, languageId))) {
					const code$1 = fileRegistry.get(fileName);
					if (code$1) {
						code$1.update(snapshot);
						return code$1;
					} else {
						const code$2 = new vueFile_1.VueVirtualCode(fileName, languageId, snapshot, vueCompilerOptions, plugins, ts);
						fileRegistry.set(fileName, code$2);
						return code$2;
					}
				}
			},
			updateVirtualCode(_fileId, code$1, snapshot) {
				code$1.update(snapshot);
				return code$1;
			},
			typescript: {
				extraFileExtensions: getAllExtensions(vueCompilerOptions).map((ext) => ({
					extension: ext.slice(1),
					isMixedContent: true,
					scriptKind: 7
				})),
				getServiceScript(root) {
					for (const code$1 of (0, language_core_1$4.forEachEmbeddedCode)(root)) if (/script_(js|jsx|ts|tsx)/.test(code$1.id)) {
						const lang = code$1.id.slice(7);
						return {
							code: code$1,
							extension: "." + lang,
							scriptKind: lang === "js" ? ts.ScriptKind.JS : lang === "jsx" ? ts.ScriptKind.JSX : lang === "tsx" ? ts.ScriptKind.TSX : ts.ScriptKind.TS
						};
					}
				}
			}
		};
	}
	function getAllExtensions(options) {
		return [...new Set([
			"extensions",
			"vitePressExtensions",
			"petiteVueExtensions"
		].flatMap((key) => options[key]))];
	}
} });

//#endregion
//#region node_modules/@vue/language-core/index.js
var require_language_core = __commonJS({ "node_modules/@vue/language-core/index.js"(exports) {
	var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	});
	var __exportStar = void 0 && (void 0).__exportStar || function(m, exports$1) {
		for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.tsCodegen = void 0;
	__exportStar(require_globalTypes(), exports);
	__exportStar(require_template$1(), exports);
	__exportStar(require_compilerOptions(), exports);
	__exportStar(require_languagePlugin(), exports);
	__exportStar(require_scriptSetupRanges(), exports);
	__exportStar(require_plugins(), exports);
	__exportStar(require_types(), exports);
	__exportStar(require_collectBindings(), exports);
	__exportStar(require_parseSfc(), exports);
	__exportStar(require_shared$1(), exports);
	__exportStar(require_vueFile(), exports);
	var vue_tsx_1 = require_vue_tsx();
	Object.defineProperty(exports, "tsCodegen", {
		enumerable: true,
		get: function() {
			return vue_tsx_1.tsCodegen;
		}
	});
	__exportStar(require_language_core$1(), exports);
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/lib/common.js
var require_common = __commonJS({ "node_modules/@vue/typescript-plugin/lib/common.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createVueLanguageServiceProxy = createVueLanguageServiceProxy;
	const language_core_1$3 = require_language_core();
	const shared_1$1 = require_shared$2();
	const windowsPathReg = /\\/g;
	function createVueLanguageServiceProxy(ts, language, languageService, vueOptions, asScriptId) {
		const proxyCache = /* @__PURE__ */ new Map();
		const getProxyMethod = (target, p) => {
			switch (p) {
				case "getCompletionsAtPosition": return getCompletionsAtPosition(ts, language, asScriptId, vueOptions, target[p]);
				case "getCompletionEntryDetails": return getCompletionEntryDetails(language, target[p]);
				case "getCodeFixesAtPosition": return getCodeFixesAtPosition(target[p]);
				case "getDefinitionAndBoundSpan": return getDefinitionAndBoundSpan(ts, language, asScriptId, languageService, vueOptions, target[p]);
			}
		};
		return new Proxy(languageService, {
			get(target, p, receiver) {
				if (!proxyCache.has(p)) proxyCache.set(p, getProxyMethod(target, p));
				const proxyMethod = proxyCache.get(p);
				if (proxyMethod) return proxyMethod;
				return Reflect.get(target, p, receiver);
			},
			set(target, p, value, receiver) {
				return Reflect.set(target, p, value, receiver);
			}
		});
	}
	function getCompletionsAtPosition(ts, language, asScriptId, vueOptions, getCompletionsAtPosition$2) {
		return (filePath, position, options, formattingSettings) => {
			const fileName = filePath.replace(windowsPathReg, "/");
			const result = getCompletionsAtPosition$2(fileName, position, options, formattingSettings);
			if (result) {
				result.entries = result.entries.filter((entry) => !entry.name.includes("__VLS_") && !entry.labelDetails?.description?.includes("__VLS_"));
				const sourceScript = language.scripts.get(asScriptId(fileName));
				const root = sourceScript?.generated?.root;
				if (root instanceof language_core_1$3.VueVirtualCode) {
					const blocks = [root.sfc.template, ...root.sfc.styles];
					const ranges = blocks.filter(Boolean).map((block) => [block.startTagEnd, block.endTagStart]);
					if (ranges.some(([start, end]) => position >= start && position <= end)) {
						const globalKinds = new Set([
							"var",
							"function",
							"module"
						]);
						const globalsOrKeywords = ts.Completions.SortText.GlobalsOrKeywords;
						const sortTexts = new Set([
							globalsOrKeywords,
							"z" + globalsOrKeywords,
							globalsOrKeywords + "1"
						]);
						result.entries = result.entries.filter((entry) => !(entry.kind === "const" && entry.name in vueOptions.macros) && (!globalKinds.has(entry.kind) || !sortTexts.has(entry.sortText) || (0, shared_1$1.isGloballyAllowed)(entry.name)));
					}
				}
				for (const item of result.entries) if (item.source) {
					const originalName = item.name;
					for (const vueExt of vueOptions.extensions) {
						const suffix = (0, shared_1$1.capitalize)(vueExt.slice(1));
						if (item.source.endsWith(vueExt) && item.name.endsWith(suffix)) {
							item.name = (0, shared_1$1.capitalize)(item.name.slice(0, -suffix.length));
							if (item.insertText) item.insertText = item.insertText.replace(`${suffix}$1`, "$1");
							if (item.data) item.data.__isComponentAutoImport = {
								ext: vueExt,
								suffix,
								originalName,
								newName: item.insertText
							};
							break;
						}
					}
					if (item.data) item.data.__isAutoImport = { fileName };
				}
			}
			return result;
		};
	}
	function getCompletionEntryDetails(language, getCompletionEntryDetails$2) {
		return (...args) => {
			const details = getCompletionEntryDetails$2(...args);
			if (args[6]?.__isComponentAutoImport) {
				const { originalName, newName } = args[6].__isComponentAutoImport;
				for (const codeAction of details?.codeActions ?? []) for (const change of codeAction.changes) for (const textChange of change.textChanges) textChange.newText = textChange.newText.replace("import " + originalName + " from ", "import " + newName + " from ");
			}
			if (args[6]?.__isAutoImport) {
				const { fileName } = args[6].__isAutoImport;
				const sourceScript = language.scripts.get(fileName);
				if (sourceScript?.generated?.root instanceof language_core_1$3.VueVirtualCode) {
					const { vueSfc } = sourceScript.generated.root;
					if (!vueSfc?.descriptor.script && !vueSfc?.descriptor.scriptSetup) for (const codeAction of details?.codeActions ?? []) {
						for (const change of codeAction.changes) {
							for (const textChange of change.textChanges) {
								textChange.newText = `<script setup lang="ts">${textChange.newText}</script>\n\n`;
								break;
							}
							break;
						}
						break;
					}
				}
			}
			return details;
		};
	}
	function getCodeFixesAtPosition(getCodeFixesAtPosition$2) {
		return (...args) => {
			let result = getCodeFixesAtPosition$2(...args);
			result = result.filter((entry) => !entry.description.includes("__VLS_"));
			return result;
		};
	}
	function getDefinitionAndBoundSpan(ts, language, asScriptId, languageService, vueOptions, getDefinitionAndBoundSpan$2) {
		return (fileName, position) => {
			const result = getDefinitionAndBoundSpan$2(fileName, position);
			if (!result?.definitions?.length) return result;
			const program = languageService.getProgram();
			const sourceScript = language.scripts.get(asScriptId(fileName));
			if (!sourceScript?.generated) return result;
			const root = sourceScript.generated.root;
			if (!(root instanceof language_core_1$3.VueVirtualCode)) return result;
			if (!root.sfc.template || position < root.sfc.template.startTagEnd || position > root.sfc.template.endTagStart) return result;
			const definitions = new Set(result.definitions);
			const skippedDefinitions = [];
			if (result.definitions.length >= 2) {
				for (const definition of result.definitions) if (root.sfc.content[definition.textSpan.start - 1] === "@" || root.sfc.content.slice(definition.textSpan.start - 5, definition.textSpan.start) === "v-on:") skippedDefinitions.push(definition);
			}
			for (const definition of result.definitions) {
				if (vueOptions.extensions.some((ext) => definition.fileName.endsWith(ext))) continue;
				const sourceFile = program.getSourceFile(definition.fileName);
				if (!sourceFile) continue;
				visit(sourceFile, definition, sourceFile);
			}
			for (const definition of skippedDefinitions) definitions.delete(definition);
			return {
				definitions: [...definitions],
				textSpan: result.textSpan
			};
			function visit(node, definition, sourceFile) {
				if (ts.isPropertySignature(node) && node.type) proxy(node.name, node.type, definition, sourceFile);
				else if (ts.isVariableDeclaration(node) && ts.isIdentifier(node.name) && node.type && !node.initializer) proxy(node.name, node.type, definition, sourceFile);
				else ts.forEachChild(node, (child) => visit(child, definition, sourceFile));
			}
			function proxy(name, type, definition, sourceFile) {
				const { textSpan, fileName: fileName$1 } = definition;
				const start = name.getStart(sourceFile);
				const end = name.getEnd();
				if (start !== textSpan.start || end - start !== textSpan.length) return;
				if (!ts.isIndexedAccessTypeNode(type)) return;
				const pos = type.indexType.getStart(sourceFile);
				const res = getDefinitionAndBoundSpan$2(fileName$1, pos);
				if (res?.definitions?.length) {
					for (const definition$1 of res.definitions) definitions.add(definition$1);
					skippedDefinitions.push(definition);
				}
			}
		};
	}
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/lib/requests/collectExtractProps.js
var require_collectExtractProps = __commonJS({ "node_modules/@vue/typescript-plugin/lib/requests/collectExtractProps.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.collectExtractProps = collectExtractProps;
	const language_core_1$2 = require_language_core();
	function collectExtractProps(ts, language, program, sourceScript, virtualCode, templateCodeRange, leadingOffset = 0) {
		const result = /* @__PURE__ */ new Map();
		const sourceFile = program.getSourceFile(virtualCode.fileName);
		const checker = program.getTypeChecker();
		const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(virtualCode);
		const maps = serviceScript ? [...language.maps.forEach(serviceScript.code)].map(([, map]) => map) : [];
		const { sfc } = virtualCode;
		sourceFile.forEachChild(function visit(node) {
			if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.expression) && node.expression.text === "__VLS_ctx" && ts.isIdentifier(node.name)) {
				const { name } = node;
				for (const map of maps) {
					let mapped = false;
					for (const source of map.toSourceLocation(name.getEnd() - leadingOffset)) if (source[0] >= sfc.template.startTagEnd + templateCodeRange[0] && source[0] <= sfc.template.startTagEnd + templateCodeRange[1] && (0, language_core_1$2.isSemanticTokensEnabled)(source[1].data)) {
						mapped = true;
						if (!result.has(name.text)) {
							const type = checker.getTypeAtLocation(node);
							const typeString = checker.typeToString(type, node, ts.TypeFormatFlags.NoTruncation);
							result.set(name.text, {
								name: name.text,
								type: typeString.includes("__VLS_") ? "any" : typeString,
								model: false
							});
						}
						const isModel = ts.isPostfixUnaryExpression(node.parent) || ts.isBinaryExpression(node.parent);
						if (isModel) result.get(name.text).model = true;
						break;
					}
					if (mapped) break;
				}
			}
			node.forEachChild(visit);
		});
		return [...result.values()];
	}
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/lib/requests/utils.js
var require_utils = __commonJS({ "node_modules/@vue/typescript-plugin/lib/requests/utils.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getComponentType = getComponentType;
	exports.getSelfComponentName = getSelfComponentName;
	exports.getVariableType = getVariableType;
	const shared_1 = require_shared$2();
	const path = require_path_browserify();
	function getComponentType(ts, program, fileName, components, tag) {
		const checker = program.getTypeChecker();
		const name = tag.split(".");
		let componentSymbol = components.type.getProperty(name[0]) ?? components.type.getProperty((0, shared_1.camelize)(name[0])) ?? components.type.getProperty((0, shared_1.capitalize)((0, shared_1.camelize)(name[0])));
		let componentType;
		if (!componentSymbol) {
			const name$1 = getSelfComponentName(fileName);
			if (name$1 === (0, shared_1.capitalize)((0, shared_1.camelize)(tag))) componentType = getVariableType(ts, program, fileName, "__VLS_export")?.type;
		} else {
			componentType = checker.getTypeOfSymbolAtLocation(componentSymbol, components.node);
			for (let i = 1; i < name.length; i++) {
				componentSymbol = componentType.getProperty(name[i]);
				if (componentSymbol) componentType = checker.getTypeOfSymbolAtLocation(componentSymbol, components.node);
			}
		}
		return componentType;
	}
	function getSelfComponentName(fileName) {
		const baseName = path.basename(fileName);
		return (0, shared_1.capitalize)((0, shared_1.camelize)(baseName.slice(0, baseName.lastIndexOf("."))));
	}
	function getVariableType(ts, program, fileName, name) {
		const tsSourceFile = program.getSourceFile(fileName);
		if (tsSourceFile) {
			const checker = program.getTypeChecker();
			const node = searchVariableDeclarationNode(ts, tsSourceFile, name);
			if (node) return {
				node,
				type: checker.getTypeAtLocation(node)
			};
		}
	}
	function searchVariableDeclarationNode(ts, sourceFile, name) {
		let result;
		walk$1(sourceFile);
		return result;
		function walk$1(node) {
			if (result) return;
			else if (ts.isVariableDeclaration(node) && node.name.getText() === name) result = node;
			else node.forEachChild(walk$1);
		}
	}
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/lib/requests/getComponentDirectives.js
var require_getComponentDirectives = __commonJS({ "node_modules/@vue/typescript-plugin/lib/requests/getComponentDirectives.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getComponentDirectives = getComponentDirectives;
	const utils_1$6 = require_utils();
	const builtInDirectives = new Set([
		"vBind",
		"vIf",
		"vOn",
		"vOnce",
		"vShow",
		"vSlot"
	]);
	function getComponentDirectives(ts, program, fileName) {
		const directives = (0, utils_1$6.getVariableType)(ts, program, fileName, "__VLS_directives");
		if (!directives) return [];
		return directives.type.getProperties().map(({ name }) => name).filter((name) => name.startsWith("v") && name.length >= 2 && name[1] === name[1].toUpperCase()).filter((name) => !builtInDirectives.has(name));
	}
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/lib/requests/getComponentEvents.js
var require_getComponentEvents = __commonJS({ "node_modules/@vue/typescript-plugin/lib/requests/getComponentEvents.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getComponentEvents = getComponentEvents;
	const utils_1$5 = require_utils();
	function getComponentEvents(ts, program, fileName, tag) {
		const checker = program.getTypeChecker();
		const components = (0, utils_1$5.getVariableType)(ts, program, fileName, "__VLS_components");
		if (!components) return [];
		const componentType = (0, utils_1$5.getComponentType)(ts, program, fileName, components, tag);
		if (!componentType) return [];
		const result = /* @__PURE__ */ new Set();
		for (const sig of componentType.getConstructSignatures()) {
			const instanceType = sig.getReturnType();
			const emitSymbol = instanceType.getProperty("$emit");
			if (emitSymbol) {
				const emitType = checker.getTypeOfSymbolAtLocation(emitSymbol, components.node);
				for (const call of emitType.getCallSignatures()) if (call.parameters.length) {
					const eventNameParamSymbol = call.parameters[0];
					const eventNameParamType = checker.getTypeOfSymbolAtLocation(eventNameParamSymbol, components.node);
					if (eventNameParamType.isStringLiteral()) result.add(eventNameParamType.value);
				}
			}
		}
		return [...result];
	}
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/lib/requests/getComponentNames.js
var require_getComponentNames = __commonJS({ "node_modules/@vue/typescript-plugin/lib/requests/getComponentNames.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getComponentNames = getComponentNames;
	const utils_1$4 = require_utils();
	function getComponentNames(ts, program, fileName) {
		const names = (0, utils_1$4.getVariableType)(ts, program, fileName, "__VLS_components")?.type.getProperties().map((c) => c.name).filter((entry) => !entry.includes("$") && !entry.startsWith("_")) ?? [];
		names.push((0, utils_1$4.getSelfComponentName)(fileName));
		return names;
	}
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/lib/requests/getComponentProps.js
var require_getComponentProps = __commonJS({ "node_modules/@vue/typescript-plugin/lib/requests/getComponentProps.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getComponentProps = getComponentProps;
	const utils_1$3 = require_utils();
	function getComponentProps(ts, program, fileName, tag) {
		const components = (0, utils_1$3.getVariableType)(ts, program, fileName, "__VLS_components");
		if (!components) return [];
		const componentType = (0, utils_1$3.getComponentType)(ts, program, fileName, components, tag);
		if (!componentType) return [];
		const result = /* @__PURE__ */ new Map();
		const checker = program.getTypeChecker();
		for (const sig of componentType.getCallSignatures()) if (sig.parameters.length) {
			const propParam = sig.parameters[0];
			const propsType = checker.getTypeOfSymbolAtLocation(propParam, components.node);
			const props = propsType.getProperties();
			for (const prop of props) handlePropSymbol(prop);
		}
		for (const sig of componentType.getConstructSignatures()) {
			const instanceType = sig.getReturnType();
			const propsSymbol = instanceType.getProperty("$props");
			if (propsSymbol) {
				const propsType = checker.getTypeOfSymbolAtLocation(propsSymbol, components.node);
				const props = propsType.getProperties();
				for (const prop of props) handlePropSymbol(prop);
			}
		}
		return [...result.values()];
		function handlePropSymbol(prop) {
			if (prop.flags & ts.SymbolFlags.Method) return;
			const name = prop.name;
			const required = !(prop.flags & ts.SymbolFlags.Optional) || void 0;
			const { documentation, deprecated } = generateDocumentation(prop.getDocumentationComment(checker), prop.getJsDocTags());
			const values = [];
			const type = checker.getTypeOfSymbol(prop);
			const subTypes = type.types;
			if (subTypes) for (const subType of subTypes) {
				const value = subType.value;
				if (value) values.push(value);
			}
			let isAttribute;
			for (const { parent } of checker.getRootSymbols(prop).flatMap((root) => root.declarations ?? [])) {
				if (!ts.isInterfaceDeclaration(parent)) continue;
				const { text } = parent.name;
				if (text.endsWith("HTMLAttributes") || text === "AriaAttributes" || text === "SVGAttributes") {
					isAttribute = true;
					break;
				}
			}
			result.set(name, {
				name,
				required,
				deprecated,
				isAttribute,
				documentation,
				values
			});
		}
	}
	function generateDocumentation(parts, jsDocTags) {
		const parsedComment = _symbolDisplayPartsToMarkdown(parts);
		const parsedJsDoc = _jsDocTagInfoToMarkdown(jsDocTags);
		const documentation = [parsedComment, parsedJsDoc].filter((str) => !!str).join("\n\n");
		const deprecated = jsDocTags.some((tag) => tag.name === "deprecated");
		return {
			documentation,
			deprecated
		};
	}
	function _symbolDisplayPartsToMarkdown(parts) {
		return parts.map((part) => {
			switch (part.kind) {
				case "keyword": return `\`${part.text}\``;
				case "functionName": return `**${part.text}**`;
				default: return part.text;
			}
		}).join("");
	}
	function _jsDocTagInfoToMarkdown(jsDocTags) {
		return jsDocTags.map((tag) => {
			const tagName = `*@${tag.name}*`;
			const tagText = tag.text?.map((t) => {
				if (t.kind === "parameterName") return `\`${t.text}\``;
				else return t.text;
			}).join("") || "";
			return `${tagName} ${tagText}`;
		}).join("\n\n");
	}
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/lib/requests/getComponentSlots.js
var require_getComponentSlots = __commonJS({ "node_modules/@vue/typescript-plugin/lib/requests/getComponentSlots.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getComponentSlots = getComponentSlots;
	const language_core_1$1 = require_language_core();
	const utils_1$2 = require_utils();
	function getComponentSlots(ts, program, virtualCode) {
		const codegen = language_core_1$1.tsCodegen.get(virtualCode.sfc);
		if (!codegen) return [];
		const assignName = codegen.getSetupSlotsAssignName() ?? `__VLS_slots`;
		const slots = (0, utils_1$2.getVariableType)(ts, program, virtualCode.fileName, assignName);
		if (!slots) return [];
		return slots.type.getProperties().map(({ name }) => name);
	}
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/lib/requests/getElementAttrs.js
var require_getElementAttrs = __commonJS({ "node_modules/@vue/typescript-plugin/lib/requests/getElementAttrs.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getElementAttrs = getElementAttrs;
	const utils_1$1 = require_utils();
	function getElementAttrs(ts, program, fileName, tag) {
		const checker = program.getTypeChecker();
		const elements = (0, utils_1$1.getVariableType)(ts, program, fileName, "__VLS_elements");
		if (!elements) return [];
		const elementType = elements.type.getProperty(tag);
		if (!elementType) return [];
		const attrs = checker.getTypeOfSymbol(elementType).getProperties();
		return attrs.map((c) => c.name);
	}
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/lib/requests/getElementNames.js
var require_getElementNames = __commonJS({ "node_modules/@vue/typescript-plugin/lib/requests/getElementNames.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getElementNames = getElementNames;
	const utils_1 = require_utils();
	function getElementNames(ts, program, fileName) {
		return (0, utils_1.getVariableType)(ts, program, fileName, "__VLS_elements")?.type.getProperties().map((c) => c.name) ?? [];
	}
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/lib/requests/getImportPathForFile.js
var require_getImportPathForFile = __commonJS({ "node_modules/@vue/typescript-plugin/lib/requests/getImportPathForFile.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getImportPathForFile = getImportPathForFile;
	function getImportPathForFile(ts, languageServiceHost, program, fileName, incomingFileName, preferences) {
		const incomingFile = program.getSourceFile(incomingFileName);
		const sourceFile = program.getSourceFile(fileName);
		if (!sourceFile || !incomingFile) return;
		const getModuleSpecifiersWithCacheInfo = ts.moduleSpecifiers.getModuleSpecifiersWithCacheInfo;
		const resolutionHost = ts.createModuleSpecifierResolutionHost(program, languageServiceHost);
		const { moduleSpecifiers } = getModuleSpecifiersWithCacheInfo(incomingFile.symbol, program.getTypeChecker(), languageServiceHost.getCompilationSettings(), sourceFile, resolutionHost, preferences);
		return moduleSpecifiers[0];
	}
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/lib/requests/isRefAtPosition.js
var require_isRefAtPosition = __commonJS({ "node_modules/@vue/typescript-plugin/lib/requests/isRefAtPosition.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isRefAtPosition = isRefAtPosition;
	const language_core_1 = require_language_core();
	function isRefAtPosition(ts, language, program, sourceScript, virtualCode, position, leadingOffset = 0) {
		const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(virtualCode);
		if (!serviceScript) return false;
		let mapped = false;
		for (const [_sourceScript, map] of language.maps.forEach(serviceScript.code)) {
			for (const [position2, mapping] of map.toGeneratedLocation(position)) if ((0, language_core_1.isCompletionEnabled)(mapping.data)) {
				position = position2;
				mapped = true;
				break;
			}
			if (mapped) break;
		}
		if (!mapped) return false;
		const sourceFile = program.getSourceFile(virtualCode.fileName);
		if (!sourceFile) return false;
		const node = findPositionIdentifier(sourceFile, sourceFile, position + leadingOffset);
		if (!node) return false;
		const checker = program.getTypeChecker();
		const type = checker.getTypeAtLocation(node);
		const props = type.getProperties();
		return props.some((prop) => prop.declarations?.some((decl) => ts.isPropertySignature(decl) && ts.isComputedPropertyName(decl.name) && ts.isIdentifier(decl.name.expression) && decl.name.expression.text === "RefSymbol"));
		function findPositionIdentifier(sourceFile$1, node$1, offset) {
			let result;
			node$1.forEachChild((child) => {
				if (!result) {
					if (child.end === offset && ts.isIdentifier(child)) result = child;
					else if (child.end >= offset && child.getStart(sourceFile$1) < offset) result = findPositionIdentifier(sourceFile$1, child, offset);
				}
			});
			return result;
		}
	}
} });

//#endregion
//#region node_modules/@vue/typescript-plugin/index.js
const createLanguageServicePlugin_1 = require_createLanguageServicePlugin();
const core = require_language_core();
const common_1 = require_common();
const collectExtractProps_1 = require_collectExtractProps();
const getComponentDirectives_1 = require_getComponentDirectives();
const getComponentEvents_1 = require_getComponentEvents();
const getComponentNames_1 = require_getComponentNames();
const getComponentProps_1 = require_getComponentProps();
const getComponentSlots_1 = require_getComponentSlots();
const getElementAttrs_1 = require_getElementAttrs();
const getElementNames_1 = require_getElementNames();
const getImportPathForFile_1 = require_getImportPathForFile();
const isRefAtPosition_1 = require_isRefAtPosition();
module.exports = (0, createLanguageServicePlugin_1.createLanguageServicePlugin)((ts, info) => {
	const vueOptions = getVueCompilerOptions();
	const languagePlugin = core.createVueLanguagePlugin(ts, info.languageServiceHost.getCompilationSettings(), vueOptions, (id) => id);
	vueOptions.globalTypesPath = core.createGlobalTypesWriter(vueOptions, ts.sys.writeFile);
	addVueCommands();
	return {
		languagePlugins: [languagePlugin],
		setup: (language) => {
			info.languageService = (0, common_1.createVueLanguageServiceProxy)(ts, language, info.languageService, vueOptions, (fileName) => fileName);
			info.project.__vue__ = { language };
		}
	};
	function getVueCompilerOptions() {
		if (info.project.projectKind === ts.server.ProjectKind.Configured) {
			const tsconfig = info.project.getProjectName();
			return core.createParsedCommandLine(ts, ts.sys, tsconfig.replace(/\\/g, "/")).vueOptions;
		} else return core.createParsedCommandLineByJson(ts, ts.sys, info.languageServiceHost.getCurrentDirectory(), {}).vueOptions;
	}
	function addVueCommands() {
		const projectService = info.project.projectService;
		projectService.logger.info("Vue: called handler processing " + info.project.projectKind);
		if (!info.session) {
			projectService.logger.info("Vue: there is no session in info.");
			return;
		}
		const session = info.session;
		if (!session.addProtocolHandler) {
			projectService.logger.info("Vue: there is no addProtocolHandler method.");
			return;
		}
		const handlers = session.handlers;
		if (handlers.has("_vue:projectInfo")) return;
		session.addProtocolHandler("_vue:projectInfo", (request) => {
			return handlers.get("projectInfo")(request);
		});
		session.addProtocolHandler("_vue:documentHighlights-full", (request) => {
			return handlers.get("documentHighlights-full")(request);
		});
		session.addProtocolHandler("_vue:encodedSemanticClassifications-full", (request) => {
			return handlers.get("encodedSemanticClassifications-full")(request);
		});
		session.addProtocolHandler("_vue:quickinfo", (request) => {
			return handlers.get("quickinfo")(request);
		});
		session.addProtocolHandler("_vue:collectExtractProps", (request) => {
			const [fileName, templateCodeRange] = request.arguments;
			const { project, language, sourceScript, virtualCode } = getProjectAndVirtualCode(fileName);
			return createResponse((0, collectExtractProps_1.collectExtractProps)(ts, language, project.getLanguageService().getProgram(), sourceScript, virtualCode, templateCodeRange, sourceScript.generated ? sourceScript.snapshot.getLength() : 0));
		});
		session.addProtocolHandler("_vue:getImportPathForFile", (request) => {
			const [fileName, incomingFileName, preferences] = request.arguments;
			const { project } = getProject(fileName);
			return createResponse((0, getImportPathForFile_1.getImportPathForFile)(ts, project, project.getLanguageService().getProgram(), fileName, incomingFileName, preferences));
		});
		session.addProtocolHandler("_vue:isRefAtPosition", (request) => {
			const [fileName, position] = request.arguments;
			const { project, language, sourceScript, virtualCode } = getProjectAndVirtualCode(fileName);
			return createResponse((0, isRefAtPosition_1.isRefAtPosition)(ts, language, project.getLanguageService().getProgram(), sourceScript, virtualCode, position, sourceScript.generated ? sourceScript.snapshot.getLength() : 0));
		});
		session.addProtocolHandler("_vue:getComponentDirectives", (request) => {
			const [fileName] = request.arguments;
			const { project } = getProject(fileName);
			return createResponse((0, getComponentDirectives_1.getComponentDirectives)(ts, project.getLanguageService().getProgram(), fileName));
		});
		session.addProtocolHandler("_vue:getComponentEvents", (request) => {
			const [fileName, tag] = request.arguments;
			const { project } = getProject(fileName);
			return createResponse((0, getComponentEvents_1.getComponentEvents)(ts, project.getLanguageService().getProgram(), fileName, tag));
		});
		session.addProtocolHandler("_vue:getComponentNames", (request) => {
			const [fileName] = request.arguments;
			const { project } = getProject(fileName);
			return createResponse((0, getComponentNames_1.getComponentNames)(ts, project.getLanguageService().getProgram(), fileName));
		});
		session.addProtocolHandler("_vue:getComponentProps", (request) => {
			const [fileName, tag] = request.arguments;
			const { project } = getProject(fileName);
			return createResponse((0, getComponentProps_1.getComponentProps)(ts, project.getLanguageService().getProgram(), fileName, tag));
		});
		session.addProtocolHandler("_vue:getComponentSlots", (request) => {
			const [fileName] = request.arguments;
			const { project, virtualCode } = getProjectAndVirtualCode(fileName);
			return createResponse((0, getComponentSlots_1.getComponentSlots)(ts, project.getLanguageService().getProgram(), virtualCode));
		});
		session.addProtocolHandler("_vue:getElementAttrs", (request) => {
			const [fileName, tag] = request.arguments;
			const { project } = getProject(fileName);
			return createResponse((0, getElementAttrs_1.getElementAttrs)(ts, project.getLanguageService().getProgram(), fileName, tag));
		});
		session.addProtocolHandler("_vue:getElementNames", (request) => {
			const [fileName] = request.arguments;
			const { project } = getProject(fileName);
			return createResponse((0, getElementNames_1.getElementNames)(ts, project.getLanguageService().getProgram(), fileName));
		});
		projectService.logger.info("Vue specific commands are successfully added.");
		function createResponse(res) {
			return {
				response: res,
				responseRequired: true
			};
		}
		function getProjectAndVirtualCode(fileName) {
			const service = getProject(fileName);
			const sourceScript = service.language.scripts.get(fileName);
			if (!sourceScript) throw new Error("No source script found for file: " + fileName);
			const virtualCode = sourceScript.generated?.root;
			if (!(virtualCode instanceof core.VueVirtualCode)) throw new Error("No virtual code found for file: " + fileName);
			return {
				...service,
				sourceScript,
				virtualCode
			};
		}
		function getProject(fileName) {
			const { project } = session["getFileAndProject"]({
				file: fileName,
				projectFileName: void 0
			});
			if (!("__vue__" in project)) throw new Error("No vue project info for project: " + project.getProjectName());
			return {
				project,
				language: project.__vue__.language
			};
		}
	}
});

//#endregion