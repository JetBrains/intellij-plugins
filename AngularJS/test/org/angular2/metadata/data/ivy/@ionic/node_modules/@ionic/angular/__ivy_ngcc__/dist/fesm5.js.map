{"version":3,"file":"fesm5.js","sources":["/Users/piotr.tomiak/WebstormProjects/ng9rc/node_modules/@ionic/angular/dist/fesm5.js"],"sourcesContent":["import { __extends, __awaiter, __generator, __assign } from 'tslib';\nimport { HostListener, Directive, ElementRef, Injectable, Inject, NgZone, defineInjectable, inject, Optional, Component, ChangeDetectionStrategy, ChangeDetectorRef, InjectionToken, ApplicationRef, Injector, ViewContainerRef, ComponentFactoryResolver, Attribute, SkipSelf, Output, EventEmitter, ViewChild, ContentChild, TemplateRef, IterableDiffers, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { DOCUMENT, Location, LocationStrategy, CommonModule } from '@angular/common';\nimport { UrlSerializer, Router, NavigationStart, ActivatedRoute, ChildrenOutletContexts, PRIMARY_OUTLET, RouterLink } from '@angular/router';\nimport { isPlatform, getPlatforms, LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD, actionSheetController, alertController, loadingController, menuController, pickerController, modalController, popoverController, toastController } from '@ionic/core';\nimport { Subject, fromEvent, BehaviorSubject } from 'rxjs';\nimport { filter, switchMap, distinctUntilChanged } from 'rxjs/operators';\nimport { applyPolyfills, defineCustomElements } from '@ionic/core/loader';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar raf = (/**\n * @param {?} h\n * @return {?}\n */\nfunction (h) {\n    if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n        return __zone_symbol__requestAnimationFrame(h);\n    }\n    if (typeof requestAnimationFrame === 'function') {\n        return requestAnimationFrame(h);\n    }\n    return setTimeout(h);\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ValueAccessor = /** @class */ (function () {\n    function ValueAccessor(el) {\n        this.el = el;\n        this.onChange = (/**\n         * @return {?}\n         */\n        function () { });\n        this.onTouched = (/**\n         * @return {?}\n         */\n        function () { });\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ValueAccessor.prototype.writeValue = /**\n     * @param {?} value\n     * @return {?}\n     */\n    function (value) {\n        this.el.nativeElement.value = this.lastValue = value == null ? '' : value;\n        setIonicClasses(this.el);\n    };\n    /**\n     * @param {?} el\n     * @param {?} value\n     * @return {?}\n     */\n    ValueAccessor.prototype.handleChangeEvent = /**\n     * @param {?} el\n     * @param {?} value\n     * @return {?}\n     */\n    function (el, value) {\n        if (el === this.el.nativeElement) {\n            if (value !== this.lastValue) {\n                this.lastValue = value;\n                this.onChange(value);\n            }\n            setIonicClasses(this.el);\n        }\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    ValueAccessor.prototype._handleBlurEvent = /**\n     * @param {?} el\n     * @return {?}\n     */\n    function (el) {\n        if (el === this.el.nativeElement) {\n            this.onTouched();\n            setIonicClasses(this.el);\n        }\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    ValueAccessor.prototype.registerOnChange = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this.onChange = fn;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    ValueAccessor.prototype.registerOnTouched = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this.onTouched = fn;\n    };\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    ValueAccessor.prototype.setDisabledState = /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    function (isDisabled) {\n        this.el.nativeElement.disabled = isDisabled;\n    };\n    ValueAccessor.propDecorators = {\n        _handleBlurEvent: [{ type: HostListener, args: ['ionBlur', ['$event.target'],] }]\n    };\n    return ValueAccessor;\n}());\n/** @type {?} */\nvar setIonicClasses = (/**\n * @param {?} element\n * @return {?}\n */\nfunction (element) {\n    raf((/**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var input = (/** @type {?} */ (element.nativeElement));\n        /** @type {?} */\n        var classes = getClasses(input);\n        setClasses(input, classes);\n        /** @type {?} */\n        var item = input.closest('ion-item');\n        if (item) {\n            setClasses(item, classes);\n        }\n    }));\n});\n/** @type {?} */\nvar getClasses = (/**\n * @param {?} element\n * @return {?}\n */\nfunction (element) {\n    /** @type {?} */\n    var classList = element.classList;\n    /** @type {?} */\n    var classes = [];\n    for (var i = 0; i < classList.length; i++) {\n        /** @type {?} */\n        var item = classList.item(i);\n        if (item !== null && startsWith(item, 'ng-')) {\n            classes.push(\"ion-\" + item.substr(3));\n        }\n    }\n    return classes;\n});\n/** @type {?} */\nvar setClasses = (/**\n * @param {?} element\n * @param {?} classes\n * @return {?}\n */\nfunction (element, classes) {\n    /** @type {?} */\n    var classList = element.classList;\n    [\n        'ion-valid',\n        'ion-invalid',\n        'ion-touched',\n        'ion-untouched',\n        'ion-dirty',\n        'ion-pristine'\n    ].forEach((/**\n     * @param {?} c\n     * @return {?}\n     */\n    function (c) { return classList.remove(c); }));\n    classes.forEach((/**\n     * @param {?} c\n     * @return {?}\n     */\n    function (c) { return classList.add(c); }));\n});\n/** @type {?} */\nvar startsWith = (/**\n * @param {?} input\n * @param {?} search\n * @return {?}\n */\nfunction (input, search) {\n    return input.substr(0, search.length) === search;\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar BooleanValueAccessor = /** @class */ (function (_super) {\n    __extends(BooleanValueAccessor, _super);\n    function BooleanValueAccessor(el) {\n        return _super.call(this, el) || this;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    BooleanValueAccessor.prototype.writeValue = /**\n     * @param {?} value\n     * @return {?}\n     */\n    function (value) {\n        this.el.nativeElement.checked = this.lastValue = value == null ? false : value;\n        setIonicClasses(this.el);\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    BooleanValueAccessor.prototype._handleIonChange = /**\n     * @param {?} el\n     * @return {?}\n     */\n    function (el) {\n        this.handleChangeEvent(el, el.checked);\n    };\n    BooleanValueAccessor.decorators = [\n        { type: Directive, args: [{\n                    /* tslint:disable-next-line:directive-selector */\n                    selector: 'ion-checkbox,ion-toggle',\n                    providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: BooleanValueAccessor,\n                            multi: true\n                        }\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    BooleanValueAccessor.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\n    BooleanValueAccessor.propDecorators = {\n        _handleIonChange: [{ type: HostListener, args: ['ionChange', ['$event.target'],] }]\n    };\n    return BooleanValueAccessor;\n}(ValueAccessor));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NumericValueAccessor = /** @class */ (function (_super) {\n    __extends(NumericValueAccessor, _super);\n    function NumericValueAccessor(el) {\n        return _super.call(this, el) || this;\n    }\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    NumericValueAccessor.prototype._handleIonChange = /**\n     * @param {?} el\n     * @return {?}\n     */\n    function (el) {\n        this.handleChangeEvent(el, el.value);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    NumericValueAccessor.prototype.registerOnChange = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        _super.prototype.registerOnChange.call(this, (/**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            fn(value === '' ? null : parseFloat(value));\n        }));\n    };\n    NumericValueAccessor.decorators = [\n        { type: Directive, args: [{\n                    /* tslint:disable-next-line:directive-selector */\n                    selector: 'ion-input[type=number]',\n                    providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: NumericValueAccessor,\n                            multi: true\n                        }\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    NumericValueAccessor.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\n    NumericValueAccessor.propDecorators = {\n        _handleIonChange: [{ type: HostListener, args: ['ionChange', ['$event.target'],] }]\n    };\n    return NumericValueAccessor;\n}(ValueAccessor));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar RadioValueAccessor = /** @class */ (function (_super) {\n    __extends(RadioValueAccessor, _super);\n    function RadioValueAccessor(el) {\n        return _super.call(this, el) || this;\n    }\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    RadioValueAccessor.prototype._handleIonSelect = /**\n     * @param {?} el\n     * @return {?}\n     */\n    function (el) {\n        this.handleChangeEvent(el, el.checked);\n    };\n    RadioValueAccessor.decorators = [\n        { type: Directive, args: [{\n                    /* tslint:disable-next-line:directive-selector */\n                    selector: 'ion-radio',\n                    providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: RadioValueAccessor,\n                            multi: true\n                        }\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    RadioValueAccessor.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\n    RadioValueAccessor.propDecorators = {\n        _handleIonSelect: [{ type: HostListener, args: ['ionSelect', ['$event.target'],] }]\n    };\n    return RadioValueAccessor;\n}(ValueAccessor));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar SelectValueAccessor = /** @class */ (function (_super) {\n    __extends(SelectValueAccessor, _super);\n    function SelectValueAccessor(el) {\n        return _super.call(this, el) || this;\n    }\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    SelectValueAccessor.prototype._handleChangeEvent = /**\n     * @param {?} el\n     * @return {?}\n     */\n    function (el) {\n        this.handleChangeEvent(el, el.value);\n    };\n    SelectValueAccessor.decorators = [\n        { type: Directive, args: [{\n                    /* tslint:disable-next-line:directive-selector */\n                    selector: 'ion-range, ion-select, ion-radio-group, ion-segment, ion-datetime',\n                    providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: SelectValueAccessor,\n                            multi: true\n                        }\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    SelectValueAccessor.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\n    SelectValueAccessor.propDecorators = {\n        _handleChangeEvent: [{ type: HostListener, args: ['ionChange', ['$event.target'],] }]\n    };\n    return SelectValueAccessor;\n}(ValueAccessor));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar TextValueAccessor = /** @class */ (function (_super) {\n    __extends(TextValueAccessor, _super);\n    function TextValueAccessor(el) {\n        return _super.call(this, el) || this;\n    }\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    TextValueAccessor.prototype._handleInputEvent = /**\n     * @param {?} el\n     * @return {?}\n     */\n    function (el) {\n        this.handleChangeEvent(el, el.value);\n    };\n    TextValueAccessor.decorators = [\n        { type: Directive, args: [{\n                    /* tslint:disable-next-line:directive-selector */\n                    selector: 'ion-input:not([type=number]),ion-textarea,ion-searchbar',\n                    providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: TextValueAccessor,\n                            multi: true\n                        }\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    TextValueAccessor.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\n    TextValueAccessor.propDecorators = {\n        _handleInputEvent: [{ type: HostListener, args: ['ionChange', ['$event.target'],] }]\n    };\n    return TextValueAccessor;\n}(ValueAccessor));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar Platform = /** @class */ (function () {\n    function Platform(doc, zone) {\n        var _this = this;\n        this.doc = doc;\n        /**\n         * @hidden\n         */\n        this.backButton = (/** @type {?} */ (new Subject()));\n        /**\n         * The pause event emits when the native platform puts the application\n         * into the background, typically when the user switches to a different\n         * application. This event would emit when a Cordova app is put into\n         * the background, however, it would not fire on a standard web browser.\n         */\n        this.pause = new Subject();\n        /**\n         * The resume event emits when the native platform pulls the application\n         * out from the background. This event would emit when a Cordova app comes\n         * out from the background, however, it would not fire on a standard web browser.\n         */\n        this.resume = new Subject();\n        /**\n         * The resize event emits when the browser window has changed dimensions. This\n         * could be from a browser window being physically resized, or from a device\n         * changing orientation.\n         */\n        this.resize = new Subject();\n        zone.run((/**\n         * @return {?}\n         */\n        function () {\n            _this.win = doc.defaultView;\n            _this.backButton.subscribeWithPriority = (/**\n             * @param {?} priority\n             * @param {?} callback\n             * @return {?}\n             */\n            function (priority, callback) {\n                return this.subscribe((/**\n                 * @param {?} ev\n                 * @return {?}\n                 */\n                function (ev) { return (ev.register(priority, (/**\n                 * @return {?}\n                 */\n                function () { return zone.run(callback); }))); }));\n            });\n            proxyEvent(_this.pause, doc, 'pause');\n            proxyEvent(_this.resume, doc, 'resume');\n            proxyEvent(_this.backButton, doc, 'ionBackButton');\n            proxyEvent(_this.resize, _this.win, 'resize');\n            /** @type {?} */\n            var readyResolve;\n            _this._readyPromise = new Promise((/**\n             * @param {?} res\n             * @return {?}\n             */\n            function (res) { readyResolve = res; }));\n            if (_this.win && _this.win['cordova']) {\n                doc.addEventListener('deviceready', (/**\n                 * @return {?}\n                 */\n                function () {\n                    readyResolve('cordova');\n                }), { once: true });\n            }\n            else {\n                (/** @type {?} */ (readyResolve))('dom');\n            }\n        }));\n    }\n    /**\n     * @returns returns true/false based on platform.\n     * @description\n     * Depending on the platform the user is on, `is(platformName)` will\n     * return `true` or `false`. Note that the same app can return `true`\n     * for more than one platform name. For example, an app running from\n     * an iPad would return `true` for the platform names: `mobile`,\n     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\n     * from Cordova then `cordova` would be true, and if it was running\n     * from a web browser on the iPad then `mobileweb` would be `true`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     if (this.platform.is('ios')) {\n     *       // This will only print when on iOS\n     *       console.log('I am an iOS device!');\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * | Platform Name   | Description                        |\n     * |-----------------|------------------------------------|\n     * | android         | on a device running Android.       |\n     * | cordova         | on a device running Cordova.       |\n     * | ios             | on a device running iOS.           |\n     * | ipad            | on an iPad device.                 |\n     * | iphone          | on an iPhone device.               |\n     * | phablet         | on a phablet device.               |\n     * | tablet          | on a tablet device.                |\n     * | electron        | in Electron on a desktop device.   |\n     * | pwa             | as a PWA app.                      |\n     * | mobile          | on a mobile device.                |\n     * | mobileweb       | on a mobile device in a browser.   |\n     * | desktop         | on a desktop device.               |\n     * | hybrid          | is a cordova or capacitor app.     |\n     *\n     */\n    /**\n     * \\@description\n     * Depending on the platform the user is on, `is(platformName)` will\n     * return `true` or `false`. Note that the same app can return `true`\n     * for more than one platform name. For example, an app running from\n     * an iPad would return `true` for the platform names: `mobile`,\n     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\n     * from Cordova then `cordova` would be true, and if it was running\n     * from a web browser on the iPad then `mobileweb` would be `true`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * \\@Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     if (this.platform.is('ios')) {\n     *       // This will only print when on iOS\n     *       console.log('I am an iOS device!');\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * | Platform Name   | Description                        |\n     * |-----------------|------------------------------------|\n     * | android         | on a device running Android.       |\n     * | cordova         | on a device running Cordova.       |\n     * | ios             | on a device running iOS.           |\n     * | ipad            | on an iPad device.                 |\n     * | iphone          | on an iPhone device.               |\n     * | phablet         | on a phablet device.               |\n     * | tablet          | on a tablet device.                |\n     * | electron        | in Electron on a desktop device.   |\n     * | pwa             | as a PWA app.                      |\n     * | mobile          | on a mobile device.                |\n     * | mobileweb       | on a mobile device in a browser.   |\n     * | desktop         | on a desktop device.               |\n     * | hybrid          | is a cordova or capacitor app.     |\n     *\n     * @param {?} platformName\n     * @return {?} returns true/false based on platform.\n     */\n    Platform.prototype.is = /**\n     * \\@description\n     * Depending on the platform the user is on, `is(platformName)` will\n     * return `true` or `false`. Note that the same app can return `true`\n     * for more than one platform name. For example, an app running from\n     * an iPad would return `true` for the platform names: `mobile`,\n     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\n     * from Cordova then `cordova` would be true, and if it was running\n     * from a web browser on the iPad then `mobileweb` would be `true`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * \\@Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     if (this.platform.is('ios')) {\n     *       // This will only print when on iOS\n     *       console.log('I am an iOS device!');\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * | Platform Name   | Description                        |\n     * |-----------------|------------------------------------|\n     * | android         | on a device running Android.       |\n     * | cordova         | on a device running Cordova.       |\n     * | ios             | on a device running iOS.           |\n     * | ipad            | on an iPad device.                 |\n     * | iphone          | on an iPhone device.               |\n     * | phablet         | on a phablet device.               |\n     * | tablet          | on a tablet device.                |\n     * | electron        | in Electron on a desktop device.   |\n     * | pwa             | as a PWA app.                      |\n     * | mobile          | on a mobile device.                |\n     * | mobileweb       | on a mobile device in a browser.   |\n     * | desktop         | on a desktop device.               |\n     * | hybrid          | is a cordova or capacitor app.     |\n     *\n     * @param {?} platformName\n     * @return {?} returns true/false based on platform.\n     */\n    function (platformName) {\n        return isPlatform(this.win, platformName);\n    };\n    /**\n     * @returns the array of platforms\n     * @description\n     * Depending on what device you are on, `platforms` can return multiple values.\n     * Each possible value is a hierarchy of platforms. For example, on an iPhone,\n     * it would return `mobile`, `ios`, and `iphone`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     // This will print an array of the current platforms\n     *     console.log(this.platform.platforms());\n     *   }\n     * }\n     * ```\n     */\n    /**\n     * \\@description\n     * Depending on what device you are on, `platforms` can return multiple values.\n     * Each possible value is a hierarchy of platforms. For example, on an iPhone,\n     * it would return `mobile`, `ios`, and `iphone`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * \\@Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     // This will print an array of the current platforms\n     *     console.log(this.platform.platforms());\n     *   }\n     * }\n     * ```\n     * @return {?} the array of platforms\n     */\n    Platform.prototype.platforms = /**\n     * \\@description\n     * Depending on what device you are on, `platforms` can return multiple values.\n     * Each possible value is a hierarchy of platforms. For example, on an iPhone,\n     * it would return `mobile`, `ios`, and `iphone`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * \\@Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     // This will print an array of the current platforms\n     *     console.log(this.platform.platforms());\n     *   }\n     * }\n     * ```\n     * @return {?} the array of platforms\n     */\n    function () {\n        return getPlatforms(this.win);\n    };\n    /**\n     * Returns a promise when the platform is ready and native functionality\n     * can be called. If the app is running from within a web browser, then\n     * the promise will resolve when the DOM is ready. When the app is running\n     * from an application engine such as Cordova, then the promise will\n     * resolve when Cordova triggers the `deviceready` event.\n     *\n     * The resolved value is the `readySource`, which states which platform\n     * ready was used. For example, when Cordova is ready, the resolved ready\n     * source is `cordova`. The default ready source value will be `dom`. The\n     * `readySource` is useful if different logic should run depending on the\n     * platform the app is running from. For example, only Cordova can execute\n     * the status bar plugin, so the web should not run status bar plugin logic.\n     *\n     * ```\n     * import { Component } from '@angular/core';\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyApp {\n     *   constructor(public platform: Platform) {\n     *     this.platform.ready().then((readySource) => {\n     *       console.log('Platform ready from', readySource);\n     *       // Platform now ready, execute any required native code\n     *     });\n     *   }\n     * }\n     * ```\n     */\n    /**\n     * Returns a promise when the platform is ready and native functionality\n     * can be called. If the app is running from within a web browser, then\n     * the promise will resolve when the DOM is ready. When the app is running\n     * from an application engine such as Cordova, then the promise will\n     * resolve when Cordova triggers the `deviceready` event.\n     *\n     * The resolved value is the `readySource`, which states which platform\n     * ready was used. For example, when Cordova is ready, the resolved ready\n     * source is `cordova`. The default ready source value will be `dom`. The\n     * `readySource` is useful if different logic should run depending on the\n     * platform the app is running from. For example, only Cordova can execute\n     * the status bar plugin, so the web should not run status bar plugin logic.\n     *\n     * ```\n     * import { Component } from '\\@angular/core';\n     * import { Platform } from 'ionic-angular';\n     *\n     * \\@Component({...})\n     * export MyApp {\n     *   constructor(public platform: Platform) {\n     *     this.platform.ready().then((readySource) => {\n     *       console.log('Platform ready from', readySource);\n     *       // Platform now ready, execute any required native code\n     *     });\n     *   }\n     * }\n     * ```\n     * @return {?}\n     */\n    Platform.prototype.ready = /**\n     * Returns a promise when the platform is ready and native functionality\n     * can be called. If the app is running from within a web browser, then\n     * the promise will resolve when the DOM is ready. When the app is running\n     * from an application engine such as Cordova, then the promise will\n     * resolve when Cordova triggers the `deviceready` event.\n     *\n     * The resolved value is the `readySource`, which states which platform\n     * ready was used. For example, when Cordova is ready, the resolved ready\n     * source is `cordova`. The default ready source value will be `dom`. The\n     * `readySource` is useful if different logic should run depending on the\n     * platform the app is running from. For example, only Cordova can execute\n     * the status bar plugin, so the web should not run status bar plugin logic.\n     *\n     * ```\n     * import { Component } from '\\@angular/core';\n     * import { Platform } from 'ionic-angular';\n     *\n     * \\@Component({...})\n     * export MyApp {\n     *   constructor(public platform: Platform) {\n     *     this.platform.ready().then((readySource) => {\n     *       console.log('Platform ready from', readySource);\n     *       // Platform now ready, execute any required native code\n     *     });\n     *   }\n     * }\n     * ```\n     * @return {?}\n     */\n    function () {\n        return this._readyPromise;\n    };\n    Object.defineProperty(Platform.prototype, \"isRTL\", {\n        /**\n         * Returns if this app is using right-to-left language direction or not.\n         * We recommend the app's `index.html` file already has the correct `dir`\n         * attribute value set, such as `<html dir=\"ltr\">` or `<html dir=\"rtl\">`.\n         * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)\n         */\n        get: /**\n         * Returns if this app is using right-to-left language direction or not.\n         * We recommend the app's `index.html` file already has the correct `dir`\n         * attribute value set, such as `<html dir=\"ltr\">` or `<html dir=\"rtl\">`.\n         * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)\n         * @return {?}\n         */\n        function () {\n            return this.doc.dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the query string parameter\n     */\n    /**\n     * Get the query string parameter\n     * @param {?} key\n     * @return {?}\n     */\n    Platform.prototype.getQueryParam = /**\n     * Get the query string parameter\n     * @param {?} key\n     * @return {?}\n     */\n    function (key) {\n        return readQueryParam(this.win.location.href, key);\n    };\n    /**\n     * Returns `true` if the app is in landscape mode.\n     */\n    /**\n     * Returns `true` if the app is in landscape mode.\n     * @return {?}\n     */\n    Platform.prototype.isLandscape = /**\n     * Returns `true` if the app is in landscape mode.\n     * @return {?}\n     */\n    function () {\n        return !this.isPortrait();\n    };\n    /**\n     * Returns `true` if the app is in portait mode.\n     */\n    /**\n     * Returns `true` if the app is in portait mode.\n     * @return {?}\n     */\n    Platform.prototype.isPortrait = /**\n     * Returns `true` if the app is in portait mode.\n     * @return {?}\n     */\n    function () {\n        return this.win.matchMedia && this.win.matchMedia('(orientation: portrait)').matches;\n    };\n    /**\n     * @param {?} expression\n     * @return {?}\n     */\n    Platform.prototype.testUserAgent = /**\n     * @param {?} expression\n     * @return {?}\n     */\n    function (expression) {\n        /** @type {?} */\n        var nav = this.win.navigator;\n        return !!(nav && nav.userAgent && nav.userAgent.indexOf(expression) >= 0);\n    };\n    /**\n     * Get the current url.\n     */\n    /**\n     * Get the current url.\n     * @return {?}\n     */\n    Platform.prototype.url = /**\n     * Get the current url.\n     * @return {?}\n     */\n    function () {\n        return this.win.location.href;\n    };\n    /**\n     * Gets the width of the platform's viewport using `window.innerWidth`.\n     */\n    /**\n     * Gets the width of the platform's viewport using `window.innerWidth`.\n     * @return {?}\n     */\n    Platform.prototype.width = /**\n     * Gets the width of the platform's viewport using `window.innerWidth`.\n     * @return {?}\n     */\n    function () {\n        return this.win.innerWidth;\n    };\n    /**\n     * Gets the height of the platform's viewport using `window.innerHeight`.\n     */\n    /**\n     * Gets the height of the platform's viewport using `window.innerHeight`.\n     * @return {?}\n     */\n    Platform.prototype.height = /**\n     * Gets the height of the platform's viewport using `window.innerHeight`.\n     * @return {?}\n     */\n    function () {\n        return this.win.innerHeight;\n    };\n    Platform.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root',\n                },] },\n    ];\n    /** @nocollapse */\n    Platform.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n        { type: NgZone }\n    ]; };\n    /** @nocollapse */ Platform.ngInjectableDef = defineInjectable({ factory: function Platform_Factory() { return new Platform(inject(DOCUMENT), inject(NgZone)); }, token: Platform, providedIn: \"root\" });\n    return Platform;\n}());\n/** @type {?} */\nvar readQueryParam = (/**\n * @param {?} url\n * @param {?} key\n * @return {?}\n */\nfunction (url, key) {\n    key = key.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n    /** @type {?} */\n    var regex = new RegExp('[\\\\?&]' + key + '=([^&#]*)');\n    /** @type {?} */\n    var results = regex.exec(url);\n    return results ? decodeURIComponent(results[1].replace(/\\+/g, ' ')) : null;\n});\n/** @type {?} */\nvar proxyEvent = (/**\n * @template T\n * @param {?} emitter\n * @param {?} el\n * @param {?} eventName\n * @return {?}\n */\nfunction (emitter, el, eventName) {\n    if (((/** @type {?} */ (el)))) {\n        el.addEventListener(eventName, (/**\n         * @param {?} ev\n         * @return {?}\n         */\n        function (ev) {\n            // ?? cordova might emit \"null\" events\n            emitter.next(ev != null ? (/** @type {?} */ (((/** @type {?} */ (ev))).detail)) : undefined);\n        }));\n    }\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NavController = /** @class */ (function () {\n    function NavController(platform, location, serializer, router) {\n        var _this = this;\n        this.location = location;\n        this.serializer = serializer;\n        this.router = router;\n        this.direction = DEFAULT_DIRECTION;\n        this.animated = DEFAULT_ANIMATED;\n        this.guessDirection = 'forward';\n        this.lastNavId = -1;\n        // Subscribe to router events to detect direction\n        if (router) {\n            router.events.subscribe((/**\n             * @param {?} ev\n             * @return {?}\n             */\n            function (ev) {\n                if (ev instanceof NavigationStart) {\n                    /** @type {?} */\n                    var id = (ev.restoredState) ? ev.restoredState.navigationId : ev.id;\n                    _this.guessDirection = id < _this.lastNavId ? 'back' : 'forward';\n                    _this.guessAnimation = !ev.restoredState ? _this.guessDirection : undefined;\n                    _this.lastNavId = _this.guessDirection === 'forward' ? ev.id : id;\n                }\n            }));\n        }\n        // Subscribe to backButton events\n        platform.backButton.subscribeWithPriority(0, (/**\n         * @return {?}\n         */\n        function () { return _this.pop(); }));\n    }\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\n     *\n     * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\n     * and that it will show a \"forward\" animation by default.\n     *\n     * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\n     * ```\n     */\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\n     *\n     * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\n     * and that it will show a \"forward\" animation by default.\n     *\n     * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\n     * ```\n     * @param {?} url\n     * @param {?=} options\n     * @return {?}\n     */\n    NavController.prototype.navigateForward = /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\n     *\n     * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\n     * and that it will show a \"forward\" animation by default.\n     *\n     * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\n     * ```\n     * @param {?} url\n     * @param {?=} options\n     * @return {?}\n     */\n    function (url, options) {\n        if (options === void 0) { options = {}; }\n        this.setDirection('forward', options.animated, options.animationDirection);\n        return this.navigate(url, options);\n    };\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('back');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\n     * and that it will show a \"back\" animation by default.\n     *\n     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\n     * ```\n     */\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('back');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\n     * and that it will show a \"back\" animation by default.\n     *\n     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\n     * ```\n     * @param {?} url\n     * @param {?=} options\n     * @return {?}\n     */\n    NavController.prototype.navigateBack = /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('back');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\n     * and that it will show a \"back\" animation by default.\n     *\n     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\n     * ```\n     * @param {?} url\n     * @param {?=} options\n     * @return {?}\n     */\n    function (url, options) {\n        if (options === void 0) { options = {}; }\n        this.setDirection('back', options.animated, options.animationDirection);\n        return this.navigate(url, options);\n    };\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('root');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **root** means that all existing pages in the stack will be removed,\n     * and the navigated page will become the single page in the stack.\n     *\n     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\n     * ```\n     */\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('root');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **root** means that all existing pages in the stack will be removed,\n     * and the navigated page will become the single page in the stack.\n     *\n     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\n     * ```\n     * @param {?} url\n     * @param {?=} options\n     * @return {?}\n     */\n    NavController.prototype.navigateRoot = /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('root');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **root** means that all existing pages in the stack will be removed,\n     * and the navigated page will become the single page in the stack.\n     *\n     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\n     * ```\n     * @param {?} url\n     * @param {?=} options\n     * @return {?}\n     */\n    function (url, options) {\n        if (options === void 0) { options = {}; }\n        this.setDirection('root', options.animated, options.animationDirection);\n        return this.navigate(url, options);\n    };\n    /**\n     * Same as [Location](https://angular.io/api/common/Location)'s back() method.\n     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\n     * by default.\n     */\n    /**\n     * Same as [Location](https://angular.io/api/common/Location)'s back() method.\n     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\n     * by default.\n     * @param {?=} options\n     * @return {?}\n     */\n    NavController.prototype.back = /**\n     * Same as [Location](https://angular.io/api/common/Location)'s back() method.\n     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\n     * by default.\n     * @param {?=} options\n     * @return {?}\n     */\n    function (options) {\n        if (options === void 0) { options = { animated: true, animationDirection: 'back' }; }\n        this.setDirection('back', options.animated, options.animationDirection);\n        return this.location.back();\n    };\n    /**\n     * This methods goes back in the context of Ionic's stack navigation.\n     *\n     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\n     * This is the recommended way to go back when you are using `ion-router-outlet`.\n     */\n    /**\n     * This methods goes back in the context of Ionic's stack navigation.\n     *\n     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\n     * This is the recommended way to go back when you are using `ion-router-outlet`.\n     * @return {?}\n     */\n    NavController.prototype.pop = /**\n     * This methods goes back in the context of Ionic's stack navigation.\n     *\n     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\n     * This is the recommended way to go back when you are using `ion-router-outlet`.\n     * @return {?}\n     */\n    function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var outlet;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        outlet = this.topOutlet;\n                        _a.label = 1;\n                    case 1:\n                        if (!outlet) return [3 /*break*/, 3];\n                        return [4 /*yield*/, outlet.pop()];\n                    case 2:\n                        if (_a.sent()) {\n                            return [3 /*break*/, 3];\n                        }\n                        else {\n                            outlet = outlet.parentOutlet;\n                        }\n                        return [3 /*break*/, 1];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This methods specifies the direction of the next navigation performed by the Angular router.\n     *\n     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\n     *\n     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\n     */\n    /**\n     * This methods specifies the direction of the next navigation performed by the Angular router.\n     *\n     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\n     *\n     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\n     * @param {?} direction\n     * @param {?=} animated\n     * @param {?=} animationDirection\n     * @return {?}\n     */\n    NavController.prototype.setDirection = /**\n     * This methods specifies the direction of the next navigation performed by the Angular router.\n     *\n     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\n     *\n     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\n     * @param {?} direction\n     * @param {?=} animated\n     * @param {?=} animationDirection\n     * @return {?}\n     */\n    function (direction, animated, animationDirection) {\n        this.direction = direction;\n        this.animated = getAnimation(direction, animated, animationDirection);\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} outlet\n     * @return {?}\n     */\n    NavController.prototype.setTopOutlet = /**\n     * \\@internal\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (outlet) {\n        this.topOutlet = outlet;\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    NavController.prototype.consumeTransition = /**\n     * \\@internal\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var direction = 'root';\n        /** @type {?} */\n        var animation;\n        if (this.direction === 'auto') {\n            direction = this.guessDirection;\n            animation = this.guessAnimation;\n        }\n        else {\n            animation = this.animated;\n            direction = this.direction;\n        }\n        this.direction = DEFAULT_DIRECTION;\n        this.animated = DEFAULT_ANIMATED;\n        return {\n            direction: direction,\n            animation: animation\n        };\n    };\n    /**\n     * @private\n     * @param {?} url\n     * @param {?} options\n     * @return {?}\n     */\n    NavController.prototype.navigate = /**\n     * @private\n     * @param {?} url\n     * @param {?} options\n     * @return {?}\n     */\n    function (url, options) {\n        if (Array.isArray(url)) {\n            return (/** @type {?} */ (this.router)).navigate(url, options);\n        }\n        else {\n            /**\n             * navigateByUrl ignores any properties that\n             * would change the url, so things like queryParams\n             * would be ignored unless we create a url tree\n             * More Info: https://github.com/angular/angular/issues/18798\n             * @type {?}\n             */\n            var urlTree = this.serializer.parse(url.toString());\n            if (options.queryParams !== undefined) {\n                urlTree.queryParams = __assign({}, options.queryParams);\n            }\n            if (options.fragment !== undefined) {\n                urlTree.fragment = options.fragment;\n            }\n            /**\n             * `navigateByUrl` will still apply `NavigationExtras` properties\n             * that do not modify the url, such as `replaceUrl` which is why\n             * `options` is passed in here.\n             */\n            return (/** @type {?} */ (this.router)).navigateByUrl(urlTree, options);\n        }\n    };\n    NavController.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root',\n                },] },\n    ];\n    /** @nocollapse */\n    NavController.ctorParameters = function () { return [\n        { type: Platform },\n        { type: Location },\n        { type: UrlSerializer },\n        { type: Router, decorators: [{ type: Optional }] }\n    ]; };\n    /** @nocollapse */ NavController.ngInjectableDef = defineInjectable({ factory: function NavController_Factory() { return new NavController(inject(Platform), inject(Location), inject(UrlSerializer), inject(Router, 8)); }, token: NavController, providedIn: \"root\" });\n    return NavController;\n}());\n/** @type {?} */\nvar getAnimation = (/**\n * @param {?} direction\n * @param {?} animated\n * @param {?} animationDirection\n * @return {?}\n */\nfunction (direction, animated, animationDirection) {\n    if (animated === false) {\n        return undefined;\n    }\n    if (animationDirection !== undefined) {\n        return animationDirection;\n    }\n    if (direction === 'forward' || direction === 'back') {\n        return direction;\n    }\n    else if (direction === 'root' && animated === true) {\n        return 'forward';\n    }\n    return undefined;\n});\n/** @type {?} */\nvar DEFAULT_DIRECTION = 'auto';\n/** @type {?} */\nvar DEFAULT_ANIMATED = undefined;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar proxyInputs = (/**\n * @param {?} Cmp\n * @param {?} inputs\n * @return {?}\n */\nfunction (Cmp, inputs) {\n    /** @type {?} */\n    var Prototype = Cmp.prototype;\n    inputs.forEach((/**\n     * @param {?} item\n     * @return {?}\n     */\n    function (item) {\n        Object.defineProperty(Prototype, item, {\n            get: /**\n             * @return {?}\n             */\n            function () { return this.el[item]; },\n            set: /**\n             * @param {?} val\n             * @return {?}\n             */\n            function (val) {\n                var _this = this;\n                this.z.runOutsideAngular((/**\n                 * @return {?}\n                 */\n                function () { return _this.el[item] = val; }));\n            },\n        });\n    }));\n});\n/** @type {?} */\nvar proxyMethods = (/**\n * @param {?} Cmp\n * @param {?} methods\n * @return {?}\n */\nfunction (Cmp, methods) {\n    /** @type {?} */\n    var Prototype = Cmp.prototype;\n    methods.forEach((/**\n     * @param {?} methodName\n     * @return {?}\n     */\n    function (methodName) {\n        Prototype[methodName] = (/**\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            /** @type {?} */\n            var args = arguments;\n            return this.z.runOutsideAngular((/**\n             * @return {?}\n             */\n            function () { return _this.el[methodName].apply(_this.el, args); }));\n        });\n    }));\n});\n/** @type {?} */\nvar proxyOutputs = (/**\n * @param {?} instance\n * @param {?} el\n * @param {?} events\n * @return {?}\n */\nfunction (instance, el, events) {\n    events.forEach((/**\n     * @param {?} eventName\n     * @return {?}\n     */\n    function (eventName) { return instance[eventName] = fromEvent(el, eventName); }));\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IonApp = /** @class */ (function () {\n    function IonApp(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonApp.decorators = [\n        { type: Component, args: [{ selector: 'ion-app', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' },] },\n    ];\n    /** @nocollapse */\n    IonApp.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonApp;\n}());\nvar IonAvatar = /** @class */ (function () {\n    function IonAvatar(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonAvatar.decorators = [\n        { type: Component, args: [{ selector: 'ion-avatar', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' },] },\n    ];\n    /** @nocollapse */\n    IonAvatar.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonAvatar;\n}());\nvar IonBackButton = /** @class */ (function () {\n    function IonBackButton(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonBackButton.decorators = [\n        { type: Component, args: [{ selector: 'ion-back-button', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'text', 'type'] },] },\n    ];\n    /** @nocollapse */\n    IonBackButton.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonBackButton;\n}());\nproxyInputs(IonBackButton, ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'text', 'type']);\nvar IonBackdrop = /** @class */ (function () {\n    function IonBackdrop(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionBackdropTap']);\n    }\n    IonBackdrop.decorators = [\n        { type: Component, args: [{ selector: 'ion-backdrop', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['stopPropagation', 'tappable', 'visible'] },] },\n    ];\n    /** @nocollapse */\n    IonBackdrop.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonBackdrop;\n}());\nproxyInputs(IonBackdrop, ['stopPropagation', 'tappable', 'visible']);\nvar IonBadge = /** @class */ (function () {\n    function IonBadge(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonBadge.decorators = [\n        { type: Component, args: [{ selector: 'ion-badge', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },\n    ];\n    /** @nocollapse */\n    IonBadge.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonBadge;\n}());\nproxyInputs(IonBadge, ['color', 'mode']);\nvar IonButton = /** @class */ (function () {\n    function IonButton(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);\n    }\n    IonButton.decorators = [\n        { type: Component, args: [{ selector: 'ion-button', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['buttonType', 'color', 'disabled', 'download', 'expand', 'fill', 'href', 'mode', 'rel', 'routerDirection', 'shape', 'size', 'strong', 'target', 'type'] },] },\n    ];\n    /** @nocollapse */\n    IonButton.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonButton;\n}());\nproxyInputs(IonButton, ['buttonType', 'color', 'disabled', 'download', 'expand', 'fill', 'href', 'mode', 'rel', 'routerDirection', 'shape', 'size', 'strong', 'target', 'type']);\nvar IonButtons = /** @class */ (function () {\n    function IonButtons(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonButtons.decorators = [\n        { type: Component, args: [{ selector: 'ion-buttons', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['collapse'] },] },\n    ];\n    /** @nocollapse */\n    IonButtons.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonButtons;\n}());\nproxyInputs(IonButtons, ['collapse']);\nvar IonCard = /** @class */ (function () {\n    function IonCard(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonCard.decorators = [\n        { type: Component, args: [{ selector: 'ion-card', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['button', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerDirection', 'target', 'type'] },] },\n    ];\n    /** @nocollapse */\n    IonCard.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonCard;\n}());\nproxyInputs(IonCard, ['button', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerDirection', 'target', 'type']);\nvar IonCardContent = /** @class */ (function () {\n    function IonCardContent(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonCardContent.decorators = [\n        { type: Component, args: [{ selector: 'ion-card-content', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['mode'] },] },\n    ];\n    /** @nocollapse */\n    IonCardContent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonCardContent;\n}());\nproxyInputs(IonCardContent, ['mode']);\nvar IonCardHeader = /** @class */ (function () {\n    function IonCardHeader(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonCardHeader.decorators = [\n        { type: Component, args: [{ selector: 'ion-card-header', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'translucent'] },] },\n    ];\n    /** @nocollapse */\n    IonCardHeader.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonCardHeader;\n}());\nproxyInputs(IonCardHeader, ['color', 'mode', 'translucent']);\nvar IonCardSubtitle = /** @class */ (function () {\n    function IonCardSubtitle(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonCardSubtitle.decorators = [\n        { type: Component, args: [{ selector: 'ion-card-subtitle', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },\n    ];\n    /** @nocollapse */\n    IonCardSubtitle.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonCardSubtitle;\n}());\nproxyInputs(IonCardSubtitle, ['color', 'mode']);\nvar IonCardTitle = /** @class */ (function () {\n    function IonCardTitle(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonCardTitle.decorators = [\n        { type: Component, args: [{ selector: 'ion-card-title', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },\n    ];\n    /** @nocollapse */\n    IonCardTitle.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonCardTitle;\n}());\nproxyInputs(IonCardTitle, ['color', 'mode']);\nvar IonCheckbox = /** @class */ (function () {\n    function IonCheckbox(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);\n    }\n    IonCheckbox.decorators = [\n        { type: Component, args: [{ selector: 'ion-checkbox', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['checked', 'color', 'disabled', 'indeterminate', 'mode', 'name', 'value'] },] },\n    ];\n    /** @nocollapse */\n    IonCheckbox.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonCheckbox;\n}());\nproxyInputs(IonCheckbox, ['checked', 'color', 'disabled', 'indeterminate', 'mode', 'name', 'value']);\nvar IonChip = /** @class */ (function () {\n    function IonChip(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonChip.decorators = [\n        { type: Component, args: [{ selector: 'ion-chip', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'outline'] },] },\n    ];\n    /** @nocollapse */\n    IonChip.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonChip;\n}());\nproxyInputs(IonChip, ['color', 'mode', 'outline']);\nvar IonCol = /** @class */ (function () {\n    function IonCol(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonCol.decorators = [\n        { type: Component, args: [{ selector: 'ion-col', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['offset', 'offsetLg', 'offsetMd', 'offsetSm', 'offsetXl', 'offsetXs', 'pull', 'pullLg', 'pullMd', 'pullSm', 'pullXl', 'pullXs', 'push', 'pushLg', 'pushMd', 'pushSm', 'pushXl', 'pushXs', 'size', 'sizeLg', 'sizeMd', 'sizeSm', 'sizeXl', 'sizeXs'] },] },\n    ];\n    /** @nocollapse */\n    IonCol.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonCol;\n}());\nproxyInputs(IonCol, ['offset', 'offsetLg', 'offsetMd', 'offsetSm', 'offsetXl', 'offsetXs', 'pull', 'pullLg', 'pullMd', 'pullSm', 'pullXl', 'pullXs', 'push', 'pushLg', 'pushMd', 'pushSm', 'pushXl', 'pushXs', 'size', 'sizeLg', 'sizeMd', 'sizeSm', 'sizeXl', 'sizeXs']);\nvar IonContent = /** @class */ (function () {\n    function IonContent(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionScrollStart', 'ionScroll', 'ionScrollEnd']);\n    }\n    IonContent.decorators = [\n        { type: Component, args: [{ selector: 'ion-content', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'forceOverscroll', 'fullscreen', 'scrollEvents', 'scrollX', 'scrollY'] },] },\n    ];\n    /** @nocollapse */\n    IonContent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonContent;\n}());\nproxyMethods(IonContent, ['getScrollElement', 'scrollToTop', 'scrollToBottom', 'scrollByPoint', 'scrollToPoint']);\nproxyInputs(IonContent, ['color', 'forceOverscroll', 'fullscreen', 'scrollEvents', 'scrollX', 'scrollY']);\nvar IonDatetime = /** @class */ (function () {\n    function IonDatetime(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionCancel', 'ionChange', 'ionFocus', 'ionBlur']);\n    }\n    IonDatetime.decorators = [\n        { type: Component, args: [{ selector: 'ion-datetime', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['cancelText', 'dayNames', 'dayShortNames', 'dayValues', 'disabled', 'displayFormat', 'doneText', 'hourValues', 'max', 'min', 'minuteValues', 'mode', 'monthNames', 'monthShortNames', 'monthValues', 'name', 'pickerFormat', 'pickerOptions', 'placeholder', 'readonly', 'value', 'yearValues'] },] },\n    ];\n    /** @nocollapse */\n    IonDatetime.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonDatetime;\n}());\nproxyMethods(IonDatetime, ['open']);\nproxyInputs(IonDatetime, ['cancelText', 'dayNames', 'dayShortNames', 'dayValues', 'disabled', 'displayFormat', 'doneText', 'hourValues', 'max', 'min', 'minuteValues', 'mode', 'monthNames', 'monthShortNames', 'monthValues', 'name', 'pickerFormat', 'pickerOptions', 'placeholder', 'readonly', 'value', 'yearValues']);\nvar IonFab = /** @class */ (function () {\n    function IonFab(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonFab.decorators = [\n        { type: Component, args: [{ selector: 'ion-fab', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['activated', 'edge', 'horizontal', 'vertical'] },] },\n    ];\n    /** @nocollapse */\n    IonFab.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonFab;\n}());\nproxyMethods(IonFab, ['close']);\nproxyInputs(IonFab, ['activated', 'edge', 'horizontal', 'vertical']);\nvar IonFabButton = /** @class */ (function () {\n    function IonFabButton(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);\n    }\n    IonFabButton.decorators = [\n        { type: Component, args: [{ selector: 'ion-fab-button', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['activated', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerDirection', 'show', 'size', 'target', 'translucent', 'type'] },] },\n    ];\n    /** @nocollapse */\n    IonFabButton.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonFabButton;\n}());\nproxyInputs(IonFabButton, ['activated', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerDirection', 'show', 'size', 'target', 'translucent', 'type']);\nvar IonFabList = /** @class */ (function () {\n    function IonFabList(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonFabList.decorators = [\n        { type: Component, args: [{ selector: 'ion-fab-list', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['activated', 'side'] },] },\n    ];\n    /** @nocollapse */\n    IonFabList.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonFabList;\n}());\nproxyInputs(IonFabList, ['activated', 'side']);\nvar IonFooter = /** @class */ (function () {\n    function IonFooter(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonFooter.decorators = [\n        { type: Component, args: [{ selector: 'ion-footer', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['mode', 'translucent'] },] },\n    ];\n    /** @nocollapse */\n    IonFooter.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonFooter;\n}());\nproxyInputs(IonFooter, ['mode', 'translucent']);\nvar IonGrid = /** @class */ (function () {\n    function IonGrid(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonGrid.decorators = [\n        { type: Component, args: [{ selector: 'ion-grid', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['fixed'] },] },\n    ];\n    /** @nocollapse */\n    IonGrid.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonGrid;\n}());\nproxyInputs(IonGrid, ['fixed']);\nvar IonHeader = /** @class */ (function () {\n    function IonHeader(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonHeader.decorators = [\n        { type: Component, args: [{ selector: 'ion-header', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['collapse', 'mode', 'translucent'] },] },\n    ];\n    /** @nocollapse */\n    IonHeader.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonHeader;\n}());\nproxyInputs(IonHeader, ['collapse', 'mode', 'translucent']);\nvar IonIcon = /** @class */ (function () {\n    function IonIcon(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonIcon.decorators = [\n        { type: Component, args: [{ selector: 'ion-icon', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['ariaLabel', 'color', 'flipRtl', 'icon', 'ios', 'lazy', 'md', 'mode', 'name', 'size', 'src'] },] },\n    ];\n    /** @nocollapse */\n    IonIcon.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonIcon;\n}());\nproxyInputs(IonIcon, ['ariaLabel', 'color', 'flipRtl', 'icon', 'ios', 'lazy', 'md', 'mode', 'name', 'size', 'src']);\nvar IonImg = /** @class */ (function () {\n    function IonImg(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionImgWillLoad', 'ionImgDidLoad', 'ionError']);\n    }\n    IonImg.decorators = [\n        { type: Component, args: [{ selector: 'ion-img', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['alt', 'src'] },] },\n    ];\n    /** @nocollapse */\n    IonImg.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonImg;\n}());\nproxyInputs(IonImg, ['alt', 'src']);\nvar IonInfiniteScroll = /** @class */ (function () {\n    function IonInfiniteScroll(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionInfinite']);\n    }\n    IonInfiniteScroll.decorators = [\n        { type: Component, args: [{ selector: 'ion-infinite-scroll', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['disabled', 'position', 'threshold'] },] },\n    ];\n    /** @nocollapse */\n    IonInfiniteScroll.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonInfiniteScroll;\n}());\nproxyMethods(IonInfiniteScroll, ['complete']);\nproxyInputs(IonInfiniteScroll, ['disabled', 'position', 'threshold']);\nvar IonInfiniteScrollContent = /** @class */ (function () {\n    function IonInfiniteScrollContent(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonInfiniteScrollContent.decorators = [\n        { type: Component, args: [{ selector: 'ion-infinite-scroll-content', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['loadingSpinner', 'loadingText'] },] },\n    ];\n    /** @nocollapse */\n    IonInfiniteScrollContent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonInfiniteScrollContent;\n}());\nproxyInputs(IonInfiniteScrollContent, ['loadingSpinner', 'loadingText']);\nvar IonInput = /** @class */ (function () {\n    function IonInput(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionBlur', 'ionFocus']);\n    }\n    IonInput.decorators = [\n        { type: Component, args: [{ selector: 'ion-input', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['accept', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearOnEdit', 'color', 'debounce', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'mode', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'spellcheck', 'step', 'type', 'value'] },] },\n    ];\n    /** @nocollapse */\n    IonInput.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonInput;\n}());\nproxyMethods(IonInput, ['setFocus', 'getInputElement']);\nproxyInputs(IonInput, ['accept', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearOnEdit', 'color', 'debounce', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'mode', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'spellcheck', 'step', 'type', 'value']);\nvar IonItem = /** @class */ (function () {\n    function IonItem(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonItem.decorators = [\n        { type: Component, args: [{ selector: 'ion-item', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['button', 'color', 'detail', 'detailIcon', 'disabled', 'download', 'href', 'lines', 'mode', 'rel', 'routerDirection', 'target', 'type'] },] },\n    ];\n    /** @nocollapse */\n    IonItem.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonItem;\n}());\nproxyInputs(IonItem, ['button', 'color', 'detail', 'detailIcon', 'disabled', 'download', 'href', 'lines', 'mode', 'rel', 'routerDirection', 'target', 'type']);\nvar IonItemDivider = /** @class */ (function () {\n    function IonItemDivider(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonItemDivider.decorators = [\n        { type: Component, args: [{ selector: 'ion-item-divider', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'sticky'] },] },\n    ];\n    /** @nocollapse */\n    IonItemDivider.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonItemDivider;\n}());\nproxyInputs(IonItemDivider, ['color', 'mode', 'sticky']);\nvar IonItemGroup = /** @class */ (function () {\n    function IonItemGroup(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonItemGroup.decorators = [\n        { type: Component, args: [{ selector: 'ion-item-group', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' },] },\n    ];\n    /** @nocollapse */\n    IonItemGroup.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonItemGroup;\n}());\nvar IonItemOption = /** @class */ (function () {\n    function IonItemOption(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonItemOption.decorators = [\n        { type: Component, args: [{ selector: 'ion-item-option', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'disabled', 'download', 'expandable', 'href', 'mode', 'rel', 'target', 'type'] },] },\n    ];\n    /** @nocollapse */\n    IonItemOption.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonItemOption;\n}());\nproxyInputs(IonItemOption, ['color', 'disabled', 'download', 'expandable', 'href', 'mode', 'rel', 'target', 'type']);\nvar IonItemOptions = /** @class */ (function () {\n    function IonItemOptions(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionSwipe']);\n    }\n    IonItemOptions.decorators = [\n        { type: Component, args: [{ selector: 'ion-item-options', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['side'] },] },\n    ];\n    /** @nocollapse */\n    IonItemOptions.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonItemOptions;\n}());\nproxyInputs(IonItemOptions, ['side']);\nvar IonItemSliding = /** @class */ (function () {\n    function IonItemSliding(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionDrag']);\n    }\n    IonItemSliding.decorators = [\n        { type: Component, args: [{ selector: 'ion-item-sliding', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['disabled'] },] },\n    ];\n    /** @nocollapse */\n    IonItemSliding.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonItemSliding;\n}());\nproxyMethods(IonItemSliding, ['getOpenAmount', 'getSlidingRatio', 'open', 'close', 'closeOpened']);\nproxyInputs(IonItemSliding, ['disabled']);\nvar IonLabel = /** @class */ (function () {\n    function IonLabel(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonLabel.decorators = [\n        { type: Component, args: [{ selector: 'ion-label', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'position'] },] },\n    ];\n    /** @nocollapse */\n    IonLabel.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonLabel;\n}());\nproxyInputs(IonLabel, ['color', 'mode', 'position']);\nvar IonList = /** @class */ (function () {\n    function IonList(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonList.decorators = [\n        { type: Component, args: [{ selector: 'ion-list', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['inset', 'lines', 'mode'] },] },\n    ];\n    /** @nocollapse */\n    IonList.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonList;\n}());\nproxyMethods(IonList, ['closeSlidingItems']);\nproxyInputs(IonList, ['inset', 'lines', 'mode']);\nvar IonListHeader = /** @class */ (function () {\n    function IonListHeader(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonListHeader.decorators = [\n        { type: Component, args: [{ selector: 'ion-list-header', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },\n    ];\n    /** @nocollapse */\n    IonListHeader.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonListHeader;\n}());\nproxyInputs(IonListHeader, ['color', 'mode']);\nvar IonMenu = /** @class */ (function () {\n    function IonMenu(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionWillOpen', 'ionWillClose', 'ionDidOpen', 'ionDidClose']);\n    }\n    IonMenu.decorators = [\n        { type: Component, args: [{ selector: 'ion-menu', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['contentId', 'disabled', 'maxEdgeStart', 'menuId', 'side', 'swipeGesture', 'type'] },] },\n    ];\n    /** @nocollapse */\n    IonMenu.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonMenu;\n}());\nproxyMethods(IonMenu, ['isOpen', 'isActive', 'open', 'close', 'toggle', 'setOpen']);\nproxyInputs(IonMenu, ['contentId', 'disabled', 'maxEdgeStart', 'menuId', 'side', 'swipeGesture', 'type']);\nvar IonMenuButton = /** @class */ (function () {\n    function IonMenuButton(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonMenuButton.decorators = [\n        { type: Component, args: [{ selector: 'ion-menu-button', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['autoHide', 'color', 'disabled', 'menu', 'type'] },] },\n    ];\n    /** @nocollapse */\n    IonMenuButton.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonMenuButton;\n}());\nproxyInputs(IonMenuButton, ['autoHide', 'color', 'disabled', 'menu', 'type']);\nvar IonMenuToggle = /** @class */ (function () {\n    function IonMenuToggle(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonMenuToggle.decorators = [\n        { type: Component, args: [{ selector: 'ion-menu-toggle', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['autoHide', 'menu'] },] },\n    ];\n    /** @nocollapse */\n    IonMenuToggle.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonMenuToggle;\n}());\nproxyInputs(IonMenuToggle, ['autoHide', 'menu']);\nvar IonNav = /** @class */ (function () {\n    function IonNav(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionNavWillChange', 'ionNavDidChange']);\n    }\n    IonNav.decorators = [\n        { type: Component, args: [{ selector: 'ion-nav', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'] },] },\n    ];\n    /** @nocollapse */\n    IonNav.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonNav;\n}());\nproxyMethods(IonNav, ['push', 'insert', 'insertPages', 'pop', 'popTo', 'popToRoot', 'removeIndex', 'setRoot', 'setPages', 'getActive', 'getByIndex', 'canGoBack', 'getPrevious']);\nproxyInputs(IonNav, ['animated', 'animation', 'root', 'rootParams', 'swipeGesture']);\nvar IonNavLink = /** @class */ (function () {\n    function IonNavLink(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonNavLink.decorators = [\n        { type: Component, args: [{ selector: 'ion-nav-link', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['component', 'componentProps', 'routerDirection'] },] },\n    ];\n    /** @nocollapse */\n    IonNavLink.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonNavLink;\n}());\nproxyInputs(IonNavLink, ['component', 'componentProps', 'routerDirection']);\nvar IonNavPop = /** @class */ (function () {\n    function IonNavPop(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonNavPop.decorators = [\n        { type: Component, args: [{ selector: 'ion-nav-pop', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' },] },\n    ];\n    /** @nocollapse */\n    IonNavPop.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonNavPop;\n}());\nvar IonNavPush = /** @class */ (function () {\n    function IonNavPush(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonNavPush.decorators = [\n        { type: Component, args: [{ selector: 'ion-nav-push', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['component', 'componentProps'] },] },\n    ];\n    /** @nocollapse */\n    IonNavPush.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonNavPush;\n}());\nproxyInputs(IonNavPush, ['component', 'componentProps']);\nvar IonNavSetRoot = /** @class */ (function () {\n    function IonNavSetRoot(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonNavSetRoot.decorators = [\n        { type: Component, args: [{ selector: 'ion-nav-set-root', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['component', 'componentProps'] },] },\n    ];\n    /** @nocollapse */\n    IonNavSetRoot.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonNavSetRoot;\n}());\nproxyInputs(IonNavSetRoot, ['component', 'componentProps']);\nvar IonNote = /** @class */ (function () {\n    function IonNote(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonNote.decorators = [\n        { type: Component, args: [{ selector: 'ion-note', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },\n    ];\n    /** @nocollapse */\n    IonNote.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonNote;\n}());\nproxyInputs(IonNote, ['color', 'mode']);\nvar IonProgressBar = /** @class */ (function () {\n    function IonProgressBar(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonProgressBar.decorators = [\n        { type: Component, args: [{ selector: 'ion-progress-bar', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['buffer', 'color', 'mode', 'reversed', 'type', 'value'] },] },\n    ];\n    /** @nocollapse */\n    IonProgressBar.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonProgressBar;\n}());\nproxyInputs(IonProgressBar, ['buffer', 'color', 'mode', 'reversed', 'type', 'value']);\nvar IonRadio = /** @class */ (function () {\n    function IonRadio(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionSelect', 'ionFocus', 'ionBlur']);\n    }\n    IonRadio.decorators = [\n        { type: Component, args: [{ selector: 'ion-radio', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['checked', 'color', 'disabled', 'mode', 'name', 'value'] },] },\n    ];\n    /** @nocollapse */\n    IonRadio.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonRadio;\n}());\nproxyInputs(IonRadio, ['checked', 'color', 'disabled', 'mode', 'name', 'value']);\nvar IonRadioGroup = /** @class */ (function () {\n    function IonRadioGroup(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionChange']);\n    }\n    IonRadioGroup.decorators = [\n        { type: Component, args: [{ selector: 'ion-radio-group', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['allowEmptySelection', 'name', 'value'] },] },\n    ];\n    /** @nocollapse */\n    IonRadioGroup.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonRadioGroup;\n}());\nproxyInputs(IonRadioGroup, ['allowEmptySelection', 'name', 'value']);\nvar IonRange = /** @class */ (function () {\n    function IonRange(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);\n    }\n    IonRange.decorators = [\n        { type: Component, args: [{ selector: 'ion-range', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'debounce', 'disabled', 'dualKnobs', 'max', 'min', 'mode', 'name', 'pin', 'snaps', 'step', 'ticks', 'value'] },] },\n    ];\n    /** @nocollapse */\n    IonRange.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonRange;\n}());\nproxyInputs(IonRange, ['color', 'debounce', 'disabled', 'dualKnobs', 'max', 'min', 'mode', 'name', 'pin', 'snaps', 'step', 'ticks', 'value']);\nvar IonRefresher = /** @class */ (function () {\n    function IonRefresher(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionRefresh', 'ionPull', 'ionStart']);\n    }\n    IonRefresher.decorators = [\n        { type: Component, args: [{ selector: 'ion-refresher', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['closeDuration', 'disabled', 'pullFactor', 'pullMax', 'pullMin', 'snapbackDuration'] },] },\n    ];\n    /** @nocollapse */\n    IonRefresher.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonRefresher;\n}());\nproxyMethods(IonRefresher, ['complete', 'cancel', 'getProgress']);\nproxyInputs(IonRefresher, ['closeDuration', 'disabled', 'pullFactor', 'pullMax', 'pullMin', 'snapbackDuration']);\nvar IonRefresherContent = /** @class */ (function () {\n    function IonRefresherContent(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonRefresherContent.decorators = [\n        { type: Component, args: [{ selector: 'ion-refresher-content', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText'] },] },\n    ];\n    /** @nocollapse */\n    IonRefresherContent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonRefresherContent;\n}());\nproxyInputs(IonRefresherContent, ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText']);\nvar IonReorder = /** @class */ (function () {\n    function IonReorder(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonReorder.decorators = [\n        { type: Component, args: [{ selector: 'ion-reorder', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' },] },\n    ];\n    /** @nocollapse */\n    IonReorder.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonReorder;\n}());\nvar IonReorderGroup = /** @class */ (function () {\n    function IonReorderGroup(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionItemReorder']);\n    }\n    IonReorderGroup.decorators = [\n        { type: Component, args: [{ selector: 'ion-reorder-group', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['disabled'] },] },\n    ];\n    /** @nocollapse */\n    IonReorderGroup.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonReorderGroup;\n}());\nproxyMethods(IonReorderGroup, ['complete']);\nproxyInputs(IonReorderGroup, ['disabled']);\nvar IonRippleEffect = /** @class */ (function () {\n    function IonRippleEffect(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonRippleEffect.decorators = [\n        { type: Component, args: [{ selector: 'ion-ripple-effect', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['type'] },] },\n    ];\n    /** @nocollapse */\n    IonRippleEffect.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonRippleEffect;\n}());\nproxyMethods(IonRippleEffect, ['addRipple']);\nproxyInputs(IonRippleEffect, ['type']);\nvar IonRow = /** @class */ (function () {\n    function IonRow(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonRow.decorators = [\n        { type: Component, args: [{ selector: 'ion-row', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' },] },\n    ];\n    /** @nocollapse */\n    IonRow.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonRow;\n}());\nvar IonSearchbar = /** @class */ (function () {\n    function IonSearchbar(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionCancel', 'ionClear', 'ionBlur', 'ionFocus']);\n    }\n    IonSearchbar.decorators = [\n        { type: Component, args: [{ selector: 'ion-searchbar', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['animated', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'color', 'debounce', 'disabled', 'inputmode', 'mode', 'placeholder', 'searchIcon', 'showCancelButton', 'spellcheck', 'type', 'value'] },] },\n    ];\n    /** @nocollapse */\n    IonSearchbar.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonSearchbar;\n}());\nproxyMethods(IonSearchbar, ['setFocus', 'getInputElement']);\nproxyInputs(IonSearchbar, ['animated', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'color', 'debounce', 'disabled', 'inputmode', 'mode', 'placeholder', 'searchIcon', 'showCancelButton', 'spellcheck', 'type', 'value']);\nvar IonSegment = /** @class */ (function () {\n    function IonSegment(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionChange']);\n    }\n    IonSegment.decorators = [\n        { type: Component, args: [{ selector: 'ion-segment', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'disabled', 'mode', 'scrollable', 'value'] },] },\n    ];\n    /** @nocollapse */\n    IonSegment.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonSegment;\n}());\nproxyInputs(IonSegment, ['color', 'disabled', 'mode', 'scrollable', 'value']);\nvar IonSegmentButton = /** @class */ (function () {\n    function IonSegmentButton(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionSelect']);\n    }\n    IonSegmentButton.decorators = [\n        { type: Component, args: [{ selector: 'ion-segment-button', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['checked', 'disabled', 'layout', 'mode', 'type', 'value'] },] },\n    ];\n    /** @nocollapse */\n    IonSegmentButton.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonSegmentButton;\n}());\nproxyInputs(IonSegmentButton, ['checked', 'disabled', 'layout', 'mode', 'type', 'value']);\nvar IonSelect = /** @class */ (function () {\n    function IonSelect(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionChange', 'ionCancel', 'ionFocus', 'ionBlur']);\n    }\n    IonSelect.decorators = [\n        { type: Component, args: [{ selector: 'ion-select', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['cancelText', 'compareWith', 'disabled', 'interface', 'interfaceOptions', 'mode', 'multiple', 'name', 'okText', 'placeholder', 'selectedText', 'value'] },] },\n    ];\n    /** @nocollapse */\n    IonSelect.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonSelect;\n}());\nproxyMethods(IonSelect, ['open']);\nproxyInputs(IonSelect, ['cancelText', 'compareWith', 'disabled', 'interface', 'interfaceOptions', 'mode', 'multiple', 'name', 'okText', 'placeholder', 'selectedText', 'value']);\nvar IonSelectOption = /** @class */ (function () {\n    function IonSelectOption(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonSelectOption.decorators = [\n        { type: Component, args: [{ selector: 'ion-select-option', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['disabled', 'selected', 'value'] },] },\n    ];\n    /** @nocollapse */\n    IonSelectOption.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonSelectOption;\n}());\nproxyInputs(IonSelectOption, ['disabled', 'selected', 'value']);\nvar IonSkeletonText = /** @class */ (function () {\n    function IonSkeletonText(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonSkeletonText.decorators = [\n        { type: Component, args: [{ selector: 'ion-skeleton-text', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['animated', 'width'] },] },\n    ];\n    /** @nocollapse */\n    IonSkeletonText.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonSkeletonText;\n}());\nproxyInputs(IonSkeletonText, ['animated', 'width']);\nvar IonSlide = /** @class */ (function () {\n    function IonSlide(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonSlide.decorators = [\n        { type: Component, args: [{ selector: 'ion-slide', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' },] },\n    ];\n    /** @nocollapse */\n    IonSlide.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonSlide;\n}());\nvar IonSlides = /** @class */ (function () {\n    function IonSlides(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionSlidesDidLoad', 'ionSlideTap', 'ionSlideDoubleTap', 'ionSlideWillChange', 'ionSlideDidChange', 'ionSlideNextStart', 'ionSlidePrevStart', 'ionSlideNextEnd', 'ionSlidePrevEnd', 'ionSlideTransitionStart', 'ionSlideTransitionEnd', 'ionSlideDrag', 'ionSlideReachStart', 'ionSlideReachEnd', 'ionSlideTouchStart', 'ionSlideTouchEnd']);\n    }\n    IonSlides.decorators = [\n        { type: Component, args: [{ selector: 'ion-slides', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['mode', 'options', 'pager', 'scrollbar'] },] },\n    ];\n    /** @nocollapse */\n    IonSlides.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonSlides;\n}());\nproxyMethods(IonSlides, ['update', 'updateAutoHeight', 'slideTo', 'slideNext', 'slidePrev', 'getActiveIndex', 'getPreviousIndex', 'length', 'isEnd', 'isBeginning', 'startAutoplay', 'stopAutoplay', 'lockSwipeToNext', 'lockSwipeToPrev', 'lockSwipes', 'getSwiper']);\nproxyInputs(IonSlides, ['mode', 'options', 'pager', 'scrollbar']);\nvar IonSpinner = /** @class */ (function () {\n    function IonSpinner(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonSpinner.decorators = [\n        { type: Component, args: [{ selector: 'ion-spinner', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'duration', 'name', 'paused'] },] },\n    ];\n    /** @nocollapse */\n    IonSpinner.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonSpinner;\n}());\nproxyInputs(IonSpinner, ['color', 'duration', 'name', 'paused']);\nvar IonSplitPane = /** @class */ (function () {\n    function IonSplitPane(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionSplitPaneVisible']);\n    }\n    IonSplitPane.decorators = [\n        { type: Component, args: [{ selector: 'ion-split-pane', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['contentId', 'disabled', 'when'] },] },\n    ];\n    /** @nocollapse */\n    IonSplitPane.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonSplitPane;\n}());\nproxyInputs(IonSplitPane, ['contentId', 'disabled', 'when']);\nvar IonTabBar = /** @class */ (function () {\n    function IonTabBar(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonTabBar.decorators = [\n        { type: Component, args: [{ selector: 'ion-tab-bar', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'selectedTab', 'translucent'] },] },\n    ];\n    /** @nocollapse */\n    IonTabBar.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonTabBar;\n}());\nproxyInputs(IonTabBar, ['color', 'mode', 'selectedTab', 'translucent']);\nvar IonTabButton = /** @class */ (function () {\n    function IonTabButton(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonTabButton.decorators = [\n        { type: Component, args: [{ selector: 'ion-tab-button', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['disabled', 'download', 'href', 'layout', 'mode', 'rel', 'selected', 'tab', 'target'] },] },\n    ];\n    /** @nocollapse */\n    IonTabButton.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonTabButton;\n}());\nproxyInputs(IonTabButton, ['disabled', 'download', 'href', 'layout', 'mode', 'rel', 'selected', 'tab', 'target']);\nvar IonText = /** @class */ (function () {\n    function IonText(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonText.decorators = [\n        { type: Component, args: [{ selector: 'ion-text', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },\n    ];\n    /** @nocollapse */\n    IonText.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonText;\n}());\nproxyInputs(IonText, ['color', 'mode']);\nvar IonTextarea = /** @class */ (function () {\n    function IonTextarea(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionChange', 'ionInput', 'ionBlur', 'ionFocus']);\n    }\n    IonTextarea.decorators = [\n        { type: Component, args: [{ selector: 'ion-textarea', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['autoGrow', 'autocapitalize', 'autofocus', 'clearOnEdit', 'color', 'cols', 'debounce', 'disabled', 'maxlength', 'minlength', 'mode', 'name', 'placeholder', 'readonly', 'required', 'rows', 'spellcheck', 'value', 'wrap'] },] },\n    ];\n    /** @nocollapse */\n    IonTextarea.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonTextarea;\n}());\nproxyMethods(IonTextarea, ['setFocus', 'getInputElement']);\nproxyInputs(IonTextarea, ['autoGrow', 'autocapitalize', 'autofocus', 'clearOnEdit', 'color', 'cols', 'debounce', 'disabled', 'maxlength', 'minlength', 'mode', 'name', 'placeholder', 'readonly', 'required', 'rows', 'spellcheck', 'value', 'wrap']);\nvar IonThumbnail = /** @class */ (function () {\n    function IonThumbnail(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonThumbnail.decorators = [\n        { type: Component, args: [{ selector: 'ion-thumbnail', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' },] },\n    ];\n    /** @nocollapse */\n    IonThumbnail.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonThumbnail;\n}());\nvar IonTitle = /** @class */ (function () {\n    function IonTitle(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonTitle.decorators = [\n        { type: Component, args: [{ selector: 'ion-title', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'size'] },] },\n    ];\n    /** @nocollapse */\n    IonTitle.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonTitle;\n}());\nproxyInputs(IonTitle, ['color', 'size']);\nvar IonToggle = /** @class */ (function () {\n    function IonToggle(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n        proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);\n    }\n    IonToggle.decorators = [\n        { type: Component, args: [{ selector: 'ion-toggle', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['checked', 'color', 'disabled', 'mode', 'name', 'value'] },] },\n    ];\n    /** @nocollapse */\n    IonToggle.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonToggle;\n}());\nproxyInputs(IonToggle, ['checked', 'color', 'disabled', 'mode', 'name', 'value']);\nvar IonToolbar = /** @class */ (function () {\n    function IonToolbar(c, r, z) {\n        this.z = z;\n        c.detach();\n        this.el = r.nativeElement;\n    }\n    IonToolbar.decorators = [\n        { type: Component, args: [{ selector: 'ion-toolbar', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },\n    ];\n    /** @nocollapse */\n    IonToolbar.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return IonToolbar;\n}());\nproxyInputs(IonToolbar, ['color', 'mode']);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar Config = /** @class */ (function () {\n    function Config() {\n    }\n    /**\n     * @param {?} key\n     * @param {?=} fallback\n     * @return {?}\n     */\n    Config.prototype.get = /**\n     * @param {?} key\n     * @param {?=} fallback\n     * @return {?}\n     */\n    function (key, fallback) {\n        /** @type {?} */\n        var c = getConfig();\n        if (c) {\n            return c.get(key, fallback);\n        }\n        return null;\n    };\n    /**\n     * @param {?} key\n     * @param {?=} fallback\n     * @return {?}\n     */\n    Config.prototype.getBoolean = /**\n     * @param {?} key\n     * @param {?=} fallback\n     * @return {?}\n     */\n    function (key, fallback) {\n        /** @type {?} */\n        var c = getConfig();\n        if (c) {\n            return c.getBoolean(key, fallback);\n        }\n        return false;\n    };\n    /**\n     * @param {?} key\n     * @param {?=} fallback\n     * @return {?}\n     */\n    Config.prototype.getNumber = /**\n     * @param {?} key\n     * @param {?=} fallback\n     * @return {?}\n     */\n    function (key, fallback) {\n        /** @type {?} */\n        var c = getConfig();\n        if (c) {\n            return c.getNumber(key, fallback);\n        }\n        return 0;\n    };\n    /**\n     * @param {?} key\n     * @param {?=} value\n     * @return {?}\n     */\n    Config.prototype.set = /**\n     * @param {?} key\n     * @param {?=} value\n     * @return {?}\n     */\n    function (key, value) {\n        console.warn(\"[DEPRECATION][Config]: The Config.set() method is deprecated and will be removed in the next major release.\");\n        /** @type {?} */\n        var c = getConfig();\n        if (c) {\n            c.set(key, value);\n        }\n    };\n    Config.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root'\n                },] },\n    ];\n    /** @nocollapse */ Config.ngInjectableDef = defineInjectable({ factory: function Config_Factory() { return new Config(); }, token: Config, providedIn: \"root\" });\n    return Config;\n}());\n/** @type {?} */\nvar ConfigToken = new InjectionToken('USERCONFIG');\n/** @type {?} */\nvar getConfig = (/**\n * @return {?}\n */\nfunction () {\n    if (typeof ((/** @type {?} */ (window))) !== 'undefined') {\n        /** @type {?} */\n        var Ionic = ((/** @type {?} */ ((/** @type {?} */ (window))))).Ionic;\n        if (Ionic && Ionic.config) {\n            return Ionic.config;\n        }\n    }\n    return null;\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * \\@description\n * NavParams are an object that exists on a page and can contain data for that particular view.\n * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible\n * option with a simple `get` method.\n *\n * \\@usage\n * ```ts\n * import { NavParams } from '\\@ionic/angular';\n *\n * export class MyClass{\n *\n *  constructor(navParams: NavParams){\n *    // userParams is an object we have in our nav-parameters\n *    navParams.get('userParams');\n *  }\n *\n * }\n * ```\n */\nvar  /**\n * \\@description\n * NavParams are an object that exists on a page and can contain data for that particular view.\n * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible\n * option with a simple `get` method.\n *\n * \\@usage\n * ```ts\n * import { NavParams } from '\\@ionic/angular';\n *\n * export class MyClass{\n *\n *  constructor(navParams: NavParams){\n *    // userParams is an object we have in our nav-parameters\n *    navParams.get('userParams');\n *  }\n *\n * }\n * ```\n */\nNavParams = /** @class */ (function () {\n    function NavParams(data) {\n        if (data === void 0) { data = {}; }\n        this.data = data;\n    }\n    /**\n     * Get the value of a nav-parameter for the current view\n     *\n     * ```ts\n     * import { NavParams } from 'ionic-angular';\n     *\n     * export class MyClass{\n     *  constructor(public navParams: NavParams){\n     *    // userParams is an object we have in our nav-parameters\n     *    this.navParams.get('userParams');\n     *  }\n     * }\n     * ```\n     *\n     * @param param Which param you want to look up\n     */\n    /**\n     * Get the value of a nav-parameter for the current view\n     *\n     * ```ts\n     * import { NavParams } from 'ionic-angular';\n     *\n     * export class MyClass{\n     *  constructor(public navParams: NavParams){\n     *    // userParams is an object we have in our nav-parameters\n     *    this.navParams.get('userParams');\n     *  }\n     * }\n     * ```\n     *\n     * @param {?} param Which param you want to look up\n     * @return {?}\n     */\n    NavParams.prototype.get = /**\n     * Get the value of a nav-parameter for the current view\n     *\n     * ```ts\n     * import { NavParams } from 'ionic-angular';\n     *\n     * export class MyClass{\n     *  constructor(public navParams: NavParams){\n     *    // userParams is an object we have in our nav-parameters\n     *    this.navParams.get('userParams');\n     *  }\n     * }\n     * ```\n     *\n     * @param {?} param Which param you want to look up\n     * @return {?}\n     */\n    function (param) {\n        return this.data[param];\n    };\n    return NavParams;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar AngularDelegate = /** @class */ (function () {\n    function AngularDelegate(zone, appRef) {\n        this.zone = zone;\n        this.appRef = appRef;\n    }\n    /**\n     * @param {?} resolver\n     * @param {?} injector\n     * @param {?=} location\n     * @return {?}\n     */\n    AngularDelegate.prototype.create = /**\n     * @param {?} resolver\n     * @param {?} injector\n     * @param {?=} location\n     * @return {?}\n     */\n    function (resolver, injector, location) {\n        return new AngularFrameworkDelegate(resolver, injector, location, this.appRef, this.zone);\n    };\n    AngularDelegate.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    AngularDelegate.ctorParameters = function () { return [\n        { type: NgZone },\n        { type: ApplicationRef }\n    ]; };\n    return AngularDelegate;\n}());\nvar AngularFrameworkDelegate = /** @class */ (function () {\n    function AngularFrameworkDelegate(resolver, injector, location, appRef, zone) {\n        this.resolver = resolver;\n        this.injector = injector;\n        this.location = location;\n        this.appRef = appRef;\n        this.zone = zone;\n        this.elRefMap = new WeakMap();\n        this.elEventsMap = new WeakMap();\n    }\n    /**\n     * @param {?} container\n     * @param {?} component\n     * @param {?=} params\n     * @param {?=} cssClasses\n     * @return {?}\n     */\n    AngularFrameworkDelegate.prototype.attachViewToDom = /**\n     * @param {?} container\n     * @param {?} component\n     * @param {?=} params\n     * @param {?=} cssClasses\n     * @return {?}\n     */\n    function (container, component, params, cssClasses) {\n        var _this = this;\n        return this.zone.run((/**\n         * @return {?}\n         */\n        function () {\n            return new Promise((/**\n             * @param {?} resolve\n             * @return {?}\n             */\n            function (resolve) {\n                /** @type {?} */\n                var el = attachView(_this.zone, _this.resolver, _this.injector, _this.location, _this.appRef, _this.elRefMap, _this.elEventsMap, container, component, params, cssClasses);\n                resolve(el);\n            }));\n        }));\n    };\n    /**\n     * @param {?} _container\n     * @param {?} component\n     * @return {?}\n     */\n    AngularFrameworkDelegate.prototype.removeViewFromDom = /**\n     * @param {?} _container\n     * @param {?} component\n     * @return {?}\n     */\n    function (_container, component) {\n        var _this = this;\n        return this.zone.run((/**\n         * @return {?}\n         */\n        function () {\n            return new Promise((/**\n             * @param {?} resolve\n             * @return {?}\n             */\n            function (resolve) {\n                /** @type {?} */\n                var componentRef = _this.elRefMap.get(component);\n                if (componentRef) {\n                    componentRef.destroy();\n                    _this.elRefMap.delete(component);\n                    /** @type {?} */\n                    var unbindEvents = _this.elEventsMap.get(component);\n                    if (unbindEvents) {\n                        unbindEvents();\n                        _this.elEventsMap.delete(component);\n                    }\n                }\n                resolve();\n            }));\n        }));\n    };\n    return AngularFrameworkDelegate;\n}());\n/** @type {?} */\nvar attachView = (/**\n * @param {?} zone\n * @param {?} resolver\n * @param {?} injector\n * @param {?} location\n * @param {?} appRef\n * @param {?} elRefMap\n * @param {?} elEventsMap\n * @param {?} container\n * @param {?} component\n * @param {?} params\n * @param {?} cssClasses\n * @return {?}\n */\nfunction (zone, resolver, injector, location, appRef, elRefMap, elEventsMap, container, component, params, cssClasses) {\n    /** @type {?} */\n    var factory = resolver.resolveComponentFactory(component);\n    /** @type {?} */\n    var childInjector = Injector.create({\n        providers: getProviders(params),\n        parent: injector\n    });\n    /** @type {?} */\n    var componentRef = (location)\n        ? location.createComponent(factory, location.length, childInjector)\n        : factory.create(childInjector);\n    /** @type {?} */\n    var instance = componentRef.instance;\n    /** @type {?} */\n    var hostElement = componentRef.location.nativeElement;\n    if (params) {\n        Object.assign(instance, params);\n    }\n    if (cssClasses) {\n        for (var _i = 0, cssClasses_1 = cssClasses; _i < cssClasses_1.length; _i++) {\n            var clazz = cssClasses_1[_i];\n            hostElement.classList.add(clazz);\n        }\n    }\n    /** @type {?} */\n    var unbindEvents = bindLifecycleEvents(zone, instance, hostElement);\n    container.appendChild(hostElement);\n    if (!location) {\n        appRef.attachView(componentRef.hostView);\n    }\n    componentRef.changeDetectorRef.reattach();\n    elRefMap.set(hostElement, componentRef);\n    elEventsMap.set(hostElement, unbindEvents);\n    return hostElement;\n});\n/** @type {?} */\nvar LIFECYCLES = [\n    LIFECYCLE_WILL_ENTER,\n    LIFECYCLE_DID_ENTER,\n    LIFECYCLE_WILL_LEAVE,\n    LIFECYCLE_DID_LEAVE,\n    LIFECYCLE_WILL_UNLOAD\n];\n/** @type {?} */\nvar bindLifecycleEvents = (/**\n * @param {?} zone\n * @param {?} instance\n * @param {?} element\n * @return {?}\n */\nfunction (zone, instance, element) {\n    return zone.run((/**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var unregisters = LIFECYCLES\n            .filter((/**\n         * @param {?} eventName\n         * @return {?}\n         */\n        function (eventName) { return typeof instance[eventName] === 'function'; }))\n            .map((/**\n         * @param {?} eventName\n         * @return {?}\n         */\n        function (eventName) {\n            /** @type {?} */\n            var handler = (/**\n             * @param {?} ev\n             * @return {?}\n             */\n            function (ev) { return instance[eventName](ev.detail); });\n            element.addEventListener(eventName, handler);\n            return (/**\n             * @return {?}\n             */\n            function () { return element.removeEventListener(eventName, handler); });\n        }));\n        return (/**\n         * @return {?}\n         */\n        function () { return unregisters.forEach((/**\n         * @param {?} fn\n         * @return {?}\n         */\n        function (fn) { return fn(); })); });\n    }));\n});\n/** @type {?} */\nvar NavParamsToken = new InjectionToken('NavParamsToken');\n/** @type {?} */\nvar getProviders = (/**\n * @param {?} params\n * @return {?}\n */\nfunction (params) {\n    return [\n        {\n            provide: NavParamsToken, useValue: params\n        },\n        {\n            provide: NavParams, useFactory: provideNavParamsInjectable, deps: [NavParamsToken]\n        }\n    ];\n});\n/** @type {?} */\nvar provideNavParamsInjectable = (/**\n * @param {?} params\n * @return {?}\n */\nfunction (params) {\n    return new NavParams(params);\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar insertView = (/**\n * @param {?} views\n * @param {?} view\n * @param {?} direction\n * @return {?}\n */\nfunction (views, view, direction) {\n    if (direction === 'root') {\n        return setRoot(views, view);\n    }\n    else if (direction === 'forward') {\n        return setForward(views, view);\n    }\n    else {\n        return setBack(views, view);\n    }\n});\n/** @type {?} */\nvar setRoot = (/**\n * @param {?} views\n * @param {?} view\n * @return {?}\n */\nfunction (views, view) {\n    views = views.filter((/**\n     * @param {?} v\n     * @return {?}\n     */\n    function (v) { return v.stackId !== view.stackId; }));\n    views.push(view);\n    return views;\n});\n/** @type {?} */\nvar setForward = (/**\n * @param {?} views\n * @param {?} view\n * @return {?}\n */\nfunction (views, view) {\n    /** @type {?} */\n    var index = views.indexOf(view);\n    if (index >= 0) {\n        views = views.filter((/**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { return v.stackId !== view.stackId || v.id <= view.id; }));\n    }\n    else {\n        views.push(view);\n    }\n    return views;\n});\n/** @type {?} */\nvar setBack = (/**\n * @param {?} views\n * @param {?} view\n * @return {?}\n */\nfunction (views, view) {\n    /** @type {?} */\n    var index = views.indexOf(view);\n    if (index >= 0) {\n        return views.filter((/**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { return v.stackId !== view.stackId || v.id <= view.id; }));\n    }\n    else {\n        return setRoot(views, view);\n    }\n});\n/** @type {?} */\nvar getUrl = (/**\n * @param {?} router\n * @param {?} activatedRoute\n * @return {?}\n */\nfunction (router, activatedRoute) {\n    /** @type {?} */\n    var urlTree = router.createUrlTree(['.'], { relativeTo: activatedRoute });\n    return router.serializeUrl(urlTree);\n});\n/** @type {?} */\nvar isTabSwitch = (/**\n * @param {?} enteringView\n * @param {?} leavingView\n * @return {?}\n */\nfunction (enteringView, leavingView) {\n    if (!leavingView) {\n        return true;\n    }\n    return enteringView.stackId !== leavingView.stackId;\n});\n/** @type {?} */\nvar computeStackId = (/**\n * @param {?} prefixUrl\n * @param {?} url\n * @return {?}\n */\nfunction (prefixUrl, url) {\n    if (!prefixUrl) {\n        return undefined;\n    }\n    /** @type {?} */\n    var segments = toSegments(url);\n    for (var i = 0; i < segments.length; i++) {\n        if (i >= prefixUrl.length) {\n            return segments[i];\n        }\n        if (segments[i] !== prefixUrl[i]) {\n            return undefined;\n        }\n    }\n    return undefined;\n});\n/** @type {?} */\nvar toSegments = (/**\n * @param {?} path\n * @return {?}\n */\nfunction (path) {\n    return path\n        .split('/')\n        .map((/**\n     * @param {?} s\n     * @return {?}\n     */\n    function (s) { return s.trim(); }))\n        .filter((/**\n     * @param {?} s\n     * @return {?}\n     */\n    function (s) { return s !== ''; }));\n});\n/** @type {?} */\nvar destroyView = (/**\n * @param {?} view\n * @return {?}\n */\nfunction (view) {\n    if (view) {\n        // TODO lifecycle event\n        view.ref.destroy();\n        view.unlistenEvents();\n    }\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar StackController = /** @class */ (function () {\n    function StackController(tabsPrefix, containerEl, router, navCtrl, zone, location) {\n        this.containerEl = containerEl;\n        this.router = router;\n        this.navCtrl = navCtrl;\n        this.zone = zone;\n        this.location = location;\n        this.views = [];\n        this.skipTransition = false;\n        this.nextId = 0;\n        this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;\n    }\n    /**\n     * @param {?} ref\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    StackController.prototype.createView = /**\n     * @param {?} ref\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    function (ref, activatedRoute) {\n        /** @type {?} */\n        var url = getUrl(this.router, activatedRoute);\n        /** @type {?} */\n        var element = (/** @type {?} */ ((ref && ref.location && ref.location.nativeElement)));\n        /** @type {?} */\n        var unlistenEvents = bindLifecycleEvents(this.zone, ref.instance, element);\n        return {\n            id: this.nextId++,\n            stackId: computeStackId(this.tabsPrefix, url),\n            unlistenEvents: unlistenEvents,\n            element: element,\n            ref: ref,\n            url: url,\n        };\n    };\n    /**\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    StackController.prototype.getExistingView = /**\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    function (activatedRoute) {\n        /** @type {?} */\n        var activatedUrlKey = getUrl(this.router, activatedRoute);\n        /** @type {?} */\n        var view = this.views.find((/**\n         * @param {?} vw\n         * @return {?}\n         */\n        function (vw) { return vw.url === activatedUrlKey; }));\n        if (view) {\n            view.ref.changeDetectorRef.reattach();\n        }\n        return view;\n    };\n    /**\n     * @param {?} enteringView\n     * @return {?}\n     */\n    StackController.prototype.setActive = /**\n     * @param {?} enteringView\n     * @return {?}\n     */\n    function (enteringView) {\n        var _this = this;\n        var _a = this.navCtrl.consumeTransition(), direction = _a.direction, animation = _a.animation;\n        /** @type {?} */\n        var leavingView = this.activeView;\n        /** @type {?} */\n        var tabSwitch = isTabSwitch(enteringView, leavingView);\n        if (tabSwitch) {\n            direction = 'back';\n            animation = undefined;\n        }\n        /** @type {?} */\n        var viewsSnapshot = this.views.slice();\n        /** @type {?} */\n        var currentNavigation;\n        /** @type {?} */\n        var router = ((/** @type {?} */ (this.router)));\n        // Angular >= 7.2.0\n        if (router.getCurrentNavigation) {\n            currentNavigation = router.getCurrentNavigation();\n            // Angular < 7.2.0\n        }\n        else if (router.navigations &&\n            router.navigations.value) {\n            currentNavigation = router.navigations.value;\n        }\n        /**\n         * If the navigation action\n         * sets `replaceUrl: true`\n         * then we need to make sure\n         * we remove the last item\n         * from our views stack\n         */\n        if (currentNavigation &&\n            currentNavigation.extras &&\n            currentNavigation.extras.replaceUrl) {\n            if (this.views.length > 0) {\n                this.views.splice(-1, 1);\n            }\n        }\n        /** @type {?} */\n        var reused = this.views.includes(enteringView);\n        /** @type {?} */\n        var views = this.insertView(enteringView, direction);\n        // Trigger change detection before transition starts\n        // This will call ngOnInit() the first time too, just after the view\n        // was attached to the dom, but BEFORE the transition starts\n        if (!reused) {\n            enteringView.ref.changeDetectorRef.detectChanges();\n        }\n        // Wait until previous transitions finish\n        return this.zone.runOutsideAngular((/**\n         * @return {?}\n         */\n        function () {\n            return _this.wait((/**\n             * @return {?}\n             */\n            function () {\n                // disconnect leaving page from change detection to\n                // reduce jank during the page transition\n                if (leavingView) {\n                    leavingView.ref.changeDetectorRef.detach();\n                }\n                // In case the enteringView is the same as the leavingPage we need to reattach()\n                enteringView.ref.changeDetectorRef.reattach();\n                return _this.transition(enteringView, leavingView, animation, _this.canGoBack(1), false)\n                    .then((/**\n                 * @return {?}\n                 */\n                function () { return cleanupAsync(enteringView, views, viewsSnapshot, _this.location); }))\n                    .then((/**\n                 * @return {?}\n                 */\n                function () { return ({\n                    enteringView: enteringView,\n                    direction: direction,\n                    animation: animation,\n                    tabSwitch: tabSwitch\n                }); }));\n            }));\n        }));\n    };\n    /**\n     * @param {?} deep\n     * @param {?=} stackId\n     * @return {?}\n     */\n    StackController.prototype.canGoBack = /**\n     * @param {?} deep\n     * @param {?=} stackId\n     * @return {?}\n     */\n    function (deep, stackId) {\n        if (stackId === void 0) { stackId = this.getActiveStackId(); }\n        return this.getStack(stackId).length > deep;\n    };\n    /**\n     * @param {?} deep\n     * @param {?=} stackId\n     * @return {?}\n     */\n    StackController.prototype.pop = /**\n     * @param {?} deep\n     * @param {?=} stackId\n     * @return {?}\n     */\n    function (deep, stackId) {\n        var _this = this;\n        if (stackId === void 0) { stackId = this.getActiveStackId(); }\n        return this.zone.run((/**\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var views = _this.getStack(stackId);\n            if (views.length <= deep) {\n                return Promise.resolve(false);\n            }\n            /** @type {?} */\n            var view = views[views.length - deep - 1];\n            /** @type {?} */\n            var url = view.url;\n            /** @type {?} */\n            var viewSavedData = view.savedData;\n            if (viewSavedData) {\n                /** @type {?} */\n                var primaryOutlet = viewSavedData.get('primary');\n                if (primaryOutlet &&\n                    primaryOutlet.route &&\n                    primaryOutlet.route._routerState &&\n                    primaryOutlet.route._routerState.snapshot &&\n                    primaryOutlet.route._routerState.snapshot.url) {\n                    url = primaryOutlet.route._routerState.snapshot.url;\n                }\n            }\n            return _this.navCtrl.navigateBack(url, view.savedExtras).then((/**\n             * @return {?}\n             */\n            function () { return true; }));\n        }));\n    };\n    /**\n     * @return {?}\n     */\n    StackController.prototype.startBackTransition = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var leavingView = this.activeView;\n        if (leavingView) {\n            /** @type {?} */\n            var views = this.getStack(leavingView.stackId);\n            /** @type {?} */\n            var enteringView_1 = views[views.length - 2];\n            return this.wait((/**\n             * @return {?}\n             */\n            function () {\n                return _this.transition(enteringView_1, // entering view\n                leavingView, // leaving view\n                'back', _this.canGoBack(2), true);\n            }));\n        }\n        return Promise.resolve();\n    };\n    /**\n     * @param {?} shouldComplete\n     * @return {?}\n     */\n    StackController.prototype.endBackTransition = /**\n     * @param {?} shouldComplete\n     * @return {?}\n     */\n    function (shouldComplete) {\n        if (shouldComplete) {\n            this.skipTransition = true;\n            this.pop(1);\n        }\n        else if (this.activeView) {\n            cleanup(this.activeView, this.views, this.views, this.location);\n        }\n    };\n    /**\n     * @param {?=} stackId\n     * @return {?}\n     */\n    StackController.prototype.getLastUrl = /**\n     * @param {?=} stackId\n     * @return {?}\n     */\n    function (stackId) {\n        /** @type {?} */\n        var views = this.getStack(stackId);\n        return views.length > 0 ? views[views.length - 1] : undefined;\n    };\n    /**\n     * @return {?}\n     */\n    StackController.prototype.getActiveStackId = /**\n     * @return {?}\n     */\n    function () {\n        return this.activeView ? this.activeView.stackId : undefined;\n    };\n    /**\n     * @return {?}\n     */\n    StackController.prototype.destroy = /**\n     * @return {?}\n     */\n    function () {\n        this.containerEl = (/** @type {?} */ (undefined));\n        this.views.forEach(destroyView);\n        this.activeView = undefined;\n        this.views = [];\n    };\n    /**\n     * @private\n     * @param {?} stackId\n     * @return {?}\n     */\n    StackController.prototype.getStack = /**\n     * @private\n     * @param {?} stackId\n     * @return {?}\n     */\n    function (stackId) {\n        return this.views.filter((/**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { return v.stackId === stackId; }));\n    };\n    /**\n     * @private\n     * @param {?} enteringView\n     * @param {?} direction\n     * @return {?}\n     */\n    StackController.prototype.insertView = /**\n     * @private\n     * @param {?} enteringView\n     * @param {?} direction\n     * @return {?}\n     */\n    function (enteringView, direction) {\n        this.activeView = enteringView;\n        this.views = insertView(this.views, enteringView, direction);\n        return this.views.slice();\n    };\n    /**\n     * @private\n     * @param {?} enteringView\n     * @param {?} leavingView\n     * @param {?} direction\n     * @param {?} showGoBack\n     * @param {?} progressAnimation\n     * @return {?}\n     */\n    StackController.prototype.transition = /**\n     * @private\n     * @param {?} enteringView\n     * @param {?} leavingView\n     * @param {?} direction\n     * @param {?} showGoBack\n     * @param {?} progressAnimation\n     * @return {?}\n     */\n    function (enteringView, leavingView, direction, showGoBack, progressAnimation) {\n        if (this.skipTransition) {\n            this.skipTransition = false;\n            return Promise.resolve(false);\n        }\n        if (leavingView === enteringView) {\n            return Promise.resolve(false);\n        }\n        /** @type {?} */\n        var enteringEl = enteringView ? enteringView.element : undefined;\n        /** @type {?} */\n        var leavingEl = leavingView ? leavingView.element : undefined;\n        /** @type {?} */\n        var containerEl = this.containerEl;\n        if (enteringEl && enteringEl !== leavingEl) {\n            enteringEl.classList.add('ion-page');\n            enteringEl.classList.add('ion-page-invisible');\n            if (enteringEl.parentElement !== containerEl) {\n                containerEl.appendChild(enteringEl);\n            }\n            if (((/** @type {?} */ (containerEl))).commit) {\n                return containerEl.commit(enteringEl, leavingEl, {\n                    deepWait: true,\n                    duration: direction === undefined ? 0 : undefined,\n                    direction: direction,\n                    showGoBack: showGoBack,\n                    progressAnimation: progressAnimation\n                });\n            }\n        }\n        return Promise.resolve(false);\n    };\n    /**\n     * @private\n     * @template T\n     * @param {?} task\n     * @return {?}\n     */\n    StackController.prototype.wait = /**\n     * @private\n     * @template T\n     * @param {?} task\n     * @return {?}\n     */\n    function (task) {\n        return __awaiter(this, void 0, void 0, function () {\n            var promise;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.runningTask !== undefined)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.runningTask];\n                    case 1:\n                        _a.sent();\n                        this.runningTask = undefined;\n                        _a.label = 2;\n                    case 2:\n                        promise = this.runningTask = task();\n                        return [2 /*return*/, promise];\n                }\n            });\n        });\n    };\n    return StackController;\n}());\n/** @type {?} */\nvar cleanupAsync = (/**\n * @param {?} activeRoute\n * @param {?} views\n * @param {?} viewsSnapshot\n * @param {?} location\n * @return {?}\n */\nfunction (activeRoute, views, viewsSnapshot, location) {\n    if (typeof ((/** @type {?} */ (requestAnimationFrame))) === 'function') {\n        return new Promise((/**\n         * @param {?} resolve\n         * @return {?}\n         */\n        function (resolve) {\n            requestAnimationFrame((/**\n             * @return {?}\n             */\n            function () {\n                cleanup(activeRoute, views, viewsSnapshot, location);\n                resolve();\n            }));\n        }));\n    }\n    return Promise.resolve();\n});\n/** @type {?} */\nvar cleanup = (/**\n * @param {?} activeRoute\n * @param {?} views\n * @param {?} viewsSnapshot\n * @param {?} location\n * @return {?}\n */\nfunction (activeRoute, views, viewsSnapshot, location) {\n    viewsSnapshot\n        .filter((/**\n     * @param {?} view\n     * @return {?}\n     */\n    function (view) { return !views.includes(view); }))\n        .forEach(destroyView);\n    views.forEach((/**\n     * @param {?} view\n     * @return {?}\n     */\n    function (view) {\n        /**\n         * In the event that a user navigated multiple\n         * times in rapid succession, we want to make sure\n         * we don't pre-emptively detach a view while\n         * it is in mid-transition.\n         *\n         * In this instance we also do not care about query\n         * params or fragments as it will be the same view regardless\n         * @type {?}\n         */\n        var locationWithoutParams = location.path().split('?')[0];\n        /** @type {?} */\n        var locationWithoutFragment = locationWithoutParams.split('#')[0];\n        if (view !== activeRoute && view.url !== locationWithoutFragment) {\n            /** @type {?} */\n            var element = view.element;\n            element.setAttribute('aria-hidden', 'true');\n            element.classList.add('ion-page-hidden');\n            view.ref.changeDetectorRef.detach();\n        }\n    }));\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IonRouterOutlet = /** @class */ (function () {\n    function IonRouterOutlet(parentContexts, location, resolver, name, tabs, config, navCtrl, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {\n        this.parentContexts = parentContexts;\n        this.location = location;\n        this.resolver = resolver;\n        this.config = config;\n        this.navCtrl = navCtrl;\n        this.parentOutlet = parentOutlet;\n        this.activated = null;\n        this.activatedView = null;\n        this._activatedRoute = null;\n        // Maintain map of activated route proxies for each component instance\n        this.proxyMap = new WeakMap();\n        // Keep the latest activated route in a subject for the proxy routes to switch map to\n        this.currentActivatedRoute$ = new BehaviorSubject(null);\n        this.stackEvents = new EventEmitter();\n        this.activateEvents = new EventEmitter();\n        this.deactivateEvents = new EventEmitter();\n        this.nativeEl = elementRef.nativeElement;\n        this.name = name || PRIMARY_OUTLET;\n        this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;\n        this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, navCtrl, zone, commonLocation);\n        parentContexts.onChildOutletCreated(this.name, (/** @type {?} */ (this)));\n    }\n    Object.defineProperty(IonRouterOutlet.prototype, \"animated\", {\n        set: /**\n         * @param {?} animated\n         * @return {?}\n         */\n        function (animated) {\n            this.nativeEl.animated = animated;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IonRouterOutlet.prototype, \"swipeGesture\", {\n        set: /**\n         * @param {?} swipe\n         * @return {?}\n         */\n        function (swipe) {\n            var _this = this;\n            this._swipeGesture = swipe;\n            this.nativeEl.swipeHandler = swipe ? {\n                canStart: (/**\n                 * @return {?}\n                 */\n                function () { return _this.stackCtrl.canGoBack(1); }),\n                onStart: (/**\n                 * @return {?}\n                 */\n                function () { return _this.stackCtrl.startBackTransition(); }),\n                onEnd: (/**\n                 * @param {?} shouldContinue\n                 * @return {?}\n                 */\n                function (shouldContinue) { return _this.stackCtrl.endBackTransition(shouldContinue); })\n            } : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.stackCtrl.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.getContext = /**\n     * @return {?}\n     */\n    function () {\n        return this.parentContexts.getContext(this.name);\n    };\n    /**\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this.activated) {\n            // If the outlet was not instantiated at the time the route got activated we need to populate\n            // the outlet when it is initialized (ie inside a NgIf)\n            /** @type {?} */\n            var context = this.getContext();\n            if (context && context.route) {\n                this.activateWith(context.route, context.resolver || null);\n            }\n        }\n        if (((/** @type {?} */ (this.nativeEl))).componentOnReady) {\n            this.nativeEl.componentOnReady().then((/**\n             * @return {?}\n             */\n            function () {\n                if (_this._swipeGesture === undefined) {\n                    _this.swipeGesture = _this.config.getBoolean('swipeBackEnabled', ((/** @type {?} */ (_this.nativeEl))).mode === 'ios');\n                }\n            }));\n        }\n    };\n    Object.defineProperty(IonRouterOutlet.prototype, \"isActivated\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return !!this.activated;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IonRouterOutlet.prototype, \"component\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this.activated) {\n                throw new Error('Outlet is not activated');\n            }\n            return this.activated.instance;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IonRouterOutlet.prototype, \"activatedRoute\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this.activated) {\n                throw new Error('Outlet is not activated');\n            }\n            return (/** @type {?} */ (this._activatedRoute));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IonRouterOutlet.prototype, \"activatedRouteData\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (this._activatedRoute) {\n                return this._activatedRoute.snapshot.data;\n            }\n            return {};\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.detach = /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     * @return {?}\n     */\n    function () {\n        throw new Error('incompatible reuse strategy');\n    };\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     * @param {?} _ref\n     * @param {?} _activatedRoute\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.attach = /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     * @param {?} _ref\n     * @param {?} _activatedRoute\n     * @return {?}\n     */\n    function (_ref, _activatedRoute) {\n        throw new Error('incompatible reuse strategy');\n    };\n    /**\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.deactivate = /**\n     * @return {?}\n     */\n    function () {\n        if (this.activated) {\n            if (this.activatedView) {\n                this.activatedView.savedData = new Map((/** @type {?} */ (this.getContext())).children['contexts']);\n                /**\n                 * Ensure we are saving the NavigationExtras\n                 * data otherwise it will be lost\n                 */\n                this.activatedView.savedExtras = {};\n                /** @type {?} */\n                var context = (/** @type {?} */ (this.getContext()));\n                if (context.route) {\n                    /** @type {?} */\n                    var contextSnapshot = context.route.snapshot;\n                    this.activatedView.savedExtras.queryParams = contextSnapshot.queryParams;\n                    this.activatedView.savedExtras.fragment = contextSnapshot.fragment;\n                }\n            }\n            /** @type {?} */\n            var c = this.component;\n            this.activatedView = null;\n            this.activated = null;\n            this._activatedRoute = null;\n            this.deactivateEvents.emit(c);\n        }\n    };\n    /**\n     * @param {?} activatedRoute\n     * @param {?} resolver\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.activateWith = /**\n     * @param {?} activatedRoute\n     * @param {?} resolver\n     * @return {?}\n     */\n    function (activatedRoute, resolver) {\n        var _this = this;\n        if (this.isActivated) {\n            throw new Error('Cannot activate an already activated outlet');\n        }\n        this._activatedRoute = activatedRoute;\n        /** @type {?} */\n        var cmpRef;\n        /** @type {?} */\n        var enteringView = this.stackCtrl.getExistingView(activatedRoute);\n        if (enteringView) {\n            cmpRef = this.activated = enteringView.ref;\n            /** @type {?} */\n            var saved = enteringView.savedData;\n            if (saved) {\n                // self-restore\n                /** @type {?} */\n                var context = (/** @type {?} */ (this.getContext()));\n                context.children['contexts'] = saved;\n            }\n            // Updated activated route proxy for this component\n            this.updateActivatedRouteProxy(cmpRef.instance, activatedRoute);\n        }\n        else {\n            /** @type {?} */\n            var snapshot = ((/** @type {?} */ (activatedRoute)))._futureSnapshot;\n            /** @type {?} */\n            var component = (/** @type {?} */ ((/** @type {?} */ (snapshot.routeConfig)).component));\n            resolver = resolver || this.resolver;\n            /** @type {?} */\n            var factory = resolver.resolveComponentFactory(component);\n            /** @type {?} */\n            var childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n            // We create an activated route proxy object that will maintain future updates for this component\n            // over its lifecycle in the stack.\n            /** @type {?} */\n            var component$ = new BehaviorSubject(null);\n            /** @type {?} */\n            var activatedRouteProxy = this.createActivatedRouteProxy(component$, activatedRoute);\n            /** @type {?} */\n            var injector = new OutletInjector(activatedRouteProxy, childContexts, this.location.injector);\n            cmpRef = this.activated = this.location.createComponent(factory, this.location.length, injector);\n            // Once the component is created we can push it to our local subject supplied to the proxy\n            component$.next(cmpRef.instance);\n            // Calling `markForCheck` to make sure we will run the change detection when the\n            // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n            enteringView = this.stackCtrl.createView(this.activated, activatedRoute);\n            // Store references to the proxy by component\n            this.proxyMap.set(cmpRef.instance, activatedRouteProxy);\n            this.currentActivatedRoute$.next({ component: cmpRef.instance, activatedRoute: activatedRoute });\n        }\n        this.activatedView = enteringView;\n        this.stackCtrl.setActive(enteringView).then((/**\n         * @param {?} data\n         * @return {?}\n         */\n        function (data) {\n            _this.navCtrl.setTopOutlet(_this);\n            _this.activateEvents.emit(cmpRef.instance);\n            _this.stackEvents.emit(data);\n        }));\n    };\n    /**\n     * Returns `true` if there are pages in the stack to go back.\n     */\n    /**\n     * Returns `true` if there are pages in the stack to go back.\n     * @param {?=} deep\n     * @param {?=} stackId\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.canGoBack = /**\n     * Returns `true` if there are pages in the stack to go back.\n     * @param {?=} deep\n     * @param {?=} stackId\n     * @return {?}\n     */\n    function (deep, stackId) {\n        if (deep === void 0) { deep = 1; }\n        return this.stackCtrl.canGoBack(deep, stackId);\n    };\n    /**\n     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\n     */\n    /**\n     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\n     * @param {?=} deep\n     * @param {?=} stackId\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.pop = /**\n     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\n     * @param {?=} deep\n     * @param {?=} stackId\n     * @return {?}\n     */\n    function (deep, stackId) {\n        if (deep === void 0) { deep = 1; }\n        return this.stackCtrl.pop(deep, stackId);\n    };\n    /**\n     * Returns the URL of the active page of each stack.\n     */\n    /**\n     * Returns the URL of the active page of each stack.\n     * @param {?=} stackId\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.getLastUrl = /**\n     * Returns the URL of the active page of each stack.\n     * @param {?=} stackId\n     * @return {?}\n     */\n    function (stackId) {\n        /** @type {?} */\n        var active = this.stackCtrl.getLastUrl(stackId);\n        return active ? active.url : undefined;\n    };\n    /**\n     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\n     */\n    /**\n     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.getActiveStackId = /**\n     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\n     * @return {?}\n     */\n    function () {\n        return this.stackCtrl.getActiveStackId();\n    };\n    /**\n     * Since the activated route can change over the life time of a component in an ion router outlet, we create\n     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\n     */\n    /**\n     * Since the activated route can change over the life time of a component in an ion router outlet, we create\n     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\n     * @private\n     * @param {?} component$\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.createActivatedRouteProxy = /**\n     * Since the activated route can change over the life time of a component in an ion router outlet, we create\n     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\n     * @private\n     * @param {?} component$\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    function (component$, activatedRoute) {\n        /** @type {?} */\n        var proxy = new ActivatedRoute();\n        proxy._futureSnapshot = ((/** @type {?} */ (activatedRoute)))._futureSnapshot;\n        proxy._routerState = ((/** @type {?} */ (activatedRoute)))._routerState;\n        proxy.snapshot = activatedRoute.snapshot;\n        proxy.outlet = activatedRoute.outlet;\n        proxy.component = activatedRoute.component;\n        // Setup wrappers for the observables so consumers don't have to worry about switching to new observables as the state updates\n        ((/** @type {?} */ (proxy)))._paramMap = this.proxyObservable(component$, 'paramMap');\n        ((/** @type {?} */ (proxy)))._queryParamMap = this.proxyObservable(component$, 'queryParamMap');\n        proxy.url = this.proxyObservable(component$, 'url');\n        proxy.params = this.proxyObservable(component$, 'params');\n        proxy.queryParams = this.proxyObservable(component$, 'queryParams');\n        proxy.fragment = this.proxyObservable(component$, 'fragment');\n        proxy.data = this.proxyObservable(component$, 'data');\n        return (/** @type {?} */ (proxy));\n    };\n    /**\n     * Create a wrapped observable that will switch to the latest activated route matched by the given component\n     */\n    /**\n     * Create a wrapped observable that will switch to the latest activated route matched by the given component\n     * @private\n     * @param {?} component$\n     * @param {?} path\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.proxyObservable = /**\n     * Create a wrapped observable that will switch to the latest activated route matched by the given component\n     * @private\n     * @param {?} component$\n     * @param {?} path\n     * @return {?}\n     */\n    function (component$, path) {\n        var _this = this;\n        return component$.pipe(\n        // First wait until the component instance is pushed\n        filter((/**\n         * @param {?} component\n         * @return {?}\n         */\n        function (component) { return !!component; })), switchMap((/**\n         * @param {?} component\n         * @return {?}\n         */\n        function (component) {\n            return _this.currentActivatedRoute$.pipe(filter((/**\n             * @param {?} current\n             * @return {?}\n             */\n            function (current) { return current !== null && current.component === component; })), switchMap((/**\n             * @param {?} current\n             * @return {?}\n             */\n            function (current) { return current && ((/** @type {?} */ (current.activatedRoute)))[path]; })), distinctUntilChanged());\n        })));\n    };\n    /**\n     * Updates the activated route proxy for the given component to the new incoming router state\n     */\n    /**\n     * Updates the activated route proxy for the given component to the new incoming router state\n     * @private\n     * @param {?} component\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    IonRouterOutlet.prototype.updateActivatedRouteProxy = /**\n     * Updates the activated route proxy for the given component to the new incoming router state\n     * @private\n     * @param {?} component\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    function (component, activatedRoute) {\n        /** @type {?} */\n        var proxy = this.proxyMap.get(component);\n        if (!proxy) {\n            throw new Error(\"Could not find activated route proxy for view\");\n        }\n        ((/** @type {?} */ (proxy)))._futureSnapshot = ((/** @type {?} */ (activatedRoute)))._futureSnapshot;\n        ((/** @type {?} */ (proxy)))._routerState = ((/** @type {?} */ (activatedRoute)))._routerState;\n        proxy.snapshot = activatedRoute.snapshot;\n        proxy.outlet = activatedRoute.outlet;\n        proxy.component = activatedRoute.component;\n        this.currentActivatedRoute$.next({ component: component, activatedRoute: activatedRoute });\n    };\n    IonRouterOutlet.decorators = [\n        { type: Directive, args: [{\n                    selector: 'ion-router-outlet',\n                    exportAs: 'outlet',\n                    inputs: ['animated', 'swipeGesture']\n                },] },\n    ];\n    /** @nocollapse */\n    IonRouterOutlet.ctorParameters = function () { return [\n        { type: ChildrenOutletContexts },\n        { type: ViewContainerRef },\n        { type: ComponentFactoryResolver },\n        { type: String, decorators: [{ type: Attribute, args: ['name',] }] },\n        { type: String, decorators: [{ type: Optional }, { type: Attribute, args: ['tabs',] }] },\n        { type: Config },\n        { type: NavController },\n        { type: Location },\n        { type: ElementRef },\n        { type: Router },\n        { type: NgZone },\n        { type: ActivatedRoute },\n        { type: IonRouterOutlet, decorators: [{ type: SkipSelf }, { type: Optional }] }\n    ]; };\n    IonRouterOutlet.propDecorators = {\n        stackEvents: [{ type: Output }],\n        activateEvents: [{ type: Output, args: ['activate',] }],\n        deactivateEvents: [{ type: Output, args: ['deactivate',] }]\n    };\n    return IonRouterOutlet;\n}());\nvar OutletInjector = /** @class */ (function () {\n    function OutletInjector(route, childContexts, parent) {\n        this.route = route;\n        this.childContexts = childContexts;\n        this.parent = parent;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    OutletInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        if (token === ActivatedRoute) {\n            return this.route;\n        }\n        if (token === ChildrenOutletContexts) {\n            return this.childContexts;\n        }\n        // tslint:disable-next-line\n        return this.parent.get(token, notFoundValue);\n    };\n    return OutletInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IonTabs = /** @class */ (function () {\n    function IonTabs(navCtrl) {\n        this.navCtrl = navCtrl;\n        this.ionTabsWillChange = new EventEmitter();\n        this.ionTabsDidChange = new EventEmitter();\n    }\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} detail\n     * @return {?}\n     */\n    IonTabs.prototype.onPageSelected = /**\n     * \\@internal\n     * @param {?} detail\n     * @return {?}\n     */\n    function (detail) {\n        /** @type {?} */\n        var stackId = detail.enteringView.stackId;\n        if (detail.tabSwitch && stackId !== undefined) {\n            if (this.tabBar) {\n                this.tabBar.selectedTab = stackId;\n            }\n            this.ionTabsWillChange.emit({ tab: stackId });\n            this.ionTabsDidChange.emit({ tab: stackId });\n        }\n    };\n    /**\n     * @param {?} tab\n     * @return {?}\n     */\n    IonTabs.prototype.select = /**\n     * @param {?} tab\n     * @return {?}\n     */\n    function (tab) {\n        /** @type {?} */\n        var alreadySelected = this.outlet.getActiveStackId() === tab;\n        /** @type {?} */\n        var href = this.outlet.tabsPrefix + \"/\" + tab;\n        /** @type {?} */\n        var url = alreadySelected\n            ? href\n            : this.outlet.getLastUrl(tab) || href;\n        return this.navCtrl.navigateRoot(url, {\n            animated: true,\n            animationDirection: 'back'\n        });\n    };\n    /**\n     * @return {?}\n     */\n    IonTabs.prototype.getSelected = /**\n     * @return {?}\n     */\n    function () {\n        return this.outlet.getActiveStackId();\n    };\n    IonTabs.decorators = [\n        { type: Component, args: [{\n                    selector: 'ion-tabs',\n                    template: \"\\n    <ng-content select=\\\"[slot=top]\\\"></ng-content>\\n    <div class=\\\"tabs-inner\\\">\\n      <ion-router-outlet #outlet tabs=\\\"true\\\" (stackEvents)=\\\"onPageSelected($event)\\\"></ion-router-outlet>\\n    </div>\\n    <ng-content></ng-content>\",\n                    styles: [\"\\n    :host {\\n      display: flex;\\n      position: absolute;\\n      top: 0;\\n      left: 0;\\n      right: 0;\\n      bottom: 0;\\n\\n      flex-direction: column;\\n\\n      width: 100%;\\n      height: 100%;\\n\\n      contain: layout size style;\\n      z-index: $z-index-page-container;\\n    }\\n    .tabs-inner {\\n      position: relative;\\n\\n      flex: 1;\\n\\n      contain: layout size style;\\n    }\"\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    IonTabs.ctorParameters = function () { return [\n        { type: NavController }\n    ]; };\n    IonTabs.propDecorators = {\n        outlet: [{ type: ViewChild, args: ['outlet', { read: IonRouterOutlet },] }],\n        tabBar: [{ type: ContentChild, args: [IonTabBar,] }],\n        ionTabsWillChange: [{ type: Output }],\n        ionTabsDidChange: [{ type: Output }],\n        select: [{ type: HostListener, args: ['ionTabButtonClick', ['$event.detail.tab'],] }]\n    };\n    return IonTabs;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IonBackButtonDelegate = /** @class */ (function () {\n    function IonBackButtonDelegate(routerOutlet, navCtrl) {\n        this.routerOutlet = routerOutlet;\n        this.navCtrl = navCtrl;\n    }\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} ev\n     * @return {?}\n     */\n    IonBackButtonDelegate.prototype.onClick = /**\n     * \\@internal\n     * @param {?} ev\n     * @return {?}\n     */\n    function (ev) {\n        if (this.routerOutlet && this.routerOutlet.canGoBack()) {\n            this.routerOutlet.pop();\n            ev.preventDefault();\n        }\n        else if (this.defaultHref != null) {\n            this.navCtrl.navigateBack(this.defaultHref);\n            ev.preventDefault();\n        }\n    };\n    IonBackButtonDelegate.decorators = [\n        { type: Directive, args: [{\n                    selector: 'ion-back-button',\n                    inputs: ['defaultHref']\n                },] },\n    ];\n    /** @nocollapse */\n    IonBackButtonDelegate.ctorParameters = function () { return [\n        { type: IonRouterOutlet, decorators: [{ type: Optional }] },\n        { type: NavController }\n    ]; };\n    IonBackButtonDelegate.propDecorators = {\n        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n    };\n    return IonBackButtonDelegate;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NavDelegate = /** @class */ (function () {\n    function NavDelegate(ref, resolver, injector, angularDelegate, location) {\n        ref.nativeElement.delegate = angularDelegate.create(resolver, injector, location);\n    }\n    NavDelegate.decorators = [\n        { type: Directive, args: [{\n                    selector: 'ion-nav',\n                },] },\n    ];\n    /** @nocollapse */\n    NavDelegate.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: ComponentFactoryResolver },\n        { type: Injector },\n        { type: AngularDelegate },\n        { type: ViewContainerRef }\n    ]; };\n    return NavDelegate;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar RouterLinkDelegate = /** @class */ (function () {\n    function RouterLinkDelegate(locationStrategy, navCtrl, elementRef, router, routerLink) {\n        this.locationStrategy = locationStrategy;\n        this.navCtrl = navCtrl;\n        this.elementRef = elementRef;\n        this.router = router;\n        this.routerLink = routerLink;\n        this.routerDirection = 'forward';\n    }\n    /**\n     * @return {?}\n     */\n    RouterLinkDelegate.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this.updateTargetUrlAndHref();\n    };\n    /**\n     * @return {?}\n     */\n    RouterLinkDelegate.prototype.ngOnChanges = /**\n     * @return {?}\n     */\n    function () {\n        this.updateTargetUrlAndHref();\n    };\n    /**\n     * @return {?}\n     */\n    RouterLinkDelegate.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    RouterLinkDelegate.prototype.updateTargetUrlAndHref = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (this.routerLink) {\n            /** @type {?} */\n            var href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n            this.elementRef.nativeElement.href = href;\n        }\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} ev\n     * @return {?}\n     */\n    RouterLinkDelegate.prototype.onClick = /**\n     * \\@internal\n     * @param {?} ev\n     * @return {?}\n     */\n    function (ev) {\n        this.navCtrl.setDirection(this.routerDirection);\n        ev.preventDefault();\n    };\n    RouterLinkDelegate.decorators = [\n        { type: Directive, args: [{\n                    selector: '[routerLink]',\n                    inputs: ['routerDirection']\n                },] },\n    ];\n    /** @nocollapse */\n    RouterLinkDelegate.ctorParameters = function () { return [\n        { type: LocationStrategy },\n        { type: NavController },\n        { type: ElementRef },\n        { type: Router },\n        { type: RouterLink, decorators: [{ type: Optional }] }\n    ]; };\n    RouterLinkDelegate.propDecorators = {\n        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n    };\n    return RouterLinkDelegate;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @hidden\n */\nvar VirtualFooter = /** @class */ (function () {\n    function VirtualFooter(templateRef) {\n        this.templateRef = templateRef;\n    }\n    VirtualFooter.decorators = [\n        { type: Directive, args: [{ selector: '[virtualFooter]' },] },\n    ];\n    /** @nocollapse */\n    VirtualFooter.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    return VirtualFooter;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @hidden\n */\nvar VirtualHeader = /** @class */ (function () {\n    function VirtualHeader(templateRef) {\n        this.templateRef = templateRef;\n    }\n    VirtualHeader.decorators = [\n        { type: Directive, args: [{ selector: '[virtualHeader]' },] },\n    ];\n    /** @nocollapse */\n    VirtualHeader.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    return VirtualHeader;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @hidden\n */\nvar VirtualItem = /** @class */ (function () {\n    function VirtualItem(templateRef, viewContainer) {\n        this.templateRef = templateRef;\n        this.viewContainer = viewContainer;\n    }\n    VirtualItem.decorators = [\n        { type: Directive, args: [{ selector: '[virtualItem]' },] },\n    ];\n    /** @nocollapse */\n    VirtualItem.ctorParameters = function () { return [\n        { type: TemplateRef },\n        { type: ViewContainerRef }\n    ]; };\n    return VirtualItem;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IonVirtualScroll = /** @class */ (function () {\n    function IonVirtualScroll(z, iterableDiffers, elementRef) {\n        this.z = z;\n        this.iterableDiffers = iterableDiffers;\n        this.refMap = new WeakMap();\n        this.el = (/** @type {?} */ (elementRef.nativeElement));\n        this.el.nodeRender = this.nodeRender.bind(this);\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    IonVirtualScroll.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (this.trackBy && 'items' in changes) {\n            // React on virtualScroll changes only once all inputs have been initialized\n            /** @type {?} */\n            var value = changes['items'].currentValue;\n            if (this.differ === undefined && value != null) {\n                try {\n                    this.differ = this.iterableDiffers.find(value).create(this.trackBy);\n                }\n                catch (e) {\n                    throw new Error(\"Cannot find a differ supporting object '\" + value + \"'. VirtualScroll only supports binding to Iterables such as Arrays.\");\n                }\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    IonVirtualScroll.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n    function () {\n        // and if there actually are changes\n        /** @type {?} */\n        var changes = this.differ !== undefined && this.items ? this.differ.diff(this.items) : null;\n        if (changes === null) {\n            return;\n        }\n        // TODO: optimize\n        this.checkRange(0);\n    };\n    /**\n     * @private\n     * @param {?} el\n     * @param {?} cell\n     * @param {?} index\n     * @return {?}\n     */\n    IonVirtualScroll.prototype.nodeRender = /**\n     * @private\n     * @param {?} el\n     * @param {?} cell\n     * @param {?} index\n     * @return {?}\n     */\n    function (el, cell, index) {\n        var _this = this;\n        return this.z.run((/**\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var node;\n            if (!el) {\n                node = _this.itmTmp.viewContainer.createEmbeddedView(_this.getComponent(cell.type), { $implicit: cell.value, index: index }, index);\n                el = getElement(node);\n                _this.refMap.set(el, node);\n            }\n            else {\n                node = (/** @type {?} */ (_this.refMap.get(el)));\n                /** @type {?} */\n                var ctx = node.context;\n                ctx.$implicit = cell.value;\n                ctx.index = cell.index;\n            }\n            // run sync change detections\n            node.detectChanges();\n            return el;\n        }));\n    };\n    /**\n     * @private\n     * @param {?} type\n     * @return {?}\n     */\n    IonVirtualScroll.prototype.getComponent = /**\n     * @private\n     * @param {?} type\n     * @return {?}\n     */\n    function (type) {\n        switch (type) {\n            case 'item': return this.itmTmp.templateRef;\n            case 'header': return this.hdrTmp.templateRef;\n            case 'footer': return this.ftrTmp.templateRef;\n        }\n        throw new Error('template for virtual item was not provided');\n    };\n    IonVirtualScroll.decorators = [\n        { type: Component, args: [{\n                    selector: 'ion-virtual-scroll',\n                    template: '<ng-content></ng-content>',\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    inputs: [\n                        'approxItemHeight',\n                        'approxHeaderHeight',\n                        'approxFooterHeight',\n                        'headerFn',\n                        'footerFn',\n                        'items',\n                        'itemHeight',\n                        'headerHeight',\n                        'footerHeight',\n                        'trackBy'\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    IonVirtualScroll.ctorParameters = function () { return [\n        { type: NgZone },\n        { type: IterableDiffers },\n        { type: ElementRef }\n    ]; };\n    IonVirtualScroll.propDecorators = {\n        itmTmp: [{ type: ContentChild, args: [VirtualItem,] }],\n        hdrTmp: [{ type: ContentChild, args: [VirtualHeader,] }],\n        ftrTmp: [{ type: ContentChild, args: [VirtualFooter,] }]\n    };\n    return IonVirtualScroll;\n}());\n/** @type {?} */\nvar getElement = (/**\n * @param {?} view\n * @return {?}\n */\nfunction (view) {\n    /** @type {?} */\n    var rootNodes = view.rootNodes;\n    for (var i = 0; i < rootNodes.length; i++) {\n        if (rootNodes[i].nodeType === 1) {\n            return rootNodes[i];\n        }\n    }\n    throw new Error('virtual element was not created');\n});\nproxyInputs(IonVirtualScroll, [\n    'approxItemHeight',\n    'approxHeaderHeight',\n    'approxFooterHeight',\n    'headerFn',\n    'footerFn',\n    'items',\n    'itemHeight',\n    'headerHeight',\n    'footerHeight'\n]);\nproxyMethods(IonVirtualScroll, [\n    'checkEnd',\n    'checkRange',\n    'positionForItem'\n]);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar CssUtilsDeprecations = /** @class */ (function () {\n    function CssUtilsDeprecations(ref) {\n        /** @type {?} */\n        var el = ((/** @type {?} */ (ref.nativeElement)));\n        /** @type {?} */\n        var attributes = Array.from(el.attributes)\n            .map((/**\n         * @param {?} a\n         * @return {?}\n         */\n        function (a) { return a.name; }))\n            .filter((/**\n         * @param {?} n\n         * @return {?}\n         */\n        function (n) { return DEPRECATED_ATTRIBUTES.includes(n); }));\n        if (attributes.length > 0) {\n            console.warn(\"[DEPRECATED][CSS] Ionic CSS attributes are deprecated.\\nReplace:\\n'<\" + el.tagName.toLowerCase() + \" \" + attributes.map((/**\n             * @param {?} n\n             * @return {?}\n             */\n            function (n) { return \"\" + n; })).join(' ') + \">'\\n\\nWith:\\n'<\" + el.tagName.toLowerCase() + \" class=\\\"\" + attributes.map((/**\n             * @param {?} n\n             * @return {?}\n             */\n            function (n) { return \"ion-\" + n; })).join(' ') + \"\\\">'\\n      \");\n        }\n    }\n    CssUtilsDeprecations.decorators = [\n        { type: Directive, args: [{\n                    selector: '[align-self-start], [align-self-end], [align-self-center], [align-self-stretch], [align-self-baseline], [align-self-auto], [wrap-reverse], [justify-content-start], [justify-content-center], [justify-content-end], [justify-content-around], [justify-content-between], [justify-content-evenly], [align-items-start], [align-items-center], [align-items-end], [align-items-stretch], [align-items-baseline], [float-left], [float-right], [float-start], [float-end], [float-sm-left], [float-sm-right], [float-sm-start], [float-sm-end], [float-md-left], [float-md-right], [float-md-start], [float-md-end], [float-lg-left], [float-lg-right], [float-lg-start], [float-lg-end], [float-xl-left], [float-xl-right], [float-xl-start], [float-xl-end], [text-center], [text-justify], [text-start], [text-end], [text-left], [text-right], [text-nowrap], [text-wrap], [text-sm-center], [text-sm-justify], [text-sm-start], [text-sm-end], [text-sm-left], [text-sm-right], [text-sm-nowrap], [text-sm-wrap], [text-md-center], [text-md-justify], [text-md-start], [text-md-end], [text-md-left], [text-md-right], [text-md-nowrap], [text-md-wrap], [text-lg-center], [text-lg-justify], [text-lg-start], [text-lg-end], [text-lg-left], [text-lg-right], [text-lg-nowrap], [text-lg-wrap], [text-xl-center], [text-xl-justify], [text-xl-start], [text-xl-end], [text-xl-left], [text-xl-right], [text-xl-nowrap], [text-xl-wrap], [text-uppercase], [text-lowercase], [text-capitalize], [text-sm-uppercase], [text-sm-lowercase], [text-sm-capitalize], [text-md-uppercase], [text-md-lowercase], [text-md-capitalize], [text-lg-uppercase], [text-lg-lowercase], [text-lg-capitalize], [text-xl-uppercase], [text-xl-lowercase], [text-xl-capitalize], [no-padding], [padding], [padding-top], [padding-bottom], [padding-start], [padding-end], [padding-vertical], [padding-horizontal], [no-margin], [margin], [margin-top], [margin-bottom], [margin-start], [margin-end], [margin-vertical], [margin-horizontal]',\n                },] },\n    ];\n    /** @nocollapse */\n    CssUtilsDeprecations.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\n    return CssUtilsDeprecations;\n}());\n/** @type {?} */\nvar DEPRECATED_ATTRIBUTES = [\n    'align-self-start',\n    'align-self-end',\n    'align-self-center',\n    'align-self-stretch',\n    'align-self-baseline',\n    'align-self-auto',\n    'wrap-reverse',\n    'justify-content-start',\n    'justify-content-center',\n    'justify-content-end',\n    'justify-content-around',\n    'justify-content-between',\n    'justify-content-evenly',\n    'align-items-start',\n    'align-items-center',\n    'align-items-end',\n    'align-items-stretch',\n    'align-items-baseline',\n    'float-left',\n    'float-right',\n    'float-start',\n    'float-end',\n    'float-sm-left',\n    'float-sm-right',\n    'float-sm-start',\n    'float-sm-end',\n    'float-md-left',\n    'float-md-right',\n    'float-md-start',\n    'float-md-end',\n    'float-lg-left',\n    'float-lg-right',\n    'float-lg-start',\n    'float-lg-end',\n    'float-xl-left',\n    'float-xl-right',\n    'float-xl-start',\n    'float-xl-end',\n    'text-center',\n    'text-justify',\n    'text-start',\n    'text-end',\n    'text-left',\n    'text-right',\n    'text-nowrap',\n    'text-wrap',\n    'text-sm-center',\n    'text-sm-justify',\n    'text-sm-start',\n    'text-sm-end',\n    'text-sm-left',\n    'text-sm-right',\n    'text-sm-nowrap',\n    'text-sm-wrap',\n    'text-md-center',\n    'text-md-justify',\n    'text-md-start',\n    'text-md-end',\n    'text-md-left',\n    'text-md-right',\n    'text-md-nowrap',\n    'text-md-wrap',\n    'text-lg-center',\n    'text-lg-justify',\n    'text-lg-start',\n    'text-lg-end',\n    'text-lg-left',\n    'text-lg-right',\n    'text-lg-nowrap',\n    'text-lg-wrap',\n    'text-xl-center',\n    'text-xl-justify',\n    'text-xl-start',\n    'text-xl-end',\n    'text-xl-left',\n    'text-xl-right',\n    'text-xl-nowrap',\n    'text-xl-wrap',\n    'text-uppercase',\n    'text-lowercase',\n    'text-capitalize',\n    'text-sm-uppercase',\n    'text-sm-lowercase',\n    'text-sm-capitalize',\n    'text-md-uppercase',\n    'text-md-lowercase',\n    'text-md-capitalize',\n    'text-lg-uppercase',\n    'text-lg-lowercase',\n    'text-lg-capitalize',\n    'text-xl-uppercase',\n    'text-xl-lowercase',\n    'text-xl-capitalize',\n    'no-padding',\n    'padding',\n    'padding-top',\n    'padding-bottom',\n    'padding-start',\n    'padding-end',\n    'padding-vertical',\n    'padding-horizontal',\n    'no-margin',\n    'margin',\n    'margin-top',\n    'margin-bottom',\n    'margin-start',\n    'margin-end',\n    'margin-vertical',\n    'margin-horizontal'\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template Opts, Overlay\n */\nvar  /**\n * @template Opts, Overlay\n */\nOverlayBaseController = /** @class */ (function () {\n    function OverlayBaseController(ctrl) {\n        this.ctrl = ctrl;\n    }\n    /**\n     * Creates a new overlay\n     */\n    /**\n     * Creates a new overlay\n     * @param {?=} opts\n     * @return {?}\n     */\n    OverlayBaseController.prototype.create = /**\n     * Creates a new overlay\n     * @param {?=} opts\n     * @return {?}\n     */\n    function (opts) {\n        // TODO: next major release opts is not optional\n        return this.ctrl.create((/** @type {?} */ ((opts || {}))));\n    };\n    /**\n     * When `id` is not provided, it dismisses the top overlay.\n     */\n    /**\n     * When `id` is not provided, it dismisses the top overlay.\n     * @param {?=} data\n     * @param {?=} role\n     * @param {?=} id\n     * @return {?}\n     */\n    OverlayBaseController.prototype.dismiss = /**\n     * When `id` is not provided, it dismisses the top overlay.\n     * @param {?=} data\n     * @param {?=} role\n     * @param {?=} id\n     * @return {?}\n     */\n    function (data, role, id) {\n        return this.ctrl.dismiss(data, role, id);\n    };\n    /**\n     * Returns the top overlay.\n     */\n    /**\n     * Returns the top overlay.\n     * @return {?}\n     */\n    OverlayBaseController.prototype.getTop = /**\n     * Returns the top overlay.\n     * @return {?}\n     */\n    function () {\n        return this.ctrl.getTop();\n    };\n    return OverlayBaseController;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ActionSheetController = /** @class */ (function (_super) {\n    __extends(ActionSheetController, _super);\n    function ActionSheetController() {\n        return _super.call(this, actionSheetController) || this;\n    }\n    ActionSheetController.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root',\n                },] },\n    ];\n    /** @nocollapse */\n    ActionSheetController.ctorParameters = function () { return []; };\n    /** @nocollapse */ ActionSheetController.ngInjectableDef = defineInjectable({ factory: function ActionSheetController_Factory() { return new ActionSheetController(); }, token: ActionSheetController, providedIn: \"root\" });\n    return ActionSheetController;\n}(OverlayBaseController));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar AlertController = /** @class */ (function (_super) {\n    __extends(AlertController, _super);\n    function AlertController() {\n        return _super.call(this, alertController) || this;\n    }\n    AlertController.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root',\n                },] },\n    ];\n    /** @nocollapse */\n    AlertController.ctorParameters = function () { return []; };\n    /** @nocollapse */ AlertController.ngInjectableDef = defineInjectable({ factory: function AlertController_Factory() { return new AlertController(); }, token: AlertController, providedIn: \"root\" });\n    return AlertController;\n}(OverlayBaseController));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar Events = /** @class */ (function () {\n    function Events() {\n        this.c = new Map();\n        console.warn(\"[DEPRECATION][Events]: The Events provider is deprecated and it will be removed in the next major release.\\n  - Use \\\"Observables\\\" for a similar pub/sub architecture: https://angular.io/guide/observables\\n  - Use \\\"Redux\\\" for advanced state management: https://ngrx.io\");\n    }\n    /**\n     * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.\n     *\n     * @param topic the topic to subscribe to\n     * @param handler the event handler\n     */\n    /**\n     * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.\n     *\n     * @param {?} topic the topic to subscribe to\n     * @param {...?} handlers\n     * @return {?}\n     */\n    Events.prototype.subscribe = /**\n     * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.\n     *\n     * @param {?} topic the topic to subscribe to\n     * @param {...?} handlers\n     * @return {?}\n     */\n    function (topic) {\n        var handlers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            handlers[_i - 1] = arguments[_i];\n        }\n        /** @type {?} */\n        var topics = this.c.get(topic);\n        if (!topics) {\n            this.c.set(topic, topics = []);\n        }\n        topics.push.apply(topics, handlers);\n    };\n    /**\n     * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.\n     *\n     * @param topic the topic to unsubscribe from\n     * @param handler the event handler\n     *\n     * @return true if a handler was removed\n     */\n    /**\n     * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.\n     *\n     * @param {?} topic the topic to unsubscribe from\n     * @param {?=} handler the event handler\n     *\n     * @return {?} true if a handler was removed\n     */\n    Events.prototype.unsubscribe = /**\n     * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.\n     *\n     * @param {?} topic the topic to unsubscribe from\n     * @param {?=} handler the event handler\n     *\n     * @return {?} true if a handler was removed\n     */\n    function (topic, handler) {\n        if (!handler) {\n            return this.c.delete(topic);\n        }\n        /** @type {?} */\n        var topics = this.c.get(topic);\n        if (!topics) {\n            return false;\n        }\n        // We need to find and remove a specific handler\n        /** @type {?} */\n        var index = topics.indexOf(handler);\n        if (index < 0) {\n            // Wasn't found, wasn't removed\n            return false;\n        }\n        topics.splice(index, 1);\n        if (topics.length === 0) {\n            this.c.delete(topic);\n        }\n        return true;\n    };\n    /**\n     * Publish an event to the given topic.\n     *\n     * @param topic the topic to publish to\n     * @param eventData the data to send as the event\n     */\n    /**\n     * Publish an event to the given topic.\n     *\n     * @param {?} topic the topic to publish to\n     * @param {...?} args\n     * @return {?}\n     */\n    Events.prototype.publish = /**\n     * Publish an event to the given topic.\n     *\n     * @param {?} topic the topic to publish to\n     * @param {...?} args\n     * @return {?}\n     */\n    function (topic) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        /** @type {?} */\n        var topics = this.c.get(topic);\n        if (!topics) {\n            return null;\n        }\n        return topics.map((/**\n         * @param {?} handler\n         * @return {?}\n         */\n        function (handler) {\n            try {\n                return handler.apply(void 0, args);\n            }\n            catch (e) {\n                console.error(e);\n                return null;\n            }\n        }));\n    };\n    Events.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root',\n                },] },\n    ];\n    /** @nocollapse */\n    Events.ctorParameters = function () { return []; };\n    /** @nocollapse */ Events.ngInjectableDef = defineInjectable({ factory: function Events_Factory() { return new Events(); }, token: Events, providedIn: \"root\" });\n    return Events;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar LoadingController = /** @class */ (function (_super) {\n    __extends(LoadingController, _super);\n    function LoadingController() {\n        return _super.call(this, loadingController) || this;\n    }\n    LoadingController.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root',\n                },] },\n    ];\n    /** @nocollapse */\n    LoadingController.ctorParameters = function () { return []; };\n    /** @nocollapse */ LoadingController.ngInjectableDef = defineInjectable({ factory: function LoadingController_Factory() { return new LoadingController(); }, token: LoadingController, providedIn: \"root\" });\n    return LoadingController;\n}(OverlayBaseController));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MenuController = /** @class */ (function () {\n    function MenuController() {\n    }\n    /**\n     * Programmatically open the Menu.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return returns a promise when the menu is fully opened\n     */\n    /**\n     * Programmatically open the Menu.\n     * @param {?=} menuId\n     * @return {?} returns a promise when the menu is fully opened\n     */\n    MenuController.prototype.open = /**\n     * Programmatically open the Menu.\n     * @param {?=} menuId\n     * @return {?} returns a promise when the menu is fully opened\n     */\n    function (menuId) {\n        return menuController.open(menuId);\n    };\n    /**\n     * Programmatically close the Menu. If no `menuId` is given as the first\n     * argument then it'll close any menu which is open. If a `menuId`\n     * is given then it'll close that exact menu.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return returns a promise when the menu is fully closed\n     */\n    /**\n     * Programmatically close the Menu. If no `menuId` is given as the first\n     * argument then it'll close any menu which is open. If a `menuId`\n     * is given then it'll close that exact menu.\n     * @param {?=} menuId\n     * @return {?} returns a promise when the menu is fully closed\n     */\n    MenuController.prototype.close = /**\n     * Programmatically close the Menu. If no `menuId` is given as the first\n     * argument then it'll close any menu which is open. If a `menuId`\n     * is given then it'll close that exact menu.\n     * @param {?=} menuId\n     * @return {?} returns a promise when the menu is fully closed\n     */\n    function (menuId) {\n        return menuController.close(menuId);\n    };\n    /**\n     * Toggle the menu. If it's closed, it will open, and if opened, it\n     * will close.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return returns a promise when the menu has been toggled\n     */\n    /**\n     * Toggle the menu. If it's closed, it will open, and if opened, it\n     * will close.\n     * @param {?=} menuId\n     * @return {?} returns a promise when the menu has been toggled\n     */\n    MenuController.prototype.toggle = /**\n     * Toggle the menu. If it's closed, it will open, and if opened, it\n     * will close.\n     * @param {?=} menuId\n     * @return {?} returns a promise when the menu has been toggled\n     */\n    function (menuId) {\n        return menuController.toggle(menuId);\n    };\n    /**\n     * Used to enable or disable a menu. For example, there could be multiple\n     * left menus, but only one of them should be able to be opened at the same\n     * time. If there are multiple menus on the same side, then enabling one menu\n     * will also automatically disable all the others that are on the same side.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu, which is useful for chaining.\n     */\n    /**\n     * Used to enable or disable a menu. For example, there could be multiple\n     * left menus, but only one of them should be able to be opened at the same\n     * time. If there are multiple menus on the same side, then enabling one menu\n     * will also automatically disable all the others that are on the same side.\n     * @param {?} shouldEnable\n     * @param {?=} menuId\n     * @return {?} Returns the instance of the menu, which is useful for chaining.\n     */\n    MenuController.prototype.enable = /**\n     * Used to enable or disable a menu. For example, there could be multiple\n     * left menus, but only one of them should be able to be opened at the same\n     * time. If there are multiple menus on the same side, then enabling one menu\n     * will also automatically disable all the others that are on the same side.\n     * @param {?} shouldEnable\n     * @param {?=} menuId\n     * @return {?} Returns the instance of the menu, which is useful for chaining.\n     */\n    function (shouldEnable, menuId) {\n        return menuController.enable(shouldEnable, menuId);\n    };\n    /**\n     * Used to enable or disable the ability to swipe open the menu.\n     * @param shouldEnable  True if it should be swipe-able, false if not.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu, which is useful for chaining.\n     * @deprecated Use swipeGesture() instead.\n     */\n    /**\n     * Used to enable or disable the ability to swipe open the menu.\n     * @deprecated Use swipeGesture() instead.\n     * @param {?} shouldEnable  True if it should be swipe-able, false if not.\n     * @param {?=} menuId\n     * @return {?} Returns the instance of the menu, which is useful for chaining.\n     */\n    MenuController.prototype.swipeEnable = /**\n     * Used to enable or disable the ability to swipe open the menu.\n     * @deprecated Use swipeGesture() instead.\n     * @param {?} shouldEnable  True if it should be swipe-able, false if not.\n     * @param {?=} menuId\n     * @return {?} Returns the instance of the menu, which is useful for chaining.\n     */\n    function (shouldEnable, menuId) {\n        console.warn('[DEPRECATED][ion-menu-controller] swipeEnable() is deprecated. Use MenuController.swipeGesture() instead');\n        return this.swipeGesture(shouldEnable, menuId);\n    };\n    /**\n     * Used to enable or disable the ability to swipe open the menu.\n     * @param shouldEnable  True if it should be swipe-able, false if not.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu, which is useful for chaining.\n     */\n    /**\n     * Used to enable or disable the ability to swipe open the menu.\n     * @param {?} shouldEnable  True if it should be swipe-able, false if not.\n     * @param {?=} menuId\n     * @return {?} Returns the instance of the menu, which is useful for chaining.\n     */\n    MenuController.prototype.swipeGesture = /**\n     * Used to enable or disable the ability to swipe open the menu.\n     * @param {?} shouldEnable  True if it should be swipe-able, false if not.\n     * @param {?=} menuId\n     * @return {?} Returns the instance of the menu, which is useful for chaining.\n     */\n    function (shouldEnable, menuId) {\n        return menuController.swipeGesture(shouldEnable, menuId);\n    };\n    /**\n     * @param [menuId] Optionally get the menu by its id, or side.\n     * @return Returns true if the specified menu is currently open, otherwise false.\n     * If the menuId is not specified, it returns true if ANY menu is currenly open.\n     */\n    /**\n     * @param {?=} menuId\n     * @return {?} Returns true if the specified menu is currently open, otherwise false.\n     * If the menuId is not specified, it returns true if ANY menu is currenly open.\n     */\n    MenuController.prototype.isOpen = /**\n     * @param {?=} menuId\n     * @return {?} Returns true if the specified menu is currently open, otherwise false.\n     * If the menuId is not specified, it returns true if ANY menu is currenly open.\n     */\n    function (menuId) {\n        return menuController.isOpen(menuId);\n    };\n    /**\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns true if the menu is currently enabled, otherwise false.\n     */\n    /**\n     * @param {?=} menuId\n     * @return {?} Returns true if the menu is currently enabled, otherwise false.\n     */\n    MenuController.prototype.isEnabled = /**\n     * @param {?=} menuId\n     * @return {?} Returns true if the menu is currently enabled, otherwise false.\n     */\n    function (menuId) {\n        return menuController.isEnabled(menuId);\n    };\n    /**\n     * Used to get a menu instance. If a `menuId` is not provided then it'll\n     * return the first menu found. If a `menuId` is `left` or `right`, then\n     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\n     * provided, then it'll try to find the menu using the menu's `id`\n     * property. If a menu is not found then it'll return `null`.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu if found, otherwise `null`.\n     */\n    /**\n     * Used to get a menu instance. If a `menuId` is not provided then it'll\n     * return the first menu found. If a `menuId` is `left` or `right`, then\n     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\n     * provided, then it'll try to find the menu using the menu's `id`\n     * property. If a menu is not found then it'll return `null`.\n     * @param {?=} menuId\n     * @return {?} Returns the instance of the menu if found, otherwise `null`.\n     */\n    MenuController.prototype.get = /**\n     * Used to get a menu instance. If a `menuId` is not provided then it'll\n     * return the first menu found. If a `menuId` is `left` or `right`, then\n     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\n     * provided, then it'll try to find the menu using the menu's `id`\n     * property. If a menu is not found then it'll return `null`.\n     * @param {?=} menuId\n     * @return {?} Returns the instance of the menu if found, otherwise `null`.\n     */\n    function (menuId) {\n        return menuController.get(menuId);\n    };\n    /**\n     * @return Returns the instance of the menu already opened, otherwise `null`.\n     */\n    /**\n     * @return {?} Returns the instance of the menu already opened, otherwise `null`.\n     */\n    MenuController.prototype.getOpen = /**\n     * @return {?} Returns the instance of the menu already opened, otherwise `null`.\n     */\n    function () {\n        return menuController.getOpen();\n    };\n    /**\n     * @return Returns an array of all menu instances.\n     */\n    /**\n     * @return {?} Returns an array of all menu instances.\n     */\n    MenuController.prototype.getMenus = /**\n     * @return {?} Returns an array of all menu instances.\n     */\n    function () {\n        return menuController.getMenus();\n    };\n    MenuController.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root',\n                },] },\n    ];\n    /** @nocollapse */ MenuController.ngInjectableDef = defineInjectable({ factory: function MenuController_Factory() { return new MenuController(); }, token: MenuController, providedIn: \"root\" });\n    return MenuController;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar PickerController = /** @class */ (function (_super) {\n    __extends(PickerController, _super);\n    function PickerController() {\n        return _super.call(this, pickerController) || this;\n    }\n    PickerController.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root',\n                },] },\n    ];\n    /** @nocollapse */\n    PickerController.ctorParameters = function () { return []; };\n    /** @nocollapse */ PickerController.ngInjectableDef = defineInjectable({ factory: function PickerController_Factory() { return new PickerController(); }, token: PickerController, providedIn: \"root\" });\n    return PickerController;\n}(OverlayBaseController));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ModalController = /** @class */ (function (_super) {\n    __extends(ModalController, _super);\n    function ModalController(angularDelegate, resolver, injector) {\n        var _this = _super.call(this, modalController) || this;\n        _this.angularDelegate = angularDelegate;\n        _this.resolver = resolver;\n        _this.injector = injector;\n        return _this;\n    }\n    /**\n     * @param {?} opts\n     * @return {?}\n     */\n    ModalController.prototype.create = /**\n     * @param {?} opts\n     * @return {?}\n     */\n    function (opts) {\n        return _super.prototype.create.call(this, __assign({}, opts, { delegate: this.angularDelegate.create(this.resolver, this.injector) }));\n    };\n    ModalController.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ModalController.ctorParameters = function () { return [\n        { type: AngularDelegate },\n        { type: ComponentFactoryResolver },\n        { type: Injector }\n    ]; };\n    return ModalController;\n}(OverlayBaseController));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar PopoverController = /** @class */ (function (_super) {\n    __extends(PopoverController, _super);\n    function PopoverController(angularDelegate, resolver, injector) {\n        var _this = _super.call(this, popoverController) || this;\n        _this.angularDelegate = angularDelegate;\n        _this.resolver = resolver;\n        _this.injector = injector;\n        return _this;\n    }\n    /**\n     * @param {?} opts\n     * @return {?}\n     */\n    PopoverController.prototype.create = /**\n     * @param {?} opts\n     * @return {?}\n     */\n    function (opts) {\n        return _super.prototype.create.call(this, __assign({}, opts, { delegate: this.angularDelegate.create(this.resolver, this.injector) }));\n    };\n    PopoverController.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    PopoverController.ctorParameters = function () { return [\n        { type: AngularDelegate },\n        { type: ComponentFactoryResolver },\n        { type: Injector }\n    ]; };\n    return PopoverController;\n}(OverlayBaseController));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ToastController = /** @class */ (function (_super) {\n    __extends(ToastController, _super);\n    function ToastController() {\n        return _super.call(this, toastController) || this;\n    }\n    ToastController.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root',\n                },] },\n    ];\n    /** @nocollapse */\n    ToastController.ctorParameters = function () { return []; };\n    /** @nocollapse */ ToastController.ngInjectableDef = defineInjectable({ factory: function ToastController_Factory() { return new ToastController(); }, token: ToastController, providedIn: \"root\" });\n    return ToastController;\n}(OverlayBaseController));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar DomController = /** @class */ (function () {\n    function DomController() {\n    }\n    /**\n     * Schedules a task to run during the READ phase of the next frame.\n     * This task should only read the DOM, but never modify it.\n     */\n    /**\n     * Schedules a task to run during the READ phase of the next frame.\n     * This task should only read the DOM, but never modify it.\n     * @param {?} cb\n     * @return {?}\n     */\n    DomController.prototype.read = /**\n     * Schedules a task to run during the READ phase of the next frame.\n     * This task should only read the DOM, but never modify it.\n     * @param {?} cb\n     * @return {?}\n     */\n    function (cb) {\n        getQueue().read(cb);\n    };\n    /**\n     * Schedules a task to run during the WRITE phase of the next frame.\n     * This task should write the DOM, but never READ it.\n     */\n    /**\n     * Schedules a task to run during the WRITE phase of the next frame.\n     * This task should write the DOM, but never READ it.\n     * @param {?} cb\n     * @return {?}\n     */\n    DomController.prototype.write = /**\n     * Schedules a task to run during the WRITE phase of the next frame.\n     * This task should write the DOM, but never READ it.\n     * @param {?} cb\n     * @return {?}\n     */\n    function (cb) {\n        getQueue().write(cb);\n    };\n    DomController.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root',\n                },] },\n    ];\n    /** @nocollapse */ DomController.ngInjectableDef = defineInjectable({ factory: function DomController_Factory() { return new DomController(); }, token: DomController, providedIn: \"root\" });\n    return DomController;\n}());\n/** @type {?} */\nvar getQueue = (/**\n * @return {?}\n */\nfunction () {\n    /** @type {?} */\n    var win = typeof ((/** @type {?} */ (window))) !== 'undefined' ? window : (/** @type {?} */ (null));\n    if (win != null) {\n        /** @type {?} */\n        var Ionic = win.Ionic;\n        if (Ionic && Ionic.queue) {\n            return Ionic.queue;\n        }\n        return {\n            read: (/**\n             * @param {?} cb\n             * @return {?}\n             */\n            function (cb) { return win.requestAnimationFrame(cb); }),\n            write: (/**\n             * @param {?} cb\n             * @return {?}\n             */\n            function (cb) { return win.requestAnimationFrame(cb); })\n        };\n    }\n    return {\n        read: (/**\n         * @param {?} cb\n         * @return {?}\n         */\n        function (cb) { return cb(); }),\n        write: (/**\n         * @param {?} cb\n         * @return {?}\n         */\n        function (cb) { return cb(); })\n    };\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IonicRouteStrategy = /** @class */ (function () {\n    function IonicRouteStrategy() {\n    }\n    /**\n     * @param {?} _route\n     * @return {?}\n     */\n    IonicRouteStrategy.prototype.shouldDetach = /**\n     * @param {?} _route\n     * @return {?}\n     */\n    function (_route) {\n        return false;\n    };\n    /**\n     * @param {?} _route\n     * @return {?}\n     */\n    IonicRouteStrategy.prototype.shouldAttach = /**\n     * @param {?} _route\n     * @return {?}\n     */\n    function (_route) {\n        return false;\n    };\n    /**\n     * @param {?} _route\n     * @param {?} _detachedTree\n     * @return {?}\n     */\n    IonicRouteStrategy.prototype.store = /**\n     * @param {?} _route\n     * @param {?} _detachedTree\n     * @return {?}\n     */\n    function (_route, _detachedTree) {\n        return;\n    };\n    /**\n     * @param {?} _route\n     * @return {?}\n     */\n    IonicRouteStrategy.prototype.retrieve = /**\n     * @param {?} _route\n     * @return {?}\n     */\n    function (_route) {\n        return null;\n    };\n    /**\n     * @param {?} future\n     * @param {?} curr\n     * @return {?}\n     */\n    IonicRouteStrategy.prototype.shouldReuseRoute = /**\n     * @param {?} future\n     * @param {?} curr\n     * @return {?}\n     */\n    function (future, curr) {\n        if (future.routeConfig !== curr.routeConfig) {\n            return false;\n        }\n        // checking router params\n        /** @type {?} */\n        var futureParams = future.params;\n        /** @type {?} */\n        var currentParams = curr.params;\n        /** @type {?} */\n        var keysA = Object.keys(futureParams);\n        /** @type {?} */\n        var keysB = Object.keys(currentParams);\n        if (keysA.length !== keysB.length) {\n            return false;\n        }\n        // Test for A's keys different from B.\n        for (var _i = 0, keysA_1 = keysA; _i < keysA_1.length; _i++) {\n            var key = keysA_1[_i];\n            if (currentParams[key] !== futureParams[key]) {\n                return false;\n            }\n        }\n        return true;\n    };\n    return IonicRouteStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar didInitialize = false;\n/** @type {?} */\nvar appInitialize = (/**\n * @param {?} config\n * @param {?} doc\n * @param {?} zone\n * @return {?}\n */\nfunction (config, doc, zone) {\n    return (/**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var win = (/** @type {?} */ (doc.defaultView));\n        if (win) {\n            if (didInitialize) {\n                console.warn('Ionic Angular was already initialized. Make sure IonicModule.forRoot() is just called once.');\n            }\n            didInitialize = true;\n            /** @type {?} */\n            var Ionic = win.Ionic = win.Ionic || {};\n            Ionic.config = __assign({}, config, { _zoneGate: (/**\n                 * @param {?} h\n                 * @return {?}\n                 */\n                function (h) { return zone.run(h); }) });\n            /** @type {?} */\n            var aelFn_1 = '__zone_symbol__addEventListener' in ((/** @type {?} */ (doc.body)))\n                ? '__zone_symbol__addEventListener'\n                : 'addEventListener';\n            return applyPolyfills().then((/**\n             * @return {?}\n             */\n            function () {\n                return defineCustomElements(win, {\n                    exclude: ['ion-tabs', 'ion-tab'],\n                    syncQueue: true,\n                    raf: raf,\n                    jmp: (/**\n                     * @param {?} h\n                     * @return {?}\n                     */\n                    function (h) { return zone.runOutsideAngular(h); }),\n                    ael: /**\n                     * @param {?} elm\n                     * @param {?} eventName\n                     * @param {?} cb\n                     * @param {?} opts\n                     * @return {?}\n                     */\n                    function (elm, eventName, cb, opts) {\n                        ((/** @type {?} */ (elm)))[aelFn_1](eventName, cb, opts);\n                    },\n                    rel: /**\n                     * @param {?} elm\n                     * @param {?} eventName\n                     * @param {?} cb\n                     * @param {?} opts\n                     * @return {?}\n                     */\n                    function (elm, eventName, cb, opts) {\n                        elm.removeEventListener(eventName, cb, opts);\n                    }\n                });\n            }));\n        }\n    });\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar DECLARATIONS = [\n    // proxies\n    IonApp,\n    IonAvatar,\n    IonBackButton,\n    IonBackdrop,\n    IonBadge,\n    IonButton,\n    IonButtons,\n    IonCard,\n    IonCardContent,\n    IonCardHeader,\n    IonCardSubtitle,\n    IonCardTitle,\n    IonCheckbox,\n    IonChip,\n    IonCol,\n    IonContent,\n    IonDatetime,\n    IonFab,\n    IonFabButton,\n    IonFabList,\n    IonFooter,\n    IonGrid,\n    IonHeader,\n    IonIcon,\n    IonImg,\n    IonInfiniteScroll,\n    IonInfiniteScrollContent,\n    IonInput,\n    IonItem,\n    IonItemDivider,\n    IonItemGroup,\n    IonItemOption,\n    IonItemOptions,\n    IonItemSliding,\n    IonLabel,\n    IonList,\n    IonListHeader,\n    IonMenu,\n    IonMenuButton,\n    IonMenuToggle,\n    IonNav,\n    IonNavLink,\n    IonNavPop,\n    IonNavPush,\n    IonNavSetRoot,\n    IonNote,\n    IonProgressBar,\n    IonRadio,\n    IonRadioGroup,\n    IonRange,\n    IonRefresher,\n    IonRefresherContent,\n    IonReorder,\n    IonReorderGroup,\n    IonRippleEffect,\n    IonRow,\n    IonSearchbar,\n    IonSegment,\n    IonSegmentButton,\n    IonSelect,\n    IonSelectOption,\n    IonSkeletonText,\n    IonSlide,\n    IonSlides,\n    IonSpinner,\n    IonSplitPane,\n    IonTabBar,\n    IonTabButton,\n    IonText,\n    IonTextarea,\n    IonThumbnail,\n    IonToggle,\n    IonToolbar,\n    IonTitle,\n    IonTabs,\n    // ngModel accessors\n    BooleanValueAccessor,\n    NumericValueAccessor,\n    RadioValueAccessor,\n    SelectValueAccessor,\n    TextValueAccessor,\n    // navigation\n    IonRouterOutlet,\n    IonBackButtonDelegate,\n    NavDelegate,\n    RouterLinkDelegate,\n    // virtual scroll\n    VirtualFooter,\n    VirtualHeader,\n    VirtualItem,\n    IonVirtualScroll,\n    // Deprecations\n    CssUtilsDeprecations\n];\nvar IonicModule = /** @class */ (function () {\n    function IonicModule() {\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    IonicModule.forRoot = /**\n     * @param {?=} config\n     * @return {?}\n     */\n    function (config) {\n        return {\n            ngModule: IonicModule,\n            providers: [\n                {\n                    provide: ConfigToken,\n                    useValue: config\n                },\n                {\n                    provide: APP_INITIALIZER,\n                    useFactory: appInitialize,\n                    multi: true,\n                    deps: [\n                        ConfigToken,\n                        DOCUMENT,\n                        NgZone\n                    ]\n                }\n            ]\n        };\n    };\n    IonicModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: DECLARATIONS,\n                    exports: DECLARATIONS,\n                    providers: [AngularDelegate, ModalController, PopoverController],\n                    imports: [CommonModule]\n                },] },\n    ];\n    return IonicModule;\n}());\n\nexport { ActionSheetController, AlertController, AngularDelegate, BooleanValueAccessor, Config, CssUtilsDeprecations, DomController, Events, IonApp, IonAvatar, IonBackButton, IonBackButtonDelegate, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonNav, IonNavLink, IonNavPop, IonNavPush, IonNavSetRoot, IonNote, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToggle, IonToolbar, IonVirtualScroll, IonicModule, IonicRouteStrategy, LoadingController, MenuController, ModalController, NavController, NavDelegate, NavParams, NumericValueAccessor, PickerController, Platform, PopoverController, RadioValueAccessor, RouterLinkDelegate, SelectValueAccessor, TextValueAccessor, ToastController, VirtualFooter, VirtualHeader, VirtualItem, ConfigToken as a, ValueAccessor as b, OverlayBaseController as d, appInitialize as e };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8GM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAgHA,AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAwCA,AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCAOA;;;;;;;;;;;;;;;;;;;;;;;MAuBA,AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAOA;;;;;;;;;;;;;;;;;;;;;;;MAuBA,AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAOA;;;;;;;;;;;;;;;;;;;;;;;MAuBA,AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAgeA,AAKA;;;;;;;;;;;;;;;;;4PAMuM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAwbvM,AAKA;;;;;;;;;;;;;;;;;;wSAQuQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAuHxQ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;KAQJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;KAQJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;;KAWJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;;KAWJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;KAQJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;KAQJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;;KAWJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;KAQJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;KAUJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;KASJ,AAGC;;;;;;;;;;;;;;;0HAMG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAmFH,AAKA;;;;;;;;;yFAC+J;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAoJ/J,AAGA;;;;;;;;;;oHAKG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA0yCH,AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2aAqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAgGA,AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAmCA,AAMA;;;;;;;;;;;;;;;;;;;;;;;;cAQA;;;;;;;;;;;KAWD,AAKC;;;;;;;;;;;;;;;;6KAQG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA6EH,AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;cAWA;;;;;;;;;;;;;;KAcD,AAGC;;;;;;;;;;8EAIG;;;;;;;;;;;;;;KAcJ,AAGC;;;;;;;;;;8EAIG;;;;;;;;;;;;;;;KAeJ,AAGC;;;;;;;;;;;6HAKG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA+GH,AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAkED,AAKC;;;;;;;;;;;;8DAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAgMJ,AAKC;;;;;;;;;;;0CAG2N;;;;;;;;;;;;KAY5N,AAKC;;;;;;;;;;;0CAGmM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAsInM,AAKA;;;;;;;;;;;4FAG+J;;;;;;;;;;;;KAYhK,AAKC;;;;;;;;;;;0CAG2M;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2O3M,AAKA;;;;;;;;;uLAC+L;;;;;;;;;;;;KAYhM,AAKC;;;;;;;;;;;0CAGuM;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2BvM,AAGA;;;;;;;;;;;qIAMG;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2BH,AAGA;;;;;;;;;;;qIAMG;;;;;;;;;;;;KAYJ,AAKC;;;;;;;;;;;0CAGmM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAgDnM,AAKA;;;;;;;;;6DAC2L;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAqV3L;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0CAQA;;;;;"}