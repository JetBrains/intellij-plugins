{"version":3,"sources":["/Users/piotr.tomiak/WebstormProjects/ng9rc/node_modules/@ngneat/transloco/fesm2015/ngneat-transloco.js"],"names":[],"mappings":"AAAA;;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0RC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4yBA,+JAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6/BAUiY;;;;;;;;;;;;;CAOlY,4BAOC;;;;;;;;;;;;;cAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsVD,waAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmFD,kGAMC;;;;;;;;;;;;;;;;;;;;;;;;kTAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BD;;;;;;;;;;;;;oBAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmDD;;;;;;;oBAKC","file":"ngneat-transloco.js","sourcesContent":["import flat from 'flat';\nimport { take, map, catchError, retry, shareReplay, switchMap, tap } from 'rxjs/operators';\nimport { InjectionToken, Inject, Injectable, Optional, Component, Input, NgModule, TemplateRef, ComponentFactoryResolver, ChangeDetectorRef, Pipe, Directive, ElementRef, ViewContainerRef, defineInjectable, inject } from '@angular/core';\nimport { of, from, BehaviorSubject, combineLatest, forkJoin, Subject } from 'rxjs';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DefaultLoader {\n    /**\n     * @param {?} translations\n     */\n    constructor(translations) {\n        this.translations = translations;\n    }\n    /**\n     * @param {?} lang\n     * @return {?}\n     */\n    getTranslation(lang) {\n        return of(this.translations.get(lang) || {});\n    }\n}\n/** @type {?} */\nconst TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} obj\n * @param {?} path\n * @return {?}\n */\nfunction getValue(obj, path) {\n    /* For cases where the key is like: 'general.something.thing' */\n    if (obj && obj.hasOwnProperty(path)) {\n        return obj[path];\n    }\n    return path.split('.').reduce((/**\n     * @param {?} p\n     * @param {?} c\n     * @return {?}\n     */\n    (p, c) => p && p[c]), obj);\n}\n/**\n * @param {?} obj\n * @param {?} prop\n * @param {?} val\n * @return {?}\n */\nfunction setValue(obj, prop, val) {\n    obj = Object.assign({}, obj);\n    /** @type {?} */\n    const split = prop.split('.');\n    /** @type {?} */\n    const lastIndex = split.length - 1;\n    split.reduce((/**\n     * @param {?} acc\n     * @param {?} part\n     * @param {?} index\n     * @return {?}\n     */\n    (acc, part, index) => {\n        if (index === lastIndex) {\n            acc[part] = val;\n        }\n        else {\n            acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n        }\n        return acc && acc[part];\n    }), obj);\n    return obj;\n}\n/**\n * @param {?} collection\n * @return {?}\n */\nfunction size(collection) {\n    if (!collection) {\n        return 0;\n    }\n    if (Array.isArray(collection)) {\n        return collection.length;\n    }\n    if (isObject(collection)) {\n        return Object.keys(collection).length;\n    }\n    return !!collection ? collection.length : 0;\n}\n/**\n * @param {?} collection\n * @return {?}\n */\nfunction isEmpty(collection) {\n    return size(collection) === 0;\n}\n/**\n * @param {?} val\n * @return {?}\n */\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\n/**\n * @param {?} val\n * @return {?}\n */\nfunction isString(val) {\n    return typeof val === 'string';\n}\n/**\n * @param {?} val\n * @return {?}\n */\nfunction isNumber(val) {\n    return typeof val === 'number';\n}\n/**\n * @param {?} item\n * @return {?}\n */\nfunction isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n}\n/**\n * @param {?} val\n * @return {?}\n */\nfunction coerceArray(val) {\n    return Array.isArray(val) ? val : [val];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\n/**\n * @param {?} str\n * @return {?}\n */\nfunction toCamelCase(str) {\n    return str\n        .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (/**\n     * @param {?} word\n     * @param {?} index\n     * @return {?}\n     */\n    (word, index) => (index == 0 ? word.toLowerCase() : word.toUpperCase())))\n        .replace(/\\s+|_|-|\\//g, '');\n}\n/**\n * @return {?}\n */\nfunction isBrowser() {\n    return typeof window !== 'undefined';\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isNil(value) {\n    return value === null || value === undefined;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isDefined(value) {\n    return isNil(value) === false;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toNumber(value) {\n    if (isNumber(value))\n        return value;\n    if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n        return Number(value);\n    }\n    return null;\n}\n/**\n * @param {?} item\n * @return {?}\n */\nfunction isScopeObject(item) {\n    return item && typeof item.scope === 'string';\n}\n/**\n * @param {?} item\n * @return {?}\n */\nfunction hasInlineLoader(item) {\n    return item && isObject(item.loader);\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction unflatten(obj) {\n    return flat.unflatten(obj, { safe: true });\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction flatten(obj) {\n    return flat(obj, { safe: true });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\nclass DefaultTranspiler {\n    /**\n     * @param {?} value\n     * @param {?=} params\n     * @param {?=} translation\n     * @return {?}\n     */\n    transpile(value, params = {}, translation) {\n        if (isString(value)) {\n            return value.replace(/{{(.*?)}}/g, (/**\n             * @param {?} _\n             * @param {?} match\n             * @return {?}\n             */\n            function (_, match) {\n                match = match.trim();\n                if (isDefined(params[match])) {\n                    return params[match];\n                }\n                return isDefined(translation[match]) ? translation[match] : '';\n            }));\n        }\n        if (isObject(value) && params) {\n            /**\n             *\n             * @example\n             *\n             * const en = {\n             *  a: {\n             *    b: {\n             *      c: \"Hello {{ value }}\"\n             *    }\n             *  }\n             * }\n             *\n             * const params =  {\n             *  \"b.c\": { value: \"Transloco \"}\n             * }\n             *\n             * service.selectTranslate('a', params);\n             *\n             * // the first param will be the result of `en.a`.\n             * // the second param will be `params`.\n             * parser.transpile(value, params, {});\n             *\n             *\n             */\n            Object.keys(params).forEach((/**\n             * @param {?} p\n             * @return {?}\n             */\n            p => {\n                // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n                /** @type {?} */\n                const v = getValue(value, p);\n                // get the params of \"b.c\" => { value: \"Transloco\" }\n                /** @type {?} */\n                const getParams = getValue(params, p);\n                // transpile the value => \"Hello Transloco\"\n                /** @type {?} */\n                const transpiled = this.transpile(v, getParams, translation);\n                // set \"b.c\" to `transpiled`\n                value = setValue(value, p, transpiled);\n            }));\n        }\n        return value;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n    providedIn: 'root',\n    factory: (/**\n     * @return {?}\n     */\n    () => {\n        return {};\n    })\n});\n/** @type {?} */\nconst defaultConfig = {\n    defaultLang: 'en',\n    reRenderOnLangChange: false,\n    prodMode: false,\n    failedRetries: 2,\n    availableLangs: [],\n    missingHandler: {\n        logMissingKey: true,\n        useFallbackTranslation: false,\n        allowEmpty: false\n    },\n    flatten: {\n        aot: false\n    }\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\nclass DefaultHandler {\n    /**\n     * @param {?} key\n     * @param {?} config\n     * @return {?}\n     */\n    handle(key, config) {\n        if (config.missingHandler.logMissingKey && !config.prodMode) {\n            /** @type {?} */\n            const msg = `Missing translation for '${key}'`;\n            console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n        }\n        return key;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\nclass DefaultInterceptor {\n    /**\n     * @param {?} translation\n     * @param {?} lang\n     * @return {?}\n     */\n    preSaveTranslation(translation, lang) {\n        return translation;\n    }\n    /**\n     * @param {?} key\n     * @param {?} value\n     * @param {?} lang\n     * @return {?}\n     */\n    preSaveTranslationKey(key, value, lang) {\n        return value;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\nclass DefaultFallbackStrategy {\n    /**\n     * @param {?} userConfig\n     */\n    constructor(userConfig) {\n        this.userConfig = userConfig;\n    }\n    /**\n     * @param {?} failedLang\n     * @return {?}\n     */\n    getNextLangs(failedLang) {\n        /** @type {?} */\n        const fallbackLang = this.userConfig.fallbackLang;\n        if (!fallbackLang) {\n            throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n        }\n        return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n    }\n}\n/** @nocollapse */\nDefaultFallbackStrategy.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_CONFIG,] }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} defaultConfig\n * @param {?} userConfig\n * @return {?}\n */\nfunction mergeConfig(defaultConfig, userConfig) {\n    return Object.assign({}, defaultConfig, userConfig, { missingHandler: Object.assign({}, defaultConfig.missingHandler, userConfig.missingHandler), flatten: Object.assign({}, defaultConfig.flatten, userConfig.flatten) });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\n/**\n * @param {?} lang\n * @return {?}\n */\nfunction getScopeFromLang(lang) {\n    if (!lang) {\n        return '';\n    }\n    /** @type {?} */\n    const split = lang.split('/');\n    split.pop();\n    return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\n/**\n * @param {?} lang\n * @return {?}\n */\nfunction getLangFromScope(lang) {\n    if (!lang) {\n        return '';\n    }\n    /** @type {?} */\n    const split = lang.split('/');\n    return split.pop();\n}\n/**\n * \\@example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n * @param {?} str\n * @param {?} value\n * @param {?=} char\n * @return {?}\n */\nfunction getPipeValue(str, value, char = '|') {\n    if (isString(str)) {\n        /** @type {?} */\n        const splitted = str.split(char);\n        /** @type {?} */\n        const lastItem = splitted.pop();\n        return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n    }\n    return [false, ''];\n}\n/**\n * @param {?} service\n * @param {?} lang\n * @return {?}\n */\nfunction shouldListenToLangChanges(service, lang) {\n    const [hasStatic] = getPipeValue(lang, 'static');\n    if (hasStatic === false) {\n        // If we didn't get 'lang|static' check if it's set in the global level\n        return service.config.reRenderOnLangChange;\n    }\n    // We have 'lang|static' so don't listen to lang changes\n    return false;\n}\n/**\n * @param {?} listenToLangChange\n * @return {?}\n */\nfunction listenOrNotOperator(listenToLangChange) {\n    return listenToLangChange ? (/**\n     * @param {?} source\n     * @return {?}\n     */\n    source => source) : take(1);\n}\n/**\n * @param {?} inlineLoader\n * @param {?} scope\n * @return {?}\n */\nfunction prependScope(inlineLoader, scope) {\n    return Object.keys(inlineLoader).reduce((/**\n     * @param {?} acc\n     * @param {?} lang\n     * @return {?}\n     */\n    (acc, lang) => {\n        acc[`${scope}/${lang}`] = inlineLoader[lang];\n        return acc;\n    }), {});\n}\n/**\n * @param {?} providerScope\n * @param {?} scope\n * @return {?}\n */\nfunction resolveInlineLoader(providerScope, scope) {\n    return hasInlineLoader(providerScope) ? prependScope(providerScope.loader, scope) : null;\n}\n/**\n * @param {?} lang\n * @return {?}\n */\nfunction getEventPayload(lang) {\n    return {\n        scope: getScopeFromLang(lang) || null,\n        langName: getLangFromScope(lang),\n        lang\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} path\n * @param {?} mainLoader\n * @param {?} inlineLoader\n * @return {?}\n */\nfunction resolveLoader(path, mainLoader, inlineLoader) {\n    if (inlineLoader) {\n        /** @type {?} */\n        const pathLoader = inlineLoader[path];\n        if (isFunction(pathLoader) === false) {\n            throw `You're using an inline loader but didn't provide a loader for ${path}`;\n        }\n        return inlineLoader[path]().then((/**\n         * @param {?} res\n         * @return {?}\n         */\n        res => (res.default ? res.default : res)));\n    }\n    return mainLoader.getTranslation(path);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} mainPath\n * @param {?} fallbackPath\n * @param {?} mainLoader\n * @param {?} inlineLoader\n * @return {?}\n */\nfunction getFallbacksLoaders(mainPath, fallbackPath, mainLoader, inlineLoader) {\n    return [mainPath, fallbackPath].map((/**\n     * @param {?} path\n     * @return {?}\n     */\n    path => {\n        /** @type {?} */\n        const loader = resolveLoader(path, mainLoader, inlineLoader);\n        return from(loader).pipe(map((/**\n         * @param {?} translation\n         * @return {?}\n         */\n        translation => ({\n            translation,\n            lang: path\n        }))));\n    }));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nlet service;\n/**\n * @template T\n * @param {?} key\n * @param {?=} params\n * @param {?=} lang\n * @return {?}\n */\nfunction translate(key, params = {}, lang) {\n    return service.translate(key, params, lang);\n}\nclass TranslocoService {\n    /**\n     * @param {?} loader\n     * @param {?} parser\n     * @param {?} missingHandler\n     * @param {?} interceptor\n     * @param {?} userConfig\n     * @param {?} fallbackStrategy\n     */\n    constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n        this.loader = loader;\n        this.parser = parser;\n        this.missingHandler = missingHandler;\n        this.interceptor = interceptor;\n        this.userConfig = userConfig;\n        this.fallbackStrategy = fallbackStrategy;\n        this.translations = new Map();\n        this.cache = new Map();\n        this.firstFallbackLang = null;\n        this.availableLangs = [];\n        this.isResolvedMissingOnce = false;\n        this.events = new Subject();\n        this.events$ = this.events.asObservable();\n        this.failedCounter = 0;\n        this.failedLangs = new Set();\n        if (!this.loader) {\n            this.loader = new DefaultLoader(this.translations);\n        }\n        service = this;\n        this.mergedConfig = mergeConfig(defaultConfig, userConfig);\n        this.setAvailableLangs(this.mergedConfig.availableLangs);\n        this.setFallbackLangForMissingTranslation(this.mergedConfig);\n        this.setDefaultLang(this.mergedConfig.defaultLang);\n        this.lang = new BehaviorSubject(this.getDefaultLang());\n        // Don't use distinctUntilChanged as we need the ability to update\n        // the value when using setTranslation or setTranslationKeys\n        this.langChanges$ = this.lang.asObservable();\n        /**\n         * When we have a failure, we want to define the next language that succeeded as the active\n         */\n        this.subscription = this.events$.subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n                // Handle scoped lang\n                /** @type {?} */\n                const lang = getLangFromScope(e.payload.lang);\n                this.setActiveLang(lang);\n            }\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    get config() {\n        return this.mergedConfig;\n    }\n    /**\n     * @return {?}\n     */\n    getDefaultLang() {\n        return this.defaultLang;\n    }\n    /**\n     * @param {?} lang\n     * @return {?}\n     */\n    setDefaultLang(lang) {\n        this.defaultLang = lang;\n    }\n    /**\n     * @return {?}\n     */\n    getActiveLang() {\n        return this.lang.getValue();\n    }\n    /**\n     * @template THIS\n     * @this {THIS}\n     * @param {?} lang\n     * @return {THIS}\n     */\n    setActiveLang(lang) {\n        (/** @type {?} */ (this)).lang.next(lang);\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * @param {?} langs\n     * @return {?}\n     */\n    setAvailableLangs(langs) {\n        this.availableLangs = langs;\n    }\n    /**\n     * @return {?}\n     */\n    getAvailableLangs() {\n        return this.availableLangs;\n    }\n    /**\n     * @param {?} path\n     * @param {?=} options\n     * @return {?}\n     */\n    load(path, options = {}) {\n        if (this.cache.has(path) === false) {\n            /** @type {?} */\n            let loadTranslation;\n            if (this.useFallbackTranslation(path)) {\n                // if the path is scope the fallback should be `scope/fallbackLang`;\n                /** @type {?} */\n                const fallback = this._isLangScoped(path)\n                    ? `${getScopeFromLang(path)}/${this.firstFallbackLang}`\n                    : this.firstFallbackLang;\n                /** @type {?} */\n                const loaders = getFallbacksLoaders(path, fallback, this.loader, options.inlineLoader);\n                loadTranslation = forkJoin(loaders);\n            }\n            else {\n                /** @type {?} */\n                const loader = resolveLoader(path, this.loader, options.inlineLoader);\n                loadTranslation = from(loader);\n            }\n            /** @type {?} */\n            const load$ = loadTranslation.pipe(retry(this.config.failedRetries), catchError((/**\n             * @return {?}\n             */\n            () => this.handleFailure(path, options))), tap((/**\n             * @param {?} translation\n             * @return {?}\n             */\n            translation => {\n                if (Array.isArray(translation)) {\n                    translation.forEach((/**\n                     * @param {?} t\n                     * @return {?}\n                     */\n                    t => {\n                        this.handleSuccess(t.lang, t.translation);\n                        // Save the fallback in cache so we'll not create a redundant request\n                        if (t.lang !== path) {\n                            this.cache.set(t.lang, of({}));\n                        }\n                    }));\n                    return;\n                }\n                this.handleSuccess(path, translation);\n            })), shareReplay(1));\n            this.cache.set(path, load$);\n        }\n        return this.cache.get(path);\n    }\n    /**\n     * Gets the instant translated value of a key\n     *\n     * \\@example\n     *\n     * translate<string>('hello')\n     * translate('hello', { value: 'value' })\n     * translate<string[]>(['hello', 'key'])\n     * translate('hello', { }, 'en')\n     * translate('scope.someKey', { }, 'en')\n     * @template T\n     * @param {?} key\n     * @param {?=} params\n     * @param {?=} lang\n     * @return {?}\n     */\n    translate(key, params = {}, lang = this.getActiveLang()) {\n        /** @type {?} */\n        let resolveLang = lang;\n        /** @type {?} */\n        let scope;\n        // If lang is scope we need to check the following cases:\n        // todos/es => in this case we should take `es` as lang\n        // todos => in this case we should set the active lang as lang\n        if (this._isLangScoped(lang)) {\n            // en for example\n            /** @type {?} */\n            const langFromScope = getLangFromScope(lang);\n            // en is lang\n            /** @type {?} */\n            const hasLang = this._isLang(langFromScope);\n            // take en\n            resolveLang = hasLang ? langFromScope : this.getActiveLang();\n            // find the scope\n            scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n        }\n        if (Array.isArray(key)) {\n            return (/** @type {?} */ (key.map((/**\n             * @param {?} k\n             * @return {?}\n             */\n            k => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang)))));\n        }\n        key = scope ? `${scope}.${key}` : key;\n        if (!key) {\n            return this.missingHandler.handle(key, this.config);\n        }\n        /** @type {?} */\n        const translation = this.getTranslation(resolveLang);\n        /** @type {?} */\n        const value = translation[key];\n        if (!value) {\n            return this._handleMissingKey(key, value, params);\n        }\n        return this.parser.transpile(value, params, translation);\n    }\n    /**\n     * Gets the translated value of a key as observable\n     *\n     * \\@example\n     *\n     * selectTranslate<string>('hello').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n     *\n     * @template T\n     * @param {?} key\n     * @param {?=} params\n     * @param {?=} lang\n     * @param {?=} _isObject\n     * @return {?}\n     */\n    selectTranslate(key, params, lang, _isObject = false) {\n        /** @type {?} */\n        const load = (/**\n         * @param {?} lang\n         * @return {?}\n         */\n        lang => this.load(lang).pipe(map((/**\n         * @return {?}\n         */\n        () => (_isObject ? this.translateObject(key, params, lang) : this.translate(key, params, lang))))));\n        if (isString(lang)) {\n            /** @type {?} */\n            const langOrScope = this._completeScopeWithLang(lang);\n            return load(langOrScope);\n        }\n        else {\n            // if the user doesn't pass lang, we need to listen to lang changes and update the value accordingly\n            return this.langChanges$.pipe(switchMap((/**\n             * @param {?} lang\n             * @return {?}\n             */\n            lang => load(lang))));\n        }\n    }\n    /**\n     * Translate the given path that returns an object\n     *\n     * \\@example\n     *\n     * service.translateObject('path.to.object', {'subpath': { value: 'someValue'}}) => returns translated object\n     *\n     * @template T\n     * @param {?} key\n     * @param {?=} params\n     * @param {?=} lang\n     * @return {?}\n     */\n    translateObject(key, params, lang = this.getActiveLang()) {\n        if (Array.isArray(key)) {\n            return (/** @type {?} */ (key.map((/**\n             * @param {?} k\n             * @return {?}\n             */\n            k => this.translateObject(k, params, lang)))));\n        }\n        /** @type {?} */\n        const translation = this.getTranslation(lang);\n        // TODO: optimize it (we can build this specific object)\n        /** @type {?} */\n        const value = getValue(unflatten(translation), key);\n        return this.parser.transpile(value, params, translation);\n    }\n    /**\n     * @template T\n     * @param {?} key\n     * @param {?=} params\n     * @param {?=} lang\n     * @return {?}\n     */\n    selectTranslateObject(key, params, lang) {\n        return this.selectTranslate(key, params, lang, true);\n    }\n    /**\n     * @param {?=} lang\n     * @return {?}\n     */\n    getTranslation(lang) {\n        return lang ? this.translations.get(lang) || {} : this.translations;\n    }\n    /**\n     * Gets an object of translations for a given language\n     *\n     * \\@example\n     *\n     * selectTranslation().subscribe()\n     * selectTranslation('es').subscribe()\n     * @param {?=} lang\n     * @return {?}\n     */\n    selectTranslation(lang) {\n        /** @type {?} */\n        const language = lang || this.getActiveLang();\n        return this.load(language).pipe(map((/**\n         * @return {?}\n         */\n        () => this.getTranslation(language))));\n    }\n    /**\n     * Sets or merge a given translation object to current lang\n     *\n     * \\@example\n     *\n     * setTranslation({ ... })\n     * setTranslation({ ... }, 'en')\n     * setTranslation({ ... }, 'es', { merge: false } )\n     * setTranslation({ ... }, 'todos/en', { merge: false } )\n     * @param {?} translation\n     * @param {?=} lang\n     * @param {?=} options\n     * @return {?}\n     */\n    setTranslation(translation, lang = this.getActiveLang(), options = {}) {\n        /** @type {?} */\n        const defaults = { merge: true, emitChange: true };\n        /** @type {?} */\n        const mergedOptions = Object.assign({}, defaults, options);\n        /** @type {?} */\n        const scope = getScopeFromLang(lang);\n        /**\n         * If this isn't a scope we use the whole translation as is\n         * otherwise we need to flat the scope and use it\n         * @type {?}\n         */\n        let flattenScopeOrTranslation = translation;\n        // Merged the scoped language into the active language\n        if (scope) {\n            /** @type {?} */\n            const key = this.getMappedScope(scope);\n            flattenScopeOrTranslation = flatten({ [key]: translation });\n        }\n        /** @type {?} */\n        const currentLang = scope ? getLangFromScope(lang) : lang;\n        /** @type {?} */\n        const mergedTranslation = Object.assign({}, (mergedOptions.merge && this.getTranslation(currentLang)), flattenScopeOrTranslation);\n        /** @type {?} */\n        const flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);\n        /** @type {?} */\n        const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n        this.translations.set(currentLang, withHook);\n        mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n    }\n    /**\n     * Sets translation key with given value\n     *\n     * \\@example\n     *\n     * setTranslationKey('key', 'value')\n     * setTranslationKey('key.nested', 'value')\n     * setTranslationKey('key.nested', 'value', 'en')\n     * @param {?} key\n     * @param {?} value\n     * @param {?=} lang\n     * @return {?}\n     */\n    setTranslationKey(key, value, lang = this.getActiveLang()) {\n        /** @type {?} */\n        const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n        /** @type {?} */\n        const newValue = Object.assign({}, this.getTranslation(lang), { [key]: withHook });\n        this.setTranslation(newValue, lang);\n    }\n    /**\n     * Sets the fallback lang for the currently active language\n     * @param {?} __0\n     * @return {?}\n     */\n    setFallbackLangForMissingTranslation({ fallbackLang }) {\n        if (this.useFallbackTranslation && fallbackLang) {\n            this.firstFallbackLang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n        }\n    }\n    /**\n     * \\@internal\n     * @param {?} key\n     * @param {?} value\n     * @param {?=} params\n     * @return {?}\n     */\n    _handleMissingKey(key, value, params) {\n        if (this.config.missingHandler.allowEmpty && value === '') {\n            return '';\n        }\n        if (this.useFallbackTranslation() && !this.isResolvedMissingOnce) {\n            this.isResolvedMissingOnce = true;\n            /** @type {?} */\n            const value = this.translate(key, params, this.firstFallbackLang);\n            this.isResolvedMissingOnce = false;\n            return value;\n        }\n        return this.missingHandler.handle(key, this.config);\n    }\n    /**\n     * \\@internal\n     * @param {?} lang\n     * @return {?}\n     */\n    _isLangScoped(lang) {\n        return this.getAvailableLangsIds().indexOf(lang) === -1;\n    }\n    /**\n     * \\@internal\n     * @param {?} lang\n     * @return {?}\n     */\n    _isLang(lang) {\n        return this.getAvailableLangsIds().indexOf(lang) !== -1;\n    }\n    /**\n     * \\@internal\n     *\n     * We always want to make sure the global lang is loaded\n     * before loading the scope since you can access both via the pipe/directive.\n     * @param {?} path\n     * @param {?=} inlineLoader\n     * @return {?}\n     */\n    _loadDependencies(path, inlineLoader) {\n        /** @type {?} */\n        const mainLang = getLangFromScope(path);\n        if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n            return combineLatest(this.load(mainLang), this.load(path, { inlineLoader }));\n        }\n        return this.load(path, { inlineLoader });\n    }\n    /**\n     * \\@internal\n     * @param {?} langOrScope\n     * @return {?}\n     */\n    _completeScopeWithLang(langOrScope) {\n        if (this._isLangScoped(langOrScope) && !this._isLang(getLangFromScope(langOrScope))) {\n            return `${langOrScope}/${this.getActiveLang()}`;\n        }\n        return langOrScope;\n    }\n    /**\n     * \\@internal\n     * @param {?} scope\n     * @param {?} alias\n     * @return {?}\n     */\n    _setScopeAlias(scope, alias) {\n        if (!this.mergedConfig.scopeMapping) {\n            this.mergedConfig.scopeMapping = {};\n        }\n        this.mergedConfig.scopeMapping[scope] = alias;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.subscription.unsubscribe();\n    }\n    /**\n     * @private\n     * @param {?} lang\n     * @return {?}\n     */\n    isLoadedTranslation(lang) {\n        return size(this.getTranslation(lang));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    getAvailableLangsIds() {\n        /** @type {?} */\n        const first = this.getAvailableLangs()[0];\n        if (isString(first)) {\n            return (/** @type {?} */ (this.getAvailableLangs()));\n        }\n        return ((/** @type {?} */ (this.getAvailableLangs()))).map((/**\n         * @param {?} l\n         * @return {?}\n         */\n        l => l.id));\n    }\n    /**\n     * @private\n     * @param {?=} lang\n     * @return {?}\n     */\n    useFallbackTranslation(lang) {\n        return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;\n    }\n    /**\n     * @private\n     * @param {?} lang\n     * @param {?} translation\n     * @return {?}\n     */\n    handleSuccess(lang, translation) {\n        this.setTranslation(translation, lang, { emitChange: false });\n        if (this.failedLangs.has(lang) === false) {\n            this.events.next({\n                wasFailure: !!this.failedLangs.size,\n                type: 'translationLoadSuccess',\n                payload: getEventPayload(lang)\n            });\n            this.failedCounter = 0;\n        }\n        else {\n            this.cache.delete(lang);\n            this.failedLangs.delete(lang);\n        }\n    }\n    /**\n     * @private\n     * @param {?} lang\n     * @param {?} mergedOptions\n     * @return {?}\n     */\n    handleFailure(lang, mergedOptions) {\n        /** @type {?} */\n        const splitted = lang.split('/');\n        this.failedLangs.add(lang);\n        /** @type {?} */\n        const fallbacks = mergedOptions.fallbackLangs || this.fallbackStrategy.getNextLangs(lang);\n        /** @type {?} */\n        const nextLang = fallbacks[this.failedCounter];\n        /** @type {?} */\n        const isFallbackLang = nextLang === splitted[splitted.length - 1];\n        if (!nextLang || isFallbackLang) {\n            /** @type {?} */\n            let msg = `Unable to load translation and all the fallback languages`;\n            if (splitted.length > 1) {\n                msg += `, did you misspelled the scope name?`;\n            }\n            throw new Error(msg);\n        }\n        /** @type {?} */\n        let resolveLang = nextLang;\n        // if it's scoped lang\n        if (splitted.length > 1) {\n            // We need to resolve it to:\n            // todos/langNotExists => todos/nextLang\n            splitted[splitted.length - 1] = nextLang;\n            resolveLang = splitted.join('/');\n        }\n        this.failedCounter++;\n        this.events.next({\n            type: 'translationLoadFailure',\n            payload: getEventPayload(lang)\n        });\n        return this.load(resolveLang);\n    }\n    /**\n     * @private\n     * @param {?} scope\n     * @return {?}\n     */\n    getMappedScope(scope) {\n        const { scopeMapping = {} } = this.config;\n        return scopeMapping[scope] || toCamelCase(scope);\n    }\n}\nTranslocoService.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] }\n];\n/** @nocollapse */\nTranslocoService.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_LOADER,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_TRANSPILER,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_MISSING_HANDLER,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_INTERCEPTOR,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_CONFIG,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_FALLBACK_STRATEGY,] }] }\n];\n/** @nocollapse */ TranslocoService.ngInjectableDef = defineInjectable({ factory: function TranslocoService_Factory() { return new TranslocoService(inject(TRANSLOCO_LOADER, 8), inject(TRANSLOCO_TRANSPILER), inject(TRANSLOCO_MISSING_HANDLER), inject(TRANSLOCO_INTERCEPTOR), inject(TRANSLOCO_CONFIG), inject(TRANSLOCO_FALLBACK_STRATEGY)); }, token: TranslocoService, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass TranslocoLoaderComponent {\n}\nTranslocoLoaderComponent.decorators = [\n    { type: Component, args: [{\n                template: `\r\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\r\n  `\n            }] }\n];\nTranslocoLoaderComponent.propDecorators = {\n    html: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass TemplateHandler {\n    /**\n     * @param {?} view\n     * @param {?} vcr\n     */\n    constructor(view, vcr) {\n        this.view = view;\n        this.vcr = vcr;\n        this.injector = this.vcr.injector;\n    }\n    /**\n     * @return {?}\n     */\n    attachView() {\n        if (this.view instanceof TemplateRef) {\n            this.vcr.createEmbeddedView(this.view);\n        }\n        else if (isString(this.view)) {\n            /** @type {?} */\n            const componentRef = this.createComponent(TranslocoLoaderComponent);\n            componentRef.instance.html = this.view;\n            componentRef.hostView.detectChanges();\n        }\n        else {\n            this.createComponent(this.view);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    detachView() {\n        this.vcr.clear();\n    }\n    /**\n     * @private\n     * @template T\n     * @param {?} cmp\n     * @return {?}\n     */\n    createComponent(cmp) {\n        /** @type {?} */\n        const cfr = this.injector.get(ComponentFactoryResolver);\n        /** @type {?} */\n        const factory = cfr.resolveComponentFactory(cmp);\n        return this.vcr.createComponent(factory);\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass LangResolver {\n    constructor() {\n        this.initialized = false;\n    }\n    // inline => provider => active\n    /**\n     * @param {?=} __0\n     * @return {?}\n     */\n    resolve({ inline, provider, active } = { inline: undefined, provider: undefined, active: undefined }) {\n        /** @type {?} */\n        let lang = active;\n        /**\n         * When the user changes the lang we need to update\n         * the view. Otherwise, the lang will remain the inline/provided lang\n         */\n        if (this.initialized) {\n            lang = active;\n            return lang;\n        }\n        if (provider) {\n            const [_, extracted] = getPipeValue(provider, 'static');\n            lang = extracted;\n        }\n        if (inline) {\n            const [_, extracted] = getPipeValue(inline, 'static');\n            lang = extracted;\n        }\n        this.initialized = true;\n        return lang;\n    }\n    /**\n     *\n     * Resolve the lang\n     *\n     * \\@example\n     *\n     * resolveLangBasedOnScope('todos/en') => en\n     * resolveLangBasedOnScope('en') => en\n     *\n     * @param {?} lang\n     * @return {?}\n     */\n    resolveLangBasedOnScope(lang) {\n        /** @type {?} */\n        const scope = getScopeFromLang(lang);\n        return scope ? getLangFromScope(lang) : lang;\n    }\n    /**\n     *\n     * Resolve the lang path for loading\n     *\n     * \\@example\n     *\n     * resolveLangPath('todos', 'en') => todos/en\n     * resolveLangPath('en') => en\n     *\n     * @param {?} lang\n     * @param {?} scope\n     * @return {?}\n     */\n    resolveLangPath(lang, scope) {\n        return scope ? `${scope}/${lang}` : lang;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ScopeResolver {\n    /**\n     * @param {?} translocoService\n     */\n    constructor(translocoService) {\n        this.translocoService = translocoService;\n    }\n    // inline => provider\n    /**\n     * @param {?=} __0\n     * @return {?}\n     */\n    resolve({ inline, provider } = { inline: undefined, provider: undefined }) {\n        if (inline) {\n            return inline;\n        }\n        if (provider) {\n            if (isScopeObject(provider)) {\n                const { scope, alias = toCamelCase(scope) } = (/** @type {?} */ (provider));\n                this.translocoService._setScopeAlias(scope, alias);\n                return scope;\n            }\n            return (/** @type {?} */ (provider));\n        }\n        return undefined;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass TranslocoDirective {\n    /**\n     * @param {?} translocoService\n     * @param {?} tpl\n     * @param {?} providerScope\n     * @param {?} providerLang\n     * @param {?} providedLoadingTpl\n     * @param {?} vcr\n     * @param {?} cdr\n     * @param {?} host\n     */\n    constructor(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host) {\n        this.translocoService = translocoService;\n        this.tpl = tpl;\n        this.providerScope = providerScope;\n        this.providerLang = providerLang;\n        this.providedLoadingTpl = providedLoadingTpl;\n        this.vcr = vcr;\n        this.cdr = cdr;\n        this.host = host;\n        this.translationMemo = {};\n        this.params = {};\n        this.loaderTplHandler = null;\n        // Whether we already rendered the view once\n        this.initialized = false;\n        this.langResolver = new LangResolver();\n        this.scopeResolver = new ScopeResolver(this.translocoService);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        /** @type {?} */\n        const loadingTpl = this.getLoadingTpl();\n        if (loadingTpl) {\n            this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);\n            this.loaderTplHandler.attachView();\n        }\n        /** @type {?} */\n        const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);\n        this.subscription = this.translocoService.langChanges$\n            .pipe(switchMap((/**\n         * @param {?} activeLang\n         * @return {?}\n         */\n        activeLang => {\n            /** @type {?} */\n            const lang = this.langResolver.resolve({\n                inline: this.inlineLang,\n                provider: this.providerLang,\n                active: activeLang\n            });\n            /** @type {?} */\n            const scope = this.scopeResolver.resolve({\n                inline: this.inlineScope,\n                provider: this.providerScope\n            });\n            this.path = this.langResolver.resolveLangPath(lang, scope);\n            /** @type {?} */\n            const inlineLoader = resolveInlineLoader(this.providerScope, scope);\n            return this.translocoService._loadDependencies(this.path, inlineLoader);\n        })), listenOrNotOperator(listenToLangChange))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n            this.tpl === null ? this.simpleStrategy() : this.structuralStrategy(this.currentLang, this.inlineRead);\n            this.cdr.markForCheck();\n            this.initialized = true;\n        }));\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        // We need to support dynamic keys/params, so if this is not the first change CD cycle\n        // we need to run the function again in order to update the value\n        /** @type {?} */\n        const notInit = Object.keys(changes).some((/**\n         * @param {?} v\n         * @return {?}\n         */\n        v => changes[v].firstChange === false));\n        notInit && this.simpleStrategy();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    simpleStrategy() {\n        this.detachLoader();\n        this.host.nativeElement.innerText = this.translocoService.translate(this.key, this.params, this.currentLang);\n    }\n    /**\n     * @private\n     * @param {?} lang\n     * @param {?} read\n     * @return {?}\n     */\n    structuralStrategy(lang, read) {\n        this.translationMemo = {};\n        if (this.view) {\n            // when the lang changes we need to change the reference so Angular will update the view\n            this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n        }\n        else {\n            this.detachLoader();\n            this.view = this.vcr.createEmbeddedView(this.tpl, {\n                $implicit: this.getTranslateFn(lang, read)\n            });\n        }\n    }\n    /**\n     * @private\n     * @param {?} lang\n     * @param {?} read\n     * @return {?}\n     */\n    getTranslateFn(lang, read) {\n        return (/**\n         * @param {?} key\n         * @param {?} params\n         * @return {?}\n         */\n        (key, params) => {\n            /** @type {?} */\n            const withRead = read ? `${read}.${key}` : key;\n            /** @type {?} */\n            const withParams = params ? `${withRead}${JSON.stringify(params)}` : withRead;\n            if (this.translationMemo.hasOwnProperty(withParams)) {\n                return this.translationMemo[withParams].value;\n            }\n            this.translationMemo[withParams] = {\n                params,\n                value: this.translocoService.translate(withRead, params, lang)\n            };\n            return this.translationMemo[withParams].value;\n        });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    getLoadingTpl() {\n        return this.inlineTpl || this.providedLoadingTpl;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.subscription && this.subscription.unsubscribe();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    detachLoader() {\n        this.loaderTplHandler && this.loaderTplHandler.detachView();\n    }\n}\nTranslocoDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[transloco]'\n            },] }\n];\n/** @nocollapse */\nTranslocoDirective.ctorParameters = () => [\n    { type: TranslocoService },\n    { type: TemplateRef, decorators: [{ type: Optional }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_SCOPE,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_LANG,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_LOADING_TEMPLATE,] }] },\n    { type: ViewContainerRef },\n    { type: ChangeDetectorRef },\n    { type: ElementRef }\n];\nTranslocoDirective.propDecorators = {\n    key: [{ type: Input, args: ['transloco',] }],\n    params: [{ type: Input, args: ['translocoParams',] }],\n    inlineScope: [{ type: Input, args: ['translocoScope',] }],\n    inlineRead: [{ type: Input, args: ['translocoRead',] }],\n    inlineLang: [{ type: Input, args: ['translocoLang',] }],\n    inlineTpl: [{ type: Input, args: ['translocoLoadingTpl',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass TranslocoPipe {\n    /**\n     * @param {?} translocoService\n     * @param {?} providerScope\n     * @param {?} providerLang\n     * @param {?} cdr\n     */\n    constructor(translocoService, providerScope, providerLang, cdr) {\n        this.translocoService = translocoService;\n        this.providerScope = providerScope;\n        this.providerLang = providerLang;\n        this.cdr = cdr;\n        this.subscription = null;\n        this.langResolver = new LangResolver();\n        this.scopeResolver = new ScopeResolver(this.translocoService);\n        this.listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang);\n    }\n    /**\n     * @param {?} key\n     * @param {?=} params\n     * @param {?=} inlineLang\n     * @return {?}\n     */\n    transform(key, params, inlineLang) {\n        if (!key) {\n            return key;\n        }\n        /** @type {?} */\n        const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n        if (keyName === this.lastKey) {\n            return this.lastValue;\n        }\n        this.lastKey = keyName;\n        this.subscription && this.subscription.unsubscribe();\n        this.subscription = this.translocoService.langChanges$\n            .pipe(switchMap((/**\n         * @param {?} activeLang\n         * @return {?}\n         */\n        activeLang => {\n            /** @type {?} */\n            const lang = this.langResolver.resolve({\n                inline: inlineLang,\n                provider: this.providerLang,\n                active: activeLang\n            });\n            /** @type {?} */\n            let scope = this.scopeResolver.resolve({ inline: undefined, provider: this.providerScope });\n            this.path = this.langResolver.resolveLangPath(lang, scope);\n            /** @type {?} */\n            const inlineLoader = resolveInlineLoader(this.providerScope, scope);\n            return this.translocoService._loadDependencies(this.path, inlineLoader);\n        })), listenOrNotOperator(this.listenToLangChange))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => this.updateValue(key, params)));\n        return this.lastValue;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.subscription && this.subscription.unsubscribe();\n    }\n    /**\n     * @private\n     * @param {?} key\n     * @param {?=} params\n     * @return {?}\n     */\n    updateValue(key, params) {\n        /** @type {?} */\n        const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n        this.lastValue = this.translocoService.translate(key, params, lang);\n        this.cdr.markForCheck();\n    }\n}\nTranslocoPipe.decorators = [\n    { type: Pipe, args: [{\n                name: 'transloco',\n                pure: false\n            },] }\n];\n/** @nocollapse */\nTranslocoPipe.ctorParameters = () => [\n    { type: TranslocoService },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_SCOPE,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_LANG,] }] },\n    { type: ChangeDetectorRef }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst defaultProviders = [\n    {\n        provide: TRANSLOCO_TRANSPILER,\n        useClass: DefaultTranspiler\n    },\n    {\n        provide: TRANSLOCO_MISSING_HANDLER,\n        useClass: DefaultHandler\n    },\n    {\n        provide: TRANSLOCO_INTERCEPTOR,\n        useClass: DefaultInterceptor\n    },\n    {\n        provide: TRANSLOCO_FALLBACK_STRATEGY,\n        useClass: DefaultFallbackStrategy,\n        deps: [TRANSLOCO_CONFIG]\n    }\n];\nclass TranslocoModule {\n}\nTranslocoModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent],\n                providers: [defaultProviders],\n                exports: [TranslocoDirective, TranslocoPipe],\n                entryComponents: [TranslocoLoaderComponent]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass TestingLoader {\n    /**\n     * @param {?} langs\n     */\n    constructor(langs) {\n        this.langs = langs;\n    }\n    /**\n     * @param {?} lang\n     * @return {?}\n     */\n    getTranslation(lang) {\n        return of(this.langs[lang]);\n    }\n}\n/** @nocollapse */\nTestingLoader.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: ['translocoLangs',] }] }\n];\nclass TranslocoTestingModule {\n    /**\n     * @param {?} langs\n     * @param {?=} config\n     * @return {?}\n     */\n    static withLangs(langs, config = {}) {\n        return {\n            ngModule: TranslocoTestingModule,\n            providers: [\n                {\n                    provide: 'translocoLangs',\n                    useValue: langs\n                },\n                {\n                    provide: TRANSLOCO_LOADER,\n                    useClass: TestingLoader\n                },\n                defaultProviders,\n                {\n                    provide: TRANSLOCO_CONFIG,\n                    useValue: Object.assign({ prodMode: true }, config)\n                }\n            ]\n        };\n    }\n}\nTranslocoTestingModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [TranslocoModule]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n * @return {?}\n */\nfunction getBrowserLang() {\n    if (isBrowser() === false) {\n        return undefined;\n    }\n    /** @type {?} */\n    let browserLang = getBrowserCultureLang();\n    if (browserLang.indexOf('-') !== -1) {\n        browserLang = browserLang.split('-')[0];\n    }\n    if (browserLang.indexOf('_') !== -1) {\n        browserLang = browserLang.split('_')[0];\n    }\n    return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n * @return {?}\n */\nfunction getBrowserCultureLang() {\n    if (isBrowser() === false) {\n        return undefined;\n    }\n    /** @type {?} */\n    const navigator = (/** @type {?} */ (window.navigator));\n    /** @type {?} */\n    let browserCultureLang = navigator.languages ? navigator.languages[0] : null;\n    browserCultureLang = browserCultureLang || navigator.language || navigator.browserLanguage || navigator.userLanguage;\n    return browserCultureLang;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { translate, TranslocoService, TranslocoDirective, TranslocoPipe, TranslocoModule, defaultProviders, TRANSLOCO_LOADER, TRANSLOCO_CONFIG, defaultConfig, TRANSLOCO_TRANSPILER, DefaultTranspiler, TRANSLOCO_SCOPE, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_LANG, TestingLoader, TranslocoTestingModule, TemplateHandler, TRANSLOCO_INTERCEPTOR, TRANSLOCO_FALLBACK_STRATEGY, DefaultFallbackStrategy, TRANSLOCO_MISSING_HANDLER, getBrowserCultureLang, getBrowserLang, getPipeValue, getLangFromScope, getScopeFromLang, getValue, setValue, size, isEmpty, isFunction, isString, isNumber, isObject, coerceArray, toCamelCase, isBrowser, isNil, isDefined, toNumber, isScopeObject, hasInlineLoader, unflatten, flatten, TranslocoLoaderComponent as c, DefaultHandler as b, DefaultInterceptor as a };\n"]}