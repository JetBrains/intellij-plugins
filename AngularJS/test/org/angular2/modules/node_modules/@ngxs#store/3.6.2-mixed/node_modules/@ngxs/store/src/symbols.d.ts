import { InjectionToken, Type } from '@angular/core';
import { Observable } from 'rxjs';
import { PlainObject, StateClass } from '@ngxs/store/internals';
import { SharedSelectorOptions, Callback } from './internal/internals';
import { NgxsExecutionStrategy } from './execution/symbols';
import { StateToken } from './state-token/state-token';
import * as ɵngcc0 from '@angular/core';
export declare const ROOT_STATE_TOKEN: InjectionToken<any>;
export declare const FEATURE_STATE_TOKEN: InjectionToken<any>;
export declare const NGXS_PLUGINS: InjectionToken<{}>;
export declare const NG_TEST_MODE: InjectionToken<Callback<boolean, any>>;
export declare const NG_DEV_MODE: InjectionToken<Callback<boolean, any>>;
export declare const META_KEY = "NGXS_META";
export declare const META_OPTIONS_KEY = "NGXS_OPTIONS_META";
export declare const SELECTOR_META_KEY = "NGXS_SELECTOR_META";
export declare type NgxsLifeCycle = Partial<NgxsOnChanges> & Partial<NgxsOnInit> & Partial<NgxsAfterBootstrap>;
export declare type NgxsPluginFn = (state: any, mutation: any, next: NgxsNextPluginFn) => any;
/**
 * The NGXS config settings.
 */
export declare class NgxsConfig {
    /**
     * Run in development mode. This will add additional debugging features:
     * - Object.freeze on the state and actions to guarantee immutability
     * (default: false)
     */
    developmentMode: boolean;
    compatibility: {
        /**
         * Support a strict Content Security Policy.
         * This will circumvent some optimisations that violate a strict CSP through the use of `new Function(...)`.
         * (default: false)
         */
        strictContentSecurityPolicy: boolean;
    };
    /**
     * Determines the execution context to perform async operations inside. An implementation can be
     * provided to override the default behaviour where the async operations are run
     * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.
     * These observable behaviours are from:
     *   `@Select(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`
     * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your
     * application doesn't rely on zone.js running change detection then you can switch to the
     * `NoopNgxsExecutionStrategy` that doesn't interact with zones.
     * (default: null)
     */
    executionStrategy: Type<NgxsExecutionStrategy>;
    /**
     * Defining the default state before module initialization
     * This is convenient if we need to create a define our own set of states.
     * @deprecated will be removed after v4
     * (default: {})
     */
    defaultsState: PlainObject;
    /**
     * Defining shared selector options
     */
    selectorOptions: SharedSelectorOptions;
    constructor();
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgxsConfig, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<NgxsConfig>;
}
export declare type StateOperator<T> = (existing: Readonly<T>) => T;
/**
 * State context provided to the actions in the state.
 */
export interface StateContext<T> {
    /**
     * Get the current state.
     */
    getState(): T;
    /**
     * Reset the state to a new value.
     */
    setState(val: T | StateOperator<T>): T;
    /**
     * Patch the existing state with the provided value.
     */
    patchState(val: Partial<T>): T;
    /**
     * Dispatch a new action and return the dispatched observable.
     */
    dispatch(actions: any | any[]): Observable<void>;
}
export declare type NgxsNextPluginFn = (state: any, mutation: any) => any;
/**
 * Plugin interface
 */
export interface NgxsPlugin {
    /**
     * Handle the state/action before its submitted to the state handlers.
     */
    handle(state: any, action: any, next: NgxsNextPluginFn): any;
}
/**
 * Options that can be provided to the store.
 */
export interface StoreOptions<T> {
    /**
     * Name of the state. Required.
     */
    name: string | StateToken<T>;
    /**
     * Default values for the state. If not provided, uses empty object.
     */
    defaults?: T;
    /**
     * Sub states for the given state.
     */
    children?: StateClass[];
}
/**
 * Represents a basic change from a previous to a new value for a single state instance.
 * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
 */
export declare class NgxsSimpleChange<T = any> {
    readonly previousValue: T;
    readonly currentValue: T;
    readonly firstChange: boolean;
    constructor(previousValue: T, currentValue: T, firstChange: boolean);
}
/**
 * On init interface
 */
export interface NgxsOnInit {
    ngxsOnInit(ctx?: StateContext<any>): void | any;
}
/**
 * On change interface
 */
export interface NgxsOnChanges {
    ngxsOnChanges(change: NgxsSimpleChange): void;
}
/**
 * After bootstrap interface
 */
export interface NgxsAfterBootstrap {
    ngxsAfterBootstrap(ctx?: StateContext<any>): void;
}
export declare type NgxsModuleOptions = Partial<NgxsConfig>;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ltYm9scy5kLnRzIiwic291cmNlcyI6WyJzeW1ib2xzLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGlvblRva2VuLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgUGxhaW5PYmplY3QsIFN0YXRlQ2xhc3MgfSBmcm9tICdAbmd4cy9zdG9yZS9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBTaGFyZWRTZWxlY3Rvck9wdGlvbnMsIENhbGxiYWNrIH0gZnJvbSAnLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBOZ3hzRXhlY3V0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL2V4ZWN1dGlvbi9zeW1ib2xzJztcclxuaW1wb3J0IHsgU3RhdGVUb2tlbiB9IGZyb20gJy4vc3RhdGUtdG9rZW4vc3RhdGUtdG9rZW4nO1xyXG5leHBvcnQgZGVjbGFyZSBjb25zdCBST09UX1NUQVRFX1RPS0VOOiBJbmplY3Rpb25Ub2tlbjxhbnk+O1xyXG5leHBvcnQgZGVjbGFyZSBjb25zdCBGRUFUVVJFX1NUQVRFX1RPS0VOOiBJbmplY3Rpb25Ub2tlbjxhbnk+O1xyXG5leHBvcnQgZGVjbGFyZSBjb25zdCBOR1hTX1BMVUdJTlM6IEluamVjdGlvblRva2VuPHt9PjtcclxuZXhwb3J0IGRlY2xhcmUgY29uc3QgTkdfVEVTVF9NT0RFOiBJbmplY3Rpb25Ub2tlbjxDYWxsYmFjazxib29sZWFuLCBhbnk+PjtcclxuZXhwb3J0IGRlY2xhcmUgY29uc3QgTkdfREVWX01PREU6IEluamVjdGlvblRva2VuPENhbGxiYWNrPGJvb2xlYW4sIGFueT4+O1xyXG5leHBvcnQgZGVjbGFyZSBjb25zdCBNRVRBX0tFWSA9IFwiTkdYU19NRVRBXCI7XHJcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE1FVEFfT1BUSU9OU19LRVkgPSBcIk5HWFNfT1BUSU9OU19NRVRBXCI7XHJcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IFNFTEVDVE9SX01FVEFfS0VZID0gXCJOR1hTX1NFTEVDVE9SX01FVEFcIjtcclxuZXhwb3J0IGRlY2xhcmUgdHlwZSBOZ3hzTGlmZUN5Y2xlID0gUGFydGlhbDxOZ3hzT25DaGFuZ2VzPiAmIFBhcnRpYWw8Tmd4c09uSW5pdD4gJiBQYXJ0aWFsPE5neHNBZnRlckJvb3RzdHJhcD47XHJcbmV4cG9ydCBkZWNsYXJlIHR5cGUgTmd4c1BsdWdpbkZuID0gKHN0YXRlOiBhbnksIG11dGF0aW9uOiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pID0+IGFueTtcclxuLyoqXHJcbiAqIFRoZSBOR1hTIGNvbmZpZyBzZXR0aW5ncy5cclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5neHNDb25maWcge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSdW4gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gVGhpcyB3aWxsIGFkZCBhZGRpdGlvbmFsIGRlYnVnZ2luZyBmZWF0dXJlczpcclxuICAgICAqIC0gT2JqZWN0LmZyZWV6ZSBvbiB0aGUgc3RhdGUgYW5kIGFjdGlvbnMgdG8gZ3VhcmFudGVlIGltbXV0YWJpbGl0eVxyXG4gICAgICogKGRlZmF1bHQ6IGZhbHNlKVxyXG4gICAgICovXHJcbiAgICBkZXZlbG9wbWVudE1vZGU6IGJvb2xlYW47XHJcbiAgICBjb21wYXRpYmlsaXR5OiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3VwcG9ydCBhIHN0cmljdCBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cclxuICAgICAgICAgKiBUaGlzIHdpbGwgY2lyY3VtdmVudCBzb21lIG9wdGltaXNhdGlvbnMgdGhhdCB2aW9sYXRlIGEgc3RyaWN0IENTUCB0aHJvdWdoIHRoZSB1c2Ugb2YgYG5ldyBGdW5jdGlvbiguLi4pYC5cclxuICAgICAgICAgKiAoZGVmYXVsdDogZmFsc2UpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RyaWN0Q29udGVudFNlY3VyaXR5UG9saWN5OiBib29sZWFuO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgZXhlY3V0aW9uIGNvbnRleHQgdG8gcGVyZm9ybSBhc3luYyBvcGVyYXRpb25zIGluc2lkZS4gQW4gaW1wbGVtZW50YXRpb24gY2FuIGJlXHJcbiAgICAgKiBwcm92aWRlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgd2hlcmUgdGhlIGFzeW5jIG9wZXJhdGlvbnMgYXJlIHJ1blxyXG4gICAgICogb3V0c2lkZSBBbmd1bGFyJ3Mgem9uZSBidXQgYWxsIG9ic2VydmFibGUgYmVoYXZpb3VycyBvZiBOR1hTIGFyZSBydW4gYmFjayBpbnNpZGUgQW5ndWxhcidzIHpvbmUuXHJcbiAgICAgKiBUaGVzZSBvYnNlcnZhYmxlIGJlaGF2aW91cnMgYXJlIGZyb206XHJcbiAgICAgKiAgIGBAU2VsZWN0KC4uLilgLCBgc3RvcmUuc2VsZWN0KC4uLilgLCBgYWN0aW9ucy5zdWJzY3JpYmUoLi4uKWAgb3IgYHN0b3JlLmRpc3BhdGNoKC4uLikuc3Vic2NyaWJlKC4uLilgXHJcbiAgICAgKiBFdmVyeSBgem9uZS5ydW5gIGNhdXNlcyBBbmd1bGFyIHRvIHJ1biBjaGFuZ2UgZGV0ZWN0aW9uIG9uIHRoZSB3aG9sZSB0cmVlIChgYXBwLnRpY2soKWApIHNvIG9mIHlvdXJcclxuICAgICAqIGFwcGxpY2F0aW9uIGRvZXNuJ3QgcmVseSBvbiB6b25lLmpzIHJ1bm5pbmcgY2hhbmdlIGRldGVjdGlvbiB0aGVuIHlvdSBjYW4gc3dpdGNoIHRvIHRoZVxyXG4gICAgICogYE5vb3BOZ3hzRXhlY3V0aW9uU3RyYXRlZ3lgIHRoYXQgZG9lc24ndCBpbnRlcmFjdCB3aXRoIHpvbmVzLlxyXG4gICAgICogKGRlZmF1bHQ6IG51bGwpXHJcbiAgICAgKi9cclxuICAgIGV4ZWN1dGlvblN0cmF0ZWd5OiBUeXBlPE5neHNFeGVjdXRpb25TdHJhdGVneT47XHJcbiAgICAvKipcclxuICAgICAqIERlZmluaW5nIHRoZSBkZWZhdWx0IHN0YXRlIGJlZm9yZSBtb2R1bGUgaW5pdGlhbGl6YXRpb25cclxuICAgICAqIFRoaXMgaXMgY29udmVuaWVudCBpZiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGRlZmluZSBvdXIgb3duIHNldCBvZiBzdGF0ZXMuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgdjRcclxuICAgICAqIChkZWZhdWx0OiB7fSlcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHNTdGF0ZTogUGxhaW5PYmplY3Q7XHJcbiAgICAvKipcclxuICAgICAqIERlZmluaW5nIHNoYXJlZCBzZWxlY3RvciBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHNlbGVjdG9yT3B0aW9uczogU2hhcmVkU2VsZWN0b3JPcHRpb25zO1xyXG4gICAgY29uc3RydWN0b3IoKTtcclxufVxyXG5leHBvcnQgZGVjbGFyZSB0eXBlIFN0YXRlT3BlcmF0b3I8VD4gPSAoZXhpc3Rpbmc6IFJlYWRvbmx5PFQ+KSA9PiBUO1xyXG4vKipcclxuICogU3RhdGUgY29udGV4dCBwcm92aWRlZCB0byB0aGUgYWN0aW9ucyBpbiB0aGUgc3RhdGUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ29udGV4dDxUPiB7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY3VycmVudCBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0U3RhdGUoKTogVDtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIHN0YXRlIHRvIGEgbmV3IHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBzZXRTdGF0ZSh2YWw6IFQgfCBTdGF0ZU9wZXJhdG9yPFQ+KTogVDtcclxuICAgIC8qKlxyXG4gICAgICogUGF0Y2ggdGhlIGV4aXN0aW5nIHN0YXRlIHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBwYXRjaFN0YXRlKHZhbDogUGFydGlhbDxUPik6IFQ7XHJcbiAgICAvKipcclxuICAgICAqIERpc3BhdGNoIGEgbmV3IGFjdGlvbiBhbmQgcmV0dXJuIHRoZSBkaXNwYXRjaGVkIG9ic2VydmFibGUuXHJcbiAgICAgKi9cclxuICAgIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxufVxyXG5leHBvcnQgZGVjbGFyZSB0eXBlIE5neHNOZXh0UGx1Z2luRm4gPSAoc3RhdGU6IGFueSwgbXV0YXRpb246IGFueSkgPT4gYW55O1xyXG4vKipcclxuICogUGx1Z2luIGludGVyZmFjZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ3hzUGx1Z2luIHtcclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIHRoZSBzdGF0ZS9hY3Rpb24gYmVmb3JlIGl0cyBzdWJtaXR0ZWQgdG8gdGhlIHN0YXRlIGhhbmRsZXJzLlxyXG4gICAgICovXHJcbiAgICBoYW5kbGUoc3RhdGU6IGFueSwgYWN0aW9uOiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pOiBhbnk7XHJcbn1cclxuLyoqXHJcbiAqIE9wdGlvbnMgdGhhdCBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIHN0b3JlLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBTdG9yZU9wdGlvbnM8VD4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lIG9mIHRoZSBzdGF0ZS4gUmVxdWlyZWQuXHJcbiAgICAgKi9cclxuICAgIG5hbWU6IHN0cmluZyB8IFN0YXRlVG9rZW48VD47XHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgdmFsdWVzIGZvciB0aGUgc3RhdGUuIElmIG5vdCBwcm92aWRlZCwgdXNlcyBlbXB0eSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzPzogVDtcclxuICAgIC8qKlxyXG4gICAgICogU3ViIHN0YXRlcyBmb3IgdGhlIGdpdmVuIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBjaGlsZHJlbj86IFN0YXRlQ2xhc3NbXTtcclxufVxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJhc2ljIGNoYW5nZSBmcm9tIGEgcHJldmlvdXMgdG8gYSBuZXcgdmFsdWUgZm9yIGEgc2luZ2xlIHN0YXRlIGluc3RhbmNlLlxyXG4gKiBQYXNzZWQgYXMgYSB2YWx1ZSBpbiBhIE5neHNTaW1wbGVDaGFuZ2VzIG9iamVjdCB0byB0aGUgbmd4c09uQ2hhbmdlcyBob29rLlxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmd4c1NpbXBsZUNoYW5nZTxUID0gYW55PiB7XHJcbiAgICByZWFkb25seSBwcmV2aW91c1ZhbHVlOiBUO1xyXG4gICAgcmVhZG9ubHkgY3VycmVudFZhbHVlOiBUO1xyXG4gICAgcmVhZG9ubHkgZmlyc3RDaGFuZ2U6IGJvb2xlYW47XHJcbiAgICBjb25zdHJ1Y3RvcihwcmV2aW91c1ZhbHVlOiBULCBjdXJyZW50VmFsdWU6IFQsIGZpcnN0Q2hhbmdlOiBib29sZWFuKTtcclxufVxyXG4vKipcclxuICogT24gaW5pdCBpbnRlcmZhY2VcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmd4c09uSW5pdCB7XHJcbiAgICBuZ3hzT25Jbml0KGN0eD86IFN0YXRlQ29udGV4dDxhbnk+KTogdm9pZCB8IGFueTtcclxufVxyXG4vKipcclxuICogT24gY2hhbmdlIGludGVyZmFjZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ3hzT25DaGFuZ2VzIHtcclxuICAgIG5neHNPbkNoYW5nZXMoY2hhbmdlOiBOZ3hzU2ltcGxlQ2hhbmdlKTogdm9pZDtcclxufVxyXG4vKipcclxuICogQWZ0ZXIgYm9vdHN0cmFwIGludGVyZmFjZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ3hzQWZ0ZXJCb290c3RyYXAge1xyXG4gICAgbmd4c0FmdGVyQm9vdHN0cmFwKGN0eD86IFN0YXRlQ29udGV4dDxhbnk+KTogdm9pZDtcclxufVxyXG5leHBvcnQgZGVjbGFyZSB0eXBlIE5neHNNb2R1bGVPcHRpb25zID0gUGFydGlhbDxOZ3hzQ29uZmlnPjtcclxuIl19