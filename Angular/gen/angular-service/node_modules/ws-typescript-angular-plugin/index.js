"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => {
  return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw")
          throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object))
            throw TypeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};

// node_modules/muggle-string/out/binarySearch.js
var require_binarySearch = __commonJS({
  "node_modules/muggle-string/out/binarySearch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.binarySearch = void 0;
    function binarySearch(offsets, start) {
      let low = 0;
      let high = offsets.length - 1;
      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const midValue = offsets[mid];
        if (midValue < start) {
          low = mid + 1;
        } else if (midValue > start) {
          high = mid - 1;
        } else {
          low = mid;
          high = mid;
          break;
        }
      }
      return Math.max(Math.min(low, high, offsets.length - 1), 0);
    }
    exports2.binarySearch = binarySearch;
  }
});

// node_modules/muggle-string/out/track.js
var require_track = __commonJS({
  "node_modules/muggle-string/out/track.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getStack = exports2.track = exports2.resetOffsetStack = exports2.offsetStack = exports2.setTracking = void 0;
    var tracking = true;
    var stackOffset = 0;
    function setTracking(value) {
      tracking = value;
    }
    exports2.setTracking = setTracking;
    function offsetStack() {
      stackOffset++;
    }
    exports2.offsetStack = offsetStack;
    function resetOffsetStack() {
      stackOffset--;
    }
    exports2.resetOffsetStack = resetOffsetStack;
    function track(segments, stacks = []) {
      return [
        new Proxy(segments, {
          get(target, prop, receiver) {
            if (tracking) {
              if (prop === "push")
                return push;
              if (prop === "pop")
                return pop;
              if (prop === "shift")
                return shift;
              if (prop === "unshift")
                return unshift;
              if (prop === "splice")
                return splice;
              if (prop === "sort")
                return sort;
              if (prop === "reverse")
                return reverse;
            }
            return Reflect.get(target, prop, receiver);
          }
        }),
        stacks
      ];
      function push(...items) {
        stacks.push({ stack: getStack(), length: items.length });
        return segments.push(...items);
      }
      function pop() {
        if (stacks.length) {
          const last = stacks[stacks.length - 1];
          if (last.length > 1) {
            last.length--;
          } else {
            stacks.pop();
          }
        }
        return segments.pop();
      }
      function shift() {
        if (stacks.length) {
          const first = stacks[0];
          if (first.length > 1) {
            first.length--;
          } else {
            stacks.shift();
          }
        }
        return segments.shift();
      }
      function unshift(...items) {
        stacks.unshift({ stack: getStack(), length: items.length });
        return segments.unshift(...items);
      }
      function splice(start, deleteCount, ...items) {
        if (deleteCount === void 0) {
          deleteCount = segments.length - start;
        }
        let _stackStart = 0;
        let operateIndex;
        for (let i = 0; i < stacks.length; i++) {
          const stack = stacks[i];
          const stackStart = _stackStart;
          const stackEnd = stackStart + stack.length;
          _stackStart = stackEnd;
          if (start >= stackStart) {
            operateIndex = i + 1;
            const originalLength = stack.length;
            stack.length = start - stackStart;
            stacks.splice(operateIndex, 0, { stack: stack.stack, length: originalLength - stack.length });
            break;
          }
        }
        if (operateIndex === void 0) {
          throw new Error("Invalid splice operation");
        }
        let _deleteCount = deleteCount;
        for (let i = operateIndex; i < stacks.length; i++) {
          const stack = stacks[i];
          while (_deleteCount > 0 && stack.length > 0) {
            stack.length--;
            _deleteCount--;
          }
          if (_deleteCount === 0) {
            break;
          }
        }
        stacks.splice(operateIndex, 0, { stack: getStack(), length: items.length });
        return segments.splice(start, deleteCount, ...items);
      }
      function sort(compareFn) {
        stacks.splice(0, stacks.length, { stack: getStack(), length: segments.length });
        return segments.sort(compareFn);
      }
      function reverse() {
        stacks.splice(0, stacks.length, { stack: getStack(), length: segments.length });
        return segments.reverse();
      }
    }
    exports2.track = track;
    function getStack() {
      const stack = new Error().stack;
      let source = stack.split("\n")[3 + stackOffset].trim();
      if (source.endsWith(")")) {
        source = source.slice(source.lastIndexOf("(") + 1, -1);
      } else {
        source = source.slice(source.lastIndexOf(" ") + 1);
      }
      return source;
    }
    exports2.getStack = getStack;
  }
});

// node_modules/muggle-string/out/types.js
var require_types = __commonJS({
  "node_modules/muggle-string/out/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/muggle-string/out/index.js
var require_out = __commonJS({
  "node_modules/muggle-string/out/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.replaceRange = exports2.replaceSourceRange = exports2.replaceAll = exports2.replace = exports2.create = exports2.toString = exports2.getLength = void 0;
    var binarySearch_1 = require_binarySearch();
    var track_1 = require_track();
    __exportStar(require_types(), exports2);
    __exportStar(require_track(), exports2);
    function getLength(segments) {
      let length = 0;
      for (const segment of segments) {
        length += typeof segment == "string" ? segment.length : segment[0].length;
      }
      return length;
    }
    exports2.getLength = getLength;
    function toString(segments) {
      return segments.map((s) => typeof s === "string" ? s : s[0]).join("");
    }
    exports2.toString = toString;
    function create(source) {
      return [[source, void 0, 0]];
    }
    exports2.create = create;
    function replace(segments, pattern, ...replacers) {
      const str = toString(segments);
      const match = str.match(pattern);
      if (match && match.index !== void 0) {
        const startOffset = match.index;
        const endOffset = startOffset + match[0].length;
        (0, track_1.offsetStack)();
        replaceRange(segments, startOffset, endOffset, ...replacers.map((replacer) => typeof replacer === "function" ? replacer(match[0]) : replacer));
        (0, track_1.resetOffsetStack)();
      }
    }
    exports2.replace = replace;
    function replaceAll(segments, pattern, ...replacers) {
      const str = toString(segments);
      const allMatch = str.matchAll(pattern);
      let length = str.length;
      let lengthDiff = 0;
      for (const match of allMatch) {
        if (match.index !== void 0) {
          const startOffset = match.index + lengthDiff;
          const endOffset = startOffset + match[0].length;
          (0, track_1.offsetStack)();
          replaceRange(segments, startOffset, endOffset, ...replacers.map((replacer) => typeof replacer === "function" ? replacer(match[0]) : replacer));
          (0, track_1.resetOffsetStack)();
          const newLength = getLength(segments);
          lengthDiff += newLength - length;
          length = newLength;
        }
      }
    }
    exports2.replaceAll = replaceAll;
    function replaceSourceRange(segments, source, startOffset, endOffset, ...newSegments) {
      for (const segment of segments) {
        if (typeof segment === "string") {
          continue;
        }
        if (segment[1] === source) {
          const segmentStart = segment[2];
          const segmentEnd = segment[2] + segment[0].length;
          if (segmentStart <= startOffset && segmentEnd >= endOffset) {
            const inserts = [];
            if (startOffset > segmentStart) {
              inserts.push(trimSegmentEnd(segment, startOffset - segmentStart));
            }
            for (const newSegment of newSegments) {
              inserts.push(newSegment);
            }
            if (endOffset < segmentEnd) {
              inserts.push(trimSegmentStart(segment, endOffset - segmentEnd));
            }
            combineStrings(inserts);
            (0, track_1.offsetStack)();
            segments.splice(segments.indexOf(segment), 1, ...inserts);
            (0, track_1.resetOffsetStack)();
            return true;
          }
        }
      }
      return false;
    }
    exports2.replaceSourceRange = replaceSourceRange;
    function replaceRange(segments, startOffset, endOffset, ...newSegments) {
      const offsets = toOffsets(segments);
      const startIndex = (0, binarySearch_1.binarySearch)(offsets, startOffset);
      const endIndex = (0, binarySearch_1.binarySearch)(offsets, endOffset);
      const startSegment = segments[startIndex];
      const endSegment = segments[endIndex];
      const startSegmentStart = offsets[startIndex];
      const endSegmentStart = offsets[endIndex];
      const endSegmentEnd = offsets[endIndex] + (typeof endSegment === "string" ? endSegment.length : endSegment[0].length);
      const inserts = [];
      if (startOffset > startSegmentStart) {
        inserts.push(trimSegmentEnd(startSegment, startOffset - startSegmentStart));
      }
      for (const newSegment of newSegments) {
        inserts.push(newSegment);
      }
      if (endOffset < endSegmentEnd) {
        inserts.push(trimSegmentStart(endSegment, endOffset - endSegmentStart));
      }
      combineStrings(inserts);
      (0, track_1.offsetStack)();
      segments.splice(startIndex, endIndex - startIndex + 1, ...inserts);
      (0, track_1.resetOffsetStack)();
    }
    exports2.replaceRange = replaceRange;
    function combineStrings(segments) {
      for (let i = segments.length - 1; i >= 1; i--) {
        if (typeof segments[i] === "string" && typeof segments[i - 1] === "string") {
          segments[i - 1] = segments[i - 1] + segments[i];
          (0, track_1.offsetStack)();
          segments.splice(i, 1);
          (0, track_1.resetOffsetStack)();
        }
      }
    }
    function trimSegmentEnd(segment, trimEnd) {
      if (typeof segment === "string") {
        return segment.slice(0, trimEnd);
      }
      return [
        segment[0].slice(0, trimEnd),
        ...segment.slice(1)
      ];
    }
    function trimSegmentStart(segment, trimStart) {
      if (typeof segment === "string") {
        return segment.slice(trimStart);
      }
      if (trimStart < 0) {
        trimStart += segment[0].length;
      }
      return [
        segment[0].slice(trimStart),
        segment[1],
        segment[2] + trimStart,
        ...segment.slice(3)
      ];
    }
    function toOffsets(segments) {
      const offsets = [];
      let offset = 0;
      for (const segment of segments) {
        offsets.push(offset);
        offset += typeof segment == "string" ? segment.length : segment[0].length;
      }
      return offsets;
    }
  }
});

// node_modules/@volar/source-map/lib/binarySearch.js
var require_binarySearch2 = __commonJS({
  "node_modules/@volar/source-map/lib/binarySearch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.binarySearch = void 0;
    function binarySearch(values, searchValue) {
      let low = 0;
      let high = values.length - 1;
      let match;
      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const midValue = values[mid];
        if (midValue < searchValue) {
          low = mid + 1;
        } else if (midValue > searchValue) {
          high = mid - 1;
        } else {
          low = mid;
          high = mid;
          match = mid;
          break;
        }
      }
      const finalLow = Math.max(Math.min(low, high, values.length - 1), 0);
      const finalHigh = Math.min(Math.max(low, high, 0), values.length - 1);
      return { low: finalLow, high: finalHigh, match };
    }
    exports2.binarySearch = binarySearch;
  }
});

// node_modules/@volar/source-map/lib/translateOffset.js
var require_translateOffset = __commonJS({
  "node_modules/@volar/source-map/lib/translateOffset.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.areRangesSortedAndNonOverlapping = exports2.translateOffset = void 0;
    function translateOffset(start, fromOffsets, toOffsets, fromLengths, toLengths = fromLengths) {
      if (!areRangesSortedAndNonOverlapping(fromOffsets, fromLengths)) {
        throw new Error("fromOffsets must be sorted in ascending order and ranges cannot overlap");
      }
      let low = 0;
      let high = fromOffsets.length - 1;
      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const fromOffset = fromOffsets[mid];
        const fromLength = fromLengths[mid];
        if (start >= fromOffset && start <= fromOffset + fromLength) {
          const toLength = toLengths[mid];
          const toOffset = toOffsets[mid];
          let rangeOffset = Math.min(start - fromOffset, toLength);
          return toOffset + rangeOffset;
        } else if (start < fromOffset) {
          high = mid - 1;
        } else {
          low = mid + 1;
        }
      }
    }
    exports2.translateOffset = translateOffset;
    function areRangesSortedAndNonOverlapping(offsets, lenghts) {
      let lastEnd = 0;
      for (let i = 0; i < offsets.length; i++) {
        if (offsets[i] < lastEnd) {
          return false;
        }
        lastEnd = offsets[i] + lenghts[i];
      }
      return true;
    }
    exports2.areRangesSortedAndNonOverlapping = areRangesSortedAndNonOverlapping;
  }
});

// node_modules/@volar/source-map/lib/sourceMap.js
var require_sourceMap = __commonJS({
  "node_modules/@volar/source-map/lib/sourceMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SourceMap = void 0;
    var binarySearch_1 = require_binarySearch2();
    var translateOffset_1 = require_translateOffset();
    var SourceMap = class {
      constructor(mappings) {
        this.mappings = mappings;
      }
      getSourceStartEnd(generatedStart, generatedEnd, filter, fallbackToAnyMatch) {
        return this.findMatchingStartEnd(generatedStart, generatedEnd, "generatedOffsets", filter, fallbackToAnyMatch);
      }
      getGeneratedStartEnd(sourceStart, sourceEnd, filter, fallbackToAnyMatch) {
        return this.findMatchingStartEnd(sourceStart, sourceEnd, "sourceOffsets", filter, fallbackToAnyMatch);
      }
      getSourceOffsets(generatedOffset, filter) {
        return this.findMatchingOffsets(generatedOffset, "generatedOffsets", filter);
      }
      getGeneratedOffsets(sourceOffset, filter) {
        return this.findMatchingOffsets(sourceOffset, "sourceOffsets", filter);
      }
      *findMatchingOffsets(offset, fromRange, filter) {
        const toRange = fromRange == "sourceOffsets" ? "generatedOffsets" : "sourceOffsets";
        for (const match of this.getStorageBasedOnRange(fromRange).findMatchingMappingIndexes(offset, filter)) {
          yield [mapOffset(match, offset, fromRange, toRange), match[0]];
        }
      }
      *findMatchingStartEnd(start, end, fromRange, filter, fallbackToAnyMatch) {
        const length = end - start;
        if (length < 0) {
          return;
        }
        if (length == 0) {
          for (const match of this.findMatchingOffsets(start, fromRange, filter)) {
            yield [match[0], 0, match[1]];
          }
          return;
        }
        const startMatches = [];
        for (const [startMapping, index] of this.getStorageBasedOnRange(fromRange).findMatchingMappingIndexes(start, filter)) {
          startMatches.push([startMapping, index]);
        }
        const toRange = fromRange == "sourceOffsets" ? "generatedOffsets" : "sourceOffsets";
        startMatches.sort((a, b) => getSpanLength(a, fromRange) - getSpanLength(b, fromRange));
        let hadMatch = false;
        for (const match of startMatches) {
          const fromStartOffset = getStartOffset(match, fromRange);
          const fromLength = getSpanLength(match, fromRange);
          if (end <= fromStartOffset + fromLength) {
            const toStartOffset = getStartOffset(match, toRange);
            const toLength = getSpanLength(match, toRange);
            if (toLength == fromLength) {
              const startOffset = toStartOffset + start - fromStartOffset;
              hadMatch = true;
              yield [startOffset, startOffset + length, match[0]];
            } else if (fromStartOffset == start && fromLength == length) {
              hadMatch = true;
              yield [toStartOffset, toStartOffset + toLength, match[0]];
            } else {
            }
          }
        }
        if (hadMatch) {
          return;
        }
        const endMatches = [];
        for (const endMapping of this.getStorageBasedOnRange(fromRange).findMatchingMappingIndexes(start + length, filter)) {
          const fromLength = getSpanLength(endMapping, fromRange);
          const toLength = getSpanLength(endMapping, toRange);
          if (fromLength == toLength) {
            endMatches.push(endMapping);
          }
        }
        endMatches.sort((a, b) => getSpanLength(a, fromRange) - getSpanLength(b, fromRange));
        for (let fallback = 0; fallback < 2; fallback++) {
          if (hadMatch || fallback && !fallbackToAnyMatch) {
            break;
          }
          for (const startMatch of startMatches) {
            let mapping = startMatch[0];
            const fromLength = getSpanLength(startMatch, fromRange);
            const toLength = getSpanLength(startMatch, toRange);
            if (fromLength != toLength) {
              continue;
            }
            for (const endMatch of endMatches) {
              if (!fallback && endMatch[0] != mapping) {
                continue;
              }
              const startOffset = mapOffset(startMatch, start, fromRange, toRange);
              const endOffset = mapOffset(endMatch, end, fromRange, toRange);
              if (startOffset <= endOffset) {
                hadMatch = true;
                yield [startOffset, endOffset, mapping];
              }
            }
          }
        }
      }
      getStorageBasedOnRange(fromRange) {
        var _a, _b;
        return fromRange === "sourceOffsets" ? (_a = this.sourceCodeOffsetsStorage) != null ? _a : this.sourceCodeOffsetsStorage = this.createStorage("sourceOffsets") : (_b = this.generatedCodeOffsetsStorage) != null ? _b : this.generatedCodeOffsetsStorage = this.createStorage("generatedOffsets");
      }
      createStorage(key) {
        if (!this.mappings.every((mapping) => (0, translateOffset_1.areRangesSortedAndNonOverlapping)(mapping[key], getLengths(mapping, key)))) {
          throw new Error("Ranges within one mapping should be sorted and non-overlapping.");
        }
        return new BinarySearchStorage(this.mappings, key);
      }
    };
    exports2.SourceMap = SourceMap;
    var BinarySearchStorage = class {
      constructor(originalMappings, key) {
        this.key = key;
        const offsetsSet = /* @__PURE__ */ new Set();
        for (const mapping of originalMappings) {
          for (let i = 0; i < mapping[key].length; i++) {
            offsetsSet.add(mapping[key][i]);
            offsetsSet.add(mapping[key][i] + getLengths(mapping, key)[i]);
          }
        }
        const offsets = [...offsetsSet].sort((a, b) => a - b);
        const mappings = offsets.map(() => /* @__PURE__ */ new Set());
        for (const mapping of originalMappings) {
          for (let i = 0; i < mapping[key].length; i++) {
            const startIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i]).match;
            const endIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i] + getLengths(mapping, key)[i]).match;
            for (let i2 = startIndex; i2 <= endIndex; i2++) {
              mappings[i2].add(mapping);
            }
          }
        }
        this.offsets = offsets;
        this.mappings = mappings;
      }
      *findMatchingMappingIndexes(offset, filter) {
        if (this.offsets.length === 0) {
          return;
        }
        const fromRange = this.key;
        const { low: start, high: end } = (0, binarySearch_1.binarySearch)(this.offsets, offset);
        const skip = /* @__PURE__ */ new Set();
        for (let i = start; i <= end; i++) {
          for (const mapping of this.mappings[i]) {
            if (skip.has(mapping)) {
              continue;
            }
            skip.add(mapping);
            if (filter && !filter(mapping.data)) {
              continue;
            }
            const fromOffsets = mapping[fromRange];
            const fromLengths = getLengths(mapping, fromRange);
            let low = 0;
            let high = fromOffsets.length - 1;
            while (low <= high) {
              const mid = Math.floor((low + high) / 2);
              const fromOffset = fromOffsets[mid];
              const fromLength = fromLengths[mid];
              if (offset >= fromOffset && offset <= fromOffset + fromLength) {
                yield [mapping, mid];
                break;
              } else if (offset < fromOffset) {
                high = mid - 1;
              } else {
                low = mid + 1;
              }
            }
          }
        }
      }
    };
    function getLengths(mapping, key) {
      var _a;
      return key == "sourceOffsets" ? mapping.lengths : (_a = mapping.generatedLengths) != null ? _a : mapping.lengths;
    }
    function getStartOffset(mappingIndex, rangeKey) {
      const [mapping, index] = mappingIndex;
      return mapping[rangeKey][index];
    }
    function getSpanLength(mappingIndex, rangeKey) {
      const [mapping, index] = mappingIndex;
      return getLengths(mapping, rangeKey)[index];
    }
    function mapOffset(mappingIndex, offset, fromRange, toRange) {
      const fromOffset = getStartOffset(mappingIndex, fromRange);
      const toOffset = getStartOffset(mappingIndex, toRange);
      if (fromOffset == offset) {
        return toOffset;
      } else {
        const toLength = getSpanLength(mappingIndex, toRange);
        return toOffset + Math.min(offset - fromOffset, toLength);
      }
    }
  }
});

// node_modules/@volar/source-map/index.js
var require_source_map = __commonJS({
  "node_modules/@volar/source-map/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_out(), exports2);
    __exportStar(require_sourceMap(), exports2);
    __exportStar(require_translateOffset(), exports2);
  }
});

// node_modules/@volar/language-core/lib/editorFeatures.js
var require_editorFeatures = __commonJS({
  "node_modules/@volar/language-core/lib/editorFeatures.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveRenameEditText = exports2.resolveRenameNewName = exports2.shouldReportDiagnostics = exports2.isSignatureHelpEnabled = exports2.isAutoInsertEnabled = exports2.isCompletionEnabled = exports2.isFormattingEnabled = exports2.isCodeActionsEnabled = exports2.isDiagnosticsEnabled = exports2.isDocumentLinkEnabled = exports2.isColorEnabled = exports2.isLinkedEditingEnabled = exports2.isSelectionRangesEnabled = exports2.isFoldingRangesEnabled = exports2.isSymbolsEnabled = exports2.isHighlightEnabled = exports2.isImplementationEnabled = exports2.isReferencesEnabled = exports2.isTypeDefinitionEnabled = exports2.isDefinitionEnabled = exports2.isRenameEnabled = exports2.isCallHierarchyEnabled = exports2.isSemanticTokensEnabled = exports2.isCodeLensEnabled = exports2.isInlayHintsEnabled = exports2.isHoverEnabled = void 0;
    function isHoverEnabled(info) {
      return !!info.semantic;
    }
    exports2.isHoverEnabled = isHoverEnabled;
    function isInlayHintsEnabled(info) {
      return !!info.semantic;
    }
    exports2.isInlayHintsEnabled = isInlayHintsEnabled;
    function isCodeLensEnabled(info) {
      return !!info.semantic;
    }
    exports2.isCodeLensEnabled = isCodeLensEnabled;
    function isSemanticTokensEnabled(info) {
      var _a, _b, _c;
      return typeof info.semantic === "object" ? (_c = (_b = (_a = info.semantic).shouldHighlight) == null ? void 0 : _b.call(_a)) != null ? _c : true : !!info.semantic;
    }
    exports2.isSemanticTokensEnabled = isSemanticTokensEnabled;
    function isCallHierarchyEnabled(info) {
      return !!info.navigation;
    }
    exports2.isCallHierarchyEnabled = isCallHierarchyEnabled;
    function isRenameEnabled(info) {
      var _a, _b, _c;
      return typeof info.navigation === "object" ? (_c = (_b = (_a = info.navigation).shouldRename) == null ? void 0 : _b.call(_a)) != null ? _c : true : !!info.navigation;
    }
    exports2.isRenameEnabled = isRenameEnabled;
    function isDefinitionEnabled(info) {
      return !!info.navigation;
    }
    exports2.isDefinitionEnabled = isDefinitionEnabled;
    function isTypeDefinitionEnabled(info) {
      return !!info.navigation;
    }
    exports2.isTypeDefinitionEnabled = isTypeDefinitionEnabled;
    function isReferencesEnabled(info) {
      return !!info.navigation;
    }
    exports2.isReferencesEnabled = isReferencesEnabled;
    function isImplementationEnabled(info) {
      return !!info.navigation;
    }
    exports2.isImplementationEnabled = isImplementationEnabled;
    function isHighlightEnabled(info) {
      return !!info.navigation;
    }
    exports2.isHighlightEnabled = isHighlightEnabled;
    function isSymbolsEnabled(info) {
      return !!info.structure;
    }
    exports2.isSymbolsEnabled = isSymbolsEnabled;
    function isFoldingRangesEnabled(info) {
      return !!info.structure;
    }
    exports2.isFoldingRangesEnabled = isFoldingRangesEnabled;
    function isSelectionRangesEnabled(info) {
      return !!info.structure;
    }
    exports2.isSelectionRangesEnabled = isSelectionRangesEnabled;
    function isLinkedEditingEnabled(info) {
      return !!info.structure;
    }
    exports2.isLinkedEditingEnabled = isLinkedEditingEnabled;
    function isColorEnabled(info) {
      return !!info.structure;
    }
    exports2.isColorEnabled = isColorEnabled;
    function isDocumentLinkEnabled(info) {
      return !!info.structure;
    }
    exports2.isDocumentLinkEnabled = isDocumentLinkEnabled;
    function isDiagnosticsEnabled(info) {
      return !!info.verification;
    }
    exports2.isDiagnosticsEnabled = isDiagnosticsEnabled;
    function isCodeActionsEnabled(info) {
      return !!info.verification;
    }
    exports2.isCodeActionsEnabled = isCodeActionsEnabled;
    function isFormattingEnabled(info) {
      return !!info.format;
    }
    exports2.isFormattingEnabled = isFormattingEnabled;
    function isCompletionEnabled(info) {
      return !!info.completion;
    }
    exports2.isCompletionEnabled = isCompletionEnabled;
    function isAutoInsertEnabled(info) {
      return !!info.completion;
    }
    exports2.isAutoInsertEnabled = isAutoInsertEnabled;
    function isSignatureHelpEnabled(info) {
      return !!info.completion;
    }
    exports2.isSignatureHelpEnabled = isSignatureHelpEnabled;
    function shouldReportDiagnostics(info) {
      var _a, _b, _c;
      return typeof info.verification === "object" ? (_c = (_b = (_a = info.verification).shouldReport) == null ? void 0 : _b.call(_a)) != null ? _c : true : !!info.verification;
    }
    exports2.shouldReportDiagnostics = shouldReportDiagnostics;
    function resolveRenameNewName(newName, info) {
      var _a, _b, _c;
      return typeof info.navigation === "object" ? (_c = (_b = (_a = info.navigation).resolveRenameNewName) == null ? void 0 : _b.call(_a, newName)) != null ? _c : newName : newName;
    }
    exports2.resolveRenameNewName = resolveRenameNewName;
    function resolveRenameEditText(text, info) {
      var _a, _b, _c;
      return typeof info.navigation === "object" ? (_c = (_b = (_a = info.navigation).resolveRenameEditText) == null ? void 0 : _b.call(_a, text)) != null ? _c : text : text;
    }
    exports2.resolveRenameEditText = resolveRenameEditText;
  }
});

// node_modules/@volar/language-core/lib/linkedCodeMap.js
var require_linkedCodeMap = __commonJS({
  "node_modules/@volar/language-core/lib/linkedCodeMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedCodeMap = void 0;
    var source_map_1 = require_source_map();
    var LinkedCodeMap = class extends source_map_1.SourceMap {
      *getLinkedOffsets(start) {
        for (const mapped of this.getGeneratedOffsets(start)) {
          yield mapped[0];
        }
        for (const mapped of this.getSourceOffsets(start)) {
          yield mapped[0];
        }
      }
    };
    exports2.LinkedCodeMap = LinkedCodeMap;
  }
});

// node_modules/@volar/language-core/lib/types.js
var require_types2 = __commonJS({
  "node_modules/@volar/language-core/lib/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@volar/language-core/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@volar/language-core/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileMap = void 0;
    var FileMap = class extends Map {
      constructor(caseSensitive) {
        super();
        this.caseSensitive = caseSensitive;
        this.originalFileNames = /* @__PURE__ */ new Map();
      }
      keys() {
        return this.originalFileNames.values();
      }
      get(key) {
        return super.get(this.normalizeId(key));
      }
      has(key) {
        return super.has(this.normalizeId(key));
      }
      set(key, value) {
        this.originalFileNames.set(this.normalizeId(key), key);
        return super.set(this.normalizeId(key), value);
      }
      delete(key) {
        this.originalFileNames.delete(this.normalizeId(key));
        return super.delete(this.normalizeId(key));
      }
      clear() {
        this.originalFileNames.clear();
        return super.clear();
      }
      normalizeId(id) {
        return this.caseSensitive ? id : id.toLowerCase();
      }
    };
    exports2.FileMap = FileMap;
  }
});

// node_modules/@volar/language-core/index.js
var require_language_core = __commonJS({
  "node_modules/@volar/language-core/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachEmbeddedCode = exports2.createLanguage = void 0;
    __exportStar(require_source_map(), exports2);
    __exportStar(require_editorFeatures(), exports2);
    __exportStar(require_linkedCodeMap(), exports2);
    __exportStar(require_types2(), exports2);
    __exportStar(require_utils(), exports2);
    var source_map_1 = require_source_map();
    var linkedCodeMap_1 = require_linkedCodeMap();
    function createLanguage(plugins, scriptRegistry, sync) {
      const virtualCodeToSourceScriptMap = /* @__PURE__ */ new WeakMap();
      const virtualCodeToSourceMap = /* @__PURE__ */ new WeakMap();
      const virtualCodeToLinkedCodeMap = /* @__PURE__ */ new WeakMap();
      return {
        plugins,
        scripts: {
          fromVirtualCode(virtualCode) {
            return virtualCodeToSourceScriptMap.get(virtualCode);
          },
          get(id) {
            sync(id);
            const result = scriptRegistry.get(id);
            if (result == null ? void 0 : result.isAssociationDirty) {
              this.set(id, result.snapshot, result.languageId);
            }
            return scriptRegistry.get(id);
          },
          set(id, snapshot, languageId, _plugins = plugins) {
            var _a, _b, _c;
            if (!languageId) {
              for (const plugin of plugins) {
                languageId = (_a = plugin.getLanguageId) == null ? void 0 : _a.call(plugin, id);
                if (languageId) {
                  break;
                }
              }
            }
            if (!languageId) {
              console.warn(`languageId not found for ${id}`);
              return;
            }
            let associatedOnly = false;
            for (const plugin of plugins) {
              if ((_b = plugin.isAssociatedFileOnly) == null ? void 0 : _b.call(plugin, id, languageId)) {
                associatedOnly = true;
                break;
              }
            }
            if (scriptRegistry.has(id)) {
              const sourceScript = scriptRegistry.get(id);
              if (sourceScript.languageId !== languageId || sourceScript.associatedOnly !== associatedOnly) {
                this.delete(id);
                return this.set(id, snapshot, languageId);
              } else if (associatedOnly) {
                sourceScript.snapshot = snapshot;
              } else if (sourceScript.isAssociationDirty || sourceScript.snapshot !== snapshot) {
                sourceScript.snapshot = snapshot;
                const codegenCtx = prepareCreateVirtualCode(sourceScript);
                if (sourceScript.generated) {
                  const { updateVirtualCode, createVirtualCode } = sourceScript.generated.languagePlugin;
                  const newVirtualCode = updateVirtualCode ? updateVirtualCode(id, sourceScript.generated.root, snapshot, codegenCtx) : createVirtualCode == null ? void 0 : createVirtualCode(id, languageId, snapshot, codegenCtx);
                  if (newVirtualCode) {
                    sourceScript.generated.root = newVirtualCode;
                    sourceScript.generated.embeddedCodes.clear();
                    for (const code of forEachEmbeddedCode(sourceScript.generated.root)) {
                      virtualCodeToSourceScriptMap.set(code, sourceScript);
                      sourceScript.generated.embeddedCodes.set(code.id, code);
                    }
                    return sourceScript;
                  } else {
                    this.delete(id);
                    return;
                  }
                }
                triggerTargetsDirty(sourceScript);
              } else {
                return sourceScript;
              }
            } else {
              const sourceScript = {
                id,
                languageId,
                snapshot,
                associatedIds: /* @__PURE__ */ new Set(),
                targetIds: /* @__PURE__ */ new Set(),
                associatedOnly
              };
              scriptRegistry.set(id, sourceScript);
              if (associatedOnly) {
                return sourceScript;
              }
              for (const languagePlugin of _plugins) {
                const virtualCode = (_c = languagePlugin.createVirtualCode) == null ? void 0 : _c.call(languagePlugin, id, languageId, snapshot, prepareCreateVirtualCode(sourceScript));
                if (virtualCode) {
                  sourceScript.generated = {
                    root: virtualCode,
                    languagePlugin,
                    embeddedCodes: /* @__PURE__ */ new Map()
                  };
                  for (const code of forEachEmbeddedCode(virtualCode)) {
                    virtualCodeToSourceScriptMap.set(code, sourceScript);
                    sourceScript.generated.embeddedCodes.set(code.id, code);
                  }
                  break;
                }
              }
              return sourceScript;
            }
          },
          delete(id) {
            var _a, _b, _c;
            const sourceScript = scriptRegistry.get(id);
            if (sourceScript) {
              (_c = (_a = sourceScript.generated) == null ? void 0 : (_b = _a.languagePlugin).disposeVirtualCode) == null ? void 0 : _c.call(_b, id, sourceScript.generated.root);
              scriptRegistry.delete(id);
              triggerTargetsDirty(sourceScript);
            }
          }
        },
        maps: {
          get(virtualCode, sourceScript) {
            var _a, _b;
            let mapCache = virtualCodeToSourceMap.get(virtualCode.snapshot);
            if (!mapCache) {
              virtualCodeToSourceMap.set(virtualCode.snapshot, mapCache = /* @__PURE__ */ new WeakMap());
            }
            if (!mapCache.has(sourceScript.snapshot)) {
              const mappings = (_b = (_a = virtualCode.associatedScriptMappings) == null ? void 0 : _a.get(sourceScript.id)) != null ? _b : virtualCode.mappings;
              mapCache.set(sourceScript.snapshot, new source_map_1.SourceMap(mappings));
            }
            return mapCache.get(sourceScript.snapshot);
          },
          *forEach(virtualCode) {
            const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);
            yield [
              sourceScript.id,
              sourceScript.snapshot,
              this.get(virtualCode, sourceScript)
            ];
            if (virtualCode.associatedScriptMappings) {
              for (const [relatedScriptId] of virtualCode.associatedScriptMappings) {
                const relatedSourceScript = scriptRegistry.get(relatedScriptId);
                if (relatedSourceScript) {
                  yield [
                    relatedSourceScript.id,
                    relatedSourceScript.snapshot,
                    this.get(virtualCode, relatedSourceScript)
                  ];
                }
              }
            }
          }
        },
        linkedCodeMaps: {
          get(virtualCode) {
            const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);
            let mapCache = virtualCodeToLinkedCodeMap.get(virtualCode.snapshot);
            if ((mapCache == null ? void 0 : mapCache[0]) !== sourceScript.snapshot) {
              virtualCodeToLinkedCodeMap.set(virtualCode.snapshot, mapCache = [
                sourceScript.snapshot,
                virtualCode.linkedCodeMappings ? new linkedCodeMap_1.LinkedCodeMap(virtualCode.linkedCodeMappings) : void 0
              ]);
            }
            return mapCache[1];
          }
        }
      };
      function triggerTargetsDirty(sourceScript) {
        sourceScript.targetIds.forEach((id) => {
          const sourceScript2 = scriptRegistry.get(id);
          if (sourceScript2) {
            sourceScript2.isAssociationDirty = true;
          }
        });
      }
      function prepareCreateVirtualCode(sourceScript) {
        var _a;
        for (const id of sourceScript.associatedIds) {
          (_a = scriptRegistry.get(id)) == null ? void 0 : _a.targetIds.delete(sourceScript.id);
        }
        sourceScript.associatedIds.clear();
        sourceScript.isAssociationDirty = false;
        return {
          getAssociatedScript(id) {
            sync(id);
            const relatedSourceScript = scriptRegistry.get(id);
            if (relatedSourceScript) {
              relatedSourceScript.targetIds.add(sourceScript.id);
              sourceScript.associatedIds.add(relatedSourceScript.id);
            }
            return relatedSourceScript;
          }
        };
      }
    }
    exports2.createLanguage = createLanguage;
    function* forEachEmbeddedCode(virtualCode) {
      yield virtualCode;
      if (virtualCode.embeddedCodes) {
        for (const embeddedCode of virtualCode.embeddedCodes) {
          yield* __yieldStar(forEachEmbeddedCode(embeddedCode));
        }
      }
    }
    exports2.forEachEmbeddedCode = forEachEmbeddedCode;
  }
});

// node_modules/@volar/typescript/lib/common.js
var require_common = __commonJS({
  "node_modules/@volar/typescript/lib/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveFileLanguageId = void 0;
    function resolveFileLanguageId(path) {
      const ext = path.split(".").pop();
      switch (ext) {
        case "js":
          return "javascript";
        case "cjs":
          return "javascript";
        case "mjs":
          return "javascript";
        case "ts":
          return "typescript";
        case "cts":
          return "typescript";
        case "mts":
          return "typescript";
        case "jsx":
          return "javascriptreact";
        case "tsx":
          return "typescriptreact";
        case "json":
          return "json";
      }
    }
    exports2.resolveFileLanguageId = resolveFileLanguageId;
  }
});

// node_modules/@volar/typescript/lib/node/dedupe.js
var require_dedupe = __commonJS({
  "node_modules/@volar/typescript/lib/node/dedupe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dedupeDocumentSpans = void 0;
    function dedupeDocumentSpans(items) {
      return dedupe(items, (item) => [
        item.fileName,
        item.textSpan.start,
        item.textSpan.length
      ].join(":"));
    }
    exports2.dedupeDocumentSpans = dedupeDocumentSpans;
    function dedupe(items, getKey) {
      const map = /* @__PURE__ */ new Map();
      for (const item of items.reverse()) {
        map.set(getKey(item), item);
      }
      return [...map.values()];
    }
  }
});

// node_modules/@volar/typescript/lib/node/utils.js
var require_utils2 = __commonJS({
  "node_modules/@volar/typescript/lib/node/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getServiceScript = exports2.notEmpty = void 0;
    function notEmpty(value) {
      return value !== null && value !== void 0;
    }
    exports2.notEmpty = notEmpty;
    function getServiceScript2(language, fileName) {
      var _a, _b;
      const sourceScript = language.scripts.get(fileName);
      if (sourceScript == null ? void 0 : sourceScript.targetIds.size) {
        for (const targetId of sourceScript.targetIds) {
          const targetScript = language.scripts.get(targetId);
          if (targetScript == null ? void 0 : targetScript.generated) {
            const serviceScript = (_a = targetScript.generated.languagePlugin.typescript) == null ? void 0 : _a.getServiceScript(targetScript.generated.root);
            if (serviceScript) {
              return [serviceScript, targetScript, sourceScript];
            }
          }
        }
      }
      if (sourceScript == null ? void 0 : sourceScript.associatedOnly) {
        return [void 0, sourceScript, sourceScript];
      }
      if (sourceScript == null ? void 0 : sourceScript.generated) {
        const serviceScript = (_b = sourceScript.generated.languagePlugin.typescript) == null ? void 0 : _b.getServiceScript(sourceScript.generated.root);
        if (serviceScript) {
          return [serviceScript, sourceScript, sourceScript];
        }
      }
      return [void 0, void 0, void 0];
    }
    exports2.getServiceScript = getServiceScript2;
  }
});

// node_modules/@volar/typescript/lib/node/transform.js
var require_transform = __commonJS({
  "node_modules/@volar/typescript/lib/node/transform.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMappingOffset = exports2.toGeneratedRange = exports2.toGeneratedOffsets = exports2.toGeneratedOffset = exports2.toGeneratedRanges = exports2.toSourceOffsets = exports2.toSourceRanges = exports2.toSourceOffset = exports2.transformTextSpan = exports2.transformTextChange = exports2.transformSpan = exports2.transformDocumentSpan = exports2.transformFileTextChanges = exports2.fillSourceFileText = exports2.transformDiagnostic = exports2.transformCallHierarchyItem = void 0;
    var language_core_1 = require_language_core();
    var utils_1 = require_utils2();
    var transformedDiagnostics = /* @__PURE__ */ new WeakMap();
    var transformedSourceFile = /* @__PURE__ */ new WeakSet();
    function transformCallHierarchyItem(language, item, filter) {
      var _a, _b, _c;
      const span = transformSpan(language, item.file, item.span, filter);
      const selectionSpan = transformSpan(language, item.file, item.selectionSpan, filter);
      return __spreadProps(__spreadValues({}, item), {
        file: (_a = span == null ? void 0 : span.fileName) != null ? _a : item.file,
        span: (_b = span == null ? void 0 : span.textSpan) != null ? _b : { start: 0, length: 0 },
        selectionSpan: (_c = selectionSpan == null ? void 0 : selectionSpan.textSpan) != null ? _c : { start: 0, length: 0 }
      });
    }
    exports2.transformCallHierarchyItem = transformCallHierarchyItem;
    function transformDiagnostic(language, diagnostic, program, isTsc) {
      var _a;
      if (!transformedDiagnostics.has(diagnostic)) {
        transformedDiagnostics.set(diagnostic, void 0);
        const { relatedInformation } = diagnostic;
        if (relatedInformation) {
          diagnostic.relatedInformation = relatedInformation.map((d) => transformDiagnostic(language, d, program, isTsc)).filter(utils_1.notEmpty);
        }
        if (diagnostic.file !== void 0 && diagnostic.start !== void 0 && diagnostic.length !== void 0) {
          const [serviceScript] = (0, utils_1.getServiceScript)(language, diagnostic.file.fileName);
          if (serviceScript) {
            const [sourceSpanFileName, sourceSpan] = (_a = transformTextSpan(void 0, language, serviceScript, {
              start: diagnostic.start,
              length: diagnostic.length
            }, language_core_1.shouldReportDiagnostics)) != null ? _a : [];
            const actualDiagnosticFile = sourceSpanFileName ? diagnostic.file.fileName === sourceSpanFileName ? diagnostic.file : program == null ? void 0 : program.getSourceFile(sourceSpanFileName) : void 0;
            if (sourceSpan && actualDiagnosticFile) {
              if (isTsc) {
                fillSourceFileText(language, diagnostic.file);
              }
              transformedDiagnostics.set(diagnostic, __spreadProps(__spreadValues({}, diagnostic), {
                file: actualDiagnosticFile,
                start: sourceSpan.start,
                length: sourceSpan.length
              }));
            }
          } else {
            transformedDiagnostics.set(diagnostic, diagnostic);
          }
        } else {
          transformedDiagnostics.set(diagnostic, diagnostic);
        }
      }
      return transformedDiagnostics.get(diagnostic);
    }
    exports2.transformDiagnostic = transformDiagnostic;
    function fillSourceFileText(language, sourceFile) {
      if (transformedSourceFile.has(sourceFile)) {
        return;
      }
      transformedSourceFile.add(sourceFile);
      const [serviceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
      if (serviceScript && !serviceScript.preventLeadingOffset) {
        const sourceScript = language.scripts.fromVirtualCode(serviceScript.code);
        sourceFile.text = sourceScript.snapshot.getText(0, sourceScript.snapshot.getLength()) + sourceFile.text.substring(sourceScript.snapshot.getLength());
      }
    }
    exports2.fillSourceFileText = fillSourceFileText;
    function transformFileTextChanges(language, changes, filter) {
      var _a;
      const changesPerFile = {};
      const newFiles = /* @__PURE__ */ new Set();
      for (const fileChanges of changes) {
        const [_, source] = (0, utils_1.getServiceScript)(language, fileChanges.fileName);
        if (source) {
          fileChanges.textChanges.forEach((c) => {
            var _a2, _b;
            const { fileName, textSpan } = (_a2 = transformSpan(language, fileChanges.fileName, c.span, filter)) != null ? _a2 : {};
            if (fileName && textSpan) {
              ((_b = changesPerFile[fileName]) != null ? _b : changesPerFile[fileName] = []).push(__spreadProps(__spreadValues({}, c), { span: textSpan }));
            }
          });
        } else {
          const list = (_a = changesPerFile[fileChanges.fileName]) != null ? _a : changesPerFile[fileChanges.fileName] = [];
          fileChanges.textChanges.forEach((c) => {
            list.push(c);
          });
          if (fileChanges.isNewFile) {
            newFiles.add(fileChanges.fileName);
          }
        }
      }
      const result = [];
      for (const fileName in changesPerFile) {
        result.push({
          fileName,
          isNewFile: newFiles.has(fileName),
          textChanges: changesPerFile[fileName]
        });
      }
      return result;
    }
    exports2.transformFileTextChanges = transformFileTextChanges;
    function transformDocumentSpan(language, documentSpan, filter, shouldFallback) {
      let textSpan = transformSpan(language, documentSpan.fileName, documentSpan.textSpan, filter);
      if (!textSpan && shouldFallback) {
        textSpan = {
          fileName: documentSpan.fileName,
          textSpan: { start: 0, length: 0 }
        };
      }
      if (!textSpan) {
        return;
      }
      const contextSpan = transformSpan(language, documentSpan.fileName, documentSpan.contextSpan, filter);
      const originalTextSpan = transformSpan(language, documentSpan.originalFileName, documentSpan.originalTextSpan, filter);
      const originalContextSpan = transformSpan(language, documentSpan.originalFileName, documentSpan.originalContextSpan, filter);
      return __spreadProps(__spreadValues({}, documentSpan), {
        fileName: textSpan.fileName,
        textSpan: textSpan.textSpan,
        contextSpan: contextSpan == null ? void 0 : contextSpan.textSpan,
        originalFileName: originalTextSpan == null ? void 0 : originalTextSpan.fileName,
        originalTextSpan: originalTextSpan == null ? void 0 : originalTextSpan.textSpan,
        originalContextSpan: originalContextSpan == null ? void 0 : originalContextSpan.textSpan
      });
    }
    exports2.transformDocumentSpan = transformDocumentSpan;
    function transformSpan(language, fileName, textSpan, filter) {
      var _a;
      if (!fileName || !textSpan) {
        return;
      }
      const [serviceScript] = (0, utils_1.getServiceScript)(language, fileName);
      if (serviceScript) {
        const [sourceSpanFileName, sourceSpan] = (_a = transformTextSpan(void 0, language, serviceScript, textSpan, filter)) != null ? _a : [];
        if (sourceSpan && sourceSpanFileName) {
          return {
            fileName: sourceSpanFileName,
            textSpan: sourceSpan
          };
        }
      } else {
        return {
          fileName,
          textSpan
        };
      }
    }
    exports2.transformSpan = transformSpan;
    function transformTextChange(sourceScript, language, serviceScript, textChange, filter) {
      var _a;
      const [sourceSpanFileName, sourceSpan] = (_a = transformTextSpan(sourceScript, language, serviceScript, textChange.span, filter)) != null ? _a : [];
      if (sourceSpan && sourceSpanFileName) {
        return [sourceSpanFileName, {
          newText: textChange.newText,
          span: sourceSpan
        }];
      }
      return void 0;
    }
    exports2.transformTextChange = transformTextChange;
    function transformTextSpan(sourceScript, language, serviceScript, textSpan, filter) {
      for (const [fileName, range] of toSourceRanges2(sourceScript, language, serviceScript, { pos: textSpan.start, end: textSpan.start + textSpan.length }, filter)) {
        return [fileName, { start: range.pos, length: range.end - range.pos }];
      }
    }
    exports2.transformTextSpan = transformTextSpan;
    function toSourceOffset(sourceScript, language, serviceScript, position, filter) {
      for (const source of toSourceOffsets(sourceScript, language, serviceScript, position, filter)) {
        return source;
      }
    }
    exports2.toSourceOffset = toSourceOffset;
    function* toSourceRanges2(sourceScript, language, serviceScript, range, filter) {
      if (sourceScript) {
        const map = language.maps.get(serviceScript.code, sourceScript);
        for (const [sourceStart, sourceEnd] of map.getSourceStartEnd(range.pos, range.end, filter, true)) {
          yield [sourceScript.id, { pos: sourceStart, end: sourceEnd }];
        }
      } else {
        let mappingOffset = getMappingOffset(language, serviceScript);
        for (const [fileName, _snapshot, map] of language.maps.forEach(serviceScript.code)) {
          for (const [sourceStart, sourceEnd] of map.getSourceStartEnd(range.pos - mappingOffset, range.end - mappingOffset, filter)) {
            yield [fileName, { pos: sourceStart, end: sourceEnd }];
          }
        }
      }
    }
    exports2.toSourceRanges = toSourceRanges2;
    function* toSourceOffsets(sourceScript, language, serviceScript, position, filter) {
      if (sourceScript) {
        const map = language.maps.get(serviceScript.code, sourceScript);
        for (const [sourceOffset] of map.getSourceOffsets(position - getMappingOffset(language, serviceScript), filter)) {
          yield [sourceScript.id, sourceOffset];
        }
      } else {
        for (const [fileName, _snapshot, map] of language.maps.forEach(serviceScript.code)) {
          for (const [sourceOffset] of map.getSourceOffsets(position - getMappingOffset(language, serviceScript), filter)) {
            yield [fileName, sourceOffset];
          }
        }
      }
    }
    exports2.toSourceOffsets = toSourceOffsets;
    function* toGeneratedRanges(language, serviceScript, sourceScript, span, filter) {
      const map = language.maps.get(serviceScript.code, sourceScript);
      for (const [generateStart, generateEnd] of map.getGeneratedStartEnd(span.pos, span.end, filter, true)) {
        let mappingOffset = getMappingOffset(language, serviceScript);
        yield { pos: generateStart + mappingOffset, end: generateEnd + mappingOffset };
      }
    }
    exports2.toGeneratedRanges = toGeneratedRanges;
    function toGeneratedOffset(language, serviceScript, sourceScript, position, filter) {
      for (const [generateOffset] of toGeneratedOffsets(language, serviceScript, sourceScript, position, filter)) {
        return generateOffset;
      }
    }
    exports2.toGeneratedOffset = toGeneratedOffset;
    function* toGeneratedOffsets(language, serviceScript, sourceScript, position, filter) {
      const map = language.maps.get(serviceScript.code, sourceScript);
      for (const [generateOffset, mapping] of map.getGeneratedOffsets(position, filter)) {
        yield [generateOffset + getMappingOffset(language, serviceScript), mapping];
      }
    }
    exports2.toGeneratedOffsets = toGeneratedOffsets;
    function toGeneratedRange2(language, serviceScript, sourceScript, range, filter) {
      for (const result of toGeneratedRanges(language, serviceScript, sourceScript, range, filter)) {
        return result;
      }
    }
    exports2.toGeneratedRange = toGeneratedRange2;
    function getMappingOffset(language, serviceScript) {
      if (serviceScript.preventLeadingOffset) {
        return 0;
      }
      const sourceScript = language.scripts.fromVirtualCode(serviceScript.code);
      return sourceScript.snapshot.getLength();
    }
    exports2.getMappingOffset = getMappingOffset;
  }
});

// node_modules/@volar/typescript/lib/node/decorateLanguageService.js
var require_decorateLanguageService = __commonJS({
  "node_modules/@volar/typescript/lib/node/decorateLanguageService.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decorateLanguageService = void 0;
    var language_core_1 = require_language_core();
    var dedupe_1 = require_dedupe();
    var transform_1 = require_transform();
    var utils_1 = require_utils2();
    var windowsPathReg = /\\/g;
    function decorateLanguageService(language, languageService) {
      const { getNavigationTree, getOutliningSpans } = languageService;
      languageService.getNavigationTree = (filePath) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (serviceScript || (targetScript == null ? void 0 : targetScript.associatedOnly)) {
          const tree = getNavigationTree(targetScript.id);
          tree.childItems = void 0;
          return tree;
        } else {
          return getNavigationTree(fileName);
        }
      };
      languageService.getOutliningSpans = (filePath) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (serviceScript || (targetScript == null ? void 0 : targetScript.associatedOnly)) {
          return [];
        } else {
          return getOutliningSpans(fileName);
        }
      };
      const { findReferences, findRenameLocations, getCompletionEntryDetails, getCompletionsAtPosition, getDefinitionAndBoundSpan, getDefinitionAtPosition, getFileReferences, getFormattingEditsForDocument, getFormattingEditsForRange, getFormattingEditsAfterKeystroke, getImplementationAtPosition, getLinkedEditingRangeAtPosition, getQuickInfoAtPosition, getSignatureHelpItems, getReferencesAtPosition, getSemanticDiagnostics, getSyntacticDiagnostics, getSuggestionDiagnostics, getTypeDefinitionAtPosition, getEncodedSemanticClassifications, getDocumentHighlights, getApplicableRefactors, getEditsForFileRename, getEditsForRefactor, getRenameInfo, getCodeFixesAtPosition, prepareCallHierarchy, provideCallHierarchyIncomingCalls, provideCallHierarchyOutgoingCalls, provideInlayHints, organizeImports } = languageService;
      languageService.getFormattingEditsForDocument = (filePath, options) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const map = language.maps.get(serviceScript.code, targetScript);
          if (!map.mappings.some((mapping) => (0, language_core_1.isFormattingEnabled)(mapping.data))) {
            return [];
          }
          const edits = getFormattingEditsForDocument(targetScript.id, options);
          return edits.map((edit) => {
            var _a;
            return (_a = (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, language_core_1.isFormattingEnabled)) == null ? void 0 : _a[1];
          }).filter(utils_1.notEmpty);
        } else {
          return getFormattingEditsForDocument(fileName, options);
        }
      };
      languageService.getFormattingEditsForRange = (filePath, start, end, options) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const generatedRange = (0, transform_1.toGeneratedRange)(language, serviceScript, sourceScript, { pos: start, end }, language_core_1.isCodeActionsEnabled);
          if (generatedRange !== void 0) {
            const edits = getFormattingEditsForRange(targetScript.id, generatedRange.pos, generatedRange.end, options);
            return edits.map((edit) => {
              var _a;
              return (_a = (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, language_core_1.isFormattingEnabled)) == null ? void 0 : _a[1];
            }).filter(utils_1.notEmpty);
          }
          return [];
        } else {
          return getFormattingEditsForRange(fileName, start, end, options);
        }
      };
      languageService.getFormattingEditsAfterKeystroke = (filePath, position, key, options) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isFormattingEnabled);
          if (generatePosition !== void 0) {
            const edits = getFormattingEditsAfterKeystroke(targetScript.id, generatePosition, key, options);
            return edits.map((edit) => {
              var _a;
              return (_a = (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, language_core_1.isFormattingEnabled)) == null ? void 0 : _a[1];
            }).filter(utils_1.notEmpty);
          }
          return [];
        } else {
          return getFormattingEditsAfterKeystroke(fileName, position, key, options);
        }
      };
      languageService.getEditsForFileRename = (oldFilePath, newFilePath, formatOptions, preferences) => {
        const edits = getEditsForFileRename(oldFilePath, newFilePath, formatOptions, preferences);
        return (0, transform_1.transformFileTextChanges)(language, edits, language_core_1.isRenameEnabled);
      };
      languageService.getLinkedEditingRangeAtPosition = (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isLinkedEditingEnabled);
          if (generatePosition !== void 0) {
            const info = getLinkedEditingRangeAtPosition(targetScript.id, generatePosition);
            if (info) {
              return {
                ranges: info.ranges.map((span) => {
                  var _a;
                  return (_a = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, span, language_core_1.isLinkedEditingEnabled)) == null ? void 0 : _a[1];
                }).filter(utils_1.notEmpty),
                wordPattern: info.wordPattern
              };
            }
          }
        } else {
          return getLinkedEditingRangeAtPosition(fileName, position);
        }
      };
      languageService.prepareCallHierarchy = (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isCallHierarchyEnabled);
          if (generatePosition !== void 0) {
            const item = prepareCallHierarchy(targetScript.id, generatePosition);
            if (Array.isArray(item)) {
              return item.map((item2) => (0, transform_1.transformCallHierarchyItem)(language, item2, language_core_1.isCallHierarchyEnabled));
            } else if (item) {
              return (0, transform_1.transformCallHierarchyItem)(language, item, language_core_1.isCallHierarchyEnabled);
            }
          }
        } else {
          return prepareCallHierarchy(fileName, position);
        }
      };
      languageService.provideCallHierarchyIncomingCalls = (filePath, position) => {
        let calls = [];
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isCallHierarchyEnabled);
          if (generatePosition !== void 0) {
            calls = provideCallHierarchyIncomingCalls(targetScript.id, generatePosition);
          }
        } else {
          calls = provideCallHierarchyIncomingCalls(fileName, position);
        }
        return calls.map((call) => {
          const from = (0, transform_1.transformCallHierarchyItem)(language, call.from, language_core_1.isCallHierarchyEnabled);
          const fromSpans = call.fromSpans.map((span) => {
            var _a;
            return (_a = (0, transform_1.transformSpan)(language, call.from.file, span, language_core_1.isCallHierarchyEnabled)) == null ? void 0 : _a.textSpan;
          }).filter(utils_1.notEmpty);
          return {
            from,
            fromSpans
          };
        });
      };
      languageService.provideCallHierarchyOutgoingCalls = (filePath, position) => {
        let calls = [];
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isCallHierarchyEnabled);
          if (generatePosition !== void 0) {
            calls = provideCallHierarchyOutgoingCalls(targetScript.id, generatePosition);
          }
        } else {
          calls = provideCallHierarchyOutgoingCalls(fileName, position);
        }
        return calls.map((call) => {
          const to = (0, transform_1.transformCallHierarchyItem)(language, call.to, language_core_1.isCallHierarchyEnabled);
          const fromSpans = call.fromSpans.map((span) => {
            var _a;
            return serviceScript ? (_a = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, span, language_core_1.isCallHierarchyEnabled)) == null ? void 0 : _a[1] : span;
          }).filter(utils_1.notEmpty);
          return {
            to,
            fromSpans
          };
        });
      };
      languageService.organizeImports = (args, formatOptions, preferences) => {
        const unresolved = organizeImports(args, formatOptions, preferences);
        return (0, transform_1.transformFileTextChanges)(language, unresolved, language_core_1.isCodeActionsEnabled);
      };
      languageService.getQuickInfoAtPosition = (filePath, position) => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          const infos = [];
          for (const [generatePosition] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, language_core_1.isHoverEnabled)) {
            const info = getQuickInfoAtPosition(targetScript.id, generatePosition);
            if (info) {
              const textSpan = (_a = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, info.textSpan, language_core_1.isHoverEnabled)) == null ? void 0 : _a[1];
              if (textSpan) {
                infos.push(__spreadProps(__spreadValues({}, info), {
                  textSpan
                }));
              }
            }
          }
          if (infos.length === 1) {
            return infos[0];
          } else if (infos.length >= 2) {
            const combine = __spreadValues({}, infos[0]);
            combine.displayParts = (_b = combine.displayParts) == null ? void 0 : _b.slice();
            combine.documentation = (_c = combine.documentation) == null ? void 0 : _c.slice();
            combine.tags = (_d = combine.tags) == null ? void 0 : _d.slice();
            const displayPartsStrs = /* @__PURE__ */ new Set([displayPartsToString(infos[0].displayParts)]);
            const documentationStrs = /* @__PURE__ */ new Set([displayPartsToString(infos[0].documentation)]);
            const tagsStrs = /* @__PURE__ */ new Set();
            for (const tag of (_e = infos[0].tags) != null ? _e : []) {
              tagsStrs.add(tag.name + "__volar__" + displayPartsToString(tag.text));
            }
            for (let i = 1; i < infos.length; i++) {
              const { displayParts, documentation, tags } = infos[i];
              if ((displayParts == null ? void 0 : displayParts.length) && !displayPartsStrs.has(displayPartsToString(displayParts))) {
                displayPartsStrs.add(displayPartsToString(displayParts));
                (_f = combine.displayParts) != null ? _f : combine.displayParts = [];
                combine.displayParts.push(__spreadProps(__spreadValues({}, displayParts[0]), { text: "\n\n" + displayParts[0].text }));
                combine.displayParts.push(...displayParts.slice(1));
              }
              if ((documentation == null ? void 0 : documentation.length) && !documentationStrs.has(displayPartsToString(documentation))) {
                documentationStrs.add(displayPartsToString(documentation));
                (_g = combine.documentation) != null ? _g : combine.documentation = [];
                combine.documentation.push(__spreadProps(__spreadValues({}, documentation[0]), { text: "\n\n" + documentation[0].text }));
                combine.documentation.push(...documentation.slice(1));
              }
              for (const tag of tags != null ? tags : []) {
                if (!tagsStrs.has(tag.name + "__volar__" + displayPartsToString(tag.text))) {
                  tagsStrs.add(tag.name + "__volar__" + displayPartsToString(tag.text));
                  (_h = combine.tags) != null ? _h : combine.tags = [];
                  combine.tags.push(tag);
                }
              }
            }
            return combine;
          }
        } else {
          return getQuickInfoAtPosition(fileName, position);
        }
      };
      languageService.getSignatureHelpItems = (filePath, position, options) => {
        var _a;
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isSignatureHelpEnabled);
          if (generatePosition !== void 0) {
            const result = getSignatureHelpItems(targetScript.id, generatePosition, options);
            if (result) {
              const applicableSpan = (_a = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, result.applicableSpan, language_core_1.isSignatureHelpEnabled)) == null ? void 0 : _a[1];
              if (applicableSpan) {
                return __spreadProps(__spreadValues({}, result), {
                  applicableSpan
                });
              }
            }
          }
        } else {
          return getSignatureHelpItems(fileName, position, options);
        }
      };
      languageService.getDocumentHighlights = (filePath, position, filesToSearch) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(fileName, position, language_core_1.isHighlightEnabled, (fileName2, position2) => getDocumentHighlights(fileName2, position2, filesToSearch), function* (result) {
          var _a;
          for (const ref of result) {
            for (const reference of ref.highlightSpans) {
              yield [(_a = reference.fileName) != null ? _a : ref.fileName, reference.textSpan.start];
            }
          }
        });
        const resolved = unresolved.flat().map((highlights) => {
          return __spreadProps(__spreadValues({}, highlights), {
            highlightSpans: highlights.highlightSpans.map((span) => {
              var _a, _b, _c, _d;
              const { textSpan } = (_b = (0, transform_1.transformSpan)(language, (_a = span.fileName) != null ? _a : highlights.fileName, span.textSpan, language_core_1.isHighlightEnabled)) != null ? _b : {};
              if (textSpan) {
                return __spreadProps(__spreadValues({}, span), {
                  contextSpan: (_d = (0, transform_1.transformSpan)(language, (_c = span.fileName) != null ? _c : highlights.fileName, span.contextSpan, language_core_1.isHighlightEnabled)) == null ? void 0 : _d.textSpan,
                  textSpan
                });
              }
            }).filter(utils_1.notEmpty)
          });
        });
        return resolved;
      };
      languageService.getApplicableRefactors = (filePath, positionOrRange, preferences, triggerReason, kind, includeInteractiveActions) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          if (typeof positionOrRange === "number") {
            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, positionOrRange, language_core_1.isCodeActionsEnabled);
            if (generatePosition !== void 0) {
              return getApplicableRefactors(targetScript.id, generatePosition, preferences, triggerReason, kind, includeInteractiveActions);
            }
          } else {
            for (const generatedRange of (0, transform_1.toGeneratedRanges)(language, serviceScript, sourceScript, positionOrRange, language_core_1.isCodeActionsEnabled)) {
              return getApplicableRefactors(targetScript.id, generatedRange, preferences, triggerReason, kind, includeInteractiveActions);
            }
          }
          return [];
        } else {
          return getApplicableRefactors(fileName, positionOrRange, preferences, triggerReason, kind, includeInteractiveActions);
        }
      };
      languageService.getEditsForRefactor = (filePath, formatOptions, positionOrRange, refactorName, actionName, preferences) => {
        let edits;
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          if (typeof positionOrRange === "number") {
            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, positionOrRange, language_core_1.isCodeActionsEnabled);
            if (generatePosition !== void 0) {
              edits = getEditsForRefactor(targetScript.id, formatOptions, generatePosition, refactorName, actionName, preferences);
            }
          } else {
            for (const range of (0, transform_1.toGeneratedRanges)(language, serviceScript, sourceScript, positionOrRange, language_core_1.isCodeActionsEnabled)) {
              edits = getEditsForRefactor(targetScript.id, formatOptions, range, refactorName, actionName, preferences);
            }
          }
        } else {
          edits = getEditsForRefactor(fileName, formatOptions, positionOrRange, refactorName, actionName, preferences);
        }
        if (edits) {
          edits.edits = (0, transform_1.transformFileTextChanges)(language, edits.edits, language_core_1.isCodeActionsEnabled);
          return edits;
        }
      };
      languageService.getRenameInfo = (filePath, position, options) => {
        var _a;
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return {
            canRename: false,
            localizedErrorMessage: "Cannot rename"
          };
        }
        if (serviceScript) {
          let failed;
          for (const [generateOffset] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, language_core_1.isRenameEnabled)) {
            const info = getRenameInfo(targetScript.id, generateOffset, options);
            if (info.canRename) {
              const span = (_a = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, info.triggerSpan, language_core_1.isRenameEnabled)) == null ? void 0 : _a[1];
              if (span) {
                info.triggerSpan = span;
                return info;
              }
            } else {
              failed = info;
            }
          }
          if (failed) {
            return failed;
          }
          return {
            canRename: false,
            localizedErrorMessage: "Failed to get rename locations"
          };
        } else {
          return getRenameInfo(fileName, position, options);
        }
      };
      languageService.getCodeFixesAtPosition = (filePath, start, end, errorCodes, formatOptions, preferences) => {
        let fixes = [];
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          const generatedRange = (0, transform_1.toGeneratedRange)(language, serviceScript, sourceScript, { pos: start, end }, language_core_1.isCodeActionsEnabled);
          if (generatedRange !== void 0) {
            fixes = getCodeFixesAtPosition(targetScript.id, generatedRange.pos, generatedRange.end, errorCodes, formatOptions, preferences);
          }
        } else {
          fixes = getCodeFixesAtPosition(fileName, start, end, errorCodes, formatOptions, preferences);
        }
        fixes = fixes.map((fix) => {
          fix.changes = (0, transform_1.transformFileTextChanges)(language, fix.changes, language_core_1.isCodeActionsEnabled);
          return fix;
        });
        return fixes;
      };
      languageService.getEncodedSemanticClassifications = (filePath, span, format) => {
        var _a, _b, _c;
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return {
            spans: [],
            endOfLineState: 0
          };
        }
        if (serviceScript) {
          let start;
          let end;
          const map = language.maps.get(serviceScript.code, targetScript);
          for (const mapping of map.mappings) {
            if ((0, language_core_1.isSemanticTokensEnabled)(mapping.data) && mapping.sourceOffsets[0] >= span.start && mapping.sourceOffsets[0] <= span.start + span.length) {
              start != null ? start : start = mapping.generatedOffsets[0];
              end != null ? end : end = mapping.generatedOffsets[mapping.generatedOffsets.length - 1] + ((_a = mapping.generatedLengths) != null ? _a : mapping.lengths)[mapping.lengths.length - 1];
              start = Math.min(start, mapping.generatedOffsets[0]);
              end = Math.max(end, mapping.generatedOffsets[mapping.generatedOffsets.length - 1] + ((_b = mapping.generatedLengths) != null ? _b : mapping.lengths)[mapping.lengths.length - 1]);
            }
          }
          start != null ? start : start = 0;
          end != null ? end : end = targetScript.snapshot.getLength();
          const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript);
          start += mappingOffset;
          end += mappingOffset;
          const result = getEncodedSemanticClassifications(targetScript.id, { start, length: end - start }, format);
          const spans = [];
          for (let i = 0; i < result.spans.length; i += 3) {
            const [_, span2] = (_c = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, {
              start: result.spans[i],
              length: result.spans[i + 1]
            }, language_core_1.isSemanticTokensEnabled)) != null ? _c : [];
            if (span2) {
              spans.push(span2.start, span2.length, result.spans[i + 2]);
            }
          }
          result.spans = spans;
          return result;
        } else {
          return getEncodedSemanticClassifications(fileName, span, format);
        }
      };
      languageService.getSyntacticDiagnostics = (filePath) => {
        var _a;
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return [];
        }
        return getSyntacticDiagnostics((_a = targetScript == null ? void 0 : targetScript.id) != null ? _a : fileName).map((d) => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false)).filter(utils_1.notEmpty).filter((d) => !serviceScript || language.scripts.get(d.file.fileName) === sourceScript);
      };
      languageService.getSemanticDiagnostics = (filePath) => {
        var _a;
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return [];
        }
        return getSemanticDiagnostics((_a = targetScript == null ? void 0 : targetScript.id) != null ? _a : fileName).map((d) => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false)).filter(utils_1.notEmpty).filter((d) => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
      };
      languageService.getSuggestionDiagnostics = (filePath) => {
        var _a;
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return [];
        }
        return getSuggestionDiagnostics((_a = targetScript == null ? void 0 : targetScript.id) != null ? _a : fileName).map((d) => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false)).filter(utils_1.notEmpty).filter((d) => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
      };
      languageService.getDefinitionAndBoundSpan = (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(fileName, position, language_core_1.isDefinitionEnabled, (fileName2, position2) => getDefinitionAndBoundSpan(fileName2, position2), function* (result) {
          var _a;
          for (const ref of (_a = result.definitions) != null ? _a : []) {
            yield [ref.fileName, ref.textSpan.start];
          }
        });
        const textSpan = unresolved.map((s) => {
          var _a;
          return (_a = (0, transform_1.transformSpan)(language, fileName, s.textSpan, language_core_1.isDefinitionEnabled)) == null ? void 0 : _a.textSpan;
        }).filter(utils_1.notEmpty)[0];
        if (!textSpan) {
          return;
        }
        const definitions = unresolved.map((s) => {
          var _a;
          return (_a = s.definitions) == null ? void 0 : _a.map((s2) => (0, transform_1.transformDocumentSpan)(language, s2, language_core_1.isDefinitionEnabled, s2.fileName !== fileName)).filter(utils_1.notEmpty);
        }).filter(utils_1.notEmpty).flat();
        return {
          textSpan,
          definitions: (0, dedupe_1.dedupeDocumentSpans)(definitions)
        };
      };
      languageService.findReferences = (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(fileName, position, language_core_1.isReferencesEnabled, (fileName2, position2) => findReferences(fileName2, position2), function* (result) {
          for (const ref of result) {
            for (const reference of ref.references) {
              yield [reference.fileName, reference.textSpan.start];
            }
          }
        });
        const resolved = unresolved.flat().map((symbol) => {
          const definition = (0, transform_1.transformDocumentSpan)(language, symbol.definition, language_core_1.isDefinitionEnabled, true);
          return {
            definition,
            references: symbol.references.map((r) => (0, transform_1.transformDocumentSpan)(language, r, language_core_1.isReferencesEnabled)).filter(utils_1.notEmpty)
          };
        });
        return resolved;
      };
      languageService.getDefinitionAtPosition = (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(fileName, position, language_core_1.isDefinitionEnabled, (fileName2, position2) => getDefinitionAtPosition(fileName2, position2), function* (result) {
          for (const ref of result) {
            yield [ref.fileName, ref.textSpan.start];
          }
        });
        const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isDefinitionEnabled, s.fileName !== fileName)).filter(utils_1.notEmpty);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
      languageService.getTypeDefinitionAtPosition = (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(fileName, position, language_core_1.isTypeDefinitionEnabled, (fileName2, position2) => getTypeDefinitionAtPosition(fileName2, position2), function* (result) {
          for (const ref of result) {
            yield [ref.fileName, ref.textSpan.start];
          }
        });
        const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isTypeDefinitionEnabled)).filter(utils_1.notEmpty);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
      languageService.getImplementationAtPosition = (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(fileName, position, language_core_1.isImplementationEnabled, (fileName2, position2) => getImplementationAtPosition(fileName2, position2), function* (result) {
          for (const ref of result) {
            yield [ref.fileName, ref.textSpan.start];
          }
        });
        const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isImplementationEnabled)).filter(utils_1.notEmpty);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
      languageService.findRenameLocations = (filePath, position, findInStrings, findInComments, preferences) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(fileName, position, language_core_1.isRenameEnabled, (fileName2, position2) => findRenameLocations(fileName2, position2, findInStrings, findInComments, preferences), function* (result) {
          for (const ref of result) {
            yield [ref.fileName, ref.textSpan.start];
          }
        });
        const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isRenameEnabled)).filter(utils_1.notEmpty);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
      languageService.getReferencesAtPosition = (filePath, position) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = linkedCodeFeatureWorker(fileName, position, language_core_1.isReferencesEnabled, (fileName2, position2) => getReferencesAtPosition(fileName2, position2), function* (result) {
          for (const ref of result) {
            yield [ref.fileName, ref.textSpan.start];
          }
        });
        const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isReferencesEnabled)).filter(utils_1.notEmpty);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
      languageService.getCompletionsAtPosition = (filePath, position, options, formattingSettings) => {
        var _a, _b;
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          const results = [];
          for (const [generatedOffset, mapping] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, language_core_1.isCompletionEnabled)) {
            const result = getCompletionsAtPosition(targetScript.id, generatedOffset, options, formattingSettings);
            if (!result) {
              continue;
            }
            if (typeof mapping.data.completion === "object" && mapping.data.completion.onlyImport) {
              result.entries = result.entries.filter((entry) => !!entry.sourceDisplay);
            }
            for (const entry of result.entries) {
              entry.replacementSpan = entry.replacementSpan && ((_a = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, entry.replacementSpan, language_core_1.isCompletionEnabled)) == null ? void 0 : _a[1]);
            }
            result.optionalReplacementSpan = result.optionalReplacementSpan && ((_b = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, result.optionalReplacementSpan, language_core_1.isCompletionEnabled)) == null ? void 0 : _b[1]);
            const isAdditional = typeof mapping.data.completion === "object" && mapping.data.completion.isAdditional;
            if (isAdditional) {
              results.push(result);
            } else {
              results.unshift(result);
            }
          }
          if (results.length) {
            return __spreadProps(__spreadValues({}, results[0]), {
              entries: results.map((additionalResult) => additionalResult.entries).flat()
            });
          }
        } else {
          return getCompletionsAtPosition(fileName, position, options, formattingSettings);
        }
      };
      languageService.getCompletionEntryDetails = (filePath, position, entryName, formatOptions, source, preferences, data) => {
        let details;
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return void 0;
        }
        if (serviceScript) {
          const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isCompletionEnabled);
          if (generatePosition !== void 0) {
            details = getCompletionEntryDetails(targetScript.id, generatePosition, entryName, formatOptions, source, preferences, data);
          }
        } else {
          return getCompletionEntryDetails(fileName, position, entryName, formatOptions, source, preferences, data);
        }
        if (details == null ? void 0 : details.codeActions) {
          for (const codeAction of details.codeActions) {
            codeAction.changes = (0, transform_1.transformFileTextChanges)(language, codeAction.changes, language_core_1.isCompletionEnabled);
          }
        }
        return details;
      };
      languageService.provideInlayHints = (filePath, span, preferences) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript == null ? void 0 : targetScript.associatedOnly) {
          return [];
        }
        if (serviceScript) {
          let start;
          let end;
          const map = language.maps.get(serviceScript.code, targetScript);
          for (const mapping of map.mappings) {
            if ((0, language_core_1.isInlayHintsEnabled)(mapping.data) && mapping.sourceOffsets[0] >= span.start && mapping.sourceOffsets[0] <= span.start + span.length) {
              start != null ? start : start = mapping.generatedOffsets[0];
              end != null ? end : end = mapping.generatedOffsets[mapping.generatedOffsets.length - 1];
              start = Math.min(start, mapping.generatedOffsets[0]);
              end = Math.max(end, mapping.generatedOffsets[mapping.generatedOffsets.length - 1]);
            }
          }
          if (start === void 0 || end === void 0) {
            start = 0;
            end = 0;
          }
          const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript);
          start += mappingOffset;
          end += mappingOffset;
          const result = provideInlayHints(targetScript.id, { start, length: end - start }, preferences);
          const hints = [];
          for (const hint of result) {
            const sourcePosition = (0, transform_1.toSourceOffset)(sourceScript, language, serviceScript, hint.position, language_core_1.isInlayHintsEnabled);
            if (sourcePosition !== void 0) {
              hints.push(__spreadProps(__spreadValues({}, hint), {
                position: sourcePosition[1]
              }));
            }
          }
          return hints;
        } else {
          return provideInlayHints(fileName, span, preferences);
        }
      };
      languageService.getFileReferences = (filePath) => {
        const fileName = filePath.replace(windowsPathReg, "/");
        const unresolved = getFileReferences(fileName);
        const resolved = unresolved.map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isReferencesEnabled)).filter(utils_1.notEmpty);
        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
      };
      function linkedCodeFeatureWorker(fileName, position, filter, worker, getLinkedCodes) {
        const results = [];
        const processedFilePositions = /* @__PURE__ */ new Set();
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (serviceScript) {
          for (const [generatedOffset] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, filter)) {
            process(targetScript.id, generatedOffset);
          }
        } else {
          process(fileName, position);
        }
        return results;
        function process(fileName2, position2) {
          if (processedFilePositions.has(fileName2 + ":" + position2)) {
            return;
          }
          processedFilePositions.add(fileName2 + ":" + position2);
          const result = worker(fileName2, position2);
          if (!result) {
            return;
          }
          results.push(result);
          for (const ref of getLinkedCodes(result)) {
            processedFilePositions.add(ref[0] + ":" + ref[1]);
            const [serviceScript2] = (0, utils_1.getServiceScript)(language, ref[0]);
            if (!serviceScript2) {
              continue;
            }
            const linkedCodeMap = language.linkedCodeMaps.get(serviceScript2.code);
            if (!linkedCodeMap) {
              continue;
            }
            const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript2);
            for (const linkedCodeOffset of linkedCodeMap.getLinkedOffsets(ref[1] - mappingOffset)) {
              process(ref[0], linkedCodeOffset + mappingOffset);
            }
          }
        }
      }
    }
    exports2.decorateLanguageService = decorateLanguageService;
    function displayPartsToString(displayParts) {
      if (displayParts) {
        return displayParts.map((displayPart) => displayPart.text).join("");
      }
      return "";
    }
  }
});

// node_modules/@volar/typescript/lib/resolveModuleName.js
var require_resolveModuleName = __commonJS({
  "node_modules/@volar/typescript/lib/resolveModuleName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createResolveModuleName = void 0;
    function createResolveModuleName(ts, host, languagePlugins, getSourceScript) {
      var _a, _b, _c, _d;
      const toSourceFileInfo = /* @__PURE__ */ new Map();
      const moduleResolutionHost = {
        readFile: host.readFile.bind(host),
        directoryExists: (_a = host.directoryExists) == null ? void 0 : _a.bind(host),
        realpath: (_b = host.realpath) == null ? void 0 : _b.bind(host),
        getCurrentDirectory: (_c = host.getCurrentDirectory) == null ? void 0 : _c.bind(host),
        getDirectories: (_d = host.getDirectories) == null ? void 0 : _d.bind(host),
        useCaseSensitiveFileNames: typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames.bind(host) : host.useCaseSensitiveFileNames,
        fileExists(fileName) {
          var _a2, _b2;
          for (const { typescript } of languagePlugins) {
            if (!typescript) {
              continue;
            }
            for (const { extension } of typescript.extraFileExtensions) {
              if (fileName.endsWith(`.d.${extension}.ts`)) {
                const sourceFileName = fileName.slice(0, -`.d.${extension}.ts`.length) + `.${extension}`;
                if (fileExists(sourceFileName)) {
                  const sourceScript = getSourceScript(sourceFileName);
                  if (sourceScript == null ? void 0 : sourceScript.generated) {
                    const serviceScript = (_a2 = sourceScript.generated.languagePlugin.typescript) == null ? void 0 : _a2.getServiceScript(sourceScript.generated.root);
                    if (serviceScript) {
                      const dtsPath = sourceFileName + ".d.ts";
                      if ((serviceScript.extension === ".js" || serviceScript.extension === ".jsx") && fileExists(dtsPath)) {
                        toSourceFileInfo.set(fileName, {
                          sourceFileName: dtsPath,
                          extension: ".ts"
                        });
                      } else {
                        toSourceFileInfo.set(fileName, {
                          sourceFileName,
                          extension: serviceScript.extension
                        });
                      }
                      return true;
                    }
                  }
                }
              }
            }
            if (typescript.resolveHiddenExtensions && fileName.endsWith(`.d.ts`)) {
              for (const { extension } of typescript.extraFileExtensions) {
                const sourceFileName = fileName.slice(0, -`.d.ts`.length) + `.${extension}`;
                if (fileExists(sourceFileName)) {
                  const sourceScript = getSourceScript(sourceFileName);
                  if (sourceScript == null ? void 0 : sourceScript.generated) {
                    const serviceScript = (_b2 = sourceScript.generated.languagePlugin.typescript) == null ? void 0 : _b2.getServiceScript(sourceScript.generated.root);
                    if (serviceScript) {
                      toSourceFileInfo.set(fileName, {
                        sourceFileName,
                        extension: serviceScript.extension
                      });
                      return true;
                    }
                  }
                }
              }
            }
          }
          return host.fileExists(fileName);
        }
      };
      return (moduleName, containingFile, compilerOptions, cache, redirectedReference, resolutionMode) => {
        const result = ts.resolveModuleName(moduleName, containingFile, compilerOptions, moduleResolutionHost, cache, redirectedReference, resolutionMode);
        if (result.resolvedModule) {
          const sourceFileInfo = toSourceFileInfo.get(result.resolvedModule.resolvedFileName);
          if (sourceFileInfo) {
            result.resolvedModule.resolvedFileName = sourceFileInfo.sourceFileName;
            result.resolvedModule.extension = sourceFileInfo.extension;
          }
        }
        toSourceFileInfo.clear();
        return result;
      };
      function fileExists(fileName) {
        var _a2, _b2, _c2, _d2, _e;
        if (host.fileExists(fileName)) {
          const fileSize = (_e = (_d2 = (_b2 = (_a2 = ts.sys).getFileSize) == null ? void 0 : _b2.call(_a2, fileName)) != null ? _d2 : (_c2 = host.readFile(fileName)) == null ? void 0 : _c2.length) != null ? _e : 0;
          return fileSize < 4 * 1024 * 1024;
        }
        return false;
      }
    }
    exports2.createResolveModuleName = createResolveModuleName;
  }
});

// node_modules/@volar/typescript/lib/node/decorateLanguageServiceHost.js
var require_decorateLanguageServiceHost = __commonJS({
  "node_modules/@volar/typescript/lib/node/decorateLanguageServiceHost.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.searchExternalFiles = exports2.decorateLanguageServiceHost = void 0;
    var resolveModuleName_1 = require_resolveModuleName();
    function decorateLanguageServiceHost(ts, language, languageServiceHost) {
      var _a, _b, _c, _d, _e;
      const pluginExtensions = language.plugins.map((plugin) => {
        var _a2, _b2;
        return (_b2 = (_a2 = plugin.typescript) == null ? void 0 : _a2.extraFileExtensions.map((ext) => "." + ext.extension)) != null ? _b2 : [];
      }).flat();
      const scripts = /* @__PURE__ */ new Map();
      const crashFileNames = /* @__PURE__ */ new Set();
      const readDirectory = (_a = languageServiceHost.readDirectory) == null ? void 0 : _a.bind(languageServiceHost);
      const resolveModuleNameLiterals = (_b = languageServiceHost.resolveModuleNameLiterals) == null ? void 0 : _b.bind(languageServiceHost);
      const resolveModuleNames = (_c = languageServiceHost.resolveModuleNames) == null ? void 0 : _c.bind(languageServiceHost);
      const getScriptSnapshot = languageServiceHost.getScriptSnapshot.bind(languageServiceHost);
      const getScriptKind = (_d = languageServiceHost.getScriptKind) == null ? void 0 : _d.bind(languageServiceHost);
      if (readDirectory) {
        languageServiceHost.readDirectory = (path, extensions, exclude, include, depth) => {
          if (extensions) {
            for (const ext of pluginExtensions) {
              if (!extensions.includes(ext)) {
                extensions = [...extensions, ext];
              }
            }
          }
          return readDirectory(path, extensions, exclude, include, depth);
        };
      }
      if (pluginExtensions.length) {
        const resolveModuleName = (0, resolveModuleName_1.createResolveModuleName)(ts, languageServiceHost, language.plugins, (fileName) => language.scripts.get(fileName));
        const getCanonicalFileName = ((_e = languageServiceHost.useCaseSensitiveFileNames) == null ? void 0 : _e.call(languageServiceHost)) ? (fileName) => fileName : (fileName) => fileName.toLowerCase();
        const moduleResolutionCache = ts.createModuleResolutionCache(languageServiceHost.getCurrentDirectory(), getCanonicalFileName, languageServiceHost.getCompilationSettings());
        if (resolveModuleNameLiterals) {
          languageServiceHost.resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, options, ...rest) => {
            if (moduleLiterals.every((name) => !pluginExtensions.some((ext) => name.text.endsWith(ext)))) {
              return resolveModuleNameLiterals(moduleLiterals, containingFile, redirectedReference, options, ...rest);
            }
            return moduleLiterals.map((moduleLiteral) => {
              return resolveModuleName(moduleLiteral.text, containingFile, options, moduleResolutionCache, redirectedReference);
            });
          };
        }
        if (resolveModuleNames) {
          languageServiceHost.resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, options, containingSourceFile) => {
            if (moduleNames.every((name) => !pluginExtensions.some((ext) => name.endsWith(ext)))) {
              return resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, options, containingSourceFile);
            }
            return moduleNames.map((moduleName) => {
              return resolveModuleName(moduleName, containingFile, options, moduleResolutionCache, redirectedReference).resolvedModule;
            });
          };
        }
      }
      languageServiceHost.getScriptSnapshot = (fileName) => {
        const virtualScript = updateVirtualScript(fileName);
        if (virtualScript) {
          return virtualScript.snapshot;
        }
        return getScriptSnapshot(fileName);
      };
      if (getScriptKind) {
        languageServiceHost.getScriptKind = (fileName) => {
          const virtualScript = updateVirtualScript(fileName);
          if (virtualScript) {
            return virtualScript.scriptKind;
          }
          return getScriptKind(fileName);
        };
      }
      function updateVirtualScript(fileName) {
        var _a2, _b2;
        if (crashFileNames.has(fileName)) {
          return;
        }
        let version;
        try {
          version = languageServiceHost.getScriptVersion(fileName);
        } catch (e) {
          crashFileNames.add(fileName);
        }
        if (version === void 0) {
          return;
        }
        let script = scripts.get(fileName);
        if (!script || script[0] !== version) {
          script = [version];
          const sourceScript = language.scripts.get(fileName);
          if (sourceScript == null ? void 0 : sourceScript.generated) {
            const serviceScript = (_a2 = sourceScript.generated.languagePlugin.typescript) == null ? void 0 : _a2.getServiceScript(sourceScript.generated.root);
            if (serviceScript) {
              if (serviceScript.preventLeadingOffset) {
                script[1] = {
                  extension: serviceScript.extension,
                  scriptKind: serviceScript.scriptKind,
                  snapshot: serviceScript.code.snapshot
                };
              } else {
                const sourceContents = sourceScript.snapshot.getText(0, sourceScript.snapshot.getLength());
                const virtualContents = sourceContents.split("\n").map((line) => " ".repeat(line.length)).join("\n") + serviceScript.code.snapshot.getText(0, serviceScript.code.snapshot.getLength());
                script[1] = {
                  extension: serviceScript.extension,
                  scriptKind: serviceScript.scriptKind,
                  snapshot: ts.ScriptSnapshot.fromString(virtualContents)
                };
              }
            }
            if ((_b2 = sourceScript.generated.languagePlugin.typescript) == null ? void 0 : _b2.getExtraServiceScripts) {
              console.warn("getExtraServiceScripts() is not available in TS plugin.");
            }
          }
          scripts.set(fileName, script);
        }
        return script[1];
      }
    }
    exports2.decorateLanguageServiceHost = decorateLanguageServiceHost;
    function searchExternalFiles(ts, project, exts) {
      if (project.projectKind !== ts.server.ProjectKind.Configured) {
        return [];
      }
      const configFile = project.getProjectName();
      const config = ts.readJsonConfigFile(configFile, project.readFile.bind(project));
      const parseHost = {
        useCaseSensitiveFileNames: project.useCaseSensitiveFileNames(),
        fileExists: project.fileExists.bind(project),
        readFile: project.readFile.bind(project),
        readDirectory: (...args) => {
          args[1] = exts;
          return project.readDirectory(...args);
        }
      };
      const parsed = ts.parseJsonSourceFileConfigFileContent(config, parseHost, project.getCurrentDirectory());
      return parsed.fileNames;
    }
    exports2.searchExternalFiles = searchExternalFiles;
  }
});

// node_modules/@volar/typescript/lib/quickstart/createLanguageServicePlugin.js
var require_createLanguageServicePlugin = __commonJS({
  "node_modules/@volar/typescript/lib/quickstart/createLanguageServicePlugin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.arrayItemsEqual = exports2.createLanguageServicePlugin = exports2.decoratedLanguageServiceHosts = exports2.decoratedLanguageServices = exports2.projectExternalFileExtensions = exports2.externalFiles = void 0;
    var language_core_1 = require_language_core();
    var common_1 = require_common();
    var decorateLanguageService_1 = require_decorateLanguageService();
    var decorateLanguageServiceHost_1 = require_decorateLanguageServiceHost();
    exports2.externalFiles = /* @__PURE__ */ new WeakMap();
    exports2.projectExternalFileExtensions = /* @__PURE__ */ new WeakMap();
    exports2.decoratedLanguageServices = /* @__PURE__ */ new WeakSet();
    exports2.decoratedLanguageServiceHosts = /* @__PURE__ */ new WeakSet();
    function createLanguageServicePlugin2(create) {
      return (modules) => {
        const { typescript: ts } = modules;
        const pluginModule = {
          create(info) {
            if (!exports2.decoratedLanguageServices.has(info.languageService) && !exports2.decoratedLanguageServiceHosts.has(info.languageServiceHost)) {
              exports2.decoratedLanguageServices.add(info.languageService);
              exports2.decoratedLanguageServiceHosts.add(info.languageServiceHost);
              const { languagePlugins, setup } = create(ts, info);
              const extensions = languagePlugins.map((plugin) => {
                var _a, _b;
                return (_b = (_a = plugin.typescript) == null ? void 0 : _a.extraFileExtensions.map((ext) => "." + ext.extension)) != null ? _b : [];
              }).flat();
              exports2.projectExternalFileExtensions.set(info.project, extensions);
              const getScriptSnapshot = info.languageServiceHost.getScriptSnapshot.bind(info.languageServiceHost);
              const getScriptVersion = info.languageServiceHost.getScriptVersion.bind(info.languageServiceHost);
              const syncedScriptVersions = new language_core_1.FileMap(ts.sys.useCaseSensitiveFileNames);
              const language = (0, language_core_1.createLanguage)([
                ...languagePlugins,
                { getLanguageId: common_1.resolveFileLanguageId }
              ], new language_core_1.FileMap(ts.sys.useCaseSensitiveFileNames), (fileName) => {
                const version = getScriptVersion(fileName);
                if (syncedScriptVersions.get(fileName) === version) {
                  return;
                }
                syncedScriptVersions.set(fileName, version);
                const snapshot = getScriptSnapshot(fileName);
                if (snapshot) {
                  language.scripts.set(fileName, snapshot);
                } else {
                  language.scripts.delete(fileName);
                }
              });
              (0, decorateLanguageService_1.decorateLanguageService)(language, info.languageService);
              (0, decorateLanguageServiceHost_1.decorateLanguageServiceHost)(ts, language, info.languageServiceHost);
              setup == null ? void 0 : setup(language);
            }
            return info.languageService;
          },
          getExternalFiles(project, updateLevel = 0) {
            if (updateLevel >= 1 || !exports2.externalFiles.has(project)) {
              const oldFiles = exports2.externalFiles.get(project);
              const extensions = exports2.projectExternalFileExtensions.get(project);
              const newFiles = (extensions == null ? void 0 : extensions.length) ? (0, decorateLanguageServiceHost_1.searchExternalFiles)(ts, project, extensions) : [];
              exports2.externalFiles.set(project, newFiles);
              if (oldFiles && !arrayItemsEqual(oldFiles, newFiles)) {
                project.refreshDiagnostics();
              }
            }
            return exports2.externalFiles.get(project);
          }
        };
        return pluginModule;
      };
    }
    exports2.createLanguageServicePlugin = createLanguageServicePlugin2;
    function arrayItemsEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      const set = new Set(a);
      for (const file of b) {
        if (!set.has(file)) {
          return false;
        }
      }
      return true;
    }
    exports2.arrayItemsEqual = arrayItemsEqual;
  }
});

// src/index.ts
var import_createLanguageServicePlugin = __toESM(require_createLanguageServicePlugin());

// src/code.ts
var AngularVirtualCode = class {
  constructor(fileName, ctx, useCaseSensitiveFileNames) {
    this.fileName = fileName;
    this.ctx = ctx;
    this.useCaseSensitiveFileNames = useCaseSensitiveFileNames;
    this.snapshot = createEmptySnapshot();
    this.mappings = [];
    this.associatedScriptMappings = /* @__PURE__ */ new Map();
  }
  get id() {
    return "main";
  }
  get languageId() {
    return "typescript";
  }
  sourceFileUpdated(snapshot, _languageId) {
    this.associatedScriptMappings.clear();
    if (this.transpiledTemplate) {
      if (snapshot.getChangeRange(this.transpiledTemplate.snapshot) !== void 0 || !sameContents(snapshot, this.transpiledTemplate.sourceCode[this.normalizeId(this.fileName)])) {
        this.transpiledTemplate = void 0;
      } else if (this.transpiledTemplate.mappings.find((mapping) => {
        var _a, _b, _c;
        return !sameContents(
          (_a = this.ctx.getAssociatedScript(mapping.source)) == null ? void 0 : _a.snapshot,
          (_c = (_b = this.transpiledTemplate) == null ? void 0 : _b.sourceCode) == null ? void 0 : _c[this.normalizeId(mapping.source)]
        );
      })) {
        this.transpiledTemplate = void 0;
      }
    }
    if (this.transpiledTemplate) {
      this.snapshot = this.transpiledTemplate.snapshot;
      this.mappings = [];
      this.transpiledTemplate.mappings.forEach((mappingSet) => {
        var _a;
        let mappingsWithData;
        if (this.normalizeId(mappingSet.source) === this.normalizeId(this.fileName)) {
          mappingsWithData = this.mappings;
        } else {
          const associatedScript = this.ctx.getAssociatedScript(mappingSet.source);
          const scriptId = associatedScript == null ? void 0 : associatedScript.id;
          if (scriptId) {
            if (!this.associatedScriptMappings.has(scriptId)) {
              this.associatedScriptMappings.set(scriptId, []);
            }
            mappingsWithData = this.associatedScriptMappings.get(scriptId);
          } else {
            return;
          }
        }
        for (let i = 0; i < mappingSet.sourceOffsets.length; i++) {
          const generatedLength = (_a = mappingSet.generatedLengths) == null ? void 0 : _a[i];
          mappingsWithData.push({
            sourceOffsets: [mappingSet.sourceOffsets[i]],
            lengths: [mappingSet.lengths[i]],
            generatedOffsets: [mappingSet.generatedOffsets[i]],
            generatedLengths: generatedLength ? [generatedLength] : void 0,
            data: {
              format: mappingSet.source === this.fileName,
              completion: true,
              navigation: true,
              semantic: true,
              structure: true,
              verification: true
            }
          });
        }
      });
    } else {
      this.snapshot = snapshot;
      this.mappings = [{
        generatedOffsets: [0],
        sourceOffsets: [0],
        lengths: [snapshot.getLength()],
        data: {
          format: true,
          completion: true,
          navigation: true,
          semantic: true,
          structure: true,
          verification: true
        }
      }];
    }
    return this;
  }
  transpiledTemplateUpdated(transpiledCode, sourceCode, mappings) {
    if (transpiledCode) {
      this.transpiledTemplate = {
        mappings,
        sourceCode: Object.fromEntries(Object.entries(sourceCode).map(([key, value]) => {
          return [this.normalizeId(key), value];
        })),
        snapshot: createScriptSnapshot(transpiledCode)
      };
    } else {
      this.transpiledTemplate = void 0;
    }
  }
  normalizeId(id) {
    return this.useCaseSensitiveFileNames ? id : id.toLowerCase();
  }
};
function fullDiffTextChangeRange(oldText, newText) {
  for (let start = 0; start < oldText.length && start < newText.length; start++) {
    if (oldText[start] !== newText[start]) {
      let end = oldText.length;
      for (let i = 0; i < oldText.length - start && i < newText.length - start; i++) {
        if (oldText[oldText.length - i - 1] !== newText[newText.length - i - 1]) {
          break;
        }
        end--;
      }
      let length = end - start;
      let newLength = length + (newText.length - oldText.length);
      if (newLength < 0) {
        length -= newLength;
        newLength = 0;
      }
      return {
        span: { start, length },
        newLength
      };
    }
  }
  return void 0;
}
function sameContents(snapshot, code) {
  return !!snapshot && !!code && snapshot.getText(0, snapshot.getLength()) === code;
}
function createScriptSnapshot(code) {
  const changeRanges = /* @__PURE__ */ new Map();
  return {
    getText: (start, end) => (code != null ? code : "").slice(start, end),
    getLength: () => (code != null ? code : "").length,
    getChangeRange(oldSnapshot) {
      if (!changeRanges.has(oldSnapshot)) {
        changeRanges.set(oldSnapshot, void 0);
        const oldText = oldSnapshot.getText(0, oldSnapshot.getLength());
        const changeRange = fullDiffTextChangeRange(oldText, code != null ? code : "");
        if (changeRange) {
          changeRanges.set(oldSnapshot, changeRange);
        }
      }
      return changeRanges.get(oldSnapshot);
    }
  };
}
function createEmptySnapshot() {
  return {
    getText: (start, end) => "",
    getLength: () => 0,
    getChangeRange(oldSnapshot) {
      return {
        span: {
          start: 0,
          length: oldSnapshot.getLength()
        },
        newLength: 0
      };
    }
  };
}

// src/decorateLanguageService.ts
var import_utils = __toESM(require_utils2());
var import_transform = __toESM(require_transform());
var console2 = __toESM(require("console"));
function toSourceRange(sourceScript, language, serviceScript, range, filter) {
  for (const result of (0, import_transform.toSourceRanges)(sourceScript, language, serviceScript, range, filter)) {
    return result;
  }
  return void 0;
}
function decorateIdeLanguageServiceExtensions(language, languageService) {
  let { webStormGetElementType, webStormGetTypeProperties, webStormGetSymbolType } = languageService;
  if (webStormGetElementType === void 0 || webStormGetElementType === void 0 || webStormGetSymbolType === void 0)
    return;
  const ngReverseMapper = function(ts, sourceFile, generatedRange) {
    const [serviceScript, targetScript, sourceScript] = (0, import_utils.getServiceScript)(language, sourceFile.fileName);
    if (targetScript == null ? void 0 : targetScript.associatedOnly) {
      return void 0;
    }
    const program = languageService.getProgram();
    const generatedFile = targetScript ? program == null ? void 0 : program.getSourceFile(targetScript.id) : void 0;
    if (serviceScript && sourceFile && generatedFile) {
      try {
        let generatedRangePosStart = ts.getPositionOfLineAndCharacter(generatedFile, generatedRange.start.line, generatedRange.start.character);
        let generatedRangePosEnd = ts.getPositionOfLineAndCharacter(generatedFile, generatedRange.end.line, generatedRange.end.character);
        const sourceRange = toSourceRange(sourceScript, language, serviceScript, { pos: generatedRangePosStart, end: generatedRangePosEnd }, () => true);
        if (sourceRange !== void 0) {
          return {
            fileName: sourceRange[0],
            pos: sourceRange[1].pos,
            end: sourceRange[1].end
          };
        }
      } catch (e) {
        console2.error(e);
      }
    }
    return void 0;
  };
  languageService.webStormGetElementType = (ts, fileName, range, forceReturnType, reverseMapper) => {
    const [serviceScript, targetScript, sourceScript] = (0, import_utils.getServiceScript)(language, fileName);
    if (targetScript == null ? void 0 : targetScript.associatedOnly) {
      return void 0;
    }
    const program = languageService.getProgram();
    const sourceFile = program == null ? void 0 : program.getSourceFile(fileName);
    const generatedFile = targetScript ? program == null ? void 0 : program.getSourceFile(targetScript.id) : void 0;
    if (serviceScript && sourceFile && generatedFile) {
      try {
        let originalRangePosStart = ts.getPositionOfLineAndCharacter(sourceFile, range.start.line, range.start.character);
        let originalRangePosEnd = ts.getPositionOfLineAndCharacter(sourceFile, range.end.line, range.end.character);
        const generatedRange = (0, import_transform.toGeneratedRange)(language, serviceScript, sourceScript, { pos: originalRangePosStart, end: originalRangePosEnd }, () => true);
        if (generatedRange !== void 0) {
          const start = ts.getLineAndCharacterOfPosition(generatedFile, generatedRange.pos);
          const end = ts.getLineAndCharacterOfPosition(generatedFile, generatedRange.end);
          return webStormGetElementType(ts, targetScript.id, { start, end }, forceReturnType, ngReverseMapper.bind(null, ts));
        }
      } catch (e) {
      }
      return void 0;
    } else {
      return webStormGetElementType(ts, fileName, range, forceReturnType, reverseMapper);
    }
  };
  languageService.webStormGetSymbolType = (ts, symbolId, _reverseMapper) => {
    return webStormGetSymbolType(ts, symbolId, ngReverseMapper.bind(null, ts));
  };
  languageService.webStormGetTypeProperties = (ts, typeId, _reverseMapper) => {
    return webStormGetTypeProperties(ts, typeId, ngReverseMapper.bind(null, ts));
  };
}
function decorateNgLanguageServiceExtensions(language, languageService) {
  languageService.webStormNgUpdateTranspiledTemplate = (_ts, fileName, transpiledCode, sourceCode, mappings) => {
    var _a;
    const sourceScript = language.scripts.get(fileName);
    const virtualCode = (_a = sourceScript == null ? void 0 : sourceScript.generated) == null ? void 0 : _a.root;
    if (sourceScript && virtualCode instanceof AngularVirtualCode) {
      virtualCode.transpiledTemplateUpdated(transpiledCode, sourceCode, mappings);
    }
  };
}

// src/index.ts
function loadLanguagePlugins(ts, info) {
  addNgCommands(ts, info);
  let ngTcbBlocks = /* @__PURE__ */ new Map();
  return {
    languagePlugins: [{
      getLanguageId(scriptId) {
        return scriptId.endsWith(".html") ? "html" : void 0;
      },
      isAssociatedFileOnly(_scriptId, languageId) {
        return languageId === "html";
      },
      createVirtualCode(scriptId, languageId, snapshot, ctx) {
        if (languageId === "typescript" && !scriptId.endsWith(".d.ts") && scriptId.indexOf("/node_modules/") < 0) {
          let virtualCode = ngTcbBlocks.get(scriptId);
          if (!virtualCode) {
            virtualCode = new AngularVirtualCode(scriptId, ctx, ts.sys.useCaseSensitiveFileNames);
            ngTcbBlocks.set(scriptId, virtualCode);
          }
          return virtualCode.sourceFileUpdated(snapshot);
        }
        return void 0;
      },
      updateVirtualCode(scriptId, virtualCode, newSnapshot, ctx) {
        return virtualCode.sourceFileUpdated(newSnapshot);
      },
      typescript: {
        extraFileExtensions: [{
          extension: "html",
          scriptKind: ts.ScriptKind.External,
          isMixedContent: true
        }],
        getServiceScript(rootVirtualCode) {
          return {
            code: rootVirtualCode,
            extension: ".ts",
            scriptKind: ts.ScriptKind.TS,
            preventLeadingOffset: true
          };
        }
      }
    }],
    setup(language) {
      decorateIdeLanguageServiceExtensions(language, info.languageService);
      decorateNgLanguageServiceExtensions(language, info.languageService);
    }
  };
}
var ngTranspiledTemplateCommand = "ngTranspiledTemplate";
function addNgCommands(ts, info) {
  let projectService = info.project.projectService;
  projectService.logger.info("Angular: called handler processing");
  let session = info.session;
  if (session == void 0) {
    projectService.logger.info("Angular: there is no session in info.");
    return;
  }
  if (session.addProtocolHandler == void 0) {
    projectService.logger.info("Angular: there is no addProtocolHandler method.");
    return;
  }
  if (session.webStormNgCommandsAdded)
    return;
  session.webStormNgCommandsAdded = true;
  session.addProtocolHandler(ngTranspiledTemplateCommand, ngTranspiledTemplateHandler.bind(null, ts, session, projectService));
  projectService.logger.info("Angular specific commands are successfully added.");
}
var ngTranspiledTemplateHandler = (ts, session, projectService, request) => {
  const requestArguments = request.arguments;
  let fileName = ts.server.toNormalizedPath(requestArguments.file);
  let project = projectService.getDefaultProjectForFile(fileName, true);
  if (project) {
    project.getLanguageService().webStormNgUpdateTranspiledTemplate(
      ts,
      fileName,
      requestArguments.transpiledContent,
      requestArguments.sourceCode,
      requestArguments.mappings
    );
    session.change(
      {
        file: fileName,
        line: 1,
        offset: 1,
        endLine: 1,
        endOffset: 1,
        insertString: ""
      }
    );
  }
  return {
    responseRequired: true,
    response: {}
  };
};
var init = (0, import_createLanguageServicePlugin.createLanguageServicePlugin)(loadLanguagePlugins);
module.exports = init;
//# sourceMappingURL=index.js.map
