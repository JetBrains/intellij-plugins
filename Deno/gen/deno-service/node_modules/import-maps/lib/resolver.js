"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const url_1 = require("url");
const utils_1 = require("import-maps/lib/utils");
function resolve(specifier, parsedImportMap, scriptURL) {
    const asURL = utils_1.tryURLLikeSpecifierParse(specifier, scriptURL);
    const normalizedSpecifier = asURL ? asURL.href : specifier;
    const scriptURLString = scriptURL.href;
    for (const [scopePrefix, scopeImports] of Object.entries(parsedImportMap.scopes)) {
        if (scopePrefix === scriptURLString ||
            (scopePrefix.endsWith("/") && scriptURLString.startsWith(scopePrefix))) {
            const scopeImportsMatch = resolveImportsMatch(normalizedSpecifier, scopeImports);
            if (scopeImportsMatch !== null) {
                return scopeImportsMatch;
            }
        }
    }
    const topLevelImportsMatch = resolveImportsMatch(normalizedSpecifier, parsedImportMap.imports);
    if (topLevelImportsMatch !== null) {
        return topLevelImportsMatch;
    }
    // The specifier was able to be turned into a URL, but wasn't remapped into anything.
    if (asURL) {
        return asURL;
    }
    throw new TypeError(`Unmapped bare specifier "${specifier}"`);
}
exports.resolve = resolve;
function resolveImportsMatch(normalizedSpecifier, specifierMap) {
    for (const [specifierKey, resolutionResult] of Object.entries(specifierMap)) {
        // Exact-match case
        if (specifierKey === normalizedSpecifier) {
            if (resolutionResult === null) {
                throw new TypeError(`Blocked by a null entry for "${specifierKey}"`);
            }
            assert_1.default(resolutionResult instanceof url_1.URL);
            return resolutionResult;
        }
        // Package prefix-match case
        if (specifierKey.endsWith("/") && normalizedSpecifier.startsWith(specifierKey)) {
            if (resolutionResult === null) {
                throw new TypeError(`Blocked by a null entry for "${specifierKey}"`);
            }
            assert_1.default(resolutionResult instanceof url_1.URL);
            const afterPrefix = normalizedSpecifier.substring(specifierKey.length);
            // Enforced by parsing
            assert_1.default(resolutionResult.href.endsWith("/"));
            const url = utils_1.tryURLParse(afterPrefix, resolutionResult);
            if (url === null) {
                throw new TypeError(`Failed to resolve prefix-match relative URL for "${specifierKey}"`);
            }
            assert_1.default(url instanceof url_1.URL);
            return url;
        }
    }
    return null;
}
