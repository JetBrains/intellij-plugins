"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// modified from https://github.com/Microsoft/typescript-tslint-plugin
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const url_1 = require("url");
const merge_deep_1 = __importDefault(require("merge-deep"));
const import_maps_1 = require("import-maps");
const logger_1 = require("typescript-deno-plugin/out/logger");
const utils_1 = require("typescript-deno-plugin/out/utils");
const universal_module_resolver_1 = require("typescript-deno-plugin/out/module_resolver/universal_module_resolver");
const hash_meta_1 = require("typescript-deno-plugin/out/module_resolver/hash_meta");
const codefix_provider_1 = require("typescript-deno-plugin/out/codefix_provider");
require("typescript-deno-plugin/out/code_fixes");
let logger;
let pluginInfo;
const config = {
    enable: true,
};
let parsedImportMap;
let projectDirectory;
module.exports = function init({ typescript }) {
    // see https://github.com/denoland/deno/blob/2debbdacb935cfe1eb7bb8d1f40a5063b339d90b/js/compiler.ts#L159-L170
    const OPTIONS = {
        allowJs: true,
        checkJs: true,
        esModuleInterop: true,
        module: typescript.ModuleKind.ESNext,
        moduleResolution: typescript.ModuleResolutionKind.NodeJs,
        jsx: typescript.JsxEmit.React,
        noEmit: true,
        strict: true,
        outDir: "$deno$",
        removeComments: true,
        stripComments: true,
        resolveJsonModule: true,
        sourceMap: true,
        target: typescript.ScriptTarget.ESNext,
        typeRoots: [],
    };
    const OPTIONS_OVERWRITE_BY_DENO = {
        allowNonTsExtensions: false,
        jsx: OPTIONS.jsx,
        module: OPTIONS.module,
        moduleResolution: OPTIONS.moduleResolution,
        resolveJsonModule: OPTIONS.resolveJsonModule,
        strict: OPTIONS.strict,
        noEmit: OPTIONS.noEmit,
        noEmitHelpers: OPTIONS.noEmitHelpers,
        target: typescript.ScriptTarget.ESNext,
    };
    return {
        create(info) {
            logger = logger_1.Logger.forPlugin(info);
            logger.info("plugin created.");
            pluginInfo = info;
            const tsLs = info.languageService;
            const tsLsHost = info.languageServiceHost;
            const project = info.project;
            Object.assign(config, info.config);
            if (!config.enable) {
                logger.info("plugin disabled.");
                return tsLs;
            }
            projectDirectory = project.getCurrentDirectory();
            // TypeScript plugins have a `cwd` of `/`, which causes issues with import resolution.
            process.chdir(projectDirectory);
            const resolveTypeReferenceDirectives = tsLsHost.resolveTypeReferenceDirectives;
            if (resolveTypeReferenceDirectives) {
                tsLsHost.resolveTypeReferenceDirectives = (typeDirectiveNames, containingFile, redirectedReference, options) => {
                    const ret = resolveTypeReferenceDirectives.call(tsLsHost, typeDirectiveNames, containingFile, redirectedReference, options);
                    if (!config.enable) {
                        logger.info("plugin disabled.");
                        return ret;
                    }
                    return ret;
                };
            }
            // ref https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#customizing-module-resolution
            const resolveModuleNames = tsLsHost.resolveModuleNames;
            if (resolveModuleNames) {
                tsLsHost.resolveModuleNames = (moduleNames, containingFile, ...rest) => {
                    logger.info("resolveModuleNames");
                    if (!config.enable) {
                        logger.info("plugin disabled.");
                        return resolveModuleNames.call(tsLsHost, moduleNames, containingFile, ...rest);
                    }
                    const resolvedModules = [];
                    parsedImportMap = parseImportMapFromFile(projectDirectory, config.importmap);
                    // try resolve typeReferenceDirectives
                    for (let moduleName of moduleNames) {
                        const parsedModuleName = parseModuleName(moduleName, containingFile, parsedImportMap, logger);
                        if (parsedModuleName == null) {
                            logger.info(`module "${moduleName}" can not parsed`);
                            resolvedModules.push(undefined);
                            continue;
                        }
                        const resolvedModule = resolveDenoModule(parsedModuleName);
                        if (!resolvedModule) {
                            logger.info(`module "${moduleName}" can not resolved`);
                            resolvedModules.push(undefined);
                            continue;
                        }
                        logger.info(`module "${moduleName}" -> ${resolvedModule.filepath}`);
                        resolvedModules.push({
                            extension: resolvedModule.extension,
                            isExternalLibraryImport: false,
                            resolvedFileName: resolvedModule.filepath,
                        });
                        const content = typescript.sys.readFile(resolvedModule.filepath);
                        if (!content) {
                            continue;
                        }
                        const { typeReferenceDirectives } = typescript.preProcessFile(content, true, true);
                        if (!typeReferenceDirectives.length) {
                            continue;
                        }
                        for (const typeRef of typeReferenceDirectives) {
                            const module = universal_module_resolver_1.universalModuleResolver.resolve(typeRef.fileName, containingFile);
                            if (module) {
                                resolvedModule.originModuleName = module.originModuleName;
                                resolvedModule.filepath = module.filepath;
                            }
                        }
                    }
                    return resolvedModules;
                };
            }
            const getCompilationSettings = info.languageServiceHost.getCompilationSettings;
            info.languageServiceHost.getCompilationSettings = () => {
                if (!config.enable) {
                    return getCompilationSettings.call(tsLsHost);
                }
                const projectConfig = getCompilationSettings.call(info.languageServiceHost);
                const compilationSettings = merge_deep_1.default(merge_deep_1.default(OPTIONS, projectConfig), OPTIONS_OVERWRITE_BY_DENO);
                return compilationSettings;
            };
            const getScriptFileNames = info.languageServiceHost.getScriptFileNames;
            info.languageServiceHost.getScriptFileNames = () => {
                if (!config.enable) {
                    return getScriptFileNames.call(tsLsHost);
                }
                const scriptFileNames = getScriptFileNames.call(info.languageServiceHost);
                const libDenoDts = utils_1.getDenoDtsPath(tsLsHost, "lib.deno.d.ts");
                if (!libDenoDts) {
                    logger.info(`Can not load lib.deno.d.ts from ${libDenoDts}.`);
                    return scriptFileNames;
                }
                scriptFileNames.push(libDenoDts);
                const libWebworkerDts = utils_1.getDenoDtsPath(tsLsHost, "lib.webworker.d.ts");
                if (!libWebworkerDts) {
                    logger.info(`Can not load lib.webworker.d.ts from ${libWebworkerDts}.`);
                    return scriptFileNames;
                }
                scriptFileNames.push(libWebworkerDts);
                return scriptFileNames;
            };
            function getCompletionEntryDetails(fileName, position, name, formatOptions, source, preferences) {
                const details = tsLs.getCompletionEntryDetails(fileName, position, name, formatOptions, source, preferences);
                if (!config.enable) {
                    return details;
                }
                if (details) {
                    if (details.codeActions && details.codeActions.length) {
                        for (const ca of details.codeActions) {
                            for (const change of ca.changes) {
                                if (!change.isNewFile) {
                                    for (const tc of change.textChanges) {
                                        tc.newText = tc.newText.replace(/^(import .* from ['"])(\..*)(['"];\n)/i, "$1$2.ts$3");
                                    }
                                }
                            }
                        }
                    }
                }
                return details;
            }
            function getSemanticDiagnostics(filename) {
                logger.info("getSemanticDiagnostics");
                const diagnostics = tsLs.getSemanticDiagnostics(filename);
                if (!config.enable) {
                    return diagnostics;
                }
                // ref: https://github.com/denoland/deno/blob/da8cb408c878aa6e90542e26173f1f14b5254d29/cli/js/compiler/util.ts#L262
                const ignoredDiagnostics = [
                    // TS2306: File 'file:///Users/rld/src/deno/cli/tests/subdir/amd_like.js' is
                    // not a module.
                    2306,
                    // TS1375: 'await' expressions are only allowed at the top level of a file
                    // when that file is a module, but this file has no imports or exports.
                    // Consider adding an empty 'export {}' to make this file a module.
                    1375,
                    // TS1103: 'for-await-of' statement is only allowed within an async function
                    // or async generator.
                    1103,
                    // TS2691: An import path cannot end with a '.ts' extension. Consider
                    // importing 'bad-module' instead.
                    // !! 2691,
                    // TS5009: Cannot find the common subdirectory path for the input files.
                    5009,
                    // TS5055: Cannot write file
                    // 'http://localhost:4545/cli/tests/subdir/mt_application_x_javascript.j4.js'
                    // because it would overwrite input file.
                    5055,
                    // TypeScript is overly opinionated that only CommonJS modules kinds can
                    // support JSON imports.  Allegedly this was fixed in
                    // Microsoft/TypeScript#26825 but that doesn't seem to be working here,
                    // so we will ignore complaints about this compiler setting.
                    5070,
                    // TS7016: Could not find a declaration file for module '...'. '...'
                    // implicitly has an 'any' type.  This is due to `allowJs` being off by
                    // default but importing of a JavaScript module.
                    7016,
                ];
                return diagnostics.filter((d) => !ignoredDiagnostics.includes(d.code)).map((d) => {
                    var _a;
                    if (d.code === 2691) {
                        const moduleName = d.file.getFullText().substr(d.start + 1, d.length - 2);
                        if (config.importmap != null) {
                            parsedImportMap = parseImportMapFromFile(projectDirectory, config.importmap);
                        }
                        const parsedModuleName = parseModuleName(moduleName, (_a = d.file) === null || _a === void 0 ? void 0 : _a.fileName, parsedImportMap, logger);
                        if (parsedModuleName == null) {
                            d.code = 10001; // InvalidRelativeImport
                            d.messageText =
                                `relative import path "${moduleName}" not prefixed with / or ./ or ../`;
                            return d;
                        }
                        const resolvedModule = resolveDenoModule(parsedModuleName);
                        if (resolvedModule != null) {
                            return d;
                        }
                        if (utils_1.isHttpURL(parsedModuleName)) {
                            d.code = 10002; // RemoteModuleNotExist
                            d.messageText =
                                `The remote module "${moduleName}" has not been cached locally`;
                            return d;
                        }
                        if (path_1.default.isAbsolute(parsedModuleName) ||
                            parsedModuleName.startsWith("./") ||
                            parsedModuleName.startsWith("../") ||
                            parsedModuleName.startsWith("file://")) {
                            d.code = 10003; // LocalModuleNotExist
                            d.messageText = `Could not find module "${moduleName}" locally`;
                            return d;
                        }
                        d.code = 10004; // InvalidImport
                        d.messageText =
                            `Import module "${moduleName}" must be a relative path or remote HTTP URL`;
                    }
                    return d;
                });
            }
            // TODO(justjavac): maybe also `getCombinedCodeFix`
            function getCodeFixesAtPosition(fileName, start, end, errorCodes, formatOptions, preferences) {
                const codeFixActions = tsLs.getCodeFixesAtPosition(fileName, start, end, errorCodes, formatOptions, preferences);
                for (const errorCode of errorCodes) {
                    const fixes = codefix_provider_1.errorCodeToFixes.get(errorCode);
                    if (fixes == null) continue;
                    
                    for (const fix of fixes) {
                        fix.replaceCodeActions(codeFixActions);
                    }
                }
                return codeFixActions;
            }
            const proxy = Object.assign(Object.create(null), tsLs, {
                getCompletionEntryDetails,
                getSemanticDiagnostics,
                getCodeFixesAtPosition,
            });
            return proxy;
        },
        onConfigurationChanged(c) {
            var _a;
            logger.info("config change to:\n" + JSON.stringify(c, null, "  "));
            Object.assign(config, c);
            parsedImportMap = parseImportMapFromFile(projectDirectory, config.importmap);
            pluginInfo.project.markAsDirty();
            pluginInfo.project.refreshDiagnostics();
            pluginInfo.project.updateGraph();
            (_a = pluginInfo.languageService.getProgram()) === null || _a === void 0 ? void 0 : _a.emit();
        },
    };
};
function parseImportMapFromFile(cwd, file) {
    const importmps = {
        imports: {},
        scopes: {},
    };
    if (file == null) {
        return importmps;
    }
    if (!path_1.default.isAbsolute(file)) {
        file = path_1.default.resolve(cwd, file);
    }
    const fullFilePath = utils_1.normalizeFilepath(file);
    if (!utils_1.pathExistsSync(fullFilePath)) {
        return importmps;
    }
    const content = fs_1.default.readFileSync(fullFilePath, {
        encoding: "utf8",
    });
    try {
        return import_maps_1.parseFromString(content, `file://${cwd}/`);
    }
    catch (_a) {
        return importmps;
    }
}
function parseModuleName(moduleName, containingFile, parsedImportMap, logger) {
    if (parsedImportMap != null) {
        try {
            let scriptURL;
            if (utils_1.isInDenoDir(containingFile)) {
                const meta = hash_meta_1.HashMeta.create(`${containingFile}.metadata.json`);
                if (meta && meta.url) {
                    scriptURL = meta.url;
                }
                else {
                    scriptURL = new url_1.URL("file:///" + path_1.default.dirname(containingFile) + "/");
                }
            }
            else {
                scriptURL = new url_1.URL("file:///" + path_1.default.dirname(containingFile) + "/");
            }
            logger && logger.info(`baseUrl: ${scriptURL}`);
            const moduleUrl = import_maps_1.resolve(moduleName, parsedImportMap, scriptURL);
            if (moduleUrl.protocol === "file:") {
                return url_1.fileURLToPath(moduleUrl.href);
            }
            if (moduleUrl.protocol === "http:" || moduleUrl.protocol === "https:") {
                return moduleUrl.href;
            }
            // just support protocol: file, http, https
            return undefined;
        }
        catch (e) {
            if (logger)
                logger.info("moduleName: " + moduleName);
            if (logger)
                logger.info("e: " + e.stack);
            return undefined;
        }
    }
}
function resolveDenoModule(moduleName) {
    return universal_module_resolver_1.universalModuleResolver.resolve(moduleName);
}
//# sourceMappingURL=index.js.map