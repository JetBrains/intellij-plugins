"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashMeta = exports.Type = void 0;
/// Copyright axetroy
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const url_1 = require("url");
const utils_1 = require("typescript-deno-plugin/out/utils");
var Type;
(function (Type) {
    Type["JavaScript"] = "javascript";
    Type["JavaScriptReact"] = "javascriptreact";
    Type["TypeScript"] = "typescript";
    Type["TypeScriptReact"] = "typescriptreact";
    Type["JSON"] = "json";
    Type["WebAssembly"] = "WebAssembly";
    Type["PlainText"] = "plaintext";
})(Type = exports.Type || (exports.Type = {}));
const extNameMap = {
    ".ts": Type.TypeScript,
    ".tsx": Type.TypeScriptReact,
    ".js": Type.JavaScript,
    ".jsx": Type.JavaScriptReact,
    ".mjs": Type.JavaScript,
    ".json": Type.JSON,
    ".wasm": Type.WebAssembly,
};
const contentTypeMap = [
    [
        ["text/typescript", "application/typescript", "application/x-typescript"],
        Type.TypeScript,
    ],
    [
        [
            "text/javascript",
            "application/javascript",
            "application/x-javascript",
            "text/ecmascript",
            "application/ecmascript",
            "text/jscript",
        ],
        Type.JavaScript,
    ],
    [["application/json"], Type.JSON],
    [["application/wasm"], Type.WebAssembly],
];
class HashMeta {
    constructor(filepath, url, headers) {
        this.filepath = filepath;
        this.url = url;
        this.headers = headers;
    }
    static create(metaFilepath) {
        metaFilepath = utils_1.normalizeFilepath(metaFilepath);
        if (!utils_1.pathExistsSync(metaFilepath)) {
            return;
        }
        const metaMap = JSON.parse(fs.readFileSync(metaFilepath, { encoding: "utf8" }));
        return new HashMeta(metaFilepath, new url_1.URL(metaMap.url), metaMap.headers);
    }
    get type() {
        const extname = path.posix.extname(this.url.pathname);
        if (extname && extNameMap[extname]) {
            return extNameMap[extname];
        }
        const contentType = (this.headers["content-type"] || "").toLowerCase();
        // ref: https://mathiasbynens.be/demo/javascript-mime-type
        if (contentType) {
            for (const [contentTypes, type] of contentTypeMap) {
                // text/javascript;charset=UTF-8
                const arr = contentType.split(";");
                for (const _contentType of arr) {
                    if (contentTypes.includes(_contentType.toLowerCase())) {
                        return type;
                    }
                }
            }
        }
        return Type.PlainText;
    }
    get extension() {
        const type = this.type;
        switch (type) {
            case Type.JavaScript:
                return ".js";
            /* istanbul ignore next */
            case Type.JavaScriptReact:
                return ".jsx";
            case Type.TypeScript:
                if (this.url.pathname.endsWith(".d.ts")) {
                    return ".d.ts";
                }
                return ".ts";
            /* istanbul ignore next */
            case Type.TypeScriptReact:
                return ".tsx";
            case Type.JSON:
                return ".json";
            /* istanbul ignore next */
            case Type.WebAssembly:
                return ".wasm";
        }
        return "";
    }
    get destinationFilepath() {
        return this.filepath.replace(/\.metadata\.json$/, "");
    }
}
exports.HashMeta = HashMeta;
//# sourceMappingURL=hash_meta.js.map