"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDenoCompileHint = exports.parseCompileHint = exports.Range = exports.Position = void 0;
const tsserverlibrary_1 = __importDefault(require("typescript/lib/tsserverlibrary"));
exports.Position = {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    create(line, character) {
        return { line, character };
    },
};
exports.Range = {
    create(start, end) {
        return { start, end };
    },
};
function parseCompileHint(sourceFile, comment) {
    const text = sourceFile.getFullText().substring(comment.pos, comment.end);
    const regexp = /@deno-types=['"]([^'"]+)['"]/;
    const matchers = regexp.exec(text);
    if (!matchers) {
        return;
    }
    const start = sourceFile.getLineAndCharacterOfPosition(comment.pos);
    const end = sourceFile.getLineAndCharacterOfPosition(comment.end);
    const moduleNameStart = exports.Position.create(start.line, start.character + '// @deno-types="'.length);
    const moduleNameEnd = exports.Position.create(end.line, end.character - '"'.length);
    const moduleName = matchers[1];
    return {
        text: moduleName,
        range: exports.Range.create(start, end),
        contentRange: exports.Range.create(moduleNameStart, moduleNameEnd),
    };
}
exports.parseCompileHint = parseCompileHint;
/**
 * Get Deno compile hint from a source file
 * @param ts
 */
function getDenoCompileHint(sourceFile, pos = 0) {
    const denoTypesComments = [];
    const comments = tsserverlibrary_1.default.getLeadingCommentRanges(sourceFile.getFullText(), pos) ||
        [];
    for (const comment of comments) {
        if (comment.hasTrailingNewLine) {
            const text = sourceFile
                .getFullText()
                .substring(comment.pos, comment.end);
            const regexp = /@deno-types=['"]([^'"]+)['"]/;
            const matchers = regexp.exec(text);
            if (matchers) {
                const compileHint = parseCompileHint(sourceFile, comment);
                /* istanbul ignore else */
                if (compileHint) {
                    denoTypesComments.push(compileHint);
                }
            }
        }
    }
    return denoTypesComments;
}
exports.getDenoCompileHint = getDenoCompileHint;
//# sourceMappingURL=deno_type_hint.js.map