"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getImportModules = void 0;
const tsserverlibrary_1 = __importDefault(require("typescript/lib/tsserverlibrary"));
const deno_type_hint_1 = require("typescript-deno-plugin/out/deno_type_hint");
function getImportModules(sourceFile) {
    const moduleNodes = [];
    function delint(SourceFile) {
        function delintNode(node) {
            let moduleNode = null;
            // import('xxx')
            if (tsserverlibrary_1.default.isCallExpression(node)) {
                const expression = node.expression;
                const args = node.arguments;
                const isDynamicImport = expression.kind === tsserverlibrary_1.default.SyntaxKind.ImportKeyword;
                /* istanbul ignore else */
                if (isDynamicImport) {
                    const argv = args[0];
                    /* istanbul ignore else */
                    if (argv && tsserverlibrary_1.default.isStringLiteral(argv)) {
                        moduleNode = argv;
                    }
                }
            } // import ts = require('ts')
            else if (tsserverlibrary_1.default.isImportEqualsDeclaration(node)) {
                const ref = node.moduleReference;
                /* istanbul ignore else */
                if (tsserverlibrary_1.default.isExternalModuleReference(ref) &&
                    ref.expression &&
                    tsserverlibrary_1.default.isStringLiteral(ref.expression)) {
                    moduleNode = ref.expression;
                }
            } // import * as from 'xx'
            // import 'xx'
            // import xx from 'xx'
            else if (tsserverlibrary_1.default.isImportDeclaration(node)) {
                const spec = node.moduleSpecifier;
                /* istanbul ignore else */
                if (tsserverlibrary_1.default.isStringLiteral(spec)) {
                    moduleNode = spec;
                }
            } // export { window } from "xxx";
            // export * from "xxx";
            // export * as xxx from "xxx";
            else if (tsserverlibrary_1.default.isExportDeclaration(node)) {
                const exportSpec = node.moduleSpecifier;
                /* istanbul ignore else */
                if (exportSpec && tsserverlibrary_1.default.isStringLiteral(exportSpec)) {
                    moduleNode = exportSpec;
                }
            }
            if (moduleNode) {
                moduleNodes.push(moduleNode);
            }
            tsserverlibrary_1.default.forEachChild(node, delintNode);
        }
        delintNode(SourceFile);
    }
    // delint it
    delint(sourceFile);
    const text = sourceFile.getFullText();
    const getComments = (node, isTrailing) => {
        /* istanbul ignore else */
        if (node.parent) {
            const nodePos = isTrailing ? node.end : node.pos;
            const parentPos = isTrailing ? node.parent.end : node.parent.pos;
            if (node.parent.kind === tsserverlibrary_1.default.SyntaxKind.SourceFile ||
                nodePos !== parentPos) {
                const comments = isTrailing
                    ? tsserverlibrary_1.default.getTrailingCommentRanges(sourceFile.text, nodePos)
                    : tsserverlibrary_1.default.getLeadingCommentRanges(sourceFile.text, nodePos);
                if (Array.isArray(comments)) {
                    return comments.map((v) => {
                        const target = Object.assign(Object.assign({}, v), { text: text.substring(v.pos, v.end) });
                        return target;
                    });
                }
                return undefined;
            }
        }
    };
    const modules = sourceFile.typeReferenceDirectives
        .map((directive) => {
        const start = sourceFile.getLineAndCharacterOfPosition(directive.pos);
        const end = sourceFile.getLineAndCharacterOfPosition(directive.end);
        const module = {
            moduleName: directive.fileName,
            location: { start, end },
            start: directive.pos,
            length: directive.end - directive.pos,
        };
        return module;
    })
        .concat(moduleNodes.map((node) => {
        const numberOfSpaces = Math.abs(
        // why plus 2?
        // because `moduleNode.text` only contain the plaintext without two quotes
        // eg `import "./test"`
        node.end - node.pos - (node.text.length + 2));
        const startPosition = node.pos + numberOfSpaces + 1; // +1 to remove quotes
        const endPosition = startPosition + node.text.length;
        const start = sourceFile.getLineAndCharacterOfPosition(startPosition);
        const end = sourceFile.getLineAndCharacterOfPosition(endPosition);
        const location = {
            start,
            end,
        };
        const leadingComments = getComments(node.parent, false);
        const trailingComments = getComments(node.parent, true);
        const module = {
            moduleName: node.text,
            location,
            start: startPosition,
            length: endPosition - startPosition,
        };
        if (trailingComments) {
            module.trailingComments = trailingComments;
        }
        if (leadingComments) {
            module.leadingComments = leadingComments;
            // get the last comment
            const comment = module.leadingComments[module.leadingComments.length - 1];
            const hint = deno_type_hint_1.parseCompileHint(sourceFile, comment);
            module.hint = hint;
        }
        return module;
    }));
    return modules;
}
exports.getImportModules = getImportModules;
//# sourceMappingURL=deno_modules.js.map